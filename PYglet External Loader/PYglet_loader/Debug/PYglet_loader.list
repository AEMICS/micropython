
PYglet_loader.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .isr_vector   000003d4  20000004  20000004  00010004  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .ARM          00000008  200003d8  200003d8  000103d8  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  2 .init_array   00000004  200003e0  200003e0  000103e0  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  3 .fini_array   00000004  200003e4  200003e4  000103e4  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  4 .data         00000098  200003e8  200003e8  000103e8  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  5 .bss          00000074  20000480  20000480  00010480  2**2
                  ALLOC
  6 .text         000099f0  200004f4  200004f4  000104f4  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  7 .RamFunc      00000244  20009ee4  20009ee4  00019ee4  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  8 .Dev_info     000000c8  2000a128  2000a128  0002a128  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  9 .rodata       0000001c  2000a1f0  2000a1f0  0001a1f0  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
 10 ._user_heap_stack 00000600  2000a20c  2000a20c  0001a20c  2**0
                  ALLOC
 11 .ARM.attributes 00000030  00000000  00000000  0002a1f0  2**0
                  CONTENTS, READONLY
 12 .debug_info   00010a3b  00000000  00000000  0002a220  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 13 .debug_abbrev 0000312f  00000000  00000000  0003ac5b  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 14 .debug_aranges 00000cc8  00000000  00000000  0003dd90  2**3
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 15 .debug_macro  00020abd  00000000  00000000  0003ea58  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 16 .debug_line   00010404  00000000  00000000  0005f515  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 17 .debug_str    000c46b9  00000000  00000000  0006f919  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 18 .comment      00000053  00000000  00000000  00133fd2  2**0
                  CONTENTS, READONLY
 19 .debug_ranges 00000b08  00000000  00000000  00134028  2**3
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 20 .debug_frame  00002fcc  00000000  00000000  00134b30  2**2
                  CONTENTS, READONLY, DEBUGGING, OCTETS

Disassembly of section .text:

200004f4 <__do_global_dtors_aux>:
200004f4:	b510      	push	{r4, lr}
200004f6:	4c05      	ldr	r4, [pc, #20]	; (2000050c <__do_global_dtors_aux+0x18>)
200004f8:	7823      	ldrb	r3, [r4, #0]
200004fa:	b933      	cbnz	r3, 2000050a <__do_global_dtors_aux+0x16>
200004fc:	4b04      	ldr	r3, [pc, #16]	; (20000510 <__do_global_dtors_aux+0x1c>)
200004fe:	b113      	cbz	r3, 20000506 <__do_global_dtors_aux+0x12>
20000500:	4804      	ldr	r0, [pc, #16]	; (20000514 <__do_global_dtors_aux+0x20>)
20000502:	f3af 8000 	nop.w
20000506:	2301      	movs	r3, #1
20000508:	7023      	strb	r3, [r4, #0]
2000050a:	bd10      	pop	{r4, pc}
2000050c:	20000480 	.word	0x20000480
20000510:	00000000 	.word	0x00000000
20000514:	20009ec8 	.word	0x20009ec8

20000518 <frame_dummy>:
20000518:	b508      	push	{r3, lr}
2000051a:	4b03      	ldr	r3, [pc, #12]	; (20000528 <frame_dummy+0x10>)
2000051c:	b11b      	cbz	r3, 20000526 <frame_dummy+0xe>
2000051e:	4903      	ldr	r1, [pc, #12]	; (2000052c <frame_dummy+0x14>)
20000520:	4803      	ldr	r0, [pc, #12]	; (20000530 <frame_dummy+0x18>)
20000522:	f3af 8000 	nop.w
20000526:	bd08      	pop	{r3, pc}
20000528:	00000000 	.word	0x00000000
2000052c:	20000484 	.word	0x20000484
20000530:	20009ec8 	.word	0x20009ec8

20000534 <_stack_init>:
20000534:	f5a3 3a80 	sub.w	sl, r3, #65536	; 0x10000
20000538:	4770      	bx	lr
2000053a:	bf00      	nop

2000053c <_mainCRTStartup>:
2000053c:	4b17      	ldr	r3, [pc, #92]	; (2000059c <_mainCRTStartup+0x60>)
2000053e:	2b00      	cmp	r3, #0
20000540:	bf08      	it	eq
20000542:	4b13      	ldreq	r3, [pc, #76]	; (20000590 <_mainCRTStartup+0x54>)
20000544:	469d      	mov	sp, r3
20000546:	f7ff fff5 	bl	20000534 <_stack_init>
2000054a:	2100      	movs	r1, #0
2000054c:	468b      	mov	fp, r1
2000054e:	460f      	mov	r7, r1
20000550:	4813      	ldr	r0, [pc, #76]	; (200005a0 <_mainCRTStartup+0x64>)
20000552:	4a14      	ldr	r2, [pc, #80]	; (200005a4 <_mainCRTStartup+0x68>)
20000554:	1a12      	subs	r2, r2, r0
20000556:	f009 fcaf 	bl	20009eb8 <memset>
2000055a:	4b0e      	ldr	r3, [pc, #56]	; (20000594 <_mainCRTStartup+0x58>)
2000055c:	2b00      	cmp	r3, #0
2000055e:	d000      	beq.n	20000562 <_mainCRTStartup+0x26>
20000560:	4798      	blx	r3
20000562:	4b0d      	ldr	r3, [pc, #52]	; (20000598 <_mainCRTStartup+0x5c>)
20000564:	2b00      	cmp	r3, #0
20000566:	d000      	beq.n	2000056a <_mainCRTStartup+0x2e>
20000568:	4798      	blx	r3
2000056a:	2000      	movs	r0, #0
2000056c:	2100      	movs	r1, #0
2000056e:	0004      	movs	r4, r0
20000570:	000d      	movs	r5, r1
20000572:	480d      	ldr	r0, [pc, #52]	; (200005a8 <_mainCRTStartup+0x6c>)
20000574:	2800      	cmp	r0, #0
20000576:	d002      	beq.n	2000057e <_mainCRTStartup+0x42>
20000578:	480c      	ldr	r0, [pc, #48]	; (200005ac <_mainCRTStartup+0x70>)
2000057a:	f3af 8000 	nop.w
2000057e:	f009 fc77 	bl	20009e70 <__libc_init_array>
20000582:	0020      	movs	r0, r4
20000584:	0029      	movs	r1, r5
20000586:	f000 fa91 	bl	20000aac <main>
2000058a:	f009 fc5d 	bl	20009e48 <exit>
2000058e:	bf00      	nop
20000590:	00080000 	.word	0x00080000
	...
200005a0:	20000480 	.word	0x20000480
200005a4:	200004f4 	.word	0x200004f4
	...
200005b0:	200003e8 	.word	0x200003e8
200005b4:	200003e8 	.word	0x200003e8
200005b8:	20000480 	.word	0x20000480
200005bc:	20000480 	.word	0x20000480
200005c0:	200004f4 	.word	0x200004f4

200005c4 <Init>:
 * @param  None
 * @retval  LOADER_OK = 1   : Operation succeeded
 * @retval  LOADER_FAIL = 0 : Operation failed
 */
int
Init(void) {
200005c4:	b580      	push	{r7, lr}
200005c6:	b084      	sub	sp, #16
200005c8:	af00      	add	r7, sp, #0

    *(uint32_t*)0xE000EDF0 = 0xA05F0000; //enable interrupts in debug
200005ca:	4b22      	ldr	r3, [pc, #136]	; (20000654 <Init+0x90>)
200005cc:	4a22      	ldr	r2, [pc, #136]	; (20000658 <Init+0x94>)
200005ce:	601a      	str	r2, [r3, #0]


    SystemInit();
200005d0:	f001 f820 	bl	20001614 <SystemInit>
     * change VTOR setting for other devices
     * SCB->VTOR = 0x20000000 | 0x200;
     *
     * */

    SCB->VTOR = 0x20000000 | 0x200;
200005d4:	4b21      	ldr	r3, [pc, #132]	; (2000065c <Init+0x98>)
200005d6:	4a22      	ldr	r2, [pc, #136]	; (20000660 <Init+0x9c>)
200005d8:	609a      	str	r2, [r3, #8]
200005da:	2300      	movs	r3, #0
200005dc:	60fb      	str	r3, [r7, #12]
  \details Assigns the given value to the Priority Mask Register.
  \param [in]    priMask  Priority Mask
 */
__STATIC_FORCEINLINE void __set_PRIMASK(uint32_t priMask)
{
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
200005de:	68fb      	ldr	r3, [r7, #12]
200005e0:	f383 8810 	msr	PRIMASK, r3
}
200005e4:	bf00      	nop

    __set_PRIMASK(0); //enable interrupts

    HAL_Init();
200005e6:	f001 f8ba 	bl	2000175e <HAL_Init>

    SystemClock_Config();
200005ea:	f000 fa6a 	bl	20000ac2 <SystemClock_Config>

    MX_GPIO_Init();
200005ee:	f000 fa39 	bl	20000a64 <MX_GPIO_Init>

    __HAL_RCC_QSPI_FORCE_RESET();  //completely reset peripheral
200005f2:	4b1c      	ldr	r3, [pc, #112]	; (20000664 <Init+0xa0>)
200005f4:	6b1b      	ldr	r3, [r3, #48]	; 0x30
200005f6:	4a1b      	ldr	r2, [pc, #108]	; (20000664 <Init+0xa0>)
200005f8:	f443 7380 	orr.w	r3, r3, #256	; 0x100
200005fc:	6313      	str	r3, [r2, #48]	; 0x30
    __HAL_RCC_QSPI_RELEASE_RESET();
200005fe:	4b19      	ldr	r3, [pc, #100]	; (20000664 <Init+0xa0>)
20000600:	6b1b      	ldr	r3, [r3, #48]	; 0x30
20000602:	4a18      	ldr	r2, [pc, #96]	; (20000664 <Init+0xa0>)
20000604:	f423 7380 	bic.w	r3, r3, #256	; 0x100
20000608:	6313      	str	r3, [r2, #48]	; 0x30

    if (CSP_QUADSPI_Init() != HAL_OK) {
2000060a:	f000 fb65 	bl	20000cd8 <CSP_QUADSPI_Init>
2000060e:	4603      	mov	r3, r0
20000610:	2b00      	cmp	r3, #0
20000612:	d007      	beq.n	20000624 <Init+0x60>
20000614:	2301      	movs	r3, #1
20000616:	60bb      	str	r3, [r7, #8]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
20000618:	68bb      	ldr	r3, [r7, #8]
2000061a:	f383 8810 	msr	PRIMASK, r3
}
2000061e:	bf00      	nop
        __set_PRIMASK(1); //disable interrupts
        return LOADER_FAIL;
20000620:	2300      	movs	r3, #0
20000622:	e013      	b.n	2000064c <Init+0x88>
    }


    if (CSP_QSPI_EnableMemoryMappedMode() != HAL_OK) {
20000624:	f000 fdd6 	bl	200011d4 <CSP_QSPI_EnableMemoryMappedMode>
20000628:	4603      	mov	r3, r0
2000062a:	2b00      	cmp	r3, #0
2000062c:	d007      	beq.n	2000063e <Init+0x7a>
2000062e:	2301      	movs	r3, #1
20000630:	607b      	str	r3, [r7, #4]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
20000632:	687b      	ldr	r3, [r7, #4]
20000634:	f383 8810 	msr	PRIMASK, r3
}
20000638:	bf00      	nop
        __set_PRIMASK(1); //disable interrupts
        return LOADER_FAIL;
2000063a:	2300      	movs	r3, #0
2000063c:	e006      	b.n	2000064c <Init+0x88>
2000063e:	2301      	movs	r3, #1
20000640:	603b      	str	r3, [r7, #0]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
20000642:	683b      	ldr	r3, [r7, #0]
20000644:	f383 8810 	msr	PRIMASK, r3
}
20000648:	bf00      	nop
    }


    __set_PRIMASK(1); //disable interrupts
    return LOADER_OK;
2000064a:	2301      	movs	r3, #1
}
2000064c:	4618      	mov	r0, r3
2000064e:	3710      	adds	r7, #16
20000650:	46bd      	mov	sp, r7
20000652:	bd80      	pop	{r7, pc}
20000654:	e000edf0 	.word	0xe000edf0
20000658:	a05f0000 	.word	0xa05f0000
2000065c:	e000ed00 	.word	0xe000ed00
20000660:	20000200 	.word	0x20000200
20000664:	40021000 	.word	0x40021000

20000668 <Write>:
 * @param   buffer : pointer to data buffer
 * @retval  LOADER_OK = 1       : Operation succeeded
 * @retval  LOADER_FAIL = 0 : Operation failed
 */
int
Write(uint32_t Address, uint32_t Size, uint8_t* buffer) {
20000668:	b580      	push	{r7, lr}
2000066a:	b088      	sub	sp, #32
2000066c:	af00      	add	r7, sp, #0
2000066e:	60f8      	str	r0, [r7, #12]
20000670:	60b9      	str	r1, [r7, #8]
20000672:	607a      	str	r2, [r7, #4]
20000674:	2300      	movs	r3, #0
20000676:	61fb      	str	r3, [r7, #28]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
20000678:	69fb      	ldr	r3, [r7, #28]
2000067a:	f383 8810 	msr	PRIMASK, r3
}
2000067e:	bf00      	nop

    __set_PRIMASK(0); //enable interrupts

    if (HAL_QSPI_Abort(&hqspi1) != HAL_OK) {
20000680:	4815      	ldr	r0, [pc, #84]	; (200006d8 <Write+0x70>)
20000682:	f006 fe54 	bl	2000732e <HAL_QSPI_Abort>
20000686:	4603      	mov	r3, r0
20000688:	2b00      	cmp	r3, #0
2000068a:	d007      	beq.n	2000069c <Write+0x34>
2000068c:	2301      	movs	r3, #1
2000068e:	61bb      	str	r3, [r7, #24]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
20000690:	69bb      	ldr	r3, [r7, #24]
20000692:	f383 8810 	msr	PRIMASK, r3
}
20000696:	bf00      	nop
        __set_PRIMASK(1); //disable interrupts
        return LOADER_FAIL;
20000698:	2300      	movs	r3, #0
2000069a:	e019      	b.n	200006d0 <Write+0x68>
    }


    if (CSP_QSPI_WriteMemory((uint8_t*) buffer, (Address & (0x0fffffff)), Size) != HAL_OK) {
2000069c:	68fb      	ldr	r3, [r7, #12]
2000069e:	f023 4370 	bic.w	r3, r3, #4026531840	; 0xf0000000
200006a2:	68ba      	ldr	r2, [r7, #8]
200006a4:	4619      	mov	r1, r3
200006a6:	6878      	ldr	r0, [r7, #4]
200006a8:	f000 fd08 	bl	200010bc <CSP_QSPI_WriteMemory>
200006ac:	4603      	mov	r3, r0
200006ae:	2b00      	cmp	r3, #0
200006b0:	d007      	beq.n	200006c2 <Write+0x5a>
200006b2:	2301      	movs	r3, #1
200006b4:	617b      	str	r3, [r7, #20]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
200006b6:	697b      	ldr	r3, [r7, #20]
200006b8:	f383 8810 	msr	PRIMASK, r3
}
200006bc:	bf00      	nop
        __set_PRIMASK(1); //disable interrupts
        return LOADER_FAIL;
200006be:	2300      	movs	r3, #0
200006c0:	e006      	b.n	200006d0 <Write+0x68>
200006c2:	2301      	movs	r3, #1
200006c4:	613b      	str	r3, [r7, #16]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
200006c6:	693b      	ldr	r3, [r7, #16]
200006c8:	f383 8810 	msr	PRIMASK, r3
}
200006cc:	bf00      	nop
    }

    __set_PRIMASK(1); //disable interrupts
    return LOADER_OK;
200006ce:	2301      	movs	r3, #1
}
200006d0:	4618      	mov	r0, r3
200006d2:	3720      	adds	r7, #32
200006d4:	46bd      	mov	sp, r7
200006d6:	bd80      	pop	{r7, pc}
200006d8:	200004a4 	.word	0x200004a4

200006dc <SectorErase>:
 * @param   EraseEndAddress   :  erase end address
 * @retval  LOADER_OK = 1       : Operation succeeded
 * @retval  LOADER_FAIL = 0 : Operation failed
 */
int
SectorErase(uint32_t EraseStartAddress, uint32_t EraseEndAddress) {
200006dc:	b580      	push	{r7, lr}
200006de:	b086      	sub	sp, #24
200006e0:	af00      	add	r7, sp, #0
200006e2:	6078      	str	r0, [r7, #4]
200006e4:	6039      	str	r1, [r7, #0]
200006e6:	2300      	movs	r3, #0
200006e8:	617b      	str	r3, [r7, #20]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
200006ea:	697b      	ldr	r3, [r7, #20]
200006ec:	f383 8810 	msr	PRIMASK, r3
}
200006f0:	bf00      	nop

    __set_PRIMASK(0); //enable interrupts

    if (HAL_QSPI_Abort(&hqspi1) != HAL_OK) {
200006f2:	4814      	ldr	r0, [pc, #80]	; (20000744 <SectorErase+0x68>)
200006f4:	f006 fe1b 	bl	2000732e <HAL_QSPI_Abort>
200006f8:	4603      	mov	r3, r0
200006fa:	2b00      	cmp	r3, #0
200006fc:	d007      	beq.n	2000070e <SectorErase+0x32>
200006fe:	2301      	movs	r3, #1
20000700:	613b      	str	r3, [r7, #16]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
20000702:	693b      	ldr	r3, [r7, #16]
20000704:	f383 8810 	msr	PRIMASK, r3
}
20000708:	bf00      	nop
        __set_PRIMASK(1); //disable interrupts
        return LOADER_FAIL;
2000070a:	2300      	movs	r3, #0
2000070c:	e015      	b.n	2000073a <SectorErase+0x5e>
    }


    if (CSP_QSPI_EraseSector(EraseStartAddress, EraseEndAddress) != HAL_OK) {
2000070e:	6839      	ldr	r1, [r7, #0]
20000710:	6878      	ldr	r0, [r7, #4]
20000712:	f000 fc83 	bl	2000101c <CSP_QSPI_EraseSector>
20000716:	4603      	mov	r3, r0
20000718:	2b00      	cmp	r3, #0
2000071a:	d007      	beq.n	2000072c <SectorErase+0x50>
2000071c:	2301      	movs	r3, #1
2000071e:	60fb      	str	r3, [r7, #12]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
20000720:	68fb      	ldr	r3, [r7, #12]
20000722:	f383 8810 	msr	PRIMASK, r3
}
20000726:	bf00      	nop
        __set_PRIMASK(1); //disable interrupts
        return LOADER_FAIL;
20000728:	2300      	movs	r3, #0
2000072a:	e006      	b.n	2000073a <SectorErase+0x5e>
2000072c:	2301      	movs	r3, #1
2000072e:	60bb      	str	r3, [r7, #8]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
20000730:	68bb      	ldr	r3, [r7, #8]
20000732:	f383 8810 	msr	PRIMASK, r3
}
20000736:	bf00      	nop
    }

    __set_PRIMASK(1); //disable interrupts
    return LOADER_OK;
20000738:	2301      	movs	r3, #1
}
2000073a:	4618      	mov	r0, r3
2000073c:	3718      	adds	r7, #24
2000073e:	46bd      	mov	sp, r7
20000740:	bd80      	pop	{r7, pc}
20000742:	bf00      	nop
20000744:	200004a4 	.word	0x200004a4

20000748 <MassErase>:
 * outputs   :
 *     none
 * Note: Optional for all types of device
 */
int
MassErase(void) {
20000748:	b580      	push	{r7, lr}
2000074a:	b084      	sub	sp, #16
2000074c:	af00      	add	r7, sp, #0
2000074e:	2300      	movs	r3, #0
20000750:	60fb      	str	r3, [r7, #12]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
20000752:	68fb      	ldr	r3, [r7, #12]
20000754:	f383 8810 	msr	PRIMASK, r3
}
20000758:	bf00      	nop

    __set_PRIMASK(0); //enable interrupts

    if (HAL_QSPI_Abort(&hqspi1) != HAL_OK) {
2000075a:	4813      	ldr	r0, [pc, #76]	; (200007a8 <MassErase+0x60>)
2000075c:	f006 fde7 	bl	2000732e <HAL_QSPI_Abort>
20000760:	4603      	mov	r3, r0
20000762:	2b00      	cmp	r3, #0
20000764:	d007      	beq.n	20000776 <MassErase+0x2e>
20000766:	2301      	movs	r3, #1
20000768:	60bb      	str	r3, [r7, #8]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
2000076a:	68bb      	ldr	r3, [r7, #8]
2000076c:	f383 8810 	msr	PRIMASK, r3
}
20000770:	bf00      	nop
        __set_PRIMASK(1); //disable interrupts
        return LOADER_FAIL;
20000772:	2300      	movs	r3, #0
20000774:	e013      	b.n	2000079e <MassErase+0x56>
    }


    if (CSP_QSPI_Erase_Chip() != HAL_OK) {
20000776:	f000 fae5 	bl	20000d44 <CSP_QSPI_Erase_Chip>
2000077a:	4603      	mov	r3, r0
2000077c:	2b00      	cmp	r3, #0
2000077e:	d007      	beq.n	20000790 <MassErase+0x48>
20000780:	2301      	movs	r3, #1
20000782:	607b      	str	r3, [r7, #4]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
20000784:	687b      	ldr	r3, [r7, #4]
20000786:	f383 8810 	msr	PRIMASK, r3
}
2000078a:	bf00      	nop
        __set_PRIMASK(1); //disable interrupts
        return LOADER_FAIL;
2000078c:	2300      	movs	r3, #0
2000078e:	e006      	b.n	2000079e <MassErase+0x56>
20000790:	2301      	movs	r3, #1
20000792:	603b      	str	r3, [r7, #0]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
20000794:	683b      	ldr	r3, [r7, #0]
20000796:	f383 8810 	msr	PRIMASK, r3
}
2000079a:	bf00      	nop
    }

    __set_PRIMASK(1); //disable interrupts
    return LOADER_OK;
2000079c:	2301      	movs	r3, #1
}
2000079e:	4618      	mov	r0, r3
200007a0:	3710      	adds	r7, #16
200007a2:	46bd      	mov	sp, r7
200007a4:	bd80      	pop	{r7, pc}
200007a6:	bf00      	nop
200007a8:	200004a4 	.word	0x200004a4

200007ac <CheckSum>:
 * outputs   :
 *     R0             : Checksum value
 * Note: Optional for all types of device
 */
uint32_t
CheckSum(uint32_t StartAddress, uint32_t Size, uint32_t InitVal) {
200007ac:	b480      	push	{r7}
200007ae:	b089      	sub	sp, #36	; 0x24
200007b0:	af00      	add	r7, sp, #0
200007b2:	60f8      	str	r0, [r7, #12]
200007b4:	60b9      	str	r1, [r7, #8]
200007b6:	607a      	str	r2, [r7, #4]
    uint8_t missalignementAddress = StartAddress % 4;
200007b8:	68fb      	ldr	r3, [r7, #12]
200007ba:	b2db      	uxtb	r3, r3
200007bc:	f003 0303 	and.w	r3, r3, #3
200007c0:	77fb      	strb	r3, [r7, #31]
    uint8_t missalignementSize = Size;
200007c2:	68bb      	ldr	r3, [r7, #8]
200007c4:	77bb      	strb	r3, [r7, #30]
    int cnt;
    uint32_t Val;

    StartAddress -= StartAddress % 4;
200007c6:	68fb      	ldr	r3, [r7, #12]
200007c8:	f023 0303 	bic.w	r3, r3, #3
200007cc:	60fb      	str	r3, [r7, #12]
    Size += (Size % 4 == 0) ? 0 : 4 - (Size % 4);
200007ce:	68bb      	ldr	r3, [r7, #8]
200007d0:	f003 0303 	and.w	r3, r3, #3
200007d4:	2b00      	cmp	r3, #0
200007d6:	d005      	beq.n	200007e4 <CheckSum+0x38>
200007d8:	68bb      	ldr	r3, [r7, #8]
200007da:	f003 0303 	and.w	r3, r3, #3
200007de:	f1c3 0304 	rsb	r3, r3, #4
200007e2:	e000      	b.n	200007e6 <CheckSum+0x3a>
200007e4:	2300      	movs	r3, #0
200007e6:	68ba      	ldr	r2, [r7, #8]
200007e8:	4413      	add	r3, r2
200007ea:	60bb      	str	r3, [r7, #8]

    for (cnt = 0; cnt < Size; cnt += 4) {
200007ec:	2300      	movs	r3, #0
200007ee:	61bb      	str	r3, [r7, #24]
200007f0:	e0b3      	b.n	2000095a <CheckSum+0x1ae>
        Val = *(uint32_t*) StartAddress;
200007f2:	68fb      	ldr	r3, [r7, #12]
200007f4:	681b      	ldr	r3, [r3, #0]
200007f6:	617b      	str	r3, [r7, #20]
        if (missalignementAddress) {
200007f8:	7ffb      	ldrb	r3, [r7, #31]
200007fa:	2b00      	cmp	r3, #0
200007fc:	d040      	beq.n	20000880 <CheckSum+0xd4>
            switch (missalignementAddress) {
200007fe:	7ffb      	ldrb	r3, [r7, #31]
20000800:	2b03      	cmp	r3, #3
20000802:	d032      	beq.n	2000086a <CheckSum+0xbe>
20000804:	2b03      	cmp	r3, #3
20000806:	f300 80a2 	bgt.w	2000094e <CheckSum+0x1a2>
2000080a:	2b01      	cmp	r3, #1
2000080c:	d002      	beq.n	20000814 <CheckSum+0x68>
2000080e:	2b02      	cmp	r3, #2
20000810:	d019      	beq.n	20000846 <CheckSum+0x9a>
20000812:	e09c      	b.n	2000094e <CheckSum+0x1a2>
                case 1:
                    InitVal += (uint8_t) (Val >> 8 & 0xff);
20000814:	697b      	ldr	r3, [r7, #20]
20000816:	0a1b      	lsrs	r3, r3, #8
20000818:	b2db      	uxtb	r3, r3
2000081a:	461a      	mov	r2, r3
2000081c:	687b      	ldr	r3, [r7, #4]
2000081e:	4413      	add	r3, r2
20000820:	607b      	str	r3, [r7, #4]
                    InitVal += (uint8_t) (Val >> 16 & 0xff);
20000822:	697b      	ldr	r3, [r7, #20]
20000824:	0c1b      	lsrs	r3, r3, #16
20000826:	b2db      	uxtb	r3, r3
20000828:	461a      	mov	r2, r3
2000082a:	687b      	ldr	r3, [r7, #4]
2000082c:	4413      	add	r3, r2
2000082e:	607b      	str	r3, [r7, #4]
                    InitVal += (uint8_t) (Val >> 24 & 0xff);
20000830:	697b      	ldr	r3, [r7, #20]
20000832:	0e1b      	lsrs	r3, r3, #24
20000834:	b2db      	uxtb	r3, r3
20000836:	461a      	mov	r2, r3
20000838:	687b      	ldr	r3, [r7, #4]
2000083a:	4413      	add	r3, r2
2000083c:	607b      	str	r3, [r7, #4]
                    missalignementAddress -= 1;
2000083e:	7ffb      	ldrb	r3, [r7, #31]
20000840:	3b01      	subs	r3, #1
20000842:	77fb      	strb	r3, [r7, #31]
                    break;
20000844:	e083      	b.n	2000094e <CheckSum+0x1a2>
                case 2:
                    InitVal += (uint8_t) (Val >> 16 & 0xff);
20000846:	697b      	ldr	r3, [r7, #20]
20000848:	0c1b      	lsrs	r3, r3, #16
2000084a:	b2db      	uxtb	r3, r3
2000084c:	461a      	mov	r2, r3
2000084e:	687b      	ldr	r3, [r7, #4]
20000850:	4413      	add	r3, r2
20000852:	607b      	str	r3, [r7, #4]
                    InitVal += (uint8_t) (Val >> 24 & 0xff);
20000854:	697b      	ldr	r3, [r7, #20]
20000856:	0e1b      	lsrs	r3, r3, #24
20000858:	b2db      	uxtb	r3, r3
2000085a:	461a      	mov	r2, r3
2000085c:	687b      	ldr	r3, [r7, #4]
2000085e:	4413      	add	r3, r2
20000860:	607b      	str	r3, [r7, #4]
                    missalignementAddress -= 2;
20000862:	7ffb      	ldrb	r3, [r7, #31]
20000864:	3b02      	subs	r3, #2
20000866:	77fb      	strb	r3, [r7, #31]
                    break;
20000868:	e071      	b.n	2000094e <CheckSum+0x1a2>
                case 3:
                    InitVal += (uint8_t) (Val >> 24 & 0xff);
2000086a:	697b      	ldr	r3, [r7, #20]
2000086c:	0e1b      	lsrs	r3, r3, #24
2000086e:	b2db      	uxtb	r3, r3
20000870:	461a      	mov	r2, r3
20000872:	687b      	ldr	r3, [r7, #4]
20000874:	4413      	add	r3, r2
20000876:	607b      	str	r3, [r7, #4]
                    missalignementAddress -= 3;
20000878:	7ffb      	ldrb	r3, [r7, #31]
2000087a:	3b03      	subs	r3, #3
2000087c:	77fb      	strb	r3, [r7, #31]
                    break;
2000087e:	e066      	b.n	2000094e <CheckSum+0x1a2>
            }
        } else if ((Size - missalignementSize) % 4 && (Size - cnt) <= 4) {
20000880:	7fbb      	ldrb	r3, [r7, #30]
20000882:	68ba      	ldr	r2, [r7, #8]
20000884:	1ad3      	subs	r3, r2, r3
20000886:	f003 0303 	and.w	r3, r3, #3
2000088a:	2b00      	cmp	r3, #0
2000088c:	d044      	beq.n	20000918 <CheckSum+0x16c>
2000088e:	69bb      	ldr	r3, [r7, #24]
20000890:	68ba      	ldr	r2, [r7, #8]
20000892:	1ad3      	subs	r3, r2, r3
20000894:	2b04      	cmp	r3, #4
20000896:	d83f      	bhi.n	20000918 <CheckSum+0x16c>
            switch (Size - missalignementSize) {
20000898:	7fbb      	ldrb	r3, [r7, #30]
2000089a:	68ba      	ldr	r2, [r7, #8]
2000089c:	1ad3      	subs	r3, r2, r3
2000089e:	2b03      	cmp	r3, #3
200008a0:	d02f      	beq.n	20000902 <CheckSum+0x156>
200008a2:	2b03      	cmp	r3, #3
200008a4:	d853      	bhi.n	2000094e <CheckSum+0x1a2>
200008a6:	2b01      	cmp	r3, #1
200008a8:	d002      	beq.n	200008b0 <CheckSum+0x104>
200008aa:	2b02      	cmp	r3, #2
200008ac:	d018      	beq.n	200008e0 <CheckSum+0x134>
200008ae:	e04e      	b.n	2000094e <CheckSum+0x1a2>
                case 1:
                    InitVal += (uint8_t) Val;
200008b0:	697b      	ldr	r3, [r7, #20]
200008b2:	b2db      	uxtb	r3, r3
200008b4:	461a      	mov	r2, r3
200008b6:	687b      	ldr	r3, [r7, #4]
200008b8:	4413      	add	r3, r2
200008ba:	607b      	str	r3, [r7, #4]
                    InitVal += (uint8_t) (Val >> 8 & 0xff);
200008bc:	697b      	ldr	r3, [r7, #20]
200008be:	0a1b      	lsrs	r3, r3, #8
200008c0:	b2db      	uxtb	r3, r3
200008c2:	461a      	mov	r2, r3
200008c4:	687b      	ldr	r3, [r7, #4]
200008c6:	4413      	add	r3, r2
200008c8:	607b      	str	r3, [r7, #4]
                    InitVal += (uint8_t) (Val >> 16 & 0xff);
200008ca:	697b      	ldr	r3, [r7, #20]
200008cc:	0c1b      	lsrs	r3, r3, #16
200008ce:	b2db      	uxtb	r3, r3
200008d0:	461a      	mov	r2, r3
200008d2:	687b      	ldr	r3, [r7, #4]
200008d4:	4413      	add	r3, r2
200008d6:	607b      	str	r3, [r7, #4]
                    missalignementSize -= 1;
200008d8:	7fbb      	ldrb	r3, [r7, #30]
200008da:	3b01      	subs	r3, #1
200008dc:	77bb      	strb	r3, [r7, #30]
                    break;
200008de:	e01a      	b.n	20000916 <CheckSum+0x16a>
                case 2:
                    InitVal += (uint8_t) Val;
200008e0:	697b      	ldr	r3, [r7, #20]
200008e2:	b2db      	uxtb	r3, r3
200008e4:	461a      	mov	r2, r3
200008e6:	687b      	ldr	r3, [r7, #4]
200008e8:	4413      	add	r3, r2
200008ea:	607b      	str	r3, [r7, #4]
                    InitVal += (uint8_t) (Val >> 8 & 0xff);
200008ec:	697b      	ldr	r3, [r7, #20]
200008ee:	0a1b      	lsrs	r3, r3, #8
200008f0:	b2db      	uxtb	r3, r3
200008f2:	461a      	mov	r2, r3
200008f4:	687b      	ldr	r3, [r7, #4]
200008f6:	4413      	add	r3, r2
200008f8:	607b      	str	r3, [r7, #4]
                    missalignementSize -= 2;
200008fa:	7fbb      	ldrb	r3, [r7, #30]
200008fc:	3b02      	subs	r3, #2
200008fe:	77bb      	strb	r3, [r7, #30]
                    break;
20000900:	e009      	b.n	20000916 <CheckSum+0x16a>
                case 3:
                    InitVal += (uint8_t) Val;
20000902:	697b      	ldr	r3, [r7, #20]
20000904:	b2db      	uxtb	r3, r3
20000906:	461a      	mov	r2, r3
20000908:	687b      	ldr	r3, [r7, #4]
2000090a:	4413      	add	r3, r2
2000090c:	607b      	str	r3, [r7, #4]
                    missalignementSize -= 3;
2000090e:	7fbb      	ldrb	r3, [r7, #30]
20000910:	3b03      	subs	r3, #3
20000912:	77bb      	strb	r3, [r7, #30]
                    break;
20000914:	bf00      	nop
            switch (Size - missalignementSize) {
20000916:	e01a      	b.n	2000094e <CheckSum+0x1a2>
            }
        } else {
            InitVal += (uint8_t) Val;
20000918:	697b      	ldr	r3, [r7, #20]
2000091a:	b2db      	uxtb	r3, r3
2000091c:	461a      	mov	r2, r3
2000091e:	687b      	ldr	r3, [r7, #4]
20000920:	4413      	add	r3, r2
20000922:	607b      	str	r3, [r7, #4]
            InitVal += (uint8_t) (Val >> 8 & 0xff);
20000924:	697b      	ldr	r3, [r7, #20]
20000926:	0a1b      	lsrs	r3, r3, #8
20000928:	b2db      	uxtb	r3, r3
2000092a:	461a      	mov	r2, r3
2000092c:	687b      	ldr	r3, [r7, #4]
2000092e:	4413      	add	r3, r2
20000930:	607b      	str	r3, [r7, #4]
            InitVal += (uint8_t) (Val >> 16 & 0xff);
20000932:	697b      	ldr	r3, [r7, #20]
20000934:	0c1b      	lsrs	r3, r3, #16
20000936:	b2db      	uxtb	r3, r3
20000938:	461a      	mov	r2, r3
2000093a:	687b      	ldr	r3, [r7, #4]
2000093c:	4413      	add	r3, r2
2000093e:	607b      	str	r3, [r7, #4]
            InitVal += (uint8_t) (Val >> 24 & 0xff);
20000940:	697b      	ldr	r3, [r7, #20]
20000942:	0e1b      	lsrs	r3, r3, #24
20000944:	b2db      	uxtb	r3, r3
20000946:	461a      	mov	r2, r3
20000948:	687b      	ldr	r3, [r7, #4]
2000094a:	4413      	add	r3, r2
2000094c:	607b      	str	r3, [r7, #4]
        }
        StartAddress += 4;
2000094e:	68fb      	ldr	r3, [r7, #12]
20000950:	3304      	adds	r3, #4
20000952:	60fb      	str	r3, [r7, #12]
    for (cnt = 0; cnt < Size; cnt += 4) {
20000954:	69bb      	ldr	r3, [r7, #24]
20000956:	3304      	adds	r3, #4
20000958:	61bb      	str	r3, [r7, #24]
2000095a:	69bb      	ldr	r3, [r7, #24]
2000095c:	68ba      	ldr	r2, [r7, #8]
2000095e:	429a      	cmp	r2, r3
20000960:	f63f af47 	bhi.w	200007f2 <CheckSum+0x46>
    }

    return (InitVal);
20000964:	687b      	ldr	r3, [r7, #4]
}
20000966:	4618      	mov	r0, r3
20000968:	3724      	adds	r7, #36	; 0x24
2000096a:	46bd      	mov	sp, r7
2000096c:	f85d 7b04 	ldr.w	r7, [sp], #4
20000970:	4770      	bx	lr

20000972 <Verify>:
 *     R0             : Operation failed (address of failure)
 *     R1             : Checksum value
 * Note: Optional for all types of device
 */
uint64_t
Verify(uint32_t MemoryAddr, uint32_t RAMBufferAddr, uint32_t Size, uint32_t missalignement) {
20000972:	b5b0      	push	{r4, r5, r7, lr}
20000974:	b08c      	sub	sp, #48	; 0x30
20000976:	af00      	add	r7, sp, #0
20000978:	60f8      	str	r0, [r7, #12]
2000097a:	60b9      	str	r1, [r7, #8]
2000097c:	607a      	str	r2, [r7, #4]
2000097e:	603b      	str	r3, [r7, #0]
20000980:	2300      	movs	r3, #0
20000982:	61fb      	str	r3, [r7, #28]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
20000984:	69fb      	ldr	r3, [r7, #28]
20000986:	f383 8810 	msr	PRIMASK, r3
}
2000098a:	bf00      	nop

    __set_PRIMASK(0); //enable interrupts
    uint32_t VerifiedData = 0, InitVal = 0;
2000098c:	2300      	movs	r3, #0
2000098e:	62fb      	str	r3, [r7, #44]	; 0x2c
20000990:	2300      	movs	r3, #0
20000992:	62bb      	str	r3, [r7, #40]	; 0x28
    uint64_t checksum;
    Size *= 4;
20000994:	687b      	ldr	r3, [r7, #4]
20000996:	009b      	lsls	r3, r3, #2
20000998:	607b      	str	r3, [r7, #4]

    if (CSP_QSPI_EnableMemoryMappedMode() != HAL_OK) {
2000099a:	f000 fc1b 	bl	200011d4 <CSP_QSPI_EnableMemoryMappedMode>
2000099e:	4603      	mov	r3, r0
200009a0:	2b00      	cmp	r3, #0
200009a2:	d00a      	beq.n	200009ba <Verify+0x48>
200009a4:	2301      	movs	r3, #1
200009a6:	61bb      	str	r3, [r7, #24]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
200009a8:	69bb      	ldr	r3, [r7, #24]
200009aa:	f383 8810 	msr	PRIMASK, r3
}
200009ae:	bf00      	nop
        __set_PRIMASK(1); //disable interrupts
        return LOADER_FAIL;
200009b0:	f04f 0400 	mov.w	r4, #0
200009b4:	f04f 0500 	mov.w	r5, #0
200009b8:	e04c      	b.n	20000a54 <Verify+0xe2>
    }

    checksum = CheckSum((uint32_t) MemoryAddr + (missalignement & 0xf),
200009ba:	683b      	ldr	r3, [r7, #0]
200009bc:	f003 020f 	and.w	r2, r3, #15
200009c0:	68fb      	ldr	r3, [r7, #12]
200009c2:	18d0      	adds	r0, r2, r3
                        Size - ((missalignement >> 16) & 0xF), InitVal);
200009c4:	683b      	ldr	r3, [r7, #0]
200009c6:	0c1b      	lsrs	r3, r3, #16
200009c8:	f003 030f 	and.w	r3, r3, #15
    checksum = CheckSum((uint32_t) MemoryAddr + (missalignement & 0xf),
200009cc:	687a      	ldr	r2, [r7, #4]
200009ce:	1ad3      	subs	r3, r2, r3
200009d0:	6aba      	ldr	r2, [r7, #40]	; 0x28
200009d2:	4619      	mov	r1, r3
200009d4:	f7ff feea 	bl	200007ac <CheckSum>
200009d8:	4603      	mov	r3, r0
200009da:	461a      	mov	r2, r3
200009dc:	f04f 0300 	mov.w	r3, #0
200009e0:	e9c7 2308 	strd	r2, r3, [r7, #32]
    while (Size > VerifiedData) {
200009e4:	e024      	b.n	20000a30 <Verify+0xbe>
        if (*(uint8_t*) MemoryAddr++
200009e6:	68fb      	ldr	r3, [r7, #12]
200009e8:	1c5a      	adds	r2, r3, #1
200009ea:	60fa      	str	r2, [r7, #12]
200009ec:	781a      	ldrb	r2, [r3, #0]
            != *((uint8_t*) RAMBufferAddr + VerifiedData)) {
200009ee:	6af9      	ldr	r1, [r7, #44]	; 0x2c
200009f0:	68bb      	ldr	r3, [r7, #8]
200009f2:	440b      	add	r3, r1
200009f4:	781b      	ldrb	r3, [r3, #0]
        if (*(uint8_t*) MemoryAddr++
200009f6:	429a      	cmp	r2, r3
200009f8:	d017      	beq.n	20000a2a <Verify+0xb8>
200009fa:	2301      	movs	r3, #1
200009fc:	617b      	str	r3, [r7, #20]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
200009fe:	697b      	ldr	r3, [r7, #20]
20000a00:	f383 8810 	msr	PRIMASK, r3
}
20000a04:	bf00      	nop
            __set_PRIMASK(1); //disable interrupts
            return ((checksum << 32) + (MemoryAddr + VerifiedData));
20000a06:	e9d7 0108 	ldrd	r0, r1, [r7, #32]
20000a0a:	f04f 0200 	mov.w	r2, #0
20000a0e:	f04f 0300 	mov.w	r3, #0
20000a12:	0003      	movs	r3, r0
20000a14:	2200      	movs	r2, #0
20000a16:	68f8      	ldr	r0, [r7, #12]
20000a18:	6af9      	ldr	r1, [r7, #44]	; 0x2c
20000a1a:	4401      	add	r1, r0
20000a1c:	4608      	mov	r0, r1
20000a1e:	f04f 0100 	mov.w	r1, #0
20000a22:	1814      	adds	r4, r2, r0
20000a24:	eb43 0501 	adc.w	r5, r3, r1
20000a28:	e014      	b.n	20000a54 <Verify+0xe2>
        }
        VerifiedData++;
20000a2a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
20000a2c:	3301      	adds	r3, #1
20000a2e:	62fb      	str	r3, [r7, #44]	; 0x2c
    while (Size > VerifiedData) {
20000a30:	687a      	ldr	r2, [r7, #4]
20000a32:	6afb      	ldr	r3, [r7, #44]	; 0x2c
20000a34:	429a      	cmp	r2, r3
20000a36:	d8d6      	bhi.n	200009e6 <Verify+0x74>
20000a38:	2301      	movs	r3, #1
20000a3a:	613b      	str	r3, [r7, #16]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
20000a3c:	693b      	ldr	r3, [r7, #16]
20000a3e:	f383 8810 	msr	PRIMASK, r3
}
20000a42:	bf00      	nop
    }

    __set_PRIMASK(1); //disable interrupts
    return (checksum << 32);
20000a44:	e9d7 2308 	ldrd	r2, r3, [r7, #32]
20000a48:	f04f 0400 	mov.w	r4, #0
20000a4c:	f04f 0500 	mov.w	r5, #0
20000a50:	0015      	movs	r5, r2
20000a52:	2400      	movs	r4, #0
20000a54:	4622      	mov	r2, r4
20000a56:	462b      	mov	r3, r5
}
20000a58:	4610      	mov	r0, r2
20000a5a:	4619      	mov	r1, r3
20000a5c:	3730      	adds	r7, #48	; 0x30
20000a5e:	46bd      	mov	sp, r7
20000a60:	bdb0      	pop	{r4, r5, r7, pc}
	...

20000a64 <MX_GPIO_Init>:
/* USER CODE END 1 */

/** Pinout Configuration
*/
void MX_GPIO_Init(void)
{
20000a64:	b480      	push	{r7}
20000a66:	b083      	sub	sp, #12
20000a68:	af00      	add	r7, sp, #0

  /* GPIO Ports Clock Enable */
  __HAL_RCC_GPIOA_CLK_ENABLE();
20000a6a:	4b0f      	ldr	r3, [pc, #60]	; (20000aa8 <MX_GPIO_Init+0x44>)
20000a6c:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
20000a6e:	4a0e      	ldr	r2, [pc, #56]	; (20000aa8 <MX_GPIO_Init+0x44>)
20000a70:	f043 0301 	orr.w	r3, r3, #1
20000a74:	64d3      	str	r3, [r2, #76]	; 0x4c
20000a76:	4b0c      	ldr	r3, [pc, #48]	; (20000aa8 <MX_GPIO_Init+0x44>)
20000a78:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
20000a7a:	f003 0301 	and.w	r3, r3, #1
20000a7e:	607b      	str	r3, [r7, #4]
20000a80:	687b      	ldr	r3, [r7, #4]
  __HAL_RCC_GPIOB_CLK_ENABLE();
20000a82:	4b09      	ldr	r3, [pc, #36]	; (20000aa8 <MX_GPIO_Init+0x44>)
20000a84:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
20000a86:	4a08      	ldr	r2, [pc, #32]	; (20000aa8 <MX_GPIO_Init+0x44>)
20000a88:	f043 0302 	orr.w	r3, r3, #2
20000a8c:	64d3      	str	r3, [r2, #76]	; 0x4c
20000a8e:	4b06      	ldr	r3, [pc, #24]	; (20000aa8 <MX_GPIO_Init+0x44>)
20000a90:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
20000a92:	f003 0302 	and.w	r3, r3, #2
20000a96:	603b      	str	r3, [r7, #0]
20000a98:	683b      	ldr	r3, [r7, #0]

}
20000a9a:	bf00      	nop
20000a9c:	370c      	adds	r7, #12
20000a9e:	46bd      	mov	sp, r7
20000aa0:	f85d 7b04 	ldr.w	r7, [sp], #4
20000aa4:	4770      	bx	lr
20000aa6:	bf00      	nop
20000aa8:	40021000 	.word	0x40021000

20000aac <main>:
/**
  * @brief  The application entry point.
  * @retval int
  */
int main(void)
{
20000aac:	b580      	push	{r7, lr}
20000aae:	af00      	add	r7, sp, #0
  /* USER CODE END 1 */

  /* MCU Configuration--------------------------------------------------------*/

  /* Reset of all peripherals, Initializes the Flash interface and the Systick. */
  HAL_Init();
20000ab0:	f000 fe55 	bl	2000175e <HAL_Init>
  /* USER CODE BEGIN Init */

  /* USER CODE END Init */

  /* Configure the system clock */
  SystemClock_Config();
20000ab4:	f000 f805 	bl	20000ac2 <SystemClock_Config>
  /* USER CODE BEGIN SysInit */

  /* USER CODE END SysInit */

  /* Initialize all configured peripherals */
  MX_GPIO_Init();
20000ab8:	f7ff ffd4 	bl	20000a64 <MX_GPIO_Init>
  MX_QUADSPI1_Init();
20000abc:	f000 f85e 	bl	20000b7c <MX_QUADSPI1_Init>

  /* USER CODE END 2 */

  /* Infinite loop */
  /* USER CODE BEGIN WHILE */
  while (1)
20000ac0:	e7fe      	b.n	20000ac0 <main+0x14>

20000ac2 <SystemClock_Config>:
/**
  * @brief System Clock Configuration
  * @retval None
  */
void SystemClock_Config(void)
{
20000ac2:	b580      	push	{r7, lr}
20000ac4:	b0a8      	sub	sp, #160	; 0xa0
20000ac6:	af00      	add	r7, sp, #0
  RCC_OscInitTypeDef RCC_OscInitStruct = {0};
20000ac8:	f107 0368 	add.w	r3, r7, #104	; 0x68
20000acc:	2238      	movs	r2, #56	; 0x38
20000ace:	2100      	movs	r1, #0
20000ad0:	4618      	mov	r0, r3
20000ad2:	f009 f9f1 	bl	20009eb8 <memset>
  RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
20000ad6:	f107 0354 	add.w	r3, r7, #84	; 0x54
20000ada:	2200      	movs	r2, #0
20000adc:	601a      	str	r2, [r3, #0]
20000ade:	605a      	str	r2, [r3, #4]
20000ae0:	609a      	str	r2, [r3, #8]
20000ae2:	60da      	str	r2, [r3, #12]
20000ae4:	611a      	str	r2, [r3, #16]
  RCC_PeriphCLKInitTypeDef PeriphClkInit = {0};
20000ae6:	463b      	mov	r3, r7
20000ae8:	2254      	movs	r2, #84	; 0x54
20000aea:	2100      	movs	r1, #0
20000aec:	4618      	mov	r0, r3
20000aee:	f009 f9e3 	bl	20009eb8 <memset>

  /** Configure the main internal regulator output voltage
  */
  HAL_PWREx_ControlVoltageScaling(PWR_REGULATOR_VOLTAGE_SCALE1);
20000af2:	f44f 7000 	mov.w	r0, #512	; 0x200
20000af6:	f004 fca1 	bl	2000543c <HAL_PWREx_ControlVoltageScaling>
  /** Initializes the RCC Oscillators according to the specified parameters
  * in the RCC_OscInitTypeDef structure.
  */
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI;
20000afa:	2302      	movs	r3, #2
20000afc:	66bb      	str	r3, [r7, #104]	; 0x68
  RCC_OscInitStruct.HSIState = RCC_HSI_ON;
20000afe:	f44f 7380 	mov.w	r3, #256	; 0x100
20000b02:	677b      	str	r3, [r7, #116]	; 0x74
  RCC_OscInitStruct.HSICalibrationValue = RCC_HSICALIBRATION_DEFAULT;
20000b04:	2340      	movs	r3, #64	; 0x40
20000b06:	67bb      	str	r3, [r7, #120]	; 0x78
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_NONE;
20000b08:	2300      	movs	r3, #0
20000b0a:	f8c7 3084 	str.w	r3, [r7, #132]	; 0x84
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
20000b0e:	f107 0368 	add.w	r3, r7, #104	; 0x68
20000b12:	4618      	mov	r0, r3
20000b14:	f007 f83e 	bl	20007b94 <HAL_RCC_OscConfig>
20000b18:	4603      	mov	r3, r0
20000b1a:	2b00      	cmp	r3, #0
20000b1c:	d001      	beq.n	20000b22 <SystemClock_Config+0x60>
  {
    Error_Handler();
20000b1e:	f000 f827 	bl	20000b70 <Error_Handler>
  }
  /** Initializes the CPU, AHB and APB buses clocks
  */
  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
20000b22:	230f      	movs	r3, #15
20000b24:	657b      	str	r3, [r7, #84]	; 0x54
                              |RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_HSI;
20000b26:	2301      	movs	r3, #1
20000b28:	65bb      	str	r3, [r7, #88]	; 0x58
  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
20000b2a:	2300      	movs	r3, #0
20000b2c:	65fb      	str	r3, [r7, #92]	; 0x5c
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;
20000b2e:	2300      	movs	r3, #0
20000b30:	663b      	str	r3, [r7, #96]	; 0x60
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
20000b32:	2300      	movs	r3, #0
20000b34:	667b      	str	r3, [r7, #100]	; 0x64

  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_0) != HAL_OK)
20000b36:	f107 0354 	add.w	r3, r7, #84	; 0x54
20000b3a:	2100      	movs	r1, #0
20000b3c:	4618      	mov	r0, r3
20000b3e:	f007 fb41 	bl	200081c4 <HAL_RCC_ClockConfig>
20000b42:	4603      	mov	r3, r0
20000b44:	2b00      	cmp	r3, #0
20000b46:	d001      	beq.n	20000b4c <SystemClock_Config+0x8a>
  {
    Error_Handler();
20000b48:	f000 f812 	bl	20000b70 <Error_Handler>
  }
  /** Initializes the peripherals clocks
  */
  PeriphClkInit.PeriphClockSelection = RCC_PERIPHCLK_QSPI;
20000b4c:	f44f 2380 	mov.w	r3, #262144	; 0x40000
20000b50:	603b      	str	r3, [r7, #0]
  PeriphClkInit.QspiClockSelection = RCC_QSPICLKSOURCE_SYSCLK;
20000b52:	2300      	movs	r3, #0
20000b54:	64fb      	str	r3, [r7, #76]	; 0x4c

  if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInit) != HAL_OK)
20000b56:	463b      	mov	r3, r7
20000b58:	4618      	mov	r0, r3
20000b5a:	f007 feb7 	bl	200088cc <HAL_RCCEx_PeriphCLKConfig>
20000b5e:	4603      	mov	r3, r0
20000b60:	2b00      	cmp	r3, #0
20000b62:	d001      	beq.n	20000b68 <SystemClock_Config+0xa6>
  {
    Error_Handler();
20000b64:	f000 f804 	bl	20000b70 <Error_Handler>
  }
}
20000b68:	bf00      	nop
20000b6a:	37a0      	adds	r7, #160	; 0xa0
20000b6c:	46bd      	mov	sp, r7
20000b6e:	bd80      	pop	{r7, pc}

20000b70 <Error_Handler>:
/**
  * @brief  This function is executed in case of error occurrence.
  * @retval None
  */
void Error_Handler(void)
{
20000b70:	b480      	push	{r7}
20000b72:	af00      	add	r7, sp, #0
  __ASM volatile ("cpsid i" : : : "memory");
20000b74:	b672      	cpsid	i
}
20000b76:	bf00      	nop
  /* USER CODE BEGIN Error_Handler_Debug */
  /* User can add his own implementation to report the HAL error return state */
  __disable_irq();
  while (1)
20000b78:	e7fe      	b.n	20000b78 <Error_Handler+0x8>
	...

20000b7c <MX_QUADSPI1_Init>:

QSPI_HandleTypeDef hqspi1;

/* QUADSPI1 init function */
void MX_QUADSPI1_Init(void)
{
20000b7c:	b580      	push	{r7, lr}
20000b7e:	af00      	add	r7, sp, #0
  /* USER CODE END QUADSPI1_Init 0 */

  /* USER CODE BEGIN QUADSPI1_Init 1 */

  /* USER CODE END QUADSPI1_Init 1 */
  hqspi1.Instance = QUADSPI;
20000b80:	4b12      	ldr	r3, [pc, #72]	; (20000bcc <MX_QUADSPI1_Init+0x50>)
20000b82:	4a13      	ldr	r2, [pc, #76]	; (20000bd0 <MX_QUADSPI1_Init+0x54>)
20000b84:	601a      	str	r2, [r3, #0]
  hqspi1.Init.ClockPrescaler = 4;
20000b86:	4b11      	ldr	r3, [pc, #68]	; (20000bcc <MX_QUADSPI1_Init+0x50>)
20000b88:	2204      	movs	r2, #4
20000b8a:	605a      	str	r2, [r3, #4]
  hqspi1.Init.FifoThreshold = 4;
20000b8c:	4b0f      	ldr	r3, [pc, #60]	; (20000bcc <MX_QUADSPI1_Init+0x50>)
20000b8e:	2204      	movs	r2, #4
20000b90:	609a      	str	r2, [r3, #8]
  hqspi1.Init.SampleShifting = QSPI_SAMPLE_SHIFTING_NONE;
20000b92:	4b0e      	ldr	r3, [pc, #56]	; (20000bcc <MX_QUADSPI1_Init+0x50>)
20000b94:	2200      	movs	r2, #0
20000b96:	60da      	str	r2, [r3, #12]
  hqspi1.Init.FlashSize = 16;
20000b98:	4b0c      	ldr	r3, [pc, #48]	; (20000bcc <MX_QUADSPI1_Init+0x50>)
20000b9a:	2210      	movs	r2, #16
20000b9c:	611a      	str	r2, [r3, #16]
  hqspi1.Init.ChipSelectHighTime = QSPI_CS_HIGH_TIME_2_CYCLE;
20000b9e:	4b0b      	ldr	r3, [pc, #44]	; (20000bcc <MX_QUADSPI1_Init+0x50>)
20000ba0:	f44f 7280 	mov.w	r2, #256	; 0x100
20000ba4:	615a      	str	r2, [r3, #20]
  hqspi1.Init.ClockMode = QSPI_CLOCK_MODE_0;
20000ba6:	4b09      	ldr	r3, [pc, #36]	; (20000bcc <MX_QUADSPI1_Init+0x50>)
20000ba8:	2200      	movs	r2, #0
20000baa:	619a      	str	r2, [r3, #24]
  hqspi1.Init.FlashID = QSPI_FLASH_ID_1;
20000bac:	4b07      	ldr	r3, [pc, #28]	; (20000bcc <MX_QUADSPI1_Init+0x50>)
20000bae:	2200      	movs	r2, #0
20000bb0:	61da      	str	r2, [r3, #28]
  hqspi1.Init.DualFlash = QSPI_DUALFLASH_DISABLE;
20000bb2:	4b06      	ldr	r3, [pc, #24]	; (20000bcc <MX_QUADSPI1_Init+0x50>)
20000bb4:	2200      	movs	r2, #0
20000bb6:	621a      	str	r2, [r3, #32]
  if (HAL_QSPI_Init(&hqspi1) != HAL_OK)
20000bb8:	4804      	ldr	r0, [pc, #16]	; (20000bcc <MX_QUADSPI1_Init+0x50>)
20000bba:	f005 fa8b 	bl	200060d4 <HAL_QSPI_Init>
20000bbe:	4603      	mov	r3, r0
20000bc0:	2b00      	cmp	r3, #0
20000bc2:	d001      	beq.n	20000bc8 <MX_QUADSPI1_Init+0x4c>
  {
    Error_Handler();
20000bc4:	f7ff ffd4 	bl	20000b70 <Error_Handler>
  }
  /* USER CODE BEGIN QUADSPI1_Init 2 */

  /* USER CODE END QUADSPI1_Init 2 */

}
20000bc8:	bf00      	nop
20000bca:	bd80      	pop	{r7, pc}
20000bcc:	200004a4 	.word	0x200004a4
20000bd0:	a0001000 	.word	0xa0001000

20000bd4 <HAL_QSPI_MspInit>:

void HAL_QSPI_MspInit(QSPI_HandleTypeDef* qspiHandle)
{
20000bd4:	b580      	push	{r7, lr}
20000bd6:	b08a      	sub	sp, #40	; 0x28
20000bd8:	af00      	add	r7, sp, #0
20000bda:	6078      	str	r0, [r7, #4]

  GPIO_InitTypeDef GPIO_InitStruct = {0};
20000bdc:	f107 0314 	add.w	r3, r7, #20
20000be0:	2200      	movs	r2, #0
20000be2:	601a      	str	r2, [r3, #0]
20000be4:	605a      	str	r2, [r3, #4]
20000be6:	609a      	str	r2, [r3, #8]
20000be8:	60da      	str	r2, [r3, #12]
20000bea:	611a      	str	r2, [r3, #16]
  if(qspiHandle->Instance==QUADSPI)
20000bec:	687b      	ldr	r3, [r7, #4]
20000bee:	681b      	ldr	r3, [r3, #0]
20000bf0:	4a25      	ldr	r2, [pc, #148]	; (20000c88 <HAL_QSPI_MspInit+0xb4>)
20000bf2:	4293      	cmp	r3, r2
20000bf4:	d144      	bne.n	20000c80 <HAL_QSPI_MspInit+0xac>
  {
  /* USER CODE BEGIN QUADSPI_MspInit 0 */

  /* USER CODE END QUADSPI_MspInit 0 */
    /* QUADSPI clock enable */
    __HAL_RCC_QSPI_CLK_ENABLE();
20000bf6:	4b25      	ldr	r3, [pc, #148]	; (20000c8c <HAL_QSPI_MspInit+0xb8>)
20000bf8:	6d1b      	ldr	r3, [r3, #80]	; 0x50
20000bfa:	4a24      	ldr	r2, [pc, #144]	; (20000c8c <HAL_QSPI_MspInit+0xb8>)
20000bfc:	f443 7380 	orr.w	r3, r3, #256	; 0x100
20000c00:	6513      	str	r3, [r2, #80]	; 0x50
20000c02:	4b22      	ldr	r3, [pc, #136]	; (20000c8c <HAL_QSPI_MspInit+0xb8>)
20000c04:	6d1b      	ldr	r3, [r3, #80]	; 0x50
20000c06:	f403 7380 	and.w	r3, r3, #256	; 0x100
20000c0a:	613b      	str	r3, [r7, #16]
20000c0c:	693b      	ldr	r3, [r7, #16]

    __HAL_RCC_GPIOA_CLK_ENABLE();
20000c0e:	4b1f      	ldr	r3, [pc, #124]	; (20000c8c <HAL_QSPI_MspInit+0xb8>)
20000c10:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
20000c12:	4a1e      	ldr	r2, [pc, #120]	; (20000c8c <HAL_QSPI_MspInit+0xb8>)
20000c14:	f043 0301 	orr.w	r3, r3, #1
20000c18:	64d3      	str	r3, [r2, #76]	; 0x4c
20000c1a:	4b1c      	ldr	r3, [pc, #112]	; (20000c8c <HAL_QSPI_MspInit+0xb8>)
20000c1c:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
20000c1e:	f003 0301 	and.w	r3, r3, #1
20000c22:	60fb      	str	r3, [r7, #12]
20000c24:	68fb      	ldr	r3, [r7, #12]
    __HAL_RCC_GPIOB_CLK_ENABLE();
20000c26:	4b19      	ldr	r3, [pc, #100]	; (20000c8c <HAL_QSPI_MspInit+0xb8>)
20000c28:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
20000c2a:	4a18      	ldr	r2, [pc, #96]	; (20000c8c <HAL_QSPI_MspInit+0xb8>)
20000c2c:	f043 0302 	orr.w	r3, r3, #2
20000c30:	64d3      	str	r3, [r2, #76]	; 0x4c
20000c32:	4b16      	ldr	r3, [pc, #88]	; (20000c8c <HAL_QSPI_MspInit+0xb8>)
20000c34:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
20000c36:	f003 0302 	and.w	r3, r3, #2
20000c3a:	60bb      	str	r3, [r7, #8]
20000c3c:	68bb      	ldr	r3, [r7, #8]
    PA6     ------> QUADSPI1_BK1_IO3
    PA7     ------> QUADSPI1_BK1_IO2
    PB0     ------> QUADSPI1_BK1_IO1
    PB1     ------> QUADSPI1_BK1_IO0
    */
    GPIO_InitStruct.Pin = GPIO_PIN_2|GPIO_PIN_3|GPIO_PIN_6|GPIO_PIN_7;
20000c3e:	23cc      	movs	r3, #204	; 0xcc
20000c40:	617b      	str	r3, [r7, #20]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
20000c42:	2302      	movs	r3, #2
20000c44:	61bb      	str	r3, [r7, #24]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
20000c46:	2300      	movs	r3, #0
20000c48:	61fb      	str	r3, [r7, #28]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
20000c4a:	2300      	movs	r3, #0
20000c4c:	623b      	str	r3, [r7, #32]
    GPIO_InitStruct.Alternate = GPIO_AF10_QUADSPI;
20000c4e:	230a      	movs	r3, #10
20000c50:	627b      	str	r3, [r7, #36]	; 0x24
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
20000c52:	f107 0314 	add.w	r3, r7, #20
20000c56:	4619      	mov	r1, r3
20000c58:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
20000c5c:	f003 ff3c 	bl	20004ad8 <HAL_GPIO_Init>

    GPIO_InitStruct.Pin = GPIO_PIN_0|GPIO_PIN_1;
20000c60:	2303      	movs	r3, #3
20000c62:	617b      	str	r3, [r7, #20]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
20000c64:	2302      	movs	r3, #2
20000c66:	61bb      	str	r3, [r7, #24]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
20000c68:	2300      	movs	r3, #0
20000c6a:	61fb      	str	r3, [r7, #28]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
20000c6c:	2300      	movs	r3, #0
20000c6e:	623b      	str	r3, [r7, #32]
    GPIO_InitStruct.Alternate = GPIO_AF10_QUADSPI;
20000c70:	230a      	movs	r3, #10
20000c72:	627b      	str	r3, [r7, #36]	; 0x24
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
20000c74:	f107 0314 	add.w	r3, r7, #20
20000c78:	4619      	mov	r1, r3
20000c7a:	4805      	ldr	r0, [pc, #20]	; (20000c90 <HAL_QSPI_MspInit+0xbc>)
20000c7c:	f003 ff2c 	bl	20004ad8 <HAL_GPIO_Init>

  /* USER CODE BEGIN QUADSPI_MspInit 1 */

  /* USER CODE END QUADSPI_MspInit 1 */
  }
}
20000c80:	bf00      	nop
20000c82:	3728      	adds	r7, #40	; 0x28
20000c84:	46bd      	mov	sp, r7
20000c86:	bd80      	pop	{r7, pc}
20000c88:	a0001000 	.word	0xa0001000
20000c8c:	40021000 	.word	0x40021000
20000c90:	48000400 	.word	0x48000400

20000c94 <HAL_QSPI_MspDeInit>:

void HAL_QSPI_MspDeInit(QSPI_HandleTypeDef* qspiHandle)
{
20000c94:	b580      	push	{r7, lr}
20000c96:	b082      	sub	sp, #8
20000c98:	af00      	add	r7, sp, #0
20000c9a:	6078      	str	r0, [r7, #4]

  if(qspiHandle->Instance==QUADSPI)
20000c9c:	687b      	ldr	r3, [r7, #4]
20000c9e:	681b      	ldr	r3, [r3, #0]
20000ca0:	4a0a      	ldr	r2, [pc, #40]	; (20000ccc <HAL_QSPI_MspDeInit+0x38>)
20000ca2:	4293      	cmp	r3, r2
20000ca4:	d10e      	bne.n	20000cc4 <HAL_QSPI_MspDeInit+0x30>
  {
  /* USER CODE BEGIN QUADSPI_MspDeInit 0 */

  /* USER CODE END QUADSPI_MspDeInit 0 */
    /* Peripheral clock disable */
    __HAL_RCC_QSPI_CLK_DISABLE();
20000ca6:	4b0a      	ldr	r3, [pc, #40]	; (20000cd0 <HAL_QSPI_MspDeInit+0x3c>)
20000ca8:	6d1b      	ldr	r3, [r3, #80]	; 0x50
20000caa:	4a09      	ldr	r2, [pc, #36]	; (20000cd0 <HAL_QSPI_MspDeInit+0x3c>)
20000cac:	f423 7380 	bic.w	r3, r3, #256	; 0x100
20000cb0:	6513      	str	r3, [r2, #80]	; 0x50
    PA6     ------> QUADSPI1_BK1_IO3
    PA7     ------> QUADSPI1_BK1_IO2
    PB0     ------> QUADSPI1_BK1_IO1
    PB1     ------> QUADSPI1_BK1_IO0
    */
    HAL_GPIO_DeInit(GPIOA, GPIO_PIN_2|GPIO_PIN_3|GPIO_PIN_6|GPIO_PIN_7);
20000cb2:	21cc      	movs	r1, #204	; 0xcc
20000cb4:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
20000cb8:	f004 f890 	bl	20004ddc <HAL_GPIO_DeInit>

    HAL_GPIO_DeInit(GPIOB, GPIO_PIN_0|GPIO_PIN_1);
20000cbc:	2103      	movs	r1, #3
20000cbe:	4805      	ldr	r0, [pc, #20]	; (20000cd4 <HAL_QSPI_MspDeInit+0x40>)
20000cc0:	f004 f88c 	bl	20004ddc <HAL_GPIO_DeInit>

  /* USER CODE BEGIN QUADSPI_MspDeInit 1 */

  /* USER CODE END QUADSPI_MspDeInit 1 */
  }
}
20000cc4:	bf00      	nop
20000cc6:	3708      	adds	r7, #8
20000cc8:	46bd      	mov	sp, r7
20000cca:	bd80      	pop	{r7, pc}
20000ccc:	a0001000 	.word	0xa0001000
20000cd0:	40021000 	.word	0x40021000
20000cd4:	48000400 	.word	0x48000400

20000cd8 <CSP_QUADSPI_Init>:

/* USER CODE BEGIN 1 */

/* QUADSPI init function */
uint8_t
CSP_QUADSPI_Init(void) {
20000cd8:	b580      	push	{r7, lr}
20000cda:	af00      	add	r7, sp, #0
    //prepare QSPI peripheral for ST-Link Utility operations
	hqspi1.Instance = QUADSPI;
20000cdc:	4b17      	ldr	r3, [pc, #92]	; (20000d3c <CSP_QUADSPI_Init+0x64>)
20000cde:	4a18      	ldr	r2, [pc, #96]	; (20000d40 <CSP_QUADSPI_Init+0x68>)
20000ce0:	601a      	str	r2, [r3, #0]
    if (HAL_QSPI_DeInit(&hqspi1) != HAL_OK) {
20000ce2:	4816      	ldr	r0, [pc, #88]	; (20000d3c <CSP_QUADSPI_Init+0x64>)
20000ce4:	f005 fa7e 	bl	200061e4 <HAL_QSPI_DeInit>
20000ce8:	4603      	mov	r3, r0
20000cea:	2b00      	cmp	r3, #0
20000cec:	d001      	beq.n	20000cf2 <CSP_QUADSPI_Init+0x1a>
        return HAL_ERROR;
20000cee:	2301      	movs	r3, #1
20000cf0:	e021      	b.n	20000d36 <CSP_QUADSPI_Init+0x5e>
    }

    MX_QUADSPI1_Init();
20000cf2:	f7ff ff43 	bl	20000b7c <MX_QUADSPI1_Init>

    if (QSPI_ResetChip() != HAL_OK) {
20000cf6:	f000 faa1 	bl	2000123c <QSPI_ResetChip>
20000cfa:	4603      	mov	r3, r0
20000cfc:	2b00      	cmp	r3, #0
20000cfe:	d001      	beq.n	20000d04 <CSP_QUADSPI_Init+0x2c>
        return HAL_ERROR;
20000d00:	2301      	movs	r3, #1
20000d02:	e018      	b.n	20000d36 <CSP_QUADSPI_Init+0x5e>
    }

    HAL_Delay(1);
20000d04:	2001      	movs	r0, #1
20000d06:	f000 fe15 	bl	20001934 <HAL_Delay>

    if (QSPI_AutoPollingMemReady() != HAL_OK) {
20000d0a:	f000 f857 	bl	20000dbc <QSPI_AutoPollingMemReady>
20000d0e:	4603      	mov	r3, r0
20000d10:	2b00      	cmp	r3, #0
20000d12:	d001      	beq.n	20000d18 <CSP_QUADSPI_Init+0x40>
        return HAL_ERROR;
20000d14:	2301      	movs	r3, #1
20000d16:	e00e      	b.n	20000d36 <CSP_QUADSPI_Init+0x5e>
    }

    if (QSPI_WriteEnable() != HAL_OK) {
20000d18:	f000 f888 	bl	20000e2c <QSPI_WriteEnable>
20000d1c:	4603      	mov	r3, r0
20000d1e:	2b00      	cmp	r3, #0
20000d20:	d001      	beq.n	20000d26 <CSP_QUADSPI_Init+0x4e>

        return HAL_ERROR;
20000d22:	2301      	movs	r3, #1
20000d24:	e007      	b.n	20000d36 <CSP_QUADSPI_Init+0x5e>
    }

    if (QSPI_Configuration() != HAL_OK) {
20000d26:	f000 f8cb 	bl	20000ec0 <QSPI_Configuration>
20000d2a:	4603      	mov	r3, r0
20000d2c:	2b00      	cmp	r3, #0
20000d2e:	d001      	beq.n	20000d34 <CSP_QUADSPI_Init+0x5c>
        return HAL_ERROR;
20000d30:	2301      	movs	r3, #1
20000d32:	e000      	b.n	20000d36 <CSP_QUADSPI_Init+0x5e>
    }

    return HAL_OK;
20000d34:	2300      	movs	r3, #0
}
20000d36:	4618      	mov	r0, r3
20000d38:	bd80      	pop	{r7, pc}
20000d3a:	bf00      	nop
20000d3c:	200004a4 	.word	0x200004a4
20000d40:	a0001000 	.word	0xa0001000

20000d44 <CSP_QSPI_Erase_Chip>:


uint8_t
CSP_QSPI_Erase_Chip(void) {
20000d44:	b580      	push	{r7, lr}
20000d46:	b08e      	sub	sp, #56	; 0x38
20000d48:	af00      	add	r7, sp, #0
    QSPI_CommandTypeDef sCommand;


    if (QSPI_WriteEnable() != HAL_OK) {
20000d4a:	f000 f86f 	bl	20000e2c <QSPI_WriteEnable>
20000d4e:	4603      	mov	r3, r0
20000d50:	2b00      	cmp	r3, #0
20000d52:	d001      	beq.n	20000d58 <CSP_QSPI_Erase_Chip+0x14>
        return HAL_ERROR;
20000d54:	2301      	movs	r3, #1
20000d56:	e02b      	b.n	20000db0 <CSP_QSPI_Erase_Chip+0x6c>
    }


    /* Erasing Sequence --------------------------------- */
    sCommand.Instruction = CHIP_ERASE_CMD;
20000d58:	23c7      	movs	r3, #199	; 0xc7
20000d5a:	603b      	str	r3, [r7, #0]
    sCommand.InstructionMode = QSPI_INSTRUCTION_1_LINE;
20000d5c:	f44f 7380 	mov.w	r3, #256	; 0x100
20000d60:	61bb      	str	r3, [r7, #24]
    sCommand.AddressSize = QSPI_ADDRESS_32_BITS;
20000d62:	f44f 5340 	mov.w	r3, #12288	; 0x3000
20000d66:	60fb      	str	r3, [r7, #12]
    sCommand.AlternateByteMode = QSPI_ALTERNATE_BYTES_NONE;
20000d68:	2300      	movs	r3, #0
20000d6a:	623b      	str	r3, [r7, #32]
    sCommand.DdrMode = QSPI_DDR_MODE_DISABLE;
20000d6c:	2300      	movs	r3, #0
20000d6e:	62fb      	str	r3, [r7, #44]	; 0x2c
    sCommand.DdrHoldHalfCycle = QSPI_DDR_HHC_ANALOG_DELAY;
20000d70:	2300      	movs	r3, #0
20000d72:	633b      	str	r3, [r7, #48]	; 0x30
    sCommand.SIOOMode = QSPI_SIOO_INST_EVERY_CMD;
20000d74:	2300      	movs	r3, #0
20000d76:	637b      	str	r3, [r7, #52]	; 0x34
    sCommand.AddressMode = QSPI_ADDRESS_NONE;
20000d78:	2300      	movs	r3, #0
20000d7a:	61fb      	str	r3, [r7, #28]
    sCommand.Address = 0;
20000d7c:	2300      	movs	r3, #0
20000d7e:	607b      	str	r3, [r7, #4]
    sCommand.DataMode = QSPI_DATA_NONE;
20000d80:	2300      	movs	r3, #0
20000d82:	627b      	str	r3, [r7, #36]	; 0x24
    sCommand.DummyCycles = 0;
20000d84:	2300      	movs	r3, #0
20000d86:	617b      	str	r3, [r7, #20]


    if (HAL_QSPI_Command(&hqspi1, &sCommand, HAL_QSPI_TIMEOUT_DEFAULT_VALUE)
20000d88:	463b      	mov	r3, r7
20000d8a:	f241 3288 	movw	r2, #5000	; 0x1388
20000d8e:	4619      	mov	r1, r3
20000d90:	4809      	ldr	r0, [pc, #36]	; (20000db8 <CSP_QSPI_Erase_Chip+0x74>)
20000d92:	f005 fc25 	bl	200065e0 <HAL_QSPI_Command>
20000d96:	4603      	mov	r3, r0
20000d98:	2b00      	cmp	r3, #0
20000d9a:	d001      	beq.n	20000da0 <CSP_QSPI_Erase_Chip+0x5c>
        != HAL_OK) {
        return HAL_ERROR;
20000d9c:	2301      	movs	r3, #1
20000d9e:	e007      	b.n	20000db0 <CSP_QSPI_Erase_Chip+0x6c>
    }

    if (QSPI_AutoPollingMemReady() != HAL_OK) {
20000da0:	f000 f80c 	bl	20000dbc <QSPI_AutoPollingMemReady>
20000da4:	4603      	mov	r3, r0
20000da6:	2b00      	cmp	r3, #0
20000da8:	d001      	beq.n	20000dae <CSP_QSPI_Erase_Chip+0x6a>
        return HAL_ERROR;
20000daa:	2301      	movs	r3, #1
20000dac:	e000      	b.n	20000db0 <CSP_QSPI_Erase_Chip+0x6c>
    }

    return HAL_OK;
20000dae:	2300      	movs	r3, #0
}
20000db0:	4618      	mov	r0, r3
20000db2:	3738      	adds	r7, #56	; 0x38
20000db4:	46bd      	mov	sp, r7
20000db6:	bd80      	pop	{r7, pc}
20000db8:	200004a4 	.word	0x200004a4

20000dbc <QSPI_AutoPollingMemReady>:

uint8_t
QSPI_AutoPollingMemReady(void) {
20000dbc:	b580      	push	{r7, lr}
20000dbe:	b094      	sub	sp, #80	; 0x50
20000dc0:	af00      	add	r7, sp, #0

    QSPI_CommandTypeDef sCommand;
    QSPI_AutoPollingTypeDef sConfig;

    /* Configure automatic polling mode to wait for memory ready ------ */
    sCommand.InstructionMode = QSPI_INSTRUCTION_1_LINE;
20000dc2:	f44f 7380 	mov.w	r3, #256	; 0x100
20000dc6:	633b      	str	r3, [r7, #48]	; 0x30
    sCommand.Instruction = READ_STATUS_REG_CMD;
20000dc8:	2305      	movs	r3, #5
20000dca:	61bb      	str	r3, [r7, #24]
    sCommand.AddressMode = QSPI_ADDRESS_NONE;
20000dcc:	2300      	movs	r3, #0
20000dce:	637b      	str	r3, [r7, #52]	; 0x34
    sCommand.AlternateByteMode = QSPI_ALTERNATE_BYTES_NONE;
20000dd0:	2300      	movs	r3, #0
20000dd2:	63bb      	str	r3, [r7, #56]	; 0x38
    sCommand.DataMode = QSPI_DATA_1_LINE;
20000dd4:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
20000dd8:	63fb      	str	r3, [r7, #60]	; 0x3c
    sCommand.DummyCycles = 0;
20000dda:	2300      	movs	r3, #0
20000ddc:	62fb      	str	r3, [r7, #44]	; 0x2c
    sCommand.DdrMode = QSPI_DDR_MODE_DISABLE;
20000dde:	2300      	movs	r3, #0
20000de0:	647b      	str	r3, [r7, #68]	; 0x44
    sCommand.DdrHoldHalfCycle = QSPI_DDR_HHC_ANALOG_DELAY;
20000de2:	2300      	movs	r3, #0
20000de4:	64bb      	str	r3, [r7, #72]	; 0x48
    sCommand.SIOOMode = QSPI_SIOO_INST_EVERY_CMD;
20000de6:	2300      	movs	r3, #0
20000de8:	64fb      	str	r3, [r7, #76]	; 0x4c

    sConfig.Match = 0x00;
20000dea:	2300      	movs	r3, #0
20000dec:	603b      	str	r3, [r7, #0]
    sConfig.Mask = 0x01;
20000dee:	2301      	movs	r3, #1
20000df0:	607b      	str	r3, [r7, #4]
    sConfig.MatchMode = QSPI_MATCH_MODE_AND;
20000df2:	2300      	movs	r3, #0
20000df4:	613b      	str	r3, [r7, #16]
    sConfig.StatusBytesSize = 1;
20000df6:	2301      	movs	r3, #1
20000df8:	60fb      	str	r3, [r7, #12]
    sConfig.Interval = 0x10;
20000dfa:	2310      	movs	r3, #16
20000dfc:	60bb      	str	r3, [r7, #8]
    sConfig.AutomaticStop = QSPI_AUTOMATIC_STOP_ENABLE;
20000dfe:	f44f 0380 	mov.w	r3, #4194304	; 0x400000
20000e02:	617b      	str	r3, [r7, #20]

    if (HAL_QSPI_AutoPolling(&hqspi1, &sCommand, &sConfig,
20000e04:	463a      	mov	r2, r7
20000e06:	f107 0118 	add.w	r1, r7, #24
20000e0a:	f241 3388 	movw	r3, #5000	; 0x1388
20000e0e:	4806      	ldr	r0, [pc, #24]	; (20000e28 <QSPI_AutoPollingMemReady+0x6c>)
20000e10:	f006 f8be 	bl	20006f90 <HAL_QSPI_AutoPolling>
20000e14:	4603      	mov	r3, r0
20000e16:	2b00      	cmp	r3, #0
20000e18:	d001      	beq.n	20000e1e <QSPI_AutoPollingMemReady+0x62>
                             HAL_QSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK) {
        return HAL_ERROR;
20000e1a:	2301      	movs	r3, #1
20000e1c:	e000      	b.n	20000e20 <QSPI_AutoPollingMemReady+0x64>
    }

    return HAL_OK;
20000e1e:	2300      	movs	r3, #0
}
20000e20:	4618      	mov	r0, r3
20000e22:	3750      	adds	r7, #80	; 0x50
20000e24:	46bd      	mov	sp, r7
20000e26:	bd80      	pop	{r7, pc}
20000e28:	200004a4 	.word	0x200004a4

20000e2c <QSPI_WriteEnable>:

static uint8_t
QSPI_WriteEnable(void) {
20000e2c:	b580      	push	{r7, lr}
20000e2e:	b094      	sub	sp, #80	; 0x50
20000e30:	af00      	add	r7, sp, #0
    QSPI_CommandTypeDef sCommand;
    QSPI_AutoPollingTypeDef sConfig;

    /* Enable write operations ------------------------------------------ */
    sCommand.InstructionMode = QSPI_INSTRUCTION_1_LINE;
20000e32:	f44f 7380 	mov.w	r3, #256	; 0x100
20000e36:	633b      	str	r3, [r7, #48]	; 0x30
    sCommand.Instruction = WRITE_ENABLE_CMD;
20000e38:	2306      	movs	r3, #6
20000e3a:	61bb      	str	r3, [r7, #24]
    sCommand.AddressMode = QSPI_ADDRESS_NONE;
20000e3c:	2300      	movs	r3, #0
20000e3e:	637b      	str	r3, [r7, #52]	; 0x34
    sCommand.AlternateByteMode = QSPI_ALTERNATE_BYTES_NONE;
20000e40:	2300      	movs	r3, #0
20000e42:	63bb      	str	r3, [r7, #56]	; 0x38
    sCommand.DataMode = QSPI_DATA_NONE;
20000e44:	2300      	movs	r3, #0
20000e46:	63fb      	str	r3, [r7, #60]	; 0x3c
    sCommand.DummyCycles = 0;
20000e48:	2300      	movs	r3, #0
20000e4a:	62fb      	str	r3, [r7, #44]	; 0x2c
    sCommand.DdrMode = QSPI_DDR_MODE_DISABLE;
20000e4c:	2300      	movs	r3, #0
20000e4e:	647b      	str	r3, [r7, #68]	; 0x44
    sCommand.DdrHoldHalfCycle = QSPI_DDR_HHC_ANALOG_DELAY;
20000e50:	2300      	movs	r3, #0
20000e52:	64bb      	str	r3, [r7, #72]	; 0x48
    sCommand.SIOOMode = QSPI_SIOO_INST_EVERY_CMD;
20000e54:	2300      	movs	r3, #0
20000e56:	64fb      	str	r3, [r7, #76]	; 0x4c

    if (HAL_QSPI_Command(&hqspi1, &sCommand, HAL_QSPI_TIMEOUT_DEFAULT_VALUE)
20000e58:	f107 0318 	add.w	r3, r7, #24
20000e5c:	f241 3288 	movw	r2, #5000	; 0x1388
20000e60:	4619      	mov	r1, r3
20000e62:	4816      	ldr	r0, [pc, #88]	; (20000ebc <QSPI_WriteEnable+0x90>)
20000e64:	f005 fbbc 	bl	200065e0 <HAL_QSPI_Command>
20000e68:	4603      	mov	r3, r0
20000e6a:	2b00      	cmp	r3, #0
20000e6c:	d001      	beq.n	20000e72 <QSPI_WriteEnable+0x46>
        != HAL_OK) {
        return HAL_ERROR;
20000e6e:	2301      	movs	r3, #1
20000e70:	e01f      	b.n	20000eb2 <QSPI_WriteEnable+0x86>
    }

    /* Configure automatic polling mode to wait for write enabling ---- */
    sConfig.Match = 0x02;
20000e72:	2302      	movs	r3, #2
20000e74:	603b      	str	r3, [r7, #0]
    sConfig.Mask = 0x02;
20000e76:	2302      	movs	r3, #2
20000e78:	607b      	str	r3, [r7, #4]
    sConfig.MatchMode = QSPI_MATCH_MODE_AND;
20000e7a:	2300      	movs	r3, #0
20000e7c:	613b      	str	r3, [r7, #16]
    sConfig.StatusBytesSize = 1;
20000e7e:	2301      	movs	r3, #1
20000e80:	60fb      	str	r3, [r7, #12]
    sConfig.Interval = 0x10;
20000e82:	2310      	movs	r3, #16
20000e84:	60bb      	str	r3, [r7, #8]
    sConfig.AutomaticStop = QSPI_AUTOMATIC_STOP_ENABLE;
20000e86:	f44f 0380 	mov.w	r3, #4194304	; 0x400000
20000e8a:	617b      	str	r3, [r7, #20]

    sCommand.Instruction = READ_STATUS_REG_CMD;
20000e8c:	2305      	movs	r3, #5
20000e8e:	61bb      	str	r3, [r7, #24]
    sCommand.DataMode = QSPI_DATA_1_LINE;
20000e90:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
20000e94:	63fb      	str	r3, [r7, #60]	; 0x3c
    if (HAL_QSPI_AutoPolling(&hqspi1, &sCommand, &sConfig,
20000e96:	463a      	mov	r2, r7
20000e98:	f107 0118 	add.w	r1, r7, #24
20000e9c:	f241 3388 	movw	r3, #5000	; 0x1388
20000ea0:	4806      	ldr	r0, [pc, #24]	; (20000ebc <QSPI_WriteEnable+0x90>)
20000ea2:	f006 f875 	bl	20006f90 <HAL_QSPI_AutoPolling>
20000ea6:	4603      	mov	r3, r0
20000ea8:	2b00      	cmp	r3, #0
20000eaa:	d001      	beq.n	20000eb0 <QSPI_WriteEnable+0x84>
                             HAL_QSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK) {
        return HAL_ERROR;
20000eac:	2301      	movs	r3, #1
20000eae:	e000      	b.n	20000eb2 <QSPI_WriteEnable+0x86>
    }

    return HAL_OK;
20000eb0:	2300      	movs	r3, #0
}
20000eb2:	4618      	mov	r0, r3
20000eb4:	3750      	adds	r7, #80	; 0x50
20000eb6:	46bd      	mov	sp, r7
20000eb8:	bd80      	pop	{r7, pc}
20000eba:	bf00      	nop
20000ebc:	200004a4 	.word	0x200004a4

20000ec0 <QSPI_Configuration>:
/*Enable quad mode and set dummy cycles count*/
uint8_t
QSPI_Configuration(void) {
20000ec0:	b580      	push	{r7, lr}
20000ec2:	b092      	sub	sp, #72	; 0x48
20000ec4:	af00      	add	r7, sp, #0
    QSPI_CommandTypeDef sCommand;
    uint8_t reg;


    /*enter 4 byte address*/
    sCommand.InstructionMode = QSPI_INSTRUCTION_1_LINE;
20000ec6:	f44f 7380 	mov.w	r3, #256	; 0x100
20000eca:	61fb      	str	r3, [r7, #28]
    sCommand.Instruction = ENTER_4_BYTE_ADD_CMD;
20000ecc:	23b7      	movs	r3, #183	; 0xb7
20000ece:	607b      	str	r3, [r7, #4]
    sCommand.AddressMode = QSPI_ADDRESS_NONE;
20000ed0:	2300      	movs	r3, #0
20000ed2:	623b      	str	r3, [r7, #32]
    sCommand.AlternateByteMode = QSPI_ALTERNATE_BYTES_NONE;
20000ed4:	2300      	movs	r3, #0
20000ed6:	627b      	str	r3, [r7, #36]	; 0x24
    sCommand.DataMode = QSPI_DATA_NONE;
20000ed8:	2300      	movs	r3, #0
20000eda:	62bb      	str	r3, [r7, #40]	; 0x28
    sCommand.DummyCycles = 0;
20000edc:	2300      	movs	r3, #0
20000ede:	61bb      	str	r3, [r7, #24]
    sCommand.DdrMode = QSPI_DDR_MODE_DISABLE;
20000ee0:	2300      	movs	r3, #0
20000ee2:	633b      	str	r3, [r7, #48]	; 0x30
    sCommand.DdrHoldHalfCycle = QSPI_DDR_HHC_ANALOG_DELAY;
20000ee4:	2300      	movs	r3, #0
20000ee6:	637b      	str	r3, [r7, #52]	; 0x34
    sCommand.SIOOMode = QSPI_SIOO_INST_EVERY_CMD;
20000ee8:	2300      	movs	r3, #0
20000eea:	63bb      	str	r3, [r7, #56]	; 0x38
    sCommand.NbData = 0;
20000eec:	2300      	movs	r3, #0
20000eee:	62fb      	str	r3, [r7, #44]	; 0x2c

    if (HAL_QSPI_Command(&hqspi1, &sCommand, HAL_QSPI_TIMEOUT_DEFAULT_VALUE)
20000ef0:	1d3b      	adds	r3, r7, #4
20000ef2:	f241 3288 	movw	r2, #5000	; 0x1388
20000ef6:	4619      	mov	r1, r3
20000ef8:	4847      	ldr	r0, [pc, #284]	; (20001018 <QSPI_Configuration+0x158>)
20000efa:	f005 fb71 	bl	200065e0 <HAL_QSPI_Command>
20000efe:	4603      	mov	r3, r0
20000f00:	2b00      	cmp	r3, #0
20000f02:	d001      	beq.n	20000f08 <QSPI_Configuration+0x48>
        != HAL_OK) {
        return HAL_ERROR;
20000f04:	2301      	movs	r3, #1
20000f06:	e083      	b.n	20001010 <QSPI_Configuration+0x150>




    /*read configuration register*/
    sCommand.InstructionMode = QSPI_INSTRUCTION_1_LINE;
20000f08:	f44f 7380 	mov.w	r3, #256	; 0x100
20000f0c:	61fb      	str	r3, [r7, #28]
    sCommand.Instruction = READ_CONFIGURATION_REG_CMD;
20000f0e:	2385      	movs	r3, #133	; 0x85
20000f10:	607b      	str	r3, [r7, #4]
    sCommand.AddressMode = QSPI_ADDRESS_NONE;
20000f12:	2300      	movs	r3, #0
20000f14:	623b      	str	r3, [r7, #32]
    sCommand.AlternateByteMode = QSPI_ALTERNATE_BYTES_NONE;
20000f16:	2300      	movs	r3, #0
20000f18:	627b      	str	r3, [r7, #36]	; 0x24
    sCommand.DataMode = QSPI_DATA_1_LINE;
20000f1a:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
20000f1e:	62bb      	str	r3, [r7, #40]	; 0x28
    sCommand.DummyCycles = 0;
20000f20:	2300      	movs	r3, #0
20000f22:	61bb      	str	r3, [r7, #24]
    sCommand.DdrMode = QSPI_DDR_MODE_DISABLE;
20000f24:	2300      	movs	r3, #0
20000f26:	633b      	str	r3, [r7, #48]	; 0x30
    sCommand.DdrHoldHalfCycle = QSPI_DDR_HHC_ANALOG_DELAY;
20000f28:	2300      	movs	r3, #0
20000f2a:	637b      	str	r3, [r7, #52]	; 0x34
    sCommand.SIOOMode = QSPI_SIOO_INST_EVERY_CMD;
20000f2c:	2300      	movs	r3, #0
20000f2e:	63bb      	str	r3, [r7, #56]	; 0x38
    sCommand.NbData = 1;
20000f30:	2301      	movs	r3, #1
20000f32:	62fb      	str	r3, [r7, #44]	; 0x2c

    if (HAL_QSPI_Command(&hqspi1, &sCommand, HAL_QSPI_TIMEOUT_DEFAULT_VALUE)
20000f34:	1d3b      	adds	r3, r7, #4
20000f36:	f241 3288 	movw	r2, #5000	; 0x1388
20000f3a:	4619      	mov	r1, r3
20000f3c:	4836      	ldr	r0, [pc, #216]	; (20001018 <QSPI_Configuration+0x158>)
20000f3e:	f005 fb4f 	bl	200065e0 <HAL_QSPI_Command>
20000f42:	4603      	mov	r3, r0
20000f44:	2b00      	cmp	r3, #0
20000f46:	d001      	beq.n	20000f4c <QSPI_Configuration+0x8c>
        != HAL_OK) {
        return HAL_ERROR;
20000f48:	2301      	movs	r3, #1
20000f4a:	e061      	b.n	20001010 <QSPI_Configuration+0x150>
    }


    if (HAL_QSPI_Receive(&hqspi1, &reg,
20000f4c:	1cfb      	adds	r3, r7, #3
20000f4e:	f241 3288 	movw	r2, #5000	; 0x1388
20000f52:	4619      	mov	r1, r3
20000f54:	4830      	ldr	r0, [pc, #192]	; (20001018 <QSPI_Configuration+0x158>)
20000f56:	f005 fc99 	bl	2000688c <HAL_QSPI_Receive>
20000f5a:	4603      	mov	r3, r0
20000f5c:	2b00      	cmp	r3, #0
20000f5e:	d001      	beq.n	20000f64 <QSPI_Configuration+0xa4>
                         HAL_QSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK) {
        return HAL_ERROR;
20000f60:	2301      	movs	r3, #1
20000f62:	e055      	b.n	20001010 <QSPI_Configuration+0x150>
    }



    if (QSPI_WriteEnable() != HAL_OK) {
20000f64:	f7ff ff62 	bl	20000e2c <QSPI_WriteEnable>
20000f68:	4603      	mov	r3, r0
20000f6a:	2b00      	cmp	r3, #0
20000f6c:	d001      	beq.n	20000f72 <QSPI_Configuration+0xb2>

        return HAL_ERROR;
20000f6e:	2301      	movs	r3, #1
20000f70:	e04e      	b.n	20001010 <QSPI_Configuration+0x150>
    }


    /*set dummy cycles*/
    MODIFY_REG(reg, 0xF0, (DUMMY_CLOCK_CYCLES_READ_QUAD << POSITION_VAL(0xF0)));
20000f72:	78fb      	ldrb	r3, [r7, #3]
20000f74:	b25b      	sxtb	r3, r3
20000f76:	f003 030f 	and.w	r3, r3, #15
20000f7a:	b25a      	sxtb	r2, r3
20000f7c:	23f0      	movs	r3, #240	; 0xf0
20000f7e:	643b      	str	r3, [r7, #64]	; 0x40
  uint32_t result;

#if ((defined (__ARM_ARCH_7M__      ) && (__ARM_ARCH_7M__      == 1)) || \
     (defined (__ARM_ARCH_7EM__     ) && (__ARM_ARCH_7EM__     == 1)) || \
     (defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1))    )
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
20000f80:	6c3b      	ldr	r3, [r7, #64]	; 0x40
20000f82:	fa93 f3a3 	rbit	r3, r3
20000f86:	63fb      	str	r3, [r7, #60]	; 0x3c
    result |= value & 1U;
    s--;
  }
  result <<= s;                        /* shift when v's highest bits are zero */
#endif
  return result;
20000f88:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
20000f8a:	647b      	str	r3, [r7, #68]	; 0x44
     optimisations using the logic "value was passed to __builtin_clz, so it
     is non-zero".
     ARM GCC 7.3 and possibly earlier will optimise this test away, leaving a
     single CLZ instruction.
   */
  if (value == 0U)
20000f8c:	6c7b      	ldr	r3, [r7, #68]	; 0x44
20000f8e:	2b00      	cmp	r3, #0
20000f90:	d101      	bne.n	20000f96 <QSPI_Configuration+0xd6>
  {
    return 32U;
20000f92:	2320      	movs	r3, #32
20000f94:	e003      	b.n	20000f9e <QSPI_Configuration+0xde>
  }
  return __builtin_clz(value);
20000f96:	6c7b      	ldr	r3, [r7, #68]	; 0x44
20000f98:	fab3 f383 	clz	r3, r3
20000f9c:	b2db      	uxtb	r3, r3
20000f9e:	4619      	mov	r1, r3
20000fa0:	230a      	movs	r3, #10
20000fa2:	408b      	lsls	r3, r1
20000fa4:	b25b      	sxtb	r3, r3
20000fa6:	4313      	orrs	r3, r2
20000fa8:	b25b      	sxtb	r3, r3
20000faa:	b2db      	uxtb	r3, r3
20000fac:	70fb      	strb	r3, [r7, #3]

    sCommand.InstructionMode = QSPI_INSTRUCTION_1_LINE;
20000fae:	f44f 7380 	mov.w	r3, #256	; 0x100
20000fb2:	61fb      	str	r3, [r7, #28]
    sCommand.AlternateByteMode = QSPI_ALTERNATE_BYTES_NONE;
20000fb4:	2300      	movs	r3, #0
20000fb6:	627b      	str	r3, [r7, #36]	; 0x24
    sCommand.DdrMode = QSPI_DDR_MODE_DISABLE;
20000fb8:	2300      	movs	r3, #0
20000fba:	633b      	str	r3, [r7, #48]	; 0x30
    sCommand.DdrHoldHalfCycle = QSPI_DDR_HHC_ANALOG_DELAY;
20000fbc:	2300      	movs	r3, #0
20000fbe:	637b      	str	r3, [r7, #52]	; 0x34
    sCommand.SIOOMode = QSPI_SIOO_INST_EVERY_CMD;
20000fc0:	2300      	movs	r3, #0
20000fc2:	63bb      	str	r3, [r7, #56]	; 0x38
    sCommand.Instruction = WRITE_VOL_CFG_REG_CMD;
20000fc4:	2381      	movs	r3, #129	; 0x81
20000fc6:	607b      	str	r3, [r7, #4]
    sCommand.AddressMode = QSPI_ADDRESS_NONE;
20000fc8:	2300      	movs	r3, #0
20000fca:	623b      	str	r3, [r7, #32]
    sCommand.DataMode = QSPI_DATA_1_LINE;
20000fcc:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
20000fd0:	62bb      	str	r3, [r7, #40]	; 0x28
    sCommand.DummyCycles = 0;
20000fd2:	2300      	movs	r3, #0
20000fd4:	61bb      	str	r3, [r7, #24]
    sCommand.NbData = 1;
20000fd6:	2301      	movs	r3, #1
20000fd8:	62fb      	str	r3, [r7, #44]	; 0x2c

    if (HAL_QSPI_Command(&hqspi1, &sCommand, HAL_QSPI_TIMEOUT_DEFAULT_VALUE)
20000fda:	1d3b      	adds	r3, r7, #4
20000fdc:	f241 3288 	movw	r2, #5000	; 0x1388
20000fe0:	4619      	mov	r1, r3
20000fe2:	480d      	ldr	r0, [pc, #52]	; (20001018 <QSPI_Configuration+0x158>)
20000fe4:	f005 fafc 	bl	200065e0 <HAL_QSPI_Command>
20000fe8:	4603      	mov	r3, r0
20000fea:	2b00      	cmp	r3, #0
20000fec:	d001      	beq.n	20000ff2 <QSPI_Configuration+0x132>
        != HAL_OK) {
        return HAL_ERROR;
20000fee:	2301      	movs	r3, #1
20000ff0:	e00e      	b.n	20001010 <QSPI_Configuration+0x150>
    }

    if (HAL_QSPI_Transmit(&hqspi1, &reg,
20000ff2:	1cfb      	adds	r3, r7, #3
20000ff4:	f241 3288 	movw	r2, #5000	; 0x1388
20000ff8:	4619      	mov	r1, r3
20000ffa:	4807      	ldr	r0, [pc, #28]	; (20001018 <QSPI_Configuration+0x158>)
20000ffc:	f005 fbb4 	bl	20006768 <HAL_QSPI_Transmit>
20001000:	4603      	mov	r3, r0
20001002:	2b00      	cmp	r3, #0
20001004:	d003      	beq.n	2000100e <QSPI_Configuration+0x14e>
                          HAL_QSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK) {
        Error_Handler();
20001006:	f7ff fdb3 	bl	20000b70 <Error_Handler>
        return HAL_ERROR;
2000100a:	2301      	movs	r3, #1
2000100c:	e000      	b.n	20001010 <QSPI_Configuration+0x150>
    }
    return HAL_OK;
2000100e:	2300      	movs	r3, #0
}
20001010:	4618      	mov	r0, r3
20001012:	3748      	adds	r7, #72	; 0x48
20001014:	46bd      	mov	sp, r7
20001016:	bd80      	pop	{r7, pc}
20001018:	200004a4 	.word	0x200004a4

2000101c <CSP_QSPI_EraseSector>:

uint8_t
CSP_QSPI_EraseSector(uint32_t EraseStartAddress, uint32_t EraseEndAddress) {
2000101c:	b580      	push	{r7, lr}
2000101e:	b090      	sub	sp, #64	; 0x40
20001020:	af00      	add	r7, sp, #0
20001022:	6078      	str	r0, [r7, #4]
20001024:	6039      	str	r1, [r7, #0]

    QSPI_CommandTypeDef sCommand;

    EraseStartAddress = EraseStartAddress
20001026:	687b      	ldr	r3, [r7, #4]
20001028:	0c1b      	lsrs	r3, r3, #16
2000102a:	041b      	lsls	r3, r3, #16
2000102c:	607b      	str	r3, [r7, #4]
                        - EraseStartAddress % MEMORY_SECTOR_SIZE;

    /* Erasing Sequence -------------------------------------------------- */
    sCommand.InstructionMode = QSPI_INSTRUCTION_1_LINE;
2000102e:	f44f 7380 	mov.w	r3, #256	; 0x100
20001032:	623b      	str	r3, [r7, #32]
    sCommand.AddressSize = QSPI_ADDRESS_32_BITS;
20001034:	f44f 5340 	mov.w	r3, #12288	; 0x3000
20001038:	617b      	str	r3, [r7, #20]
    sCommand.AlternateByteMode = QSPI_ALTERNATE_BYTES_NONE;
2000103a:	2300      	movs	r3, #0
2000103c:	62bb      	str	r3, [r7, #40]	; 0x28
    sCommand.DdrMode = QSPI_DDR_MODE_DISABLE;
2000103e:	2300      	movs	r3, #0
20001040:	637b      	str	r3, [r7, #52]	; 0x34
    sCommand.DdrHoldHalfCycle = QSPI_DDR_HHC_ANALOG_DELAY;
20001042:	2300      	movs	r3, #0
20001044:	63bb      	str	r3, [r7, #56]	; 0x38
    sCommand.SIOOMode = QSPI_SIOO_INST_EVERY_CMD;
20001046:	2300      	movs	r3, #0
20001048:	63fb      	str	r3, [r7, #60]	; 0x3c
    sCommand.Instruction = SECTOR_ERASE_CMD;
2000104a:	23d8      	movs	r3, #216	; 0xd8
2000104c:	60bb      	str	r3, [r7, #8]
    sCommand.AddressMode = QSPI_ADDRESS_1_LINE;
2000104e:	f44f 6380 	mov.w	r3, #1024	; 0x400
20001052:	627b      	str	r3, [r7, #36]	; 0x24

    sCommand.DataMode = QSPI_DATA_NONE;
20001054:	2300      	movs	r3, #0
20001056:	62fb      	str	r3, [r7, #44]	; 0x2c
    sCommand.DummyCycles = 0;
20001058:	2300      	movs	r3, #0
2000105a:	61fb      	str	r3, [r7, #28]

    while (EraseEndAddress >= EraseStartAddress) {
2000105c:	e022      	b.n	200010a4 <CSP_QSPI_EraseSector+0x88>
        sCommand.Address = (EraseStartAddress & 0x0FFFFFFF);
2000105e:	687b      	ldr	r3, [r7, #4]
20001060:	f023 4370 	bic.w	r3, r3, #4026531840	; 0xf0000000
20001064:	60fb      	str	r3, [r7, #12]

        if (QSPI_WriteEnable() != HAL_OK) {
20001066:	f7ff fee1 	bl	20000e2c <QSPI_WriteEnable>
2000106a:	4603      	mov	r3, r0
2000106c:	2b00      	cmp	r3, #0
2000106e:	d001      	beq.n	20001074 <CSP_QSPI_EraseSector+0x58>
            return HAL_ERROR;
20001070:	2301      	movs	r3, #1
20001072:	e01c      	b.n	200010ae <CSP_QSPI_EraseSector+0x92>
        }

        if (HAL_QSPI_Command(&hqspi1, &sCommand, HAL_QSPI_TIMEOUT_DEFAULT_VALUE)
20001074:	f107 0308 	add.w	r3, r7, #8
20001078:	f241 3288 	movw	r2, #5000	; 0x1388
2000107c:	4619      	mov	r1, r3
2000107e:	480e      	ldr	r0, [pc, #56]	; (200010b8 <CSP_QSPI_EraseSector+0x9c>)
20001080:	f005 faae 	bl	200065e0 <HAL_QSPI_Command>
20001084:	4603      	mov	r3, r0
20001086:	2b00      	cmp	r3, #0
20001088:	d001      	beq.n	2000108e <CSP_QSPI_EraseSector+0x72>
            != HAL_OK) {
            return HAL_ERROR;
2000108a:	2301      	movs	r3, #1
2000108c:	e00f      	b.n	200010ae <CSP_QSPI_EraseSector+0x92>
        }
        EraseStartAddress += MEMORY_SECTOR_SIZE;
2000108e:	687b      	ldr	r3, [r7, #4]
20001090:	f503 3380 	add.w	r3, r3, #65536	; 0x10000
20001094:	607b      	str	r3, [r7, #4]

        if (QSPI_AutoPollingMemReady() != HAL_OK) {
20001096:	f7ff fe91 	bl	20000dbc <QSPI_AutoPollingMemReady>
2000109a:	4603      	mov	r3, r0
2000109c:	2b00      	cmp	r3, #0
2000109e:	d001      	beq.n	200010a4 <CSP_QSPI_EraseSector+0x88>
            return HAL_ERROR;
200010a0:	2301      	movs	r3, #1
200010a2:	e004      	b.n	200010ae <CSP_QSPI_EraseSector+0x92>
    while (EraseEndAddress >= EraseStartAddress) {
200010a4:	683a      	ldr	r2, [r7, #0]
200010a6:	687b      	ldr	r3, [r7, #4]
200010a8:	429a      	cmp	r2, r3
200010aa:	d2d8      	bcs.n	2000105e <CSP_QSPI_EraseSector+0x42>
        }
    }

    return HAL_OK;
200010ac:	2300      	movs	r3, #0
}
200010ae:	4618      	mov	r0, r3
200010b0:	3740      	adds	r7, #64	; 0x40
200010b2:	46bd      	mov	sp, r7
200010b4:	bd80      	pop	{r7, pc}
200010b6:	bf00      	nop
200010b8:	200004a4 	.word	0x200004a4

200010bc <CSP_QSPI_WriteMemory>:

uint8_t
CSP_QSPI_WriteMemory(uint8_t* buffer, uint32_t address, uint32_t buffer_size) {
200010bc:	b580      	push	{r7, lr}
200010be:	b096      	sub	sp, #88	; 0x58
200010c0:	af00      	add	r7, sp, #0
200010c2:	60f8      	str	r0, [r7, #12]
200010c4:	60b9      	str	r1, [r7, #8]
200010c6:	607a      	str	r2, [r7, #4]

    QSPI_CommandTypeDef sCommand;
    uint32_t end_addr, current_size, current_addr;

    /* Calculation of the size between the write address and the end of the page */
    current_addr = 0;
200010c8:	2300      	movs	r3, #0
200010ca:	653b      	str	r3, [r7, #80]	; 0x50


    //
    while (current_addr <= address) {
200010cc:	e003      	b.n	200010d6 <CSP_QSPI_WriteMemory+0x1a>
        current_addr += MEMORY_PAGE_SIZE;
200010ce:	6d3b      	ldr	r3, [r7, #80]	; 0x50
200010d0:	f503 7380 	add.w	r3, r3, #256	; 0x100
200010d4:	653b      	str	r3, [r7, #80]	; 0x50
    while (current_addr <= address) {
200010d6:	6d3a      	ldr	r2, [r7, #80]	; 0x50
200010d8:	68bb      	ldr	r3, [r7, #8]
200010da:	429a      	cmp	r2, r3
200010dc:	d9f7      	bls.n	200010ce <CSP_QSPI_WriteMemory+0x12>
    }
    current_size = current_addr - address;
200010de:	6d3a      	ldr	r2, [r7, #80]	; 0x50
200010e0:	68bb      	ldr	r3, [r7, #8]
200010e2:	1ad3      	subs	r3, r2, r3
200010e4:	657b      	str	r3, [r7, #84]	; 0x54

    /* Check if the size of the data is less than the remaining place in the page */
    if (current_size > buffer_size) {
200010e6:	6d7a      	ldr	r2, [r7, #84]	; 0x54
200010e8:	687b      	ldr	r3, [r7, #4]
200010ea:	429a      	cmp	r2, r3
200010ec:	d901      	bls.n	200010f2 <CSP_QSPI_WriteMemory+0x36>
        current_size = buffer_size;
200010ee:	687b      	ldr	r3, [r7, #4]
200010f0:	657b      	str	r3, [r7, #84]	; 0x54
    }

    /* Initialize the adress variables */
    current_addr = address;
200010f2:	68bb      	ldr	r3, [r7, #8]
200010f4:	653b      	str	r3, [r7, #80]	; 0x50
    end_addr = address + buffer_size;
200010f6:	68ba      	ldr	r2, [r7, #8]
200010f8:	687b      	ldr	r3, [r7, #4]
200010fa:	4413      	add	r3, r2
200010fc:	64fb      	str	r3, [r7, #76]	; 0x4c

    sCommand.InstructionMode = QSPI_INSTRUCTION_1_LINE;
200010fe:	f44f 7380 	mov.w	r3, #256	; 0x100
20001102:	62fb      	str	r3, [r7, #44]	; 0x2c
    sCommand.AddressSize = QSPI_ADDRESS_32_BITS;
20001104:	f44f 5340 	mov.w	r3, #12288	; 0x3000
20001108:	623b      	str	r3, [r7, #32]
    sCommand.AlternateByteMode = QSPI_ALTERNATE_BYTES_NONE;
2000110a:	2300      	movs	r3, #0
2000110c:	637b      	str	r3, [r7, #52]	; 0x34
    sCommand.DdrMode = QSPI_DDR_MODE_DISABLE;
2000110e:	2300      	movs	r3, #0
20001110:	643b      	str	r3, [r7, #64]	; 0x40
    sCommand.DdrHoldHalfCycle = QSPI_DDR_HHC_ANALOG_DELAY;
20001112:	2300      	movs	r3, #0
20001114:	647b      	str	r3, [r7, #68]	; 0x44
    sCommand.SIOOMode = QSPI_SIOO_INST_EVERY_CMD;
20001116:	2300      	movs	r3, #0
20001118:	64bb      	str	r3, [r7, #72]	; 0x48
    sCommand.Instruction = QUAD_IN_FAST_PROG_CMD;
2000111a:	2332      	movs	r3, #50	; 0x32
2000111c:	617b      	str	r3, [r7, #20]
    sCommand.AddressMode = QSPI_ADDRESS_1_LINE;
2000111e:	f44f 6380 	mov.w	r3, #1024	; 0x400
20001122:	633b      	str	r3, [r7, #48]	; 0x30
    sCommand.DataMode = QSPI_DATA_4_LINES;
20001124:	f04f 7340 	mov.w	r3, #50331648	; 0x3000000
20001128:	63bb      	str	r3, [r7, #56]	; 0x38
    sCommand.NbData = buffer_size;
2000112a:	687b      	ldr	r3, [r7, #4]
2000112c:	63fb      	str	r3, [r7, #60]	; 0x3c
    sCommand.Address = address;
2000112e:	68bb      	ldr	r3, [r7, #8]
20001130:	61bb      	str	r3, [r7, #24]
    sCommand.DummyCycles = 0;
20001132:	2300      	movs	r3, #0
20001134:	62bb      	str	r3, [r7, #40]	; 0x28

    /* Perform the write page by page */
    do {
        sCommand.Address = current_addr;
20001136:	6d3b      	ldr	r3, [r7, #80]	; 0x50
20001138:	61bb      	str	r3, [r7, #24]
        sCommand.NbData = current_size;
2000113a:	6d7b      	ldr	r3, [r7, #84]	; 0x54
2000113c:	63fb      	str	r3, [r7, #60]	; 0x3c

        if (current_size == 0) {
2000113e:	6d7b      	ldr	r3, [r7, #84]	; 0x54
20001140:	2b00      	cmp	r3, #0
20001142:	d101      	bne.n	20001148 <CSP_QSPI_WriteMemory+0x8c>
            return HAL_OK;
20001144:	2300      	movs	r3, #0
20001146:	e03f      	b.n	200011c8 <CSP_QSPI_WriteMemory+0x10c>
        }

        /* Enable write operations */
        if (QSPI_WriteEnable() != HAL_OK) {
20001148:	f7ff fe70 	bl	20000e2c <QSPI_WriteEnable>
2000114c:	4603      	mov	r3, r0
2000114e:	2b00      	cmp	r3, #0
20001150:	d001      	beq.n	20001156 <CSP_QSPI_WriteMemory+0x9a>
            return HAL_ERROR;
20001152:	2301      	movs	r3, #1
20001154:	e038      	b.n	200011c8 <CSP_QSPI_WriteMemory+0x10c>
        }

        /* Configure the command */
        if (HAL_QSPI_Command(&hqspi1, &sCommand, HAL_QSPI_TIMEOUT_DEFAULT_VALUE)
20001156:	f107 0314 	add.w	r3, r7, #20
2000115a:	f241 3288 	movw	r2, #5000	; 0x1388
2000115e:	4619      	mov	r1, r3
20001160:	481b      	ldr	r0, [pc, #108]	; (200011d0 <CSP_QSPI_WriteMemory+0x114>)
20001162:	f005 fa3d 	bl	200065e0 <HAL_QSPI_Command>
20001166:	4603      	mov	r3, r0
20001168:	2b00      	cmp	r3, #0
2000116a:	d001      	beq.n	20001170 <CSP_QSPI_WriteMemory+0xb4>
            != HAL_OK) {

            return HAL_ERROR;
2000116c:	2301      	movs	r3, #1
2000116e:	e02b      	b.n	200011c8 <CSP_QSPI_WriteMemory+0x10c>
        }

        /* Transmission of the data */
        if (HAL_QSPI_Transmit(&hqspi1, buffer, HAL_QSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK) {
20001170:	f241 3288 	movw	r2, #5000	; 0x1388
20001174:	68f9      	ldr	r1, [r7, #12]
20001176:	4816      	ldr	r0, [pc, #88]	; (200011d0 <CSP_QSPI_WriteMemory+0x114>)
20001178:	f005 faf6 	bl	20006768 <HAL_QSPI_Transmit>
2000117c:	4603      	mov	r3, r0
2000117e:	2b00      	cmp	r3, #0
20001180:	d001      	beq.n	20001186 <CSP_QSPI_WriteMemory+0xca>

            return HAL_ERROR;
20001182:	2301      	movs	r3, #1
20001184:	e020      	b.n	200011c8 <CSP_QSPI_WriteMemory+0x10c>
        }

        /* Configure automatic polling mode to wait for end of program */
        if (QSPI_AutoPollingMemReady() != HAL_OK) {
20001186:	f7ff fe19 	bl	20000dbc <QSPI_AutoPollingMemReady>
2000118a:	4603      	mov	r3, r0
2000118c:	2b00      	cmp	r3, #0
2000118e:	d001      	beq.n	20001194 <CSP_QSPI_WriteMemory+0xd8>
            return HAL_ERROR;
20001190:	2301      	movs	r3, #1
20001192:	e019      	b.n	200011c8 <CSP_QSPI_WriteMemory+0x10c>
        }

        /* Update the address and size variables for next page programming */
        current_addr += current_size;
20001194:	6d3a      	ldr	r2, [r7, #80]	; 0x50
20001196:	6d7b      	ldr	r3, [r7, #84]	; 0x54
20001198:	4413      	add	r3, r2
2000119a:	653b      	str	r3, [r7, #80]	; 0x50
        buffer += current_size;
2000119c:	68fa      	ldr	r2, [r7, #12]
2000119e:	6d7b      	ldr	r3, [r7, #84]	; 0x54
200011a0:	4413      	add	r3, r2
200011a2:	60fb      	str	r3, [r7, #12]
        current_size =
            ((current_addr + MEMORY_PAGE_SIZE) > end_addr) ?
200011a4:	6d3b      	ldr	r3, [r7, #80]	; 0x50
200011a6:	f503 7380 	add.w	r3, r3, #256	; 0x100
            (end_addr - current_addr) : MEMORY_PAGE_SIZE;
200011aa:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
200011ac:	429a      	cmp	r2, r3
200011ae:	d203      	bcs.n	200011b8 <CSP_QSPI_WriteMemory+0xfc>
200011b0:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
200011b2:	6d3b      	ldr	r3, [r7, #80]	; 0x50
200011b4:	1ad3      	subs	r3, r2, r3
200011b6:	e001      	b.n	200011bc <CSP_QSPI_WriteMemory+0x100>
200011b8:	f44f 7380 	mov.w	r3, #256	; 0x100
        current_size =
200011bc:	657b      	str	r3, [r7, #84]	; 0x54
    } while (current_addr <= end_addr);
200011be:	6d3a      	ldr	r2, [r7, #80]	; 0x50
200011c0:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
200011c2:	429a      	cmp	r2, r3
200011c4:	d9b7      	bls.n	20001136 <CSP_QSPI_WriteMemory+0x7a>

    return HAL_OK;
200011c6:	2300      	movs	r3, #0

}
200011c8:	4618      	mov	r0, r3
200011ca:	3758      	adds	r7, #88	; 0x58
200011cc:	46bd      	mov	sp, r7
200011ce:	bd80      	pop	{r7, pc}
200011d0:	200004a4 	.word	0x200004a4

200011d4 <CSP_QSPI_EnableMemoryMappedMode>:


uint8_t
CSP_QSPI_EnableMemoryMappedMode(void) {
200011d4:	b580      	push	{r7, lr}
200011d6:	b090      	sub	sp, #64	; 0x40
200011d8:	af00      	add	r7, sp, #0
    QSPI_CommandTypeDef sCommand;
    QSPI_MemoryMappedTypeDef sMemMappedCfg;

    /* Enable Memory-Mapped mode-------------------------------------------------- */

    sCommand.InstructionMode = QSPI_INSTRUCTION_1_LINE;
200011da:	f44f 7380 	mov.w	r3, #256	; 0x100
200011de:	623b      	str	r3, [r7, #32]
    sCommand.AddressSize = QSPI_ADDRESS_32_BITS;
200011e0:	f44f 5340 	mov.w	r3, #12288	; 0x3000
200011e4:	617b      	str	r3, [r7, #20]
    sCommand.AlternateByteMode = QSPI_ALTERNATE_BYTES_NONE;
200011e6:	2300      	movs	r3, #0
200011e8:	62bb      	str	r3, [r7, #40]	; 0x28
    sCommand.DdrMode = QSPI_DDR_MODE_DISABLE;
200011ea:	2300      	movs	r3, #0
200011ec:	637b      	str	r3, [r7, #52]	; 0x34
    sCommand.DdrHoldHalfCycle = QSPI_DDR_HHC_ANALOG_DELAY;
200011ee:	2300      	movs	r3, #0
200011f0:	63bb      	str	r3, [r7, #56]	; 0x38
    sCommand.SIOOMode = QSPI_SIOO_INST_EVERY_CMD;
200011f2:	2300      	movs	r3, #0
200011f4:	63fb      	str	r3, [r7, #60]	; 0x3c
    sCommand.AddressMode = QSPI_ADDRESS_4_LINES;
200011f6:	f44f 6340 	mov.w	r3, #3072	; 0xc00
200011fa:	627b      	str	r3, [r7, #36]	; 0x24
    sCommand.DataMode = QSPI_DATA_4_LINES;
200011fc:	f04f 7340 	mov.w	r3, #50331648	; 0x3000000
20001200:	62fb      	str	r3, [r7, #44]	; 0x2c
    sCommand.NbData = 0;
20001202:	2300      	movs	r3, #0
20001204:	633b      	str	r3, [r7, #48]	; 0x30
    sCommand.Address = 0;
20001206:	2300      	movs	r3, #0
20001208:	60fb      	str	r3, [r7, #12]
    sCommand.Instruction = QUAD_OUT_FAST_READ_CMD;
2000120a:	23eb      	movs	r3, #235	; 0xeb
2000120c:	60bb      	str	r3, [r7, #8]
    sCommand.DummyCycles = DUMMY_CLOCK_CYCLES_READ_QUAD;
2000120e:	230a      	movs	r3, #10
20001210:	61fb      	str	r3, [r7, #28]

    sMemMappedCfg.TimeOutActivation = QSPI_TIMEOUT_COUNTER_DISABLE;
20001212:	2300      	movs	r3, #0
20001214:	607b      	str	r3, [r7, #4]

    if (HAL_QSPI_MemoryMapped(&hqspi1, &sCommand, &sMemMappedCfg) != HAL_OK) {
20001216:	463a      	mov	r2, r7
20001218:	f107 0308 	add.w	r3, r7, #8
2000121c:	4619      	mov	r1, r3
2000121e:	4806      	ldr	r0, [pc, #24]	; (20001238 <CSP_QSPI_EnableMemoryMappedMode+0x64>)
20001220:	f005 ffa5 	bl	2000716e <HAL_QSPI_MemoryMapped>
20001224:	4603      	mov	r3, r0
20001226:	2b00      	cmp	r3, #0
20001228:	d001      	beq.n	2000122e <CSP_QSPI_EnableMemoryMappedMode+0x5a>
        return HAL_ERROR;
2000122a:	2301      	movs	r3, #1
2000122c:	e000      	b.n	20001230 <CSP_QSPI_EnableMemoryMappedMode+0x5c>
    }
    return HAL_OK;
2000122e:	2300      	movs	r3, #0
}
20001230:	4618      	mov	r0, r3
20001232:	3740      	adds	r7, #64	; 0x40
20001234:	46bd      	mov	sp, r7
20001236:	bd80      	pop	{r7, pc}
20001238:	200004a4 	.word	0x200004a4

2000123c <QSPI_ResetChip>:

uint8_t
QSPI_ResetChip() {
2000123c:	b580      	push	{r7, lr}
2000123e:	b090      	sub	sp, #64	; 0x40
20001240:	af00      	add	r7, sp, #0
    QSPI_CommandTypeDef sCommand;
    uint32_t temp = 0;
20001242:	2300      	movs	r3, #0
20001244:	63fb      	str	r3, [r7, #60]	; 0x3c
    /* Erasing Sequence -------------------------------------------------- */
    sCommand.InstructionMode = QSPI_INSTRUCTION_1_LINE;
20001246:	f44f 7380 	mov.w	r3, #256	; 0x100
2000124a:	61fb      	str	r3, [r7, #28]
    sCommand.AddressSize = QSPI_ADDRESS_24_BITS;
2000124c:	f44f 5300 	mov.w	r3, #8192	; 0x2000
20001250:	613b      	str	r3, [r7, #16]
    sCommand.AlternateByteMode = QSPI_ALTERNATE_BYTES_NONE;
20001252:	2300      	movs	r3, #0
20001254:	627b      	str	r3, [r7, #36]	; 0x24
    sCommand.DdrMode = QSPI_DDR_MODE_DISABLE;
20001256:	2300      	movs	r3, #0
20001258:	633b      	str	r3, [r7, #48]	; 0x30
    sCommand.DdrHoldHalfCycle = QSPI_DDR_HHC_ANALOG_DELAY;
2000125a:	2300      	movs	r3, #0
2000125c:	637b      	str	r3, [r7, #52]	; 0x34
    sCommand.SIOOMode = QSPI_SIOO_INST_EVERY_CMD;
2000125e:	2300      	movs	r3, #0
20001260:	63bb      	str	r3, [r7, #56]	; 0x38
    sCommand.Instruction = RESET_ENABLE_CMD;
20001262:	2366      	movs	r3, #102	; 0x66
20001264:	607b      	str	r3, [r7, #4]
    sCommand.AddressMode = QSPI_ADDRESS_NONE;
20001266:	2300      	movs	r3, #0
20001268:	623b      	str	r3, [r7, #32]
    sCommand.Address = 0;
2000126a:	2300      	movs	r3, #0
2000126c:	60bb      	str	r3, [r7, #8]
    sCommand.DataMode = QSPI_DATA_NONE;
2000126e:	2300      	movs	r3, #0
20001270:	62bb      	str	r3, [r7, #40]	; 0x28
    sCommand.DummyCycles = 0;
20001272:	2300      	movs	r3, #0
20001274:	61bb      	str	r3, [r7, #24]

    if (HAL_QSPI_Command(&hqspi1, &sCommand, HAL_QSPI_TIMEOUT_DEFAULT_VALUE)
20001276:	1d3b      	adds	r3, r7, #4
20001278:	f241 3288 	movw	r2, #5000	; 0x1388
2000127c:	4619      	mov	r1, r3
2000127e:	481d      	ldr	r0, [pc, #116]	; (200012f4 <QSPI_ResetChip+0xb8>)
20001280:	f005 f9ae 	bl	200065e0 <HAL_QSPI_Command>
20001284:	4603      	mov	r3, r0
20001286:	2b00      	cmp	r3, #0
20001288:	d001      	beq.n	2000128e <QSPI_ResetChip+0x52>
        != HAL_OK) {
        return HAL_ERROR;
2000128a:	2301      	movs	r3, #1
2000128c:	e02e      	b.n	200012ec <QSPI_ResetChip+0xb0>
    }
    for (temp = 0; temp < 0x2f; temp++) {
2000128e:	2300      	movs	r3, #0
20001290:	63fb      	str	r3, [r7, #60]	; 0x3c
20001292:	e003      	b.n	2000129c <QSPI_ResetChip+0x60>
        __NOP();
20001294:	bf00      	nop
    for (temp = 0; temp < 0x2f; temp++) {
20001296:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
20001298:	3301      	adds	r3, #1
2000129a:	63fb      	str	r3, [r7, #60]	; 0x3c
2000129c:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
2000129e:	2b2e      	cmp	r3, #46	; 0x2e
200012a0:	d9f8      	bls.n	20001294 <QSPI_ResetChip+0x58>
    }

    sCommand.InstructionMode = QSPI_INSTRUCTION_1_LINE;
200012a2:	f44f 7380 	mov.w	r3, #256	; 0x100
200012a6:	61fb      	str	r3, [r7, #28]
    sCommand.AddressSize = QSPI_ADDRESS_24_BITS;
200012a8:	f44f 5300 	mov.w	r3, #8192	; 0x2000
200012ac:	613b      	str	r3, [r7, #16]
    sCommand.AlternateByteMode = QSPI_ALTERNATE_BYTES_NONE;
200012ae:	2300      	movs	r3, #0
200012b0:	627b      	str	r3, [r7, #36]	; 0x24
    sCommand.DdrMode = QSPI_DDR_MODE_DISABLE;
200012b2:	2300      	movs	r3, #0
200012b4:	633b      	str	r3, [r7, #48]	; 0x30
    sCommand.DdrHoldHalfCycle = QSPI_DDR_HHC_ANALOG_DELAY;
200012b6:	2300      	movs	r3, #0
200012b8:	637b      	str	r3, [r7, #52]	; 0x34
    sCommand.SIOOMode = QSPI_SIOO_INST_EVERY_CMD;
200012ba:	2300      	movs	r3, #0
200012bc:	63bb      	str	r3, [r7, #56]	; 0x38
    sCommand.Instruction = RESET_EXECUTE_CMD;
200012be:	2399      	movs	r3, #153	; 0x99
200012c0:	607b      	str	r3, [r7, #4]
    sCommand.AddressMode = QSPI_ADDRESS_NONE;
200012c2:	2300      	movs	r3, #0
200012c4:	623b      	str	r3, [r7, #32]
    sCommand.Address = 0;
200012c6:	2300      	movs	r3, #0
200012c8:	60bb      	str	r3, [r7, #8]
    sCommand.DataMode = QSPI_DATA_NONE;
200012ca:	2300      	movs	r3, #0
200012cc:	62bb      	str	r3, [r7, #40]	; 0x28
    sCommand.DummyCycles = 0;
200012ce:	2300      	movs	r3, #0
200012d0:	61bb      	str	r3, [r7, #24]

    if (HAL_QSPI_Command(&hqspi1, &sCommand, HAL_QSPI_TIMEOUT_DEFAULT_VALUE)
200012d2:	1d3b      	adds	r3, r7, #4
200012d4:	f241 3288 	movw	r2, #5000	; 0x1388
200012d8:	4619      	mov	r1, r3
200012da:	4806      	ldr	r0, [pc, #24]	; (200012f4 <QSPI_ResetChip+0xb8>)
200012dc:	f005 f980 	bl	200065e0 <HAL_QSPI_Command>
200012e0:	4603      	mov	r3, r0
200012e2:	2b00      	cmp	r3, #0
200012e4:	d001      	beq.n	200012ea <QSPI_ResetChip+0xae>
        != HAL_OK) {
        return HAL_ERROR;
200012e6:	2301      	movs	r3, #1
200012e8:	e000      	b.n	200012ec <QSPI_ResetChip+0xb0>
    }
    return HAL_OK;
200012ea:	2300      	movs	r3, #0
}
200012ec:	4618      	mov	r0, r3
200012ee:	3740      	adds	r7, #64	; 0x40
200012f0:	46bd      	mov	sp, r7
200012f2:	bd80      	pop	{r7, pc}
200012f4:	200004a4 	.word	0x200004a4

200012f8 <HAL_MspInit>:
/* USER CODE END 0 */
/**
  * Initializes the Global MSP.
  */
void HAL_MspInit(void)
{
200012f8:	b580      	push	{r7, lr}
200012fa:	b082      	sub	sp, #8
200012fc:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN MspInit 0 */

  /* USER CODE END MspInit 0 */

  __HAL_RCC_SYSCFG_CLK_ENABLE();
200012fe:	4b0f      	ldr	r3, [pc, #60]	; (2000133c <HAL_MspInit+0x44>)
20001300:	6e1b      	ldr	r3, [r3, #96]	; 0x60
20001302:	4a0e      	ldr	r2, [pc, #56]	; (2000133c <HAL_MspInit+0x44>)
20001304:	f043 0301 	orr.w	r3, r3, #1
20001308:	6613      	str	r3, [r2, #96]	; 0x60
2000130a:	4b0c      	ldr	r3, [pc, #48]	; (2000133c <HAL_MspInit+0x44>)
2000130c:	6e1b      	ldr	r3, [r3, #96]	; 0x60
2000130e:	f003 0301 	and.w	r3, r3, #1
20001312:	607b      	str	r3, [r7, #4]
20001314:	687b      	ldr	r3, [r7, #4]
  __HAL_RCC_PWR_CLK_ENABLE();
20001316:	4b09      	ldr	r3, [pc, #36]	; (2000133c <HAL_MspInit+0x44>)
20001318:	6d9b      	ldr	r3, [r3, #88]	; 0x58
2000131a:	4a08      	ldr	r2, [pc, #32]	; (2000133c <HAL_MspInit+0x44>)
2000131c:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
20001320:	6593      	str	r3, [r2, #88]	; 0x58
20001322:	4b06      	ldr	r3, [pc, #24]	; (2000133c <HAL_MspInit+0x44>)
20001324:	6d9b      	ldr	r3, [r3, #88]	; 0x58
20001326:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
2000132a:	603b      	str	r3, [r7, #0]
2000132c:	683b      	ldr	r3, [r7, #0]

  /* System interrupt init*/

  /** Disable the internal Pull-Up in Dead Battery pins of UCPD peripheral
  */
  HAL_PWREx_DisableUCPDDeadBattery();
2000132e:	f004 fec1 	bl	200060b4 <HAL_PWREx_DisableUCPDDeadBattery>

  /* USER CODE BEGIN MspInit 1 */

  /* USER CODE END MspInit 1 */
}
20001332:	bf00      	nop
20001334:	3708      	adds	r7, #8
20001336:	46bd      	mov	sp, r7
20001338:	bd80      	pop	{r7, pc}
2000133a:	bf00      	nop
2000133c:	40021000 	.word	0x40021000

20001340 <NMI_Handler>:
/******************************************************************************/
/**
  * @brief This function handles Non maskable interrupt.
  */
void NMI_Handler(void)
{
20001340:	b480      	push	{r7}
20001342:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN NonMaskableInt_IRQn 0 */

  /* USER CODE END NonMaskableInt_IRQn 0 */
  /* USER CODE BEGIN NonMaskableInt_IRQn 1 */
  while (1)
20001344:	e7fe      	b.n	20001344 <NMI_Handler+0x4>

20001346 <HardFault_Handler>:

/**
  * @brief This function handles Hard fault interrupt.
  */
void HardFault_Handler(void)
{
20001346:	b480      	push	{r7}
20001348:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN HardFault_IRQn 0 */

  /* USER CODE END HardFault_IRQn 0 */
  while (1)
2000134a:	e7fe      	b.n	2000134a <HardFault_Handler+0x4>

2000134c <MemManage_Handler>:

/**
  * @brief This function handles Memory management fault.
  */
void MemManage_Handler(void)
{
2000134c:	b480      	push	{r7}
2000134e:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN MemoryManagement_IRQn 0 */

  /* USER CODE END MemoryManagement_IRQn 0 */
  while (1)
20001350:	e7fe      	b.n	20001350 <MemManage_Handler+0x4>

20001352 <BusFault_Handler>:

/**
  * @brief This function handles Prefetch fault, memory access fault.
  */
void BusFault_Handler(void)
{
20001352:	b480      	push	{r7}
20001354:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN BusFault_IRQn 0 */

  /* USER CODE END BusFault_IRQn 0 */
  while (1)
20001356:	e7fe      	b.n	20001356 <BusFault_Handler+0x4>

20001358 <UsageFault_Handler>:

/**
  * @brief This function handles Undefined instruction or illegal state.
  */
void UsageFault_Handler(void)
{
20001358:	b480      	push	{r7}
2000135a:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN UsageFault_IRQn 0 */

  /* USER CODE END UsageFault_IRQn 0 */
  while (1)
2000135c:	e7fe      	b.n	2000135c <UsageFault_Handler+0x4>

2000135e <SVC_Handler>:

/**
  * @brief This function handles System service call via SWI instruction.
  */
void SVC_Handler(void)
{
2000135e:	b480      	push	{r7}
20001360:	af00      	add	r7, sp, #0

  /* USER CODE END SVCall_IRQn 0 */
  /* USER CODE BEGIN SVCall_IRQn 1 */

  /* USER CODE END SVCall_IRQn 1 */
}
20001362:	bf00      	nop
20001364:	46bd      	mov	sp, r7
20001366:	f85d 7b04 	ldr.w	r7, [sp], #4
2000136a:	4770      	bx	lr

2000136c <DebugMon_Handler>:

/**
  * @brief This function handles Debug monitor.
  */
void DebugMon_Handler(void)
{
2000136c:	b480      	push	{r7}
2000136e:	af00      	add	r7, sp, #0

  /* USER CODE END DebugMonitor_IRQn 0 */
  /* USER CODE BEGIN DebugMonitor_IRQn 1 */

  /* USER CODE END DebugMonitor_IRQn 1 */
}
20001370:	bf00      	nop
20001372:	46bd      	mov	sp, r7
20001374:	f85d 7b04 	ldr.w	r7, [sp], #4
20001378:	4770      	bx	lr

2000137a <PendSV_Handler>:

/**
  * @brief This function handles Pendable request for system service.
  */
void PendSV_Handler(void)
{
2000137a:	b480      	push	{r7}
2000137c:	af00      	add	r7, sp, #0

  /* USER CODE END PendSV_IRQn 0 */
  /* USER CODE BEGIN PendSV_IRQn 1 */

  /* USER CODE END PendSV_IRQn 1 */
}
2000137e:	bf00      	nop
20001380:	46bd      	mov	sp, r7
20001382:	f85d 7b04 	ldr.w	r7, [sp], #4
20001386:	4770      	bx	lr

20001388 <SysTick_Handler>:

/**
  * @brief This function handles System tick timer.
  */
void SysTick_Handler(void)
{
20001388:	b580      	push	{r7, lr}
2000138a:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN SysTick_IRQn 0 */

  /* USER CODE END SysTick_IRQn 0 */
  HAL_IncTick();
2000138c:	f000 fa74 	bl	20001878 <HAL_IncTick>
  /* USER CODE BEGIN SysTick_IRQn 1 */

  /* USER CODE END SysTick_IRQn 1 */
}
20001390:	bf00      	nop
20001392:	bd80      	pop	{r7, pc}

20001394 <initialise_monitor_handles>:
char **environ = __env;


/* Functions */
void initialise_monitor_handles()
{
20001394:	b480      	push	{r7}
20001396:	af00      	add	r7, sp, #0
}
20001398:	bf00      	nop
2000139a:	46bd      	mov	sp, r7
2000139c:	f85d 7b04 	ldr.w	r7, [sp], #4
200013a0:	4770      	bx	lr

200013a2 <_getpid>:

int _getpid(void)
{
200013a2:	b480      	push	{r7}
200013a4:	af00      	add	r7, sp, #0
	return 1;
200013a6:	2301      	movs	r3, #1
}
200013a8:	4618      	mov	r0, r3
200013aa:	46bd      	mov	sp, r7
200013ac:	f85d 7b04 	ldr.w	r7, [sp], #4
200013b0:	4770      	bx	lr

200013b2 <_kill>:

int _kill(int pid, int sig)
{
200013b2:	b580      	push	{r7, lr}
200013b4:	b082      	sub	sp, #8
200013b6:	af00      	add	r7, sp, #0
200013b8:	6078      	str	r0, [r7, #4]
200013ba:	6039      	str	r1, [r7, #0]
	errno = EINVAL;
200013bc:	f008 fd3e 	bl	20009e3c <__errno>
200013c0:	4603      	mov	r3, r0
200013c2:	2216      	movs	r2, #22
200013c4:	601a      	str	r2, [r3, #0]
	return -1;
200013c6:	f04f 33ff 	mov.w	r3, #4294967295
}
200013ca:	4618      	mov	r0, r3
200013cc:	3708      	adds	r7, #8
200013ce:	46bd      	mov	sp, r7
200013d0:	bd80      	pop	{r7, pc}

200013d2 <_exit>:

void _exit (int status)
{
200013d2:	b580      	push	{r7, lr}
200013d4:	b082      	sub	sp, #8
200013d6:	af00      	add	r7, sp, #0
200013d8:	6078      	str	r0, [r7, #4]
	_kill(status, -1);
200013da:	f04f 31ff 	mov.w	r1, #4294967295
200013de:	6878      	ldr	r0, [r7, #4]
200013e0:	f7ff ffe7 	bl	200013b2 <_kill>
	while (1) {}		/* Make sure we hang here */
200013e4:	e7fe      	b.n	200013e4 <_exit+0x12>

200013e6 <_read>:
}

__attribute__((weak)) int _read(int file, char *ptr, int len)
{
200013e6:	b580      	push	{r7, lr}
200013e8:	b086      	sub	sp, #24
200013ea:	af00      	add	r7, sp, #0
200013ec:	60f8      	str	r0, [r7, #12]
200013ee:	60b9      	str	r1, [r7, #8]
200013f0:	607a      	str	r2, [r7, #4]
	int DataIdx;

	for (DataIdx = 0; DataIdx < len; DataIdx++)
200013f2:	2300      	movs	r3, #0
200013f4:	617b      	str	r3, [r7, #20]
200013f6:	e00a      	b.n	2000140e <_read+0x28>
	{
		*ptr++ = __io_getchar();
200013f8:	f3af 8000 	nop.w
200013fc:	4601      	mov	r1, r0
200013fe:	68bb      	ldr	r3, [r7, #8]
20001400:	1c5a      	adds	r2, r3, #1
20001402:	60ba      	str	r2, [r7, #8]
20001404:	b2ca      	uxtb	r2, r1
20001406:	701a      	strb	r2, [r3, #0]
	for (DataIdx = 0; DataIdx < len; DataIdx++)
20001408:	697b      	ldr	r3, [r7, #20]
2000140a:	3301      	adds	r3, #1
2000140c:	617b      	str	r3, [r7, #20]
2000140e:	697a      	ldr	r2, [r7, #20]
20001410:	687b      	ldr	r3, [r7, #4]
20001412:	429a      	cmp	r2, r3
20001414:	dbf0      	blt.n	200013f8 <_read+0x12>
	}

return len;
20001416:	687b      	ldr	r3, [r7, #4]
}
20001418:	4618      	mov	r0, r3
2000141a:	3718      	adds	r7, #24
2000141c:	46bd      	mov	sp, r7
2000141e:	bd80      	pop	{r7, pc}

20001420 <_write>:

__attribute__((weak)) int _write(int file, char *ptr, int len)
{
20001420:	b580      	push	{r7, lr}
20001422:	b086      	sub	sp, #24
20001424:	af00      	add	r7, sp, #0
20001426:	60f8      	str	r0, [r7, #12]
20001428:	60b9      	str	r1, [r7, #8]
2000142a:	607a      	str	r2, [r7, #4]
	int DataIdx;

	for (DataIdx = 0; DataIdx < len; DataIdx++)
2000142c:	2300      	movs	r3, #0
2000142e:	617b      	str	r3, [r7, #20]
20001430:	e009      	b.n	20001446 <_write+0x26>
	{
		__io_putchar(*ptr++);
20001432:	68bb      	ldr	r3, [r7, #8]
20001434:	1c5a      	adds	r2, r3, #1
20001436:	60ba      	str	r2, [r7, #8]
20001438:	781b      	ldrb	r3, [r3, #0]
2000143a:	4618      	mov	r0, r3
2000143c:	f3af 8000 	nop.w
	for (DataIdx = 0; DataIdx < len; DataIdx++)
20001440:	697b      	ldr	r3, [r7, #20]
20001442:	3301      	adds	r3, #1
20001444:	617b      	str	r3, [r7, #20]
20001446:	697a      	ldr	r2, [r7, #20]
20001448:	687b      	ldr	r3, [r7, #4]
2000144a:	429a      	cmp	r2, r3
2000144c:	dbf1      	blt.n	20001432 <_write+0x12>
	}
	return len;
2000144e:	687b      	ldr	r3, [r7, #4]
}
20001450:	4618      	mov	r0, r3
20001452:	3718      	adds	r7, #24
20001454:	46bd      	mov	sp, r7
20001456:	bd80      	pop	{r7, pc}

20001458 <_close>:

int _close(int file)
{
20001458:	b480      	push	{r7}
2000145a:	b083      	sub	sp, #12
2000145c:	af00      	add	r7, sp, #0
2000145e:	6078      	str	r0, [r7, #4]
	return -1;
20001460:	f04f 33ff 	mov.w	r3, #4294967295
}
20001464:	4618      	mov	r0, r3
20001466:	370c      	adds	r7, #12
20001468:	46bd      	mov	sp, r7
2000146a:	f85d 7b04 	ldr.w	r7, [sp], #4
2000146e:	4770      	bx	lr

20001470 <_fstat>:


int _fstat(int file, struct stat *st)
{
20001470:	b480      	push	{r7}
20001472:	b083      	sub	sp, #12
20001474:	af00      	add	r7, sp, #0
20001476:	6078      	str	r0, [r7, #4]
20001478:	6039      	str	r1, [r7, #0]
	st->st_mode = S_IFCHR;
2000147a:	683b      	ldr	r3, [r7, #0]
2000147c:	f44f 5200 	mov.w	r2, #8192	; 0x2000
20001480:	605a      	str	r2, [r3, #4]
	return 0;
20001482:	2300      	movs	r3, #0
}
20001484:	4618      	mov	r0, r3
20001486:	370c      	adds	r7, #12
20001488:	46bd      	mov	sp, r7
2000148a:	f85d 7b04 	ldr.w	r7, [sp], #4
2000148e:	4770      	bx	lr

20001490 <_isatty>:

int _isatty(int file)
{
20001490:	b480      	push	{r7}
20001492:	b083      	sub	sp, #12
20001494:	af00      	add	r7, sp, #0
20001496:	6078      	str	r0, [r7, #4]
	return 1;
20001498:	2301      	movs	r3, #1
}
2000149a:	4618      	mov	r0, r3
2000149c:	370c      	adds	r7, #12
2000149e:	46bd      	mov	sp, r7
200014a0:	f85d 7b04 	ldr.w	r7, [sp], #4
200014a4:	4770      	bx	lr

200014a6 <_lseek>:

int _lseek(int file, int ptr, int dir)
{
200014a6:	b480      	push	{r7}
200014a8:	b085      	sub	sp, #20
200014aa:	af00      	add	r7, sp, #0
200014ac:	60f8      	str	r0, [r7, #12]
200014ae:	60b9      	str	r1, [r7, #8]
200014b0:	607a      	str	r2, [r7, #4]
	return 0;
200014b2:	2300      	movs	r3, #0
}
200014b4:	4618      	mov	r0, r3
200014b6:	3714      	adds	r7, #20
200014b8:	46bd      	mov	sp, r7
200014ba:	f85d 7b04 	ldr.w	r7, [sp], #4
200014be:	4770      	bx	lr

200014c0 <_open>:

int _open(char *path, int flags, ...)
{
200014c0:	b40e      	push	{r1, r2, r3}
200014c2:	b480      	push	{r7}
200014c4:	b082      	sub	sp, #8
200014c6:	af00      	add	r7, sp, #0
200014c8:	6078      	str	r0, [r7, #4]
	/* Pretend like we always fail */
	return -1;
200014ca:	f04f 33ff 	mov.w	r3, #4294967295
}
200014ce:	4618      	mov	r0, r3
200014d0:	3708      	adds	r7, #8
200014d2:	46bd      	mov	sp, r7
200014d4:	f85d 7b04 	ldr.w	r7, [sp], #4
200014d8:	b003      	add	sp, #12
200014da:	4770      	bx	lr

200014dc <_wait>:

int _wait(int *status)
{
200014dc:	b580      	push	{r7, lr}
200014de:	b082      	sub	sp, #8
200014e0:	af00      	add	r7, sp, #0
200014e2:	6078      	str	r0, [r7, #4]
	errno = ECHILD;
200014e4:	f008 fcaa 	bl	20009e3c <__errno>
200014e8:	4603      	mov	r3, r0
200014ea:	220a      	movs	r2, #10
200014ec:	601a      	str	r2, [r3, #0]
	return -1;
200014ee:	f04f 33ff 	mov.w	r3, #4294967295
}
200014f2:	4618      	mov	r0, r3
200014f4:	3708      	adds	r7, #8
200014f6:	46bd      	mov	sp, r7
200014f8:	bd80      	pop	{r7, pc}

200014fa <_unlink>:

int _unlink(char *name)
{
200014fa:	b580      	push	{r7, lr}
200014fc:	b082      	sub	sp, #8
200014fe:	af00      	add	r7, sp, #0
20001500:	6078      	str	r0, [r7, #4]
	errno = ENOENT;
20001502:	f008 fc9b 	bl	20009e3c <__errno>
20001506:	4603      	mov	r3, r0
20001508:	2202      	movs	r2, #2
2000150a:	601a      	str	r2, [r3, #0]
	return -1;
2000150c:	f04f 33ff 	mov.w	r3, #4294967295
}
20001510:	4618      	mov	r0, r3
20001512:	3708      	adds	r7, #8
20001514:	46bd      	mov	sp, r7
20001516:	bd80      	pop	{r7, pc}

20001518 <_times>:

int _times(struct tms *buf)
{
20001518:	b480      	push	{r7}
2000151a:	b083      	sub	sp, #12
2000151c:	af00      	add	r7, sp, #0
2000151e:	6078      	str	r0, [r7, #4]
	return -1;
20001520:	f04f 33ff 	mov.w	r3, #4294967295
}
20001524:	4618      	mov	r0, r3
20001526:	370c      	adds	r7, #12
20001528:	46bd      	mov	sp, r7
2000152a:	f85d 7b04 	ldr.w	r7, [sp], #4
2000152e:	4770      	bx	lr

20001530 <_stat>:

int _stat(char *file, struct stat *st)
{
20001530:	b480      	push	{r7}
20001532:	b083      	sub	sp, #12
20001534:	af00      	add	r7, sp, #0
20001536:	6078      	str	r0, [r7, #4]
20001538:	6039      	str	r1, [r7, #0]
	st->st_mode = S_IFCHR;
2000153a:	683b      	ldr	r3, [r7, #0]
2000153c:	f44f 5200 	mov.w	r2, #8192	; 0x2000
20001540:	605a      	str	r2, [r3, #4]
	return 0;
20001542:	2300      	movs	r3, #0
}
20001544:	4618      	mov	r0, r3
20001546:	370c      	adds	r7, #12
20001548:	46bd      	mov	sp, r7
2000154a:	f85d 7b04 	ldr.w	r7, [sp], #4
2000154e:	4770      	bx	lr

20001550 <_link>:

int _link(char *old, char *new)
{
20001550:	b580      	push	{r7, lr}
20001552:	b082      	sub	sp, #8
20001554:	af00      	add	r7, sp, #0
20001556:	6078      	str	r0, [r7, #4]
20001558:	6039      	str	r1, [r7, #0]
	errno = EMLINK;
2000155a:	f008 fc6f 	bl	20009e3c <__errno>
2000155e:	4603      	mov	r3, r0
20001560:	221f      	movs	r2, #31
20001562:	601a      	str	r2, [r3, #0]
	return -1;
20001564:	f04f 33ff 	mov.w	r3, #4294967295
}
20001568:	4618      	mov	r0, r3
2000156a:	3708      	adds	r7, #8
2000156c:	46bd      	mov	sp, r7
2000156e:	bd80      	pop	{r7, pc}

20001570 <_fork>:

int _fork(void)
{
20001570:	b580      	push	{r7, lr}
20001572:	af00      	add	r7, sp, #0
	errno = EAGAIN;
20001574:	f008 fc62 	bl	20009e3c <__errno>
20001578:	4603      	mov	r3, r0
2000157a:	220b      	movs	r2, #11
2000157c:	601a      	str	r2, [r3, #0]
	return -1;
2000157e:	f04f 33ff 	mov.w	r3, #4294967295
}
20001582:	4618      	mov	r0, r3
20001584:	bd80      	pop	{r7, pc}

20001586 <_execve>:

int _execve(char *name, char **argv, char **env)
{
20001586:	b580      	push	{r7, lr}
20001588:	b084      	sub	sp, #16
2000158a:	af00      	add	r7, sp, #0
2000158c:	60f8      	str	r0, [r7, #12]
2000158e:	60b9      	str	r1, [r7, #8]
20001590:	607a      	str	r2, [r7, #4]
	errno = ENOMEM;
20001592:	f008 fc53 	bl	20009e3c <__errno>
20001596:	4603      	mov	r3, r0
20001598:	220c      	movs	r2, #12
2000159a:	601a      	str	r2, [r3, #0]
	return -1;
2000159c:	f04f 33ff 	mov.w	r3, #4294967295
}
200015a0:	4618      	mov	r0, r3
200015a2:	3710      	adds	r7, #16
200015a4:	46bd      	mov	sp, r7
200015a6:	bd80      	pop	{r7, pc}

200015a8 <_sbrk>:
 *
 * @param incr Memory size
 * @return Pointer to allocated memory
 */
void *_sbrk(ptrdiff_t incr)
{
200015a8:	b580      	push	{r7, lr}
200015aa:	b086      	sub	sp, #24
200015ac:	af00      	add	r7, sp, #0
200015ae:	6078      	str	r0, [r7, #4]
  extern uint8_t _end; /* Symbol defined in the linker script */
  extern uint8_t _estack; /* Symbol defined in the linker script */
  extern uint32_t _Min_Stack_Size; /* Symbol defined in the linker script */
  const uint32_t stack_limit = (uint32_t)&_estack - (uint32_t)&_Min_Stack_Size;
200015b0:	4a14      	ldr	r2, [pc, #80]	; (20001604 <_sbrk+0x5c>)
200015b2:	4b15      	ldr	r3, [pc, #84]	; (20001608 <_sbrk+0x60>)
200015b4:	1ad3      	subs	r3, r2, r3
200015b6:	617b      	str	r3, [r7, #20]
  const uint8_t *max_heap = (uint8_t *)stack_limit;
200015b8:	697b      	ldr	r3, [r7, #20]
200015ba:	613b      	str	r3, [r7, #16]
  uint8_t *prev_heap_end;

  /* Initialize heap end at first call */
  if (NULL == __sbrk_heap_end)
200015bc:	4b13      	ldr	r3, [pc, #76]	; (2000160c <_sbrk+0x64>)
200015be:	681b      	ldr	r3, [r3, #0]
200015c0:	2b00      	cmp	r3, #0
200015c2:	d102      	bne.n	200015ca <_sbrk+0x22>
  {
    __sbrk_heap_end = &_end;
200015c4:	4b11      	ldr	r3, [pc, #68]	; (2000160c <_sbrk+0x64>)
200015c6:	4a12      	ldr	r2, [pc, #72]	; (20001610 <_sbrk+0x68>)
200015c8:	601a      	str	r2, [r3, #0]
  }

  /* Protect heap from growing into the reserved MSP stack */
  if (__sbrk_heap_end + incr > max_heap)
200015ca:	4b10      	ldr	r3, [pc, #64]	; (2000160c <_sbrk+0x64>)
200015cc:	681a      	ldr	r2, [r3, #0]
200015ce:	687b      	ldr	r3, [r7, #4]
200015d0:	4413      	add	r3, r2
200015d2:	693a      	ldr	r2, [r7, #16]
200015d4:	429a      	cmp	r2, r3
200015d6:	d207      	bcs.n	200015e8 <_sbrk+0x40>
  {
    errno = ENOMEM;
200015d8:	f008 fc30 	bl	20009e3c <__errno>
200015dc:	4603      	mov	r3, r0
200015de:	220c      	movs	r2, #12
200015e0:	601a      	str	r2, [r3, #0]
    return (void *)-1;
200015e2:	f04f 33ff 	mov.w	r3, #4294967295
200015e6:	e009      	b.n	200015fc <_sbrk+0x54>
  }

  prev_heap_end = __sbrk_heap_end;
200015e8:	4b08      	ldr	r3, [pc, #32]	; (2000160c <_sbrk+0x64>)
200015ea:	681b      	ldr	r3, [r3, #0]
200015ec:	60fb      	str	r3, [r7, #12]
  __sbrk_heap_end += incr;
200015ee:	4b07      	ldr	r3, [pc, #28]	; (2000160c <_sbrk+0x64>)
200015f0:	681a      	ldr	r2, [r3, #0]
200015f2:	687b      	ldr	r3, [r7, #4]
200015f4:	4413      	add	r3, r2
200015f6:	4a05      	ldr	r2, [pc, #20]	; (2000160c <_sbrk+0x64>)
200015f8:	6013      	str	r3, [r2, #0]

  return (void *)prev_heap_end;
200015fa:	68fb      	ldr	r3, [r7, #12]
}
200015fc:	4618      	mov	r0, r3
200015fe:	3718      	adds	r7, #24
20001600:	46bd      	mov	sp, r7
20001602:	bd80      	pop	{r7, pc}
20001604:	20080004 	.word	0x20080004
20001608:	00000400 	.word	0x00000400
2000160c:	200004a0 	.word	0x200004a0
20001610:	2000a20c 	.word	0x2000a20c

20001614 <SystemInit>:
  * @param  None
  * @retval None
  */

void SystemInit(void)
{
20001614:	b480      	push	{r7}
20001616:	af00      	add	r7, sp, #0
  /* FPU settings ------------------------------------------------------------*/
  #if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
    SCB->CPACR |= ((3UL << (10*2))|(3UL << (11*2)));  /* set CP10 and CP11 Full Access */
20001618:	4b06      	ldr	r3, [pc, #24]	; (20001634 <SystemInit+0x20>)
2000161a:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
2000161e:	4a05      	ldr	r2, [pc, #20]	; (20001634 <SystemInit+0x20>)
20001620:	f443 0370 	orr.w	r3, r3, #15728640	; 0xf00000
20001624:	f8c2 3088 	str.w	r3, [r2, #136]	; 0x88

  /* Configure the Vector Table location add offset address ------------------*/
#if defined(USER_VECT_TAB_ADDRESS)
  SCB->VTOR = VECT_TAB_BASE_ADDRESS | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal SRAM */
#endif /* USER_VECT_TAB_ADDRESS */
}
20001628:	bf00      	nop
2000162a:	46bd      	mov	sp, r7
2000162c:	f85d 7b04 	ldr.w	r7, [sp], #4
20001630:	4770      	bx	lr
20001632:	bf00      	nop
20001634:	e000ed00 	.word	0xe000ed00

20001638 <SystemCoreClockUpdate>:
  *
  * @param  None
  * @retval None
  */
void SystemCoreClockUpdate(void)
{
20001638:	b480      	push	{r7}
2000163a:	b087      	sub	sp, #28
2000163c:	af00      	add	r7, sp, #0
  uint32_t tmp, pllvco, pllr, pllsource, pllm;

  /* Get SYSCLK source -------------------------------------------------------*/
  switch (RCC->CFGR & RCC_CFGR_SWS)
2000163e:	4b2e      	ldr	r3, [pc, #184]	; (200016f8 <SystemCoreClockUpdate+0xc0>)
20001640:	689b      	ldr	r3, [r3, #8]
20001642:	f003 030c 	and.w	r3, r3, #12
20001646:	2b0c      	cmp	r3, #12
20001648:	d00e      	beq.n	20001668 <SystemCoreClockUpdate+0x30>
2000164a:	2b0c      	cmp	r3, #12
2000164c:	d83e      	bhi.n	200016cc <SystemCoreClockUpdate+0x94>
2000164e:	2b04      	cmp	r3, #4
20001650:	d002      	beq.n	20001658 <SystemCoreClockUpdate+0x20>
20001652:	2b08      	cmp	r3, #8
20001654:	d004      	beq.n	20001660 <SystemCoreClockUpdate+0x28>
      pllr = (((RCC->PLLCFGR & RCC_PLLCFGR_PLLR) >> 25) + 1U) * 2U;
      SystemCoreClock = pllvco/pllr;
      break;

    default:
      break;
20001656:	e039      	b.n	200016cc <SystemCoreClockUpdate+0x94>
      SystemCoreClock = HSI_VALUE;
20001658:	4b28      	ldr	r3, [pc, #160]	; (200016fc <SystemCoreClockUpdate+0xc4>)
2000165a:	4a29      	ldr	r2, [pc, #164]	; (20001700 <SystemCoreClockUpdate+0xc8>)
2000165c:	601a      	str	r2, [r3, #0]
      break;
2000165e:	e036      	b.n	200016ce <SystemCoreClockUpdate+0x96>
      SystemCoreClock = HSE_VALUE;
20001660:	4b26      	ldr	r3, [pc, #152]	; (200016fc <SystemCoreClockUpdate+0xc4>)
20001662:	4a28      	ldr	r2, [pc, #160]	; (20001704 <SystemCoreClockUpdate+0xcc>)
20001664:	601a      	str	r2, [r3, #0]
      break;
20001666:	e032      	b.n	200016ce <SystemCoreClockUpdate+0x96>
      pllsource = (RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC);
20001668:	4b23      	ldr	r3, [pc, #140]	; (200016f8 <SystemCoreClockUpdate+0xc0>)
2000166a:	68db      	ldr	r3, [r3, #12]
2000166c:	f003 0303 	and.w	r3, r3, #3
20001670:	613b      	str	r3, [r7, #16]
      pllm = ((RCC->PLLCFGR & RCC_PLLCFGR_PLLM) >> 4) + 1U ;
20001672:	4b21      	ldr	r3, [pc, #132]	; (200016f8 <SystemCoreClockUpdate+0xc0>)
20001674:	68db      	ldr	r3, [r3, #12]
20001676:	091b      	lsrs	r3, r3, #4
20001678:	f003 030f 	and.w	r3, r3, #15
2000167c:	3301      	adds	r3, #1
2000167e:	60fb      	str	r3, [r7, #12]
      if (pllsource == 0x02UL) /* HSI used as PLL clock source */
20001680:	693b      	ldr	r3, [r7, #16]
20001682:	2b02      	cmp	r3, #2
20001684:	d105      	bne.n	20001692 <SystemCoreClockUpdate+0x5a>
        pllvco = (HSI_VALUE / pllm);
20001686:	4a1e      	ldr	r2, [pc, #120]	; (20001700 <SystemCoreClockUpdate+0xc8>)
20001688:	68fb      	ldr	r3, [r7, #12]
2000168a:	fbb2 f3f3 	udiv	r3, r2, r3
2000168e:	617b      	str	r3, [r7, #20]
20001690:	e004      	b.n	2000169c <SystemCoreClockUpdate+0x64>
        pllvco = (HSE_VALUE / pllm);
20001692:	4a1c      	ldr	r2, [pc, #112]	; (20001704 <SystemCoreClockUpdate+0xcc>)
20001694:	68fb      	ldr	r3, [r7, #12]
20001696:	fbb2 f3f3 	udiv	r3, r2, r3
2000169a:	617b      	str	r3, [r7, #20]
      pllvco = pllvco * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> 8);
2000169c:	4b16      	ldr	r3, [pc, #88]	; (200016f8 <SystemCoreClockUpdate+0xc0>)
2000169e:	68db      	ldr	r3, [r3, #12]
200016a0:	0a1b      	lsrs	r3, r3, #8
200016a2:	f003 027f 	and.w	r2, r3, #127	; 0x7f
200016a6:	697b      	ldr	r3, [r7, #20]
200016a8:	fb02 f303 	mul.w	r3, r2, r3
200016ac:	617b      	str	r3, [r7, #20]
      pllr = (((RCC->PLLCFGR & RCC_PLLCFGR_PLLR) >> 25) + 1U) * 2U;
200016ae:	4b12      	ldr	r3, [pc, #72]	; (200016f8 <SystemCoreClockUpdate+0xc0>)
200016b0:	68db      	ldr	r3, [r3, #12]
200016b2:	0e5b      	lsrs	r3, r3, #25
200016b4:	f003 0303 	and.w	r3, r3, #3
200016b8:	3301      	adds	r3, #1
200016ba:	005b      	lsls	r3, r3, #1
200016bc:	60bb      	str	r3, [r7, #8]
      SystemCoreClock = pllvco/pllr;
200016be:	697a      	ldr	r2, [r7, #20]
200016c0:	68bb      	ldr	r3, [r7, #8]
200016c2:	fbb2 f3f3 	udiv	r3, r2, r3
200016c6:	4a0d      	ldr	r2, [pc, #52]	; (200016fc <SystemCoreClockUpdate+0xc4>)
200016c8:	6013      	str	r3, [r2, #0]
      break;
200016ca:	e000      	b.n	200016ce <SystemCoreClockUpdate+0x96>
      break;
200016cc:	bf00      	nop
  }
  /* Compute HCLK clock frequency --------------------------------------------*/
  /* Get HCLK prescaler */
  tmp = AHBPrescTable[((RCC->CFGR & RCC_CFGR_HPRE) >> 4)];
200016ce:	4b0a      	ldr	r3, [pc, #40]	; (200016f8 <SystemCoreClockUpdate+0xc0>)
200016d0:	689b      	ldr	r3, [r3, #8]
200016d2:	091b      	lsrs	r3, r3, #4
200016d4:	f003 030f 	and.w	r3, r3, #15
200016d8:	4a0b      	ldr	r2, [pc, #44]	; (20001708 <SystemCoreClockUpdate+0xd0>)
200016da:	5cd3      	ldrb	r3, [r2, r3]
200016dc:	607b      	str	r3, [r7, #4]
  /* HCLK clock frequency */
  SystemCoreClock >>= tmp;
200016de:	4b07      	ldr	r3, [pc, #28]	; (200016fc <SystemCoreClockUpdate+0xc4>)
200016e0:	681a      	ldr	r2, [r3, #0]
200016e2:	687b      	ldr	r3, [r7, #4]
200016e4:	fa22 f303 	lsr.w	r3, r2, r3
200016e8:	4a04      	ldr	r2, [pc, #16]	; (200016fc <SystemCoreClockUpdate+0xc4>)
200016ea:	6013      	str	r3, [r2, #0]
}
200016ec:	bf00      	nop
200016ee:	371c      	adds	r7, #28
200016f0:	46bd      	mov	sp, r7
200016f2:	f85d 7b04 	ldr.w	r7, [sp], #4
200016f6:	4770      	bx	lr
200016f8:	40021000 	.word	0x40021000
200016fc:	200003f0 	.word	0x200003f0
20001700:	00f42400 	.word	0x00f42400
20001704:	007a1200 	.word	0x007a1200
20001708:	2000a1f0 	.word	0x2000a1f0

2000170c <Reset_Handler>:

    .section	.text.Reset_Handler
	.weak	Reset_Handler
	.type	Reset_Handler, %function
Reset_Handler:
  ldr   r0, =_estack
2000170c:	480d      	ldr	r0, [pc, #52]	; (20001744 <LoopForever+0x2>)
  mov   sp, r0          /* set stack pointer */
2000170e:	4685      	mov	sp, r0

/* Copy the data segment initializers from flash to SRAM */
  ldr r0, =_sdata
20001710:	480d      	ldr	r0, [pc, #52]	; (20001748 <LoopForever+0x6>)
  ldr r1, =_edata
20001712:	490e      	ldr	r1, [pc, #56]	; (2000174c <LoopForever+0xa>)
  ldr r2, =_sidata
20001714:	4a0e      	ldr	r2, [pc, #56]	; (20001750 <LoopForever+0xe>)
  movs r3, #0
20001716:	2300      	movs	r3, #0
  b	LoopCopyDataInit
20001718:	e002      	b.n	20001720 <LoopCopyDataInit>

2000171a <CopyDataInit>:

CopyDataInit:
  ldr r4, [r2, r3]
2000171a:	58d4      	ldr	r4, [r2, r3]
  str r4, [r0, r3]
2000171c:	50c4      	str	r4, [r0, r3]
  adds r3, r3, #4
2000171e:	3304      	adds	r3, #4

20001720 <LoopCopyDataInit>:

LoopCopyDataInit:
  adds r4, r0, r3
20001720:	18c4      	adds	r4, r0, r3
  cmp r4, r1
20001722:	428c      	cmp	r4, r1
  bcc CopyDataInit
20001724:	d3f9      	bcc.n	2000171a <CopyDataInit>
  
/* Zero fill the bss segment. */
  ldr r2, =_sbss
20001726:	4a0b      	ldr	r2, [pc, #44]	; (20001754 <LoopForever+0x12>)
  ldr r4, =_ebss
20001728:	4c0b      	ldr	r4, [pc, #44]	; (20001758 <LoopForever+0x16>)
  movs r3, #0
2000172a:	2300      	movs	r3, #0
  b LoopFillZerobss
2000172c:	e001      	b.n	20001732 <LoopFillZerobss>

2000172e <FillZerobss>:

FillZerobss:
  str  r3, [r2]
2000172e:	6013      	str	r3, [r2, #0]
  adds r2, r2, #4
20001730:	3204      	adds	r2, #4

20001732 <LoopFillZerobss>:

LoopFillZerobss:
  cmp r2, r4
20001732:	42a2      	cmp	r2, r4
  bcc FillZerobss
20001734:	d3fb      	bcc.n	2000172e <FillZerobss>

/* Call the clock system intitialization function.*/
    bl  SystemInit
20001736:	f7ff ff6d 	bl	20001614 <SystemInit>
/* Call static constructors */
    bl __libc_init_array
2000173a:	f008 fb99 	bl	20009e70 <__libc_init_array>
/* Call the application's entry point.*/
	bl	main
2000173e:	f7ff f9b5 	bl	20000aac <main>

20001742 <LoopForever>:

LoopForever:
    b LoopForever
20001742:	e7fe      	b.n	20001742 <LoopForever>
  ldr   r0, =_estack
20001744:	20080004 	.word	0x20080004
  ldr r0, =_sdata
20001748:	200003e8 	.word	0x200003e8
  ldr r1, =_edata
2000174c:	20000480 	.word	0x20000480
  ldr r2, =_sidata
20001750:	200003e8 	.word	0x200003e8
  ldr r2, =_sbss
20001754:	20000480 	.word	0x20000480
  ldr r4, =_ebss
20001758:	200004f4 	.word	0x200004f4

2000175c <ADC1_2_IRQHandler>:
 * @retval : None
*/
    .section	.text.Default_Handler,"ax",%progbits
Default_Handler:
Infinite_Loop:
	b	Infinite_Loop
2000175c:	e7fe      	b.n	2000175c <ADC1_2_IRQHandler>

2000175e <HAL_Init>:
  *         each 1ms in the SysTick_Handler() interrupt handler.
  *
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_Init(void)
{
2000175e:	b580      	push	{r7, lr}
20001760:	b082      	sub	sp, #8
20001762:	af00      	add	r7, sp, #0
  HAL_StatusTypeDef  status = HAL_OK;
20001764:	2300      	movs	r3, #0
20001766:	71fb      	strb	r3, [r7, #7]
#if (PREFETCH_ENABLE != 0U)
  __HAL_FLASH_PREFETCH_BUFFER_ENABLE();
#endif /* PREFETCH_ENABLE */

  /* Set Interrupt Group Priority */
  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
20001768:	2003      	movs	r0, #3
2000176a:	f000 fc8b 	bl	20002084 <HAL_NVIC_SetPriorityGrouping>

  /* Use SysTick as time base source and configure 1ms tick (default clock after Reset is HSI) */
  if (HAL_InitTick(TICK_INT_PRIORITY) != HAL_OK)
2000176e:	2000      	movs	r0, #0
20001770:	f000 f848 	bl	20001804 <HAL_InitTick>
20001774:	4603      	mov	r3, r0
20001776:	2b00      	cmp	r3, #0
20001778:	d002      	beq.n	20001780 <HAL_Init+0x22>
  {
    status = HAL_ERROR;
2000177a:	2301      	movs	r3, #1
2000177c:	71fb      	strb	r3, [r7, #7]
2000177e:	e001      	b.n	20001784 <HAL_Init+0x26>
  }
  else
  {
    /* Init the low level hardware */
    HAL_MspInit();
20001780:	f7ff fdba 	bl	200012f8 <HAL_MspInit>
  }

  /* Return function status */
  return status;
20001784:	79fb      	ldrb	r3, [r7, #7]

}
20001786:	4618      	mov	r0, r3
20001788:	3708      	adds	r7, #8
2000178a:	46bd      	mov	sp, r7
2000178c:	bd80      	pop	{r7, pc}
	...

20001790 <HAL_DeInit>:
  * @brief  This function de-initializes common part of the HAL and stops the source of time base.
  * @note   This function is optional.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DeInit(void)
{
20001790:	b580      	push	{r7, lr}
20001792:	af00      	add	r7, sp, #0
  /* Reset of all peripherals */
  __HAL_RCC_APB1_FORCE_RESET();
20001794:	4b13      	ldr	r3, [pc, #76]	; (200017e4 <HAL_DeInit+0x54>)
20001796:	f04f 32ff 	mov.w	r2, #4294967295
2000179a:	639a      	str	r2, [r3, #56]	; 0x38
  __HAL_RCC_APB1_RELEASE_RESET();
2000179c:	4b11      	ldr	r3, [pc, #68]	; (200017e4 <HAL_DeInit+0x54>)
2000179e:	2200      	movs	r2, #0
200017a0:	639a      	str	r2, [r3, #56]	; 0x38

  __HAL_RCC_APB2_FORCE_RESET();
200017a2:	4b10      	ldr	r3, [pc, #64]	; (200017e4 <HAL_DeInit+0x54>)
200017a4:	f04f 32ff 	mov.w	r2, #4294967295
200017a8:	641a      	str	r2, [r3, #64]	; 0x40
  __HAL_RCC_APB2_RELEASE_RESET();
200017aa:	4b0e      	ldr	r3, [pc, #56]	; (200017e4 <HAL_DeInit+0x54>)
200017ac:	2200      	movs	r2, #0
200017ae:	641a      	str	r2, [r3, #64]	; 0x40

  __HAL_RCC_AHB1_FORCE_RESET();
200017b0:	4b0c      	ldr	r3, [pc, #48]	; (200017e4 <HAL_DeInit+0x54>)
200017b2:	f04f 32ff 	mov.w	r2, #4294967295
200017b6:	629a      	str	r2, [r3, #40]	; 0x28
  __HAL_RCC_AHB1_RELEASE_RESET();
200017b8:	4b0a      	ldr	r3, [pc, #40]	; (200017e4 <HAL_DeInit+0x54>)
200017ba:	2200      	movs	r2, #0
200017bc:	629a      	str	r2, [r3, #40]	; 0x28

  __HAL_RCC_AHB2_FORCE_RESET();
200017be:	4b09      	ldr	r3, [pc, #36]	; (200017e4 <HAL_DeInit+0x54>)
200017c0:	f04f 32ff 	mov.w	r2, #4294967295
200017c4:	62da      	str	r2, [r3, #44]	; 0x2c
  __HAL_RCC_AHB2_RELEASE_RESET();
200017c6:	4b07      	ldr	r3, [pc, #28]	; (200017e4 <HAL_DeInit+0x54>)
200017c8:	2200      	movs	r2, #0
200017ca:	62da      	str	r2, [r3, #44]	; 0x2c

  __HAL_RCC_AHB3_FORCE_RESET();
200017cc:	4b05      	ldr	r3, [pc, #20]	; (200017e4 <HAL_DeInit+0x54>)
200017ce:	f04f 32ff 	mov.w	r2, #4294967295
200017d2:	631a      	str	r2, [r3, #48]	; 0x30
  __HAL_RCC_AHB3_RELEASE_RESET();
200017d4:	4b03      	ldr	r3, [pc, #12]	; (200017e4 <HAL_DeInit+0x54>)
200017d6:	2200      	movs	r2, #0
200017d8:	631a      	str	r2, [r3, #48]	; 0x30

  /* De-Init the low level hardware */
  HAL_MspDeInit();
200017da:	f000 f80c 	bl	200017f6 <HAL_MspDeInit>

  /* Return function status */
  return HAL_OK;
200017de:	2300      	movs	r3, #0
}
200017e0:	4618      	mov	r0, r3
200017e2:	bd80      	pop	{r7, pc}
200017e4:	40021000 	.word	0x40021000
/**
  * @brief  Initialize the MSP.
  * @retval None
  */
__weak void HAL_MspInit(void)
{
200017e8:	b480      	push	{r7}
200017ea:	af00      	add	r7, sp, #0
  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_MspInit could be implemented in the user file
   */
}
200017ec:	bf00      	nop
200017ee:	46bd      	mov	sp, r7
200017f0:	f85d 7b04 	ldr.w	r7, [sp], #4
200017f4:	4770      	bx	lr

200017f6 <HAL_MspDeInit>:
/**
  * @brief  DeInitializes the MSP.
  * @retval None
  */
__weak void HAL_MspDeInit(void)
{
200017f6:	b480      	push	{r7}
200017f8:	af00      	add	r7, sp, #0
  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_MspDeInit could be implemented in the user file
   */
}
200017fa:	bf00      	nop
200017fc:	46bd      	mov	sp, r7
200017fe:	f85d 7b04 	ldr.w	r7, [sp], #4
20001802:	4770      	bx	lr

20001804 <HAL_InitTick>:
  *       implementation  in user file.
  * @param TickPriority: Tick interrupt priority.
  * @retval HAL status
  */
__weak HAL_StatusTypeDef HAL_InitTick(uint32_t TickPriority)
{
20001804:	b580      	push	{r7, lr}
20001806:	b084      	sub	sp, #16
20001808:	af00      	add	r7, sp, #0
2000180a:	6078      	str	r0, [r7, #4]
  HAL_StatusTypeDef  status = HAL_OK;
2000180c:	2300      	movs	r3, #0
2000180e:	73fb      	strb	r3, [r7, #15]

  if (uwTickFreq != 0U)
20001810:	4b16      	ldr	r3, [pc, #88]	; (2000186c <HAL_InitTick+0x68>)
20001812:	681b      	ldr	r3, [r3, #0]
20001814:	2b00      	cmp	r3, #0
20001816:	d022      	beq.n	2000185e <HAL_InitTick+0x5a>
  {
    /* Configure the SysTick to have interrupt in 1ms time basis*/
    if (HAL_SYSTICK_Config(SystemCoreClock / (1000U / uwTickFreq)) == 0U)
20001818:	4b15      	ldr	r3, [pc, #84]	; (20001870 <HAL_InitTick+0x6c>)
2000181a:	681a      	ldr	r2, [r3, #0]
2000181c:	4b13      	ldr	r3, [pc, #76]	; (2000186c <HAL_InitTick+0x68>)
2000181e:	681b      	ldr	r3, [r3, #0]
20001820:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
20001824:	fbb1 f3f3 	udiv	r3, r1, r3
20001828:	fbb2 f3f3 	udiv	r3, r2, r3
2000182c:	4618      	mov	r0, r3
2000182e:	f000 fc6e 	bl	2000210e <HAL_SYSTICK_Config>
20001832:	4603      	mov	r3, r0
20001834:	2b00      	cmp	r3, #0
20001836:	d10f      	bne.n	20001858 <HAL_InitTick+0x54>
    {
      /* Configure the SysTick IRQ priority */
      if (TickPriority < (1UL << __NVIC_PRIO_BITS))
20001838:	687b      	ldr	r3, [r7, #4]
2000183a:	2b0f      	cmp	r3, #15
2000183c:	d809      	bhi.n	20001852 <HAL_InitTick+0x4e>
      {
        HAL_NVIC_SetPriority(SysTick_IRQn, TickPriority, 0U);
2000183e:	2200      	movs	r2, #0
20001840:	6879      	ldr	r1, [r7, #4]
20001842:	f04f 30ff 	mov.w	r0, #4294967295
20001846:	f000 fc28 	bl	2000209a <HAL_NVIC_SetPriority>
        uwTickPrio = TickPriority;
2000184a:	4a0a      	ldr	r2, [pc, #40]	; (20001874 <HAL_InitTick+0x70>)
2000184c:	687b      	ldr	r3, [r7, #4]
2000184e:	6013      	str	r3, [r2, #0]
20001850:	e007      	b.n	20001862 <HAL_InitTick+0x5e>
      }
      else
      {
        status = HAL_ERROR;
20001852:	2301      	movs	r3, #1
20001854:	73fb      	strb	r3, [r7, #15]
20001856:	e004      	b.n	20001862 <HAL_InitTick+0x5e>
      }
    }
    else
    {
      status = HAL_ERROR;
20001858:	2301      	movs	r3, #1
2000185a:	73fb      	strb	r3, [r7, #15]
2000185c:	e001      	b.n	20001862 <HAL_InitTick+0x5e>
    }
  }
  else
  {
    status = HAL_ERROR;
2000185e:	2301      	movs	r3, #1
20001860:	73fb      	strb	r3, [r7, #15]
  }

  /* Return function status */
  return status;
20001862:	7bfb      	ldrb	r3, [r7, #15]
}
20001864:	4618      	mov	r0, r3
20001866:	3710      	adds	r7, #16
20001868:	46bd      	mov	sp, r7
2000186a:	bd80      	pop	{r7, pc}
2000186c:	200003f8 	.word	0x200003f8
20001870:	200003f0 	.word	0x200003f0
20001874:	200003f4 	.word	0x200003f4

20001878 <HAL_IncTick>:
  * @note This function is declared as __weak to be overwritten in case of other
  *      implementations in user file.
  * @retval None
  */
__weak void HAL_IncTick(void)
{
20001878:	b480      	push	{r7}
2000187a:	af00      	add	r7, sp, #0
  uwTick += uwTickFreq;
2000187c:	4b05      	ldr	r3, [pc, #20]	; (20001894 <HAL_IncTick+0x1c>)
2000187e:	681a      	ldr	r2, [r3, #0]
20001880:	4b05      	ldr	r3, [pc, #20]	; (20001898 <HAL_IncTick+0x20>)
20001882:	681b      	ldr	r3, [r3, #0]
20001884:	4413      	add	r3, r2
20001886:	4a03      	ldr	r2, [pc, #12]	; (20001894 <HAL_IncTick+0x1c>)
20001888:	6013      	str	r3, [r2, #0]
}
2000188a:	bf00      	nop
2000188c:	46bd      	mov	sp, r7
2000188e:	f85d 7b04 	ldr.w	r7, [sp], #4
20001892:	4770      	bx	lr
20001894:	200004f0 	.word	0x200004f0
20001898:	200003f8 	.word	0x200003f8

2000189c <HAL_GetTick>:
  * @note This function is declared as __weak to be overwritten in case of other
  *       implementations in user file.
  * @retval tick value
  */
__weak uint32_t HAL_GetTick(void)
{
2000189c:	b480      	push	{r7}
2000189e:	af00      	add	r7, sp, #0
  return uwTick;
200018a0:	4b03      	ldr	r3, [pc, #12]	; (200018b0 <HAL_GetTick+0x14>)
200018a2:	681b      	ldr	r3, [r3, #0]
}
200018a4:	4618      	mov	r0, r3
200018a6:	46bd      	mov	sp, r7
200018a8:	f85d 7b04 	ldr.w	r7, [sp], #4
200018ac:	4770      	bx	lr
200018ae:	bf00      	nop
200018b0:	200004f0 	.word	0x200004f0

200018b4 <HAL_GetTickPrio>:
/**
  * @brief This function returns a tick priority.
  * @retval tick priority
  */
uint32_t HAL_GetTickPrio(void)
{
200018b4:	b480      	push	{r7}
200018b6:	af00      	add	r7, sp, #0
  return uwTickPrio;
200018b8:	4b03      	ldr	r3, [pc, #12]	; (200018c8 <HAL_GetTickPrio+0x14>)
200018ba:	681b      	ldr	r3, [r3, #0]
}
200018bc:	4618      	mov	r0, r3
200018be:	46bd      	mov	sp, r7
200018c0:	f85d 7b04 	ldr.w	r7, [sp], #4
200018c4:	4770      	bx	lr
200018c6:	bf00      	nop
200018c8:	200003f4 	.word	0x200003f4

200018cc <HAL_SetTickFreq>:
/**
  * @brief Set new tick Freq.
  * @retval status
  */
HAL_StatusTypeDef HAL_SetTickFreq(uint32_t Freq)
{
200018cc:	b580      	push	{r7, lr}
200018ce:	b084      	sub	sp, #16
200018d0:	af00      	add	r7, sp, #0
200018d2:	6078      	str	r0, [r7, #4]
  HAL_StatusTypeDef status  = HAL_OK;
200018d4:	2300      	movs	r3, #0
200018d6:	73fb      	strb	r3, [r7, #15]
  uint32_t prevTickFreq;

  assert_param(IS_TICKFREQ(Freq));

  if (uwTickFreq != Freq)
200018d8:	4b0e      	ldr	r3, [pc, #56]	; (20001914 <HAL_SetTickFreq+0x48>)
200018da:	681b      	ldr	r3, [r3, #0]
200018dc:	687a      	ldr	r2, [r7, #4]
200018de:	429a      	cmp	r2, r3
200018e0:	d012      	beq.n	20001908 <HAL_SetTickFreq+0x3c>
  {
    /* Back up uwTickFreq frequency */
    prevTickFreq = uwTickFreq;
200018e2:	4b0c      	ldr	r3, [pc, #48]	; (20001914 <HAL_SetTickFreq+0x48>)
200018e4:	681b      	ldr	r3, [r3, #0]
200018e6:	60bb      	str	r3, [r7, #8]

    /* Update uwTickFreq global variable used by HAL_InitTick() */
    uwTickFreq = Freq;
200018e8:	4a0a      	ldr	r2, [pc, #40]	; (20001914 <HAL_SetTickFreq+0x48>)
200018ea:	687b      	ldr	r3, [r7, #4]
200018ec:	6013      	str	r3, [r2, #0]

    /* Apply the new tick Freq  */
    status = HAL_InitTick(uwTickPrio);
200018ee:	4b0a      	ldr	r3, [pc, #40]	; (20001918 <HAL_SetTickFreq+0x4c>)
200018f0:	681b      	ldr	r3, [r3, #0]
200018f2:	4618      	mov	r0, r3
200018f4:	f7ff ff86 	bl	20001804 <HAL_InitTick>
200018f8:	4603      	mov	r3, r0
200018fa:	73fb      	strb	r3, [r7, #15]

    if (status != HAL_OK)
200018fc:	7bfb      	ldrb	r3, [r7, #15]
200018fe:	2b00      	cmp	r3, #0
20001900:	d002      	beq.n	20001908 <HAL_SetTickFreq+0x3c>
    {
      /* Restore previous tick frequency */
      uwTickFreq = prevTickFreq;
20001902:	4a04      	ldr	r2, [pc, #16]	; (20001914 <HAL_SetTickFreq+0x48>)
20001904:	68bb      	ldr	r3, [r7, #8]
20001906:	6013      	str	r3, [r2, #0]
    }
  }

  return status;
20001908:	7bfb      	ldrb	r3, [r7, #15]
}
2000190a:	4618      	mov	r0, r3
2000190c:	3710      	adds	r7, #16
2000190e:	46bd      	mov	sp, r7
20001910:	bd80      	pop	{r7, pc}
20001912:	bf00      	nop
20001914:	200003f8 	.word	0x200003f8
20001918:	200003f4 	.word	0x200003f4

2000191c <HAL_GetTickFreq>:
/**
  * @brief Returns tick frequency.
  * @retval tick period in Hz
  */
uint32_t HAL_GetTickFreq(void)
{
2000191c:	b480      	push	{r7}
2000191e:	af00      	add	r7, sp, #0
  return uwTickFreq;
20001920:	4b03      	ldr	r3, [pc, #12]	; (20001930 <HAL_GetTickFreq+0x14>)
20001922:	681b      	ldr	r3, [r3, #0]
}
20001924:	4618      	mov	r0, r3
20001926:	46bd      	mov	sp, r7
20001928:	f85d 7b04 	ldr.w	r7, [sp], #4
2000192c:	4770      	bx	lr
2000192e:	bf00      	nop
20001930:	200003f8 	.word	0x200003f8

20001934 <HAL_Delay>:
  *       implementations in user file.
  * @param Delay specifies the delay time length, in milliseconds.
  * @retval None
  */
__weak void HAL_Delay(uint32_t Delay)
{
20001934:	b580      	push	{r7, lr}
20001936:	b084      	sub	sp, #16
20001938:	af00      	add	r7, sp, #0
2000193a:	6078      	str	r0, [r7, #4]
  uint32_t tickstart = HAL_GetTick();
2000193c:	f7ff ffae 	bl	2000189c <HAL_GetTick>
20001940:	60b8      	str	r0, [r7, #8]
  uint32_t wait = Delay;
20001942:	687b      	ldr	r3, [r7, #4]
20001944:	60fb      	str	r3, [r7, #12]

  /* Add a freq to guarantee minimum wait */
  if (wait < HAL_MAX_DELAY)
20001946:	68fb      	ldr	r3, [r7, #12]
20001948:	f1b3 3fff 	cmp.w	r3, #4294967295
2000194c:	d004      	beq.n	20001958 <HAL_Delay+0x24>
  {
    wait += (uint32_t)(uwTickFreq);
2000194e:	4b09      	ldr	r3, [pc, #36]	; (20001974 <HAL_Delay+0x40>)
20001950:	681b      	ldr	r3, [r3, #0]
20001952:	68fa      	ldr	r2, [r7, #12]
20001954:	4413      	add	r3, r2
20001956:	60fb      	str	r3, [r7, #12]
  }

  while ((HAL_GetTick() - tickstart) < wait)
20001958:	bf00      	nop
2000195a:	f7ff ff9f 	bl	2000189c <HAL_GetTick>
2000195e:	4602      	mov	r2, r0
20001960:	68bb      	ldr	r3, [r7, #8]
20001962:	1ad3      	subs	r3, r2, r3
20001964:	68fa      	ldr	r2, [r7, #12]
20001966:	429a      	cmp	r2, r3
20001968:	d8f7      	bhi.n	2000195a <HAL_Delay+0x26>
  {
  }
}
2000196a:	bf00      	nop
2000196c:	bf00      	nop
2000196e:	3710      	adds	r7, #16
20001970:	46bd      	mov	sp, r7
20001972:	bd80      	pop	{r7, pc}
20001974:	200003f8 	.word	0x200003f8

20001978 <HAL_SuspendTick>:
  * @note This function is declared as __weak to be overwritten in case of other
  *       implementations in user file.
  * @retval None
  */
__weak void HAL_SuspendTick(void)
{
20001978:	b480      	push	{r7}
2000197a:	af00      	add	r7, sp, #0
  /* Disable SysTick Interrupt */
  CLEAR_BIT(SysTick->CTRL, SysTick_CTRL_TICKINT_Msk);
2000197c:	4b05      	ldr	r3, [pc, #20]	; (20001994 <HAL_SuspendTick+0x1c>)
2000197e:	681b      	ldr	r3, [r3, #0]
20001980:	4a04      	ldr	r2, [pc, #16]	; (20001994 <HAL_SuspendTick+0x1c>)
20001982:	f023 0302 	bic.w	r3, r3, #2
20001986:	6013      	str	r3, [r2, #0]
}
20001988:	bf00      	nop
2000198a:	46bd      	mov	sp, r7
2000198c:	f85d 7b04 	ldr.w	r7, [sp], #4
20001990:	4770      	bx	lr
20001992:	bf00      	nop
20001994:	e000e010 	.word	0xe000e010

20001998 <HAL_ResumeTick>:
  * @note This function is declared as __weak to be overwritten in case of other
  *       implementations in user file.
  * @retval None
  */
__weak void HAL_ResumeTick(void)
{
20001998:	b480      	push	{r7}
2000199a:	af00      	add	r7, sp, #0
  /* Enable SysTick Interrupt */
  SET_BIT(SysTick->CTRL, SysTick_CTRL_TICKINT_Msk);
2000199c:	4b05      	ldr	r3, [pc, #20]	; (200019b4 <HAL_ResumeTick+0x1c>)
2000199e:	681b      	ldr	r3, [r3, #0]
200019a0:	4a04      	ldr	r2, [pc, #16]	; (200019b4 <HAL_ResumeTick+0x1c>)
200019a2:	f043 0302 	orr.w	r3, r3, #2
200019a6:	6013      	str	r3, [r2, #0]
}
200019a8:	bf00      	nop
200019aa:	46bd      	mov	sp, r7
200019ac:	f85d 7b04 	ldr.w	r7, [sp], #4
200019b0:	4770      	bx	lr
200019b2:	bf00      	nop
200019b4:	e000e010 	.word	0xe000e010

200019b8 <HAL_GetHalVersion>:
/**
  * @brief  Returns the HAL revision.
  * @retval version : 0xXYZR (8bits for each decimal, R for RC)
  */
uint32_t HAL_GetHalVersion(void)
{
200019b8:	b480      	push	{r7}
200019ba:	af00      	add	r7, sp, #0
  return __STM32G4xx_HAL_VERSION;
200019bc:	4b02      	ldr	r3, [pc, #8]	; (200019c8 <HAL_GetHalVersion+0x10>)
}
200019be:	4618      	mov	r0, r3
200019c0:	46bd      	mov	sp, r7
200019c2:	f85d 7b04 	ldr.w	r7, [sp], #4
200019c6:	4770      	bx	lr
200019c8:	01020100 	.word	0x01020100

200019cc <HAL_GetREVID>:
/**
  * @brief  Returns the device revision identifier.
  * @retval Device revision identifier
  */
uint32_t HAL_GetREVID(void)
{
200019cc:	b480      	push	{r7}
200019ce:	af00      	add	r7, sp, #0
  return ((DBGMCU->IDCODE & DBGMCU_IDCODE_REV_ID) >> 16U);
200019d0:	4b04      	ldr	r3, [pc, #16]	; (200019e4 <HAL_GetREVID+0x18>)
200019d2:	681b      	ldr	r3, [r3, #0]
200019d4:	0c1b      	lsrs	r3, r3, #16
200019d6:	b29b      	uxth	r3, r3
}
200019d8:	4618      	mov	r0, r3
200019da:	46bd      	mov	sp, r7
200019dc:	f85d 7b04 	ldr.w	r7, [sp], #4
200019e0:	4770      	bx	lr
200019e2:	bf00      	nop
200019e4:	e0042000 	.word	0xe0042000

200019e8 <HAL_GetDEVID>:
/**
  * @brief  Returns the device identifier.
  * @retval Device identifier
  */
uint32_t HAL_GetDEVID(void)
{
200019e8:	b480      	push	{r7}
200019ea:	af00      	add	r7, sp, #0
  return (DBGMCU->IDCODE & DBGMCU_IDCODE_DEV_ID);
200019ec:	4b04      	ldr	r3, [pc, #16]	; (20001a00 <HAL_GetDEVID+0x18>)
200019ee:	681b      	ldr	r3, [r3, #0]
200019f0:	f3c3 030b 	ubfx	r3, r3, #0, #12
}
200019f4:	4618      	mov	r0, r3
200019f6:	46bd      	mov	sp, r7
200019f8:	f85d 7b04 	ldr.w	r7, [sp], #4
200019fc:	4770      	bx	lr
200019fe:	bf00      	nop
20001a00:	e0042000 	.word	0xe0042000

20001a04 <HAL_DBGMCU_EnableDBGSleepMode>:
/**
  * @brief  Enable the Debug Module during SLEEP mode.
  * @retval None
  */
void HAL_DBGMCU_EnableDBGSleepMode(void)
{
20001a04:	b480      	push	{r7}
20001a06:	af00      	add	r7, sp, #0
  SET_BIT(DBGMCU->CR, DBGMCU_CR_DBG_SLEEP);
20001a08:	4b05      	ldr	r3, [pc, #20]	; (20001a20 <HAL_DBGMCU_EnableDBGSleepMode+0x1c>)
20001a0a:	685b      	ldr	r3, [r3, #4]
20001a0c:	4a04      	ldr	r2, [pc, #16]	; (20001a20 <HAL_DBGMCU_EnableDBGSleepMode+0x1c>)
20001a0e:	f043 0301 	orr.w	r3, r3, #1
20001a12:	6053      	str	r3, [r2, #4]
}
20001a14:	bf00      	nop
20001a16:	46bd      	mov	sp, r7
20001a18:	f85d 7b04 	ldr.w	r7, [sp], #4
20001a1c:	4770      	bx	lr
20001a1e:	bf00      	nop
20001a20:	e0042000 	.word	0xe0042000

20001a24 <HAL_DBGMCU_DisableDBGSleepMode>:
/**
  * @brief  Disable the Debug Module during SLEEP mode.
  * @retval None
  */
void HAL_DBGMCU_DisableDBGSleepMode(void)
{
20001a24:	b480      	push	{r7}
20001a26:	af00      	add	r7, sp, #0
  CLEAR_BIT(DBGMCU->CR, DBGMCU_CR_DBG_SLEEP);
20001a28:	4b05      	ldr	r3, [pc, #20]	; (20001a40 <HAL_DBGMCU_DisableDBGSleepMode+0x1c>)
20001a2a:	685b      	ldr	r3, [r3, #4]
20001a2c:	4a04      	ldr	r2, [pc, #16]	; (20001a40 <HAL_DBGMCU_DisableDBGSleepMode+0x1c>)
20001a2e:	f023 0301 	bic.w	r3, r3, #1
20001a32:	6053      	str	r3, [r2, #4]
}
20001a34:	bf00      	nop
20001a36:	46bd      	mov	sp, r7
20001a38:	f85d 7b04 	ldr.w	r7, [sp], #4
20001a3c:	4770      	bx	lr
20001a3e:	bf00      	nop
20001a40:	e0042000 	.word	0xe0042000

20001a44 <HAL_DBGMCU_EnableDBGStopMode>:
/**
  * @brief  Enable the Debug Module during STOP0/STOP1/STOP2 modes.
  * @retval None
  */
void HAL_DBGMCU_EnableDBGStopMode(void)
{
20001a44:	b480      	push	{r7}
20001a46:	af00      	add	r7, sp, #0
  SET_BIT(DBGMCU->CR, DBGMCU_CR_DBG_STOP);
20001a48:	4b05      	ldr	r3, [pc, #20]	; (20001a60 <HAL_DBGMCU_EnableDBGStopMode+0x1c>)
20001a4a:	685b      	ldr	r3, [r3, #4]
20001a4c:	4a04      	ldr	r2, [pc, #16]	; (20001a60 <HAL_DBGMCU_EnableDBGStopMode+0x1c>)
20001a4e:	f043 0302 	orr.w	r3, r3, #2
20001a52:	6053      	str	r3, [r2, #4]
}
20001a54:	bf00      	nop
20001a56:	46bd      	mov	sp, r7
20001a58:	f85d 7b04 	ldr.w	r7, [sp], #4
20001a5c:	4770      	bx	lr
20001a5e:	bf00      	nop
20001a60:	e0042000 	.word	0xe0042000

20001a64 <HAL_DBGMCU_DisableDBGStopMode>:
/**
  * @brief  Disable the Debug Module during STOP0/STOP1/STOP2 modes.
  * @retval None
  */
void HAL_DBGMCU_DisableDBGStopMode(void)
{
20001a64:	b480      	push	{r7}
20001a66:	af00      	add	r7, sp, #0
  CLEAR_BIT(DBGMCU->CR, DBGMCU_CR_DBG_STOP);
20001a68:	4b05      	ldr	r3, [pc, #20]	; (20001a80 <HAL_DBGMCU_DisableDBGStopMode+0x1c>)
20001a6a:	685b      	ldr	r3, [r3, #4]
20001a6c:	4a04      	ldr	r2, [pc, #16]	; (20001a80 <HAL_DBGMCU_DisableDBGStopMode+0x1c>)
20001a6e:	f023 0302 	bic.w	r3, r3, #2
20001a72:	6053      	str	r3, [r2, #4]
}
20001a74:	bf00      	nop
20001a76:	46bd      	mov	sp, r7
20001a78:	f85d 7b04 	ldr.w	r7, [sp], #4
20001a7c:	4770      	bx	lr
20001a7e:	bf00      	nop
20001a80:	e0042000 	.word	0xe0042000

20001a84 <HAL_DBGMCU_EnableDBGStandbyMode>:
/**
  * @brief  Enable the Debug Module during STANDBY mode.
  * @retval None
  */
void HAL_DBGMCU_EnableDBGStandbyMode(void)
{
20001a84:	b480      	push	{r7}
20001a86:	af00      	add	r7, sp, #0
  SET_BIT(DBGMCU->CR, DBGMCU_CR_DBG_STANDBY);
20001a88:	4b05      	ldr	r3, [pc, #20]	; (20001aa0 <HAL_DBGMCU_EnableDBGStandbyMode+0x1c>)
20001a8a:	685b      	ldr	r3, [r3, #4]
20001a8c:	4a04      	ldr	r2, [pc, #16]	; (20001aa0 <HAL_DBGMCU_EnableDBGStandbyMode+0x1c>)
20001a8e:	f043 0304 	orr.w	r3, r3, #4
20001a92:	6053      	str	r3, [r2, #4]
}
20001a94:	bf00      	nop
20001a96:	46bd      	mov	sp, r7
20001a98:	f85d 7b04 	ldr.w	r7, [sp], #4
20001a9c:	4770      	bx	lr
20001a9e:	bf00      	nop
20001aa0:	e0042000 	.word	0xe0042000

20001aa4 <HAL_DBGMCU_DisableDBGStandbyMode>:
/**
  * @brief  Disable the Debug Module during STANDBY mode.
  * @retval None
  */
void HAL_DBGMCU_DisableDBGStandbyMode(void)
{
20001aa4:	b480      	push	{r7}
20001aa6:	af00      	add	r7, sp, #0
  CLEAR_BIT(DBGMCU->CR, DBGMCU_CR_DBG_STANDBY);
20001aa8:	4b05      	ldr	r3, [pc, #20]	; (20001ac0 <HAL_DBGMCU_DisableDBGStandbyMode+0x1c>)
20001aaa:	685b      	ldr	r3, [r3, #4]
20001aac:	4a04      	ldr	r2, [pc, #16]	; (20001ac0 <HAL_DBGMCU_DisableDBGStandbyMode+0x1c>)
20001aae:	f023 0304 	bic.w	r3, r3, #4
20001ab2:	6053      	str	r3, [r2, #4]
}
20001ab4:	bf00      	nop
20001ab6:	46bd      	mov	sp, r7
20001ab8:	f85d 7b04 	ldr.w	r7, [sp], #4
20001abc:	4770      	bx	lr
20001abe:	bf00      	nop
20001ac0:	e0042000 	.word	0xe0042000

20001ac4 <HAL_SYSCFG_CCMSRAMErase>:
  * @note   As long as CCMSRAM is not erased the CCMER bit will be set.
  *         This bit is automatically reset at the end of the CCMSRAM erase operation.
  * @retval None
  */
void HAL_SYSCFG_CCMSRAMErase(void)
{
20001ac4:	b480      	push	{r7}
20001ac6:	af00      	add	r7, sp, #0
  /* unlock the write protection of the CCMER bit */
  SYSCFG->SKR = 0xCA;
20001ac8:	4b08      	ldr	r3, [pc, #32]	; (20001aec <HAL_SYSCFG_CCMSRAMErase+0x28>)
20001aca:	22ca      	movs	r2, #202	; 0xca
20001acc:	625a      	str	r2, [r3, #36]	; 0x24
  SYSCFG->SKR = 0x53;
20001ace:	4b07      	ldr	r3, [pc, #28]	; (20001aec <HAL_SYSCFG_CCMSRAMErase+0x28>)
20001ad0:	2253      	movs	r2, #83	; 0x53
20001ad2:	625a      	str	r2, [r3, #36]	; 0x24
  /* Starts a hardware CCMSRAM erase operation*/
  SET_BIT(SYSCFG->SCSR, SYSCFG_SCSR_CCMER);
20001ad4:	4b05      	ldr	r3, [pc, #20]	; (20001aec <HAL_SYSCFG_CCMSRAMErase+0x28>)
20001ad6:	699b      	ldr	r3, [r3, #24]
20001ad8:	4a04      	ldr	r2, [pc, #16]	; (20001aec <HAL_SYSCFG_CCMSRAMErase+0x28>)
20001ada:	f043 0301 	orr.w	r3, r3, #1
20001ade:	6193      	str	r3, [r2, #24]
}
20001ae0:	bf00      	nop
20001ae2:	46bd      	mov	sp, r7
20001ae4:	f85d 7b04 	ldr.w	r7, [sp], #4
20001ae8:	4770      	bx	lr
20001aea:	bf00      	nop
20001aec:	40010000 	.word	0x40010000

20001af0 <HAL_SYSCFG_EnableMemorySwappingBank>:
  *         and Flash Bank1 mapped at 0x08040000 (and aliased at 0x00040000)
  *
  * @retval None
  */
void HAL_SYSCFG_EnableMemorySwappingBank(void)
{
20001af0:	b480      	push	{r7}
20001af2:	af00      	add	r7, sp, #0
  SET_BIT(SYSCFG->MEMRMP, SYSCFG_MEMRMP_FB_MODE);
20001af4:	4b05      	ldr	r3, [pc, #20]	; (20001b0c <HAL_SYSCFG_EnableMemorySwappingBank+0x1c>)
20001af6:	681b      	ldr	r3, [r3, #0]
20001af8:	4a04      	ldr	r2, [pc, #16]	; (20001b0c <HAL_SYSCFG_EnableMemorySwappingBank+0x1c>)
20001afa:	f443 7380 	orr.w	r3, r3, #256	; 0x100
20001afe:	6013      	str	r3, [r2, #0]
}
20001b00:	bf00      	nop
20001b02:	46bd      	mov	sp, r7
20001b04:	f85d 7b04 	ldr.w	r7, [sp], #4
20001b08:	4770      	bx	lr
20001b0a:	bf00      	nop
20001b0c:	40010000 	.word	0x40010000

20001b10 <HAL_SYSCFG_DisableMemorySwappingBank>:
  *         and Flash Bank2 mapped at 0x08040000 (and aliased at 0x00040000)
  *
  * @retval None
  */
void HAL_SYSCFG_DisableMemorySwappingBank(void)
{
20001b10:	b480      	push	{r7}
20001b12:	af00      	add	r7, sp, #0
  CLEAR_BIT(SYSCFG->MEMRMP, SYSCFG_MEMRMP_FB_MODE);
20001b14:	4b05      	ldr	r3, [pc, #20]	; (20001b2c <HAL_SYSCFG_DisableMemorySwappingBank+0x1c>)
20001b16:	681b      	ldr	r3, [r3, #0]
20001b18:	4a04      	ldr	r2, [pc, #16]	; (20001b2c <HAL_SYSCFG_DisableMemorySwappingBank+0x1c>)
20001b1a:	f423 7380 	bic.w	r3, r3, #256	; 0x100
20001b1e:	6013      	str	r3, [r2, #0]
}
20001b20:	bf00      	nop
20001b22:	46bd      	mov	sp, r7
20001b24:	f85d 7b04 	ldr.w	r7, [sp], #4
20001b28:	4770      	bx	lr
20001b2a:	bf00      	nop
20001b2c:	40010000 	.word	0x40010000

20001b30 <HAL_SYSCFG_VREFBUF_VoltageScalingConfig>:
  *            @arg SYSCFG_VREFBUF_VOLTAGE_SCALE2: VREFBUF_OUT around 2.9 V.
  *                                                This requires VDDA equal to or higher than 3.15 V.
  * @retval None
  */
void HAL_SYSCFG_VREFBUF_VoltageScalingConfig(uint32_t VoltageScaling)
{
20001b30:	b480      	push	{r7}
20001b32:	b083      	sub	sp, #12
20001b34:	af00      	add	r7, sp, #0
20001b36:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_SYSCFG_VREFBUF_VOLTAGE_SCALE(VoltageScaling));

  MODIFY_REG(VREFBUF->CSR, VREFBUF_CSR_VRS, VoltageScaling);
20001b38:	4b06      	ldr	r3, [pc, #24]	; (20001b54 <HAL_SYSCFG_VREFBUF_VoltageScalingConfig+0x24>)
20001b3a:	681b      	ldr	r3, [r3, #0]
20001b3c:	f023 0230 	bic.w	r2, r3, #48	; 0x30
20001b40:	4904      	ldr	r1, [pc, #16]	; (20001b54 <HAL_SYSCFG_VREFBUF_VoltageScalingConfig+0x24>)
20001b42:	687b      	ldr	r3, [r7, #4]
20001b44:	4313      	orrs	r3, r2
20001b46:	600b      	str	r3, [r1, #0]
}
20001b48:	bf00      	nop
20001b4a:	370c      	adds	r7, #12
20001b4c:	46bd      	mov	sp, r7
20001b4e:	f85d 7b04 	ldr.w	r7, [sp], #4
20001b52:	4770      	bx	lr
20001b54:	40010030 	.word	0x40010030

20001b58 <HAL_SYSCFG_VREFBUF_HighImpedanceConfig>:
  *            @arg SYSCFG_VREFBUF_HIGH_IMPEDANCE_DISABLE: VREF+ pin is internally connect to VREFINT output.
  *            @arg SYSCFG_VREFBUF_HIGH_IMPEDANCE_ENABLE: VREF+ pin is high impedance.
  * @retval None
  */
void HAL_SYSCFG_VREFBUF_HighImpedanceConfig(uint32_t Mode)
{
20001b58:	b480      	push	{r7}
20001b5a:	b083      	sub	sp, #12
20001b5c:	af00      	add	r7, sp, #0
20001b5e:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_SYSCFG_VREFBUF_HIGH_IMPEDANCE(Mode));

  MODIFY_REG(VREFBUF->CSR, VREFBUF_CSR_HIZ, Mode);
20001b60:	4b06      	ldr	r3, [pc, #24]	; (20001b7c <HAL_SYSCFG_VREFBUF_HighImpedanceConfig+0x24>)
20001b62:	681b      	ldr	r3, [r3, #0]
20001b64:	f023 0202 	bic.w	r2, r3, #2
20001b68:	4904      	ldr	r1, [pc, #16]	; (20001b7c <HAL_SYSCFG_VREFBUF_HighImpedanceConfig+0x24>)
20001b6a:	687b      	ldr	r3, [r7, #4]
20001b6c:	4313      	orrs	r3, r2
20001b6e:	600b      	str	r3, [r1, #0]
}
20001b70:	bf00      	nop
20001b72:	370c      	adds	r7, #12
20001b74:	46bd      	mov	sp, r7
20001b76:	f85d 7b04 	ldr.w	r7, [sp], #4
20001b7a:	4770      	bx	lr
20001b7c:	40010030 	.word	0x40010030

20001b80 <HAL_SYSCFG_VREFBUF_TrimmingConfig>:
  * @param TrimmingValue specifies trimming code for VREFBUF calibration
  *        This parameter can be a number between Min_Data = 0x00 and Max_Data = 0x3F
  * @retval None
  */
void HAL_SYSCFG_VREFBUF_TrimmingConfig(uint32_t TrimmingValue)
{
20001b80:	b480      	push	{r7}
20001b82:	b083      	sub	sp, #12
20001b84:	af00      	add	r7, sp, #0
20001b86:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_SYSCFG_VREFBUF_TRIMMING(TrimmingValue));

  MODIFY_REG(VREFBUF->CCR, VREFBUF_CCR_TRIM, TrimmingValue);
20001b88:	4b06      	ldr	r3, [pc, #24]	; (20001ba4 <HAL_SYSCFG_VREFBUF_TrimmingConfig+0x24>)
20001b8a:	685b      	ldr	r3, [r3, #4]
20001b8c:	f023 023f 	bic.w	r2, r3, #63	; 0x3f
20001b90:	4904      	ldr	r1, [pc, #16]	; (20001ba4 <HAL_SYSCFG_VREFBUF_TrimmingConfig+0x24>)
20001b92:	687b      	ldr	r3, [r7, #4]
20001b94:	4313      	orrs	r3, r2
20001b96:	604b      	str	r3, [r1, #4]
}
20001b98:	bf00      	nop
20001b9a:	370c      	adds	r7, #12
20001b9c:	46bd      	mov	sp, r7
20001b9e:	f85d 7b04 	ldr.w	r7, [sp], #4
20001ba2:	4770      	bx	lr
20001ba4:	40010030 	.word	0x40010030

20001ba8 <HAL_SYSCFG_EnableVREFBUF>:
/**
  * @brief  Enable the Internal Voltage Reference buffer (VREFBUF).
  * @retval HAL_OK/HAL_TIMEOUT
  */
HAL_StatusTypeDef HAL_SYSCFG_EnableVREFBUF(void)
{
20001ba8:	b580      	push	{r7, lr}
20001baa:	b082      	sub	sp, #8
20001bac:	af00      	add	r7, sp, #0
  uint32_t tickstart;

  SET_BIT(VREFBUF->CSR, VREFBUF_CSR_ENVR);
20001bae:	4b0f      	ldr	r3, [pc, #60]	; (20001bec <HAL_SYSCFG_EnableVREFBUF+0x44>)
20001bb0:	681b      	ldr	r3, [r3, #0]
20001bb2:	4a0e      	ldr	r2, [pc, #56]	; (20001bec <HAL_SYSCFG_EnableVREFBUF+0x44>)
20001bb4:	f043 0301 	orr.w	r3, r3, #1
20001bb8:	6013      	str	r3, [r2, #0]

  /* Get Start Tick*/
  tickstart = HAL_GetTick();
20001bba:	f7ff fe6f 	bl	2000189c <HAL_GetTick>
20001bbe:	6078      	str	r0, [r7, #4]

  /* Wait for VRR bit  */
  while (READ_BIT(VREFBUF->CSR, VREFBUF_CSR_VRR) == 0x00U)
20001bc0:	e008      	b.n	20001bd4 <HAL_SYSCFG_EnableVREFBUF+0x2c>
  {
    if ((HAL_GetTick() - tickstart) > VREFBUF_TIMEOUT_VALUE)
20001bc2:	f7ff fe6b 	bl	2000189c <HAL_GetTick>
20001bc6:	4602      	mov	r2, r0
20001bc8:	687b      	ldr	r3, [r7, #4]
20001bca:	1ad3      	subs	r3, r2, r3
20001bcc:	2b0a      	cmp	r3, #10
20001bce:	d901      	bls.n	20001bd4 <HAL_SYSCFG_EnableVREFBUF+0x2c>
    {
      return HAL_TIMEOUT;
20001bd0:	2303      	movs	r3, #3
20001bd2:	e006      	b.n	20001be2 <HAL_SYSCFG_EnableVREFBUF+0x3a>
  while (READ_BIT(VREFBUF->CSR, VREFBUF_CSR_VRR) == 0x00U)
20001bd4:	4b05      	ldr	r3, [pc, #20]	; (20001bec <HAL_SYSCFG_EnableVREFBUF+0x44>)
20001bd6:	681b      	ldr	r3, [r3, #0]
20001bd8:	f003 0308 	and.w	r3, r3, #8
20001bdc:	2b00      	cmp	r3, #0
20001bde:	d0f0      	beq.n	20001bc2 <HAL_SYSCFG_EnableVREFBUF+0x1a>
    }
  }

  return HAL_OK;
20001be0:	2300      	movs	r3, #0
}
20001be2:	4618      	mov	r0, r3
20001be4:	3708      	adds	r7, #8
20001be6:	46bd      	mov	sp, r7
20001be8:	bd80      	pop	{r7, pc}
20001bea:	bf00      	nop
20001bec:	40010030 	.word	0x40010030

20001bf0 <HAL_SYSCFG_DisableVREFBUF>:
  * @brief  Disable the Internal Voltage Reference buffer (VREFBUF).
  *
  * @retval None
  */
void HAL_SYSCFG_DisableVREFBUF(void)
{
20001bf0:	b480      	push	{r7}
20001bf2:	af00      	add	r7, sp, #0
  CLEAR_BIT(VREFBUF->CSR, VREFBUF_CSR_ENVR);
20001bf4:	4b05      	ldr	r3, [pc, #20]	; (20001c0c <HAL_SYSCFG_DisableVREFBUF+0x1c>)
20001bf6:	681b      	ldr	r3, [r3, #0]
20001bf8:	4a04      	ldr	r2, [pc, #16]	; (20001c0c <HAL_SYSCFG_DisableVREFBUF+0x1c>)
20001bfa:	f023 0301 	bic.w	r3, r3, #1
20001bfe:	6013      	str	r3, [r2, #0]
}
20001c00:	bf00      	nop
20001c02:	46bd      	mov	sp, r7
20001c04:	f85d 7b04 	ldr.w	r7, [sp], #4
20001c08:	4770      	bx	lr
20001c0a:	bf00      	nop
20001c0c:	40010030 	.word	0x40010030

20001c10 <HAL_SYSCFG_EnableIOSwitchBooster>:
  * @brief  Enable the I/O analog switch voltage booster
  *
  * @retval None
  */
void HAL_SYSCFG_EnableIOSwitchBooster(void)
{
20001c10:	b480      	push	{r7}
20001c12:	af00      	add	r7, sp, #0
  SET_BIT(SYSCFG->CFGR1, SYSCFG_CFGR1_BOOSTEN);
20001c14:	4b05      	ldr	r3, [pc, #20]	; (20001c2c <HAL_SYSCFG_EnableIOSwitchBooster+0x1c>)
20001c16:	685b      	ldr	r3, [r3, #4]
20001c18:	4a04      	ldr	r2, [pc, #16]	; (20001c2c <HAL_SYSCFG_EnableIOSwitchBooster+0x1c>)
20001c1a:	f443 7380 	orr.w	r3, r3, #256	; 0x100
20001c1e:	6053      	str	r3, [r2, #4]
}
20001c20:	bf00      	nop
20001c22:	46bd      	mov	sp, r7
20001c24:	f85d 7b04 	ldr.w	r7, [sp], #4
20001c28:	4770      	bx	lr
20001c2a:	bf00      	nop
20001c2c:	40010000 	.word	0x40010000

20001c30 <HAL_SYSCFG_DisableIOSwitchBooster>:
  * @brief  Disable the I/O analog switch voltage booster
  *
  * @retval None
  */
void HAL_SYSCFG_DisableIOSwitchBooster(void)
{
20001c30:	b480      	push	{r7}
20001c32:	af00      	add	r7, sp, #0
  CLEAR_BIT(SYSCFG->CFGR1, SYSCFG_CFGR1_BOOSTEN);
20001c34:	4b05      	ldr	r3, [pc, #20]	; (20001c4c <HAL_SYSCFG_DisableIOSwitchBooster+0x1c>)
20001c36:	685b      	ldr	r3, [r3, #4]
20001c38:	4a04      	ldr	r2, [pc, #16]	; (20001c4c <HAL_SYSCFG_DisableIOSwitchBooster+0x1c>)
20001c3a:	f423 7380 	bic.w	r3, r3, #256	; 0x100
20001c3e:	6053      	str	r3, [r2, #4]
}
20001c40:	bf00      	nop
20001c42:	46bd      	mov	sp, r7
20001c44:	f85d 7b04 	ldr.w	r7, [sp], #4
20001c48:	4770      	bx	lr
20001c4a:	bf00      	nop
20001c4c:	40010000 	.word	0x40010000

20001c50 <HAL_SYSCFG_EnableIOSwitchVDD>:
  * @brief  Enable the I/O analog switch voltage by VDD
  *
  * @retval None
  */
void HAL_SYSCFG_EnableIOSwitchVDD(void)
{
20001c50:	b480      	push	{r7}
20001c52:	af00      	add	r7, sp, #0
  SET_BIT(SYSCFG->CFGR1, SYSCFG_CFGR1_ANASWVDD);
20001c54:	4b05      	ldr	r3, [pc, #20]	; (20001c6c <HAL_SYSCFG_EnableIOSwitchVDD+0x1c>)
20001c56:	685b      	ldr	r3, [r3, #4]
20001c58:	4a04      	ldr	r2, [pc, #16]	; (20001c6c <HAL_SYSCFG_EnableIOSwitchVDD+0x1c>)
20001c5a:	f443 7300 	orr.w	r3, r3, #512	; 0x200
20001c5e:	6053      	str	r3, [r2, #4]
}
20001c60:	bf00      	nop
20001c62:	46bd      	mov	sp, r7
20001c64:	f85d 7b04 	ldr.w	r7, [sp], #4
20001c68:	4770      	bx	lr
20001c6a:	bf00      	nop
20001c6c:	40010000 	.word	0x40010000

20001c70 <HAL_SYSCFG_DisableIOSwitchVDD>:
  * @brief  Disable the I/O analog switch voltage by VDD
  *
  * @retval None
  */
void HAL_SYSCFG_DisableIOSwitchVDD(void)
{
20001c70:	b480      	push	{r7}
20001c72:	af00      	add	r7, sp, #0
  CLEAR_BIT(SYSCFG->CFGR1, SYSCFG_CFGR1_ANASWVDD);
20001c74:	4b05      	ldr	r3, [pc, #20]	; (20001c8c <HAL_SYSCFG_DisableIOSwitchVDD+0x1c>)
20001c76:	685b      	ldr	r3, [r3, #4]
20001c78:	4a04      	ldr	r2, [pc, #16]	; (20001c8c <HAL_SYSCFG_DisableIOSwitchVDD+0x1c>)
20001c7a:	f423 7300 	bic.w	r3, r3, #512	; 0x200
20001c7e:	6053      	str	r3, [r2, #4]
}
20001c80:	bf00      	nop
20001c82:	46bd      	mov	sp, r7
20001c84:	f85d 7b04 	ldr.w	r7, [sp], #4
20001c88:	4770      	bx	lr
20001c8a:	bf00      	nop
20001c8c:	40010000 	.word	0x40010000

20001c90 <HAL_SYSCFG_CCMSRAM_WriteProtectionEnable>:
  * @param Page: This parameter is a long 32bit value and can be a value of @ref SYSCFG_CCMSRAMWRP
  * @note   write protection can only be disabled by a system reset
  * @retval None
  */
void HAL_SYSCFG_CCMSRAM_WriteProtectionEnable(uint32_t Page)
{
20001c90:	b480      	push	{r7}
20001c92:	b083      	sub	sp, #12
20001c94:	af00      	add	r7, sp, #0
20001c96:	6078      	str	r0, [r7, #4]
  assert_param(IS_SYSCFG_CCMSRAMWRP_PAGE(Page));

  SET_BIT(SYSCFG->SWPR, (uint32_t)(Page));
20001c98:	4b05      	ldr	r3, [pc, #20]	; (20001cb0 <HAL_SYSCFG_CCMSRAM_WriteProtectionEnable+0x20>)
20001c9a:	6a1a      	ldr	r2, [r3, #32]
20001c9c:	4904      	ldr	r1, [pc, #16]	; (20001cb0 <HAL_SYSCFG_CCMSRAM_WriteProtectionEnable+0x20>)
20001c9e:	687b      	ldr	r3, [r7, #4]
20001ca0:	4313      	orrs	r3, r2
20001ca2:	620b      	str	r3, [r1, #32]
}
20001ca4:	bf00      	nop
20001ca6:	370c      	adds	r7, #12
20001ca8:	46bd      	mov	sp, r7
20001caa:	f85d 7b04 	ldr.w	r7, [sp], #4
20001cae:	4770      	bx	lr
20001cb0:	40010000 	.word	0x40010000

20001cb4 <__NVIC_SetPriorityGrouping>:
           In case of a conflict between priority grouping and available
           priority bits (__NVIC_PRIO_BITS), the smallest possible priority group is set.
  \param [in]      PriorityGroup  Priority grouping field.
 */
__STATIC_INLINE void __NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
20001cb4:	b480      	push	{r7}
20001cb6:	b085      	sub	sp, #20
20001cb8:	af00      	add	r7, sp, #0
20001cba:	6078      	str	r0, [r7, #4]
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */
20001cbc:	687b      	ldr	r3, [r7, #4]
20001cbe:	f003 0307 	and.w	r3, r3, #7
20001cc2:	60fb      	str	r3, [r7, #12]

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
20001cc4:	4b0c      	ldr	r3, [pc, #48]	; (20001cf8 <__NVIC_SetPriorityGrouping+0x44>)
20001cc6:	68db      	ldr	r3, [r3, #12]
20001cc8:	60bb      	str	r3, [r7, #8]
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
20001cca:	68ba      	ldr	r2, [r7, #8]
20001ccc:	f64f 03ff 	movw	r3, #63743	; 0xf8ff
20001cd0:	4013      	ands	r3, r2
20001cd2:	60bb      	str	r3, [r7, #8]
  reg_value  =  (reg_value                                   |
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << SCB_AIRCR_PRIGROUP_Pos)  );              /* Insert write key and priority group */
20001cd4:	68fb      	ldr	r3, [r7, #12]
20001cd6:	021a      	lsls	r2, r3, #8
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
20001cd8:	68bb      	ldr	r3, [r7, #8]
20001cda:	4313      	orrs	r3, r2
  reg_value  =  (reg_value                                   |
20001cdc:	f043 63bf 	orr.w	r3, r3, #100139008	; 0x5f80000
20001ce0:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
20001ce4:	60bb      	str	r3, [r7, #8]
  SCB->AIRCR =  reg_value;
20001ce6:	4a04      	ldr	r2, [pc, #16]	; (20001cf8 <__NVIC_SetPriorityGrouping+0x44>)
20001ce8:	68bb      	ldr	r3, [r7, #8]
20001cea:	60d3      	str	r3, [r2, #12]
}
20001cec:	bf00      	nop
20001cee:	3714      	adds	r7, #20
20001cf0:	46bd      	mov	sp, r7
20001cf2:	f85d 7b04 	ldr.w	r7, [sp], #4
20001cf6:	4770      	bx	lr
20001cf8:	e000ed00 	.word	0xe000ed00

20001cfc <__NVIC_GetPriorityGrouping>:
  \brief   Get Priority Grouping
  \details Reads the priority grouping field from the NVIC Interrupt Controller.
  \return                Priority grouping field (SCB->AIRCR [10:8] PRIGROUP field).
 */
__STATIC_INLINE uint32_t __NVIC_GetPriorityGrouping(void)
{
20001cfc:	b480      	push	{r7}
20001cfe:	af00      	add	r7, sp, #0
  return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
20001d00:	4b04      	ldr	r3, [pc, #16]	; (20001d14 <__NVIC_GetPriorityGrouping+0x18>)
20001d02:	68db      	ldr	r3, [r3, #12]
20001d04:	0a1b      	lsrs	r3, r3, #8
20001d06:	f003 0307 	and.w	r3, r3, #7
}
20001d0a:	4618      	mov	r0, r3
20001d0c:	46bd      	mov	sp, r7
20001d0e:	f85d 7b04 	ldr.w	r7, [sp], #4
20001d12:	4770      	bx	lr
20001d14:	e000ed00 	.word	0xe000ed00

20001d18 <__NVIC_EnableIRQ>:
  \details Enables a device specific interrupt in the NVIC interrupt controller.
  \param [in]      IRQn  Device specific interrupt number.
  \note    IRQn must not be negative.
 */
__STATIC_INLINE void __NVIC_EnableIRQ(IRQn_Type IRQn)
{
20001d18:	b480      	push	{r7}
20001d1a:	b083      	sub	sp, #12
20001d1c:	af00      	add	r7, sp, #0
20001d1e:	4603      	mov	r3, r0
20001d20:	71fb      	strb	r3, [r7, #7]
  if ((int32_t)(IRQn) >= 0)
20001d22:	f997 3007 	ldrsb.w	r3, [r7, #7]
20001d26:	2b00      	cmp	r3, #0
20001d28:	db0b      	blt.n	20001d42 <__NVIC_EnableIRQ+0x2a>
  {
    __COMPILER_BARRIER();
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
20001d2a:	79fb      	ldrb	r3, [r7, #7]
20001d2c:	f003 021f 	and.w	r2, r3, #31
20001d30:	4907      	ldr	r1, [pc, #28]	; (20001d50 <__NVIC_EnableIRQ+0x38>)
20001d32:	f997 3007 	ldrsb.w	r3, [r7, #7]
20001d36:	095b      	lsrs	r3, r3, #5
20001d38:	2001      	movs	r0, #1
20001d3a:	fa00 f202 	lsl.w	r2, r0, r2
20001d3e:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    __COMPILER_BARRIER();
  }
}
20001d42:	bf00      	nop
20001d44:	370c      	adds	r7, #12
20001d46:	46bd      	mov	sp, r7
20001d48:	f85d 7b04 	ldr.w	r7, [sp], #4
20001d4c:	4770      	bx	lr
20001d4e:	bf00      	nop
20001d50:	e000e100 	.word	0xe000e100

20001d54 <__NVIC_DisableIRQ>:
  \details Disables a device specific interrupt in the NVIC interrupt controller.
  \param [in]      IRQn  Device specific interrupt number.
  \note    IRQn must not be negative.
 */
__STATIC_INLINE void __NVIC_DisableIRQ(IRQn_Type IRQn)
{
20001d54:	b480      	push	{r7}
20001d56:	b083      	sub	sp, #12
20001d58:	af00      	add	r7, sp, #0
20001d5a:	4603      	mov	r3, r0
20001d5c:	71fb      	strb	r3, [r7, #7]
  if ((int32_t)(IRQn) >= 0)
20001d5e:	f997 3007 	ldrsb.w	r3, [r7, #7]
20001d62:	2b00      	cmp	r3, #0
20001d64:	db12      	blt.n	20001d8c <__NVIC_DisableIRQ+0x38>
  {
    NVIC->ICER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
20001d66:	79fb      	ldrb	r3, [r7, #7]
20001d68:	f003 021f 	and.w	r2, r3, #31
20001d6c:	490a      	ldr	r1, [pc, #40]	; (20001d98 <__NVIC_DisableIRQ+0x44>)
20001d6e:	f997 3007 	ldrsb.w	r3, [r7, #7]
20001d72:	095b      	lsrs	r3, r3, #5
20001d74:	2001      	movs	r0, #1
20001d76:	fa00 f202 	lsl.w	r2, r0, r2
20001d7a:	3320      	adds	r3, #32
20001d7c:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
  __ASM volatile ("dsb 0xF":::"memory");
20001d80:	f3bf 8f4f 	dsb	sy
}
20001d84:	bf00      	nop
  __ASM volatile ("isb 0xF":::"memory");
20001d86:	f3bf 8f6f 	isb	sy
}
20001d8a:	bf00      	nop
    __DSB();
    __ISB();
  }
}
20001d8c:	bf00      	nop
20001d8e:	370c      	adds	r7, #12
20001d90:	46bd      	mov	sp, r7
20001d92:	f85d 7b04 	ldr.w	r7, [sp], #4
20001d96:	4770      	bx	lr
20001d98:	e000e100 	.word	0xe000e100

20001d9c <__NVIC_GetPendingIRQ>:
  \return             0  Interrupt status is not pending.
  \return             1  Interrupt status is pending.
  \note    IRQn must not be negative.
 */
__STATIC_INLINE uint32_t __NVIC_GetPendingIRQ(IRQn_Type IRQn)
{
20001d9c:	b480      	push	{r7}
20001d9e:	b083      	sub	sp, #12
20001da0:	af00      	add	r7, sp, #0
20001da2:	4603      	mov	r3, r0
20001da4:	71fb      	strb	r3, [r7, #7]
  if ((int32_t)(IRQn) >= 0)
20001da6:	f997 3007 	ldrsb.w	r3, [r7, #7]
20001daa:	2b00      	cmp	r3, #0
20001dac:	db0e      	blt.n	20001dcc <__NVIC_GetPendingIRQ+0x30>
  {
    return((uint32_t)(((NVIC->ISPR[(((uint32_t)IRQn) >> 5UL)] & (1UL << (((uint32_t)IRQn) & 0x1FUL))) != 0UL) ? 1UL : 0UL));
20001dae:	4a0b      	ldr	r2, [pc, #44]	; (20001ddc <__NVIC_GetPendingIRQ+0x40>)
20001db0:	f997 3007 	ldrsb.w	r3, [r7, #7]
20001db4:	095b      	lsrs	r3, r3, #5
20001db6:	3340      	adds	r3, #64	; 0x40
20001db8:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
20001dbc:	79fb      	ldrb	r3, [r7, #7]
20001dbe:	f003 031f 	and.w	r3, r3, #31
20001dc2:	fa22 f303 	lsr.w	r3, r2, r3
20001dc6:	f003 0301 	and.w	r3, r3, #1
20001dca:	e000      	b.n	20001dce <__NVIC_GetPendingIRQ+0x32>
  }
  else
  {
    return(0U);
20001dcc:	2300      	movs	r3, #0
  }
}
20001dce:	4618      	mov	r0, r3
20001dd0:	370c      	adds	r7, #12
20001dd2:	46bd      	mov	sp, r7
20001dd4:	f85d 7b04 	ldr.w	r7, [sp], #4
20001dd8:	4770      	bx	lr
20001dda:	bf00      	nop
20001ddc:	e000e100 	.word	0xe000e100

20001de0 <__NVIC_SetPendingIRQ>:
  \details Sets the pending bit of a device specific interrupt in the NVIC pending register.
  \param [in]      IRQn  Device specific interrupt number.
  \note    IRQn must not be negative.
 */
__STATIC_INLINE void __NVIC_SetPendingIRQ(IRQn_Type IRQn)
{
20001de0:	b480      	push	{r7}
20001de2:	b083      	sub	sp, #12
20001de4:	af00      	add	r7, sp, #0
20001de6:	4603      	mov	r3, r0
20001de8:	71fb      	strb	r3, [r7, #7]
  if ((int32_t)(IRQn) >= 0)
20001dea:	f997 3007 	ldrsb.w	r3, [r7, #7]
20001dee:	2b00      	cmp	r3, #0
20001df0:	db0c      	blt.n	20001e0c <__NVIC_SetPendingIRQ+0x2c>
  {
    NVIC->ISPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
20001df2:	79fb      	ldrb	r3, [r7, #7]
20001df4:	f003 021f 	and.w	r2, r3, #31
20001df8:	4907      	ldr	r1, [pc, #28]	; (20001e18 <__NVIC_SetPendingIRQ+0x38>)
20001dfa:	f997 3007 	ldrsb.w	r3, [r7, #7]
20001dfe:	095b      	lsrs	r3, r3, #5
20001e00:	2001      	movs	r0, #1
20001e02:	fa00 f202 	lsl.w	r2, r0, r2
20001e06:	3340      	adds	r3, #64	; 0x40
20001e08:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
  }
}
20001e0c:	bf00      	nop
20001e0e:	370c      	adds	r7, #12
20001e10:	46bd      	mov	sp, r7
20001e12:	f85d 7b04 	ldr.w	r7, [sp], #4
20001e16:	4770      	bx	lr
20001e18:	e000e100 	.word	0xe000e100

20001e1c <__NVIC_ClearPendingIRQ>:
  \details Clears the pending bit of a device specific interrupt in the NVIC pending register.
  \param [in]      IRQn  Device specific interrupt number.
  \note    IRQn must not be negative.
 */
__STATIC_INLINE void __NVIC_ClearPendingIRQ(IRQn_Type IRQn)
{
20001e1c:	b480      	push	{r7}
20001e1e:	b083      	sub	sp, #12
20001e20:	af00      	add	r7, sp, #0
20001e22:	4603      	mov	r3, r0
20001e24:	71fb      	strb	r3, [r7, #7]
  if ((int32_t)(IRQn) >= 0)
20001e26:	f997 3007 	ldrsb.w	r3, [r7, #7]
20001e2a:	2b00      	cmp	r3, #0
20001e2c:	db0c      	blt.n	20001e48 <__NVIC_ClearPendingIRQ+0x2c>
  {
    NVIC->ICPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
20001e2e:	79fb      	ldrb	r3, [r7, #7]
20001e30:	f003 021f 	and.w	r2, r3, #31
20001e34:	4907      	ldr	r1, [pc, #28]	; (20001e54 <__NVIC_ClearPendingIRQ+0x38>)
20001e36:	f997 3007 	ldrsb.w	r3, [r7, #7]
20001e3a:	095b      	lsrs	r3, r3, #5
20001e3c:	2001      	movs	r0, #1
20001e3e:	fa00 f202 	lsl.w	r2, r0, r2
20001e42:	3360      	adds	r3, #96	; 0x60
20001e44:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
  }
}
20001e48:	bf00      	nop
20001e4a:	370c      	adds	r7, #12
20001e4c:	46bd      	mov	sp, r7
20001e4e:	f85d 7b04 	ldr.w	r7, [sp], #4
20001e52:	4770      	bx	lr
20001e54:	e000e100 	.word	0xe000e100

20001e58 <__NVIC_GetActive>:
  \return             0  Interrupt status is not active.
  \return             1  Interrupt status is active.
  \note    IRQn must not be negative.
 */
__STATIC_INLINE uint32_t __NVIC_GetActive(IRQn_Type IRQn)
{
20001e58:	b480      	push	{r7}
20001e5a:	b083      	sub	sp, #12
20001e5c:	af00      	add	r7, sp, #0
20001e5e:	4603      	mov	r3, r0
20001e60:	71fb      	strb	r3, [r7, #7]
  if ((int32_t)(IRQn) >= 0)
20001e62:	f997 3007 	ldrsb.w	r3, [r7, #7]
20001e66:	2b00      	cmp	r3, #0
20001e68:	db0e      	blt.n	20001e88 <__NVIC_GetActive+0x30>
  {
    return((uint32_t)(((NVIC->IABR[(((uint32_t)IRQn) >> 5UL)] & (1UL << (((uint32_t)IRQn) & 0x1FUL))) != 0UL) ? 1UL : 0UL));
20001e6a:	4a0b      	ldr	r2, [pc, #44]	; (20001e98 <__NVIC_GetActive+0x40>)
20001e6c:	f997 3007 	ldrsb.w	r3, [r7, #7]
20001e70:	095b      	lsrs	r3, r3, #5
20001e72:	3380      	adds	r3, #128	; 0x80
20001e74:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
20001e78:	79fb      	ldrb	r3, [r7, #7]
20001e7a:	f003 031f 	and.w	r3, r3, #31
20001e7e:	fa22 f303 	lsr.w	r3, r2, r3
20001e82:	f003 0301 	and.w	r3, r3, #1
20001e86:	e000      	b.n	20001e8a <__NVIC_GetActive+0x32>
  }
  else
  {
    return(0U);
20001e88:	2300      	movs	r3, #0
  }
}
20001e8a:	4618      	mov	r0, r3
20001e8c:	370c      	adds	r7, #12
20001e8e:	46bd      	mov	sp, r7
20001e90:	f85d 7b04 	ldr.w	r7, [sp], #4
20001e94:	4770      	bx	lr
20001e96:	bf00      	nop
20001e98:	e000e100 	.word	0xe000e100

20001e9c <__NVIC_SetPriority>:
  \param [in]      IRQn  Interrupt number.
  \param [in]  priority  Priority to set.
  \note    The priority cannot be set for every processor exception.
 */
__STATIC_INLINE void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
20001e9c:	b480      	push	{r7}
20001e9e:	b083      	sub	sp, #12
20001ea0:	af00      	add	r7, sp, #0
20001ea2:	4603      	mov	r3, r0
20001ea4:	6039      	str	r1, [r7, #0]
20001ea6:	71fb      	strb	r3, [r7, #7]
  if ((int32_t)(IRQn) >= 0)
20001ea8:	f997 3007 	ldrsb.w	r3, [r7, #7]
20001eac:	2b00      	cmp	r3, #0
20001eae:	db0a      	blt.n	20001ec6 <__NVIC_SetPriority+0x2a>
  {
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
20001eb0:	683b      	ldr	r3, [r7, #0]
20001eb2:	b2da      	uxtb	r2, r3
20001eb4:	490c      	ldr	r1, [pc, #48]	; (20001ee8 <__NVIC_SetPriority+0x4c>)
20001eb6:	f997 3007 	ldrsb.w	r3, [r7, #7]
20001eba:	0112      	lsls	r2, r2, #4
20001ebc:	b2d2      	uxtb	r2, r2
20001ebe:	440b      	add	r3, r1
20001ec0:	f883 2300 	strb.w	r2, [r3, #768]	; 0x300
  }
  else
  {
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
  }
}
20001ec4:	e00a      	b.n	20001edc <__NVIC_SetPriority+0x40>
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
20001ec6:	683b      	ldr	r3, [r7, #0]
20001ec8:	b2da      	uxtb	r2, r3
20001eca:	4908      	ldr	r1, [pc, #32]	; (20001eec <__NVIC_SetPriority+0x50>)
20001ecc:	79fb      	ldrb	r3, [r7, #7]
20001ece:	f003 030f 	and.w	r3, r3, #15
20001ed2:	3b04      	subs	r3, #4
20001ed4:	0112      	lsls	r2, r2, #4
20001ed6:	b2d2      	uxtb	r2, r2
20001ed8:	440b      	add	r3, r1
20001eda:	761a      	strb	r2, [r3, #24]
}
20001edc:	bf00      	nop
20001ede:	370c      	adds	r7, #12
20001ee0:	46bd      	mov	sp, r7
20001ee2:	f85d 7b04 	ldr.w	r7, [sp], #4
20001ee6:	4770      	bx	lr
20001ee8:	e000e100 	.word	0xe000e100
20001eec:	e000ed00 	.word	0xe000ed00

20001ef0 <__NVIC_GetPriority>:
  \param [in]   IRQn  Interrupt number.
  \return             Interrupt Priority.
                      Value is aligned automatically to the implemented priority bits of the microcontroller.
 */
__STATIC_INLINE uint32_t __NVIC_GetPriority(IRQn_Type IRQn)
{
20001ef0:	b480      	push	{r7}
20001ef2:	b083      	sub	sp, #12
20001ef4:	af00      	add	r7, sp, #0
20001ef6:	4603      	mov	r3, r0
20001ef8:	71fb      	strb	r3, [r7, #7]

  if ((int32_t)(IRQn) >= 0)
20001efa:	f997 3007 	ldrsb.w	r3, [r7, #7]
20001efe:	2b00      	cmp	r3, #0
20001f00:	db09      	blt.n	20001f16 <__NVIC_GetPriority+0x26>
  {
    return(((uint32_t)NVIC->IP[((uint32_t)IRQn)]               >> (8U - __NVIC_PRIO_BITS)));
20001f02:	4a0d      	ldr	r2, [pc, #52]	; (20001f38 <__NVIC_GetPriority+0x48>)
20001f04:	f997 3007 	ldrsb.w	r3, [r7, #7]
20001f08:	4413      	add	r3, r2
20001f0a:	f893 3300 	ldrb.w	r3, [r3, #768]	; 0x300
20001f0e:	b2db      	uxtb	r3, r3
20001f10:	091b      	lsrs	r3, r3, #4
20001f12:	b2db      	uxtb	r3, r3
20001f14:	e009      	b.n	20001f2a <__NVIC_GetPriority+0x3a>
  }
  else
  {
    return(((uint32_t)SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] >> (8U - __NVIC_PRIO_BITS)));
20001f16:	4a09      	ldr	r2, [pc, #36]	; (20001f3c <__NVIC_GetPriority+0x4c>)
20001f18:	79fb      	ldrb	r3, [r7, #7]
20001f1a:	f003 030f 	and.w	r3, r3, #15
20001f1e:	3b04      	subs	r3, #4
20001f20:	4413      	add	r3, r2
20001f22:	7e1b      	ldrb	r3, [r3, #24]
20001f24:	b2db      	uxtb	r3, r3
20001f26:	091b      	lsrs	r3, r3, #4
20001f28:	b2db      	uxtb	r3, r3
  }
}
20001f2a:	4618      	mov	r0, r3
20001f2c:	370c      	adds	r7, #12
20001f2e:	46bd      	mov	sp, r7
20001f30:	f85d 7b04 	ldr.w	r7, [sp], #4
20001f34:	4770      	bx	lr
20001f36:	bf00      	nop
20001f38:	e000e100 	.word	0xe000e100
20001f3c:	e000ed00 	.word	0xe000ed00

20001f40 <NVIC_EncodePriority>:
  \param [in]   PreemptPriority  Preemptive priority value (starting from 0).
  \param [in]       SubPriority  Subpriority value (starting from 0).
  \return                        Encoded priority. Value can be used in the function \ref NVIC_SetPriority().
 */
__STATIC_INLINE uint32_t NVIC_EncodePriority (uint32_t PriorityGroup, uint32_t PreemptPriority, uint32_t SubPriority)
{
20001f40:	b480      	push	{r7}
20001f42:	b089      	sub	sp, #36	; 0x24
20001f44:	af00      	add	r7, sp, #0
20001f46:	60f8      	str	r0, [r7, #12]
20001f48:	60b9      	str	r1, [r7, #8]
20001f4a:	607a      	str	r2, [r7, #4]
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
20001f4c:	68fb      	ldr	r3, [r7, #12]
20001f4e:	f003 0307 	and.w	r3, r3, #7
20001f52:	61fb      	str	r3, [r7, #28]
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
20001f54:	69fb      	ldr	r3, [r7, #28]
20001f56:	f1c3 0307 	rsb	r3, r3, #7
20001f5a:	2b04      	cmp	r3, #4
20001f5c:	bf28      	it	cs
20001f5e:	2304      	movcs	r3, #4
20001f60:	61bb      	str	r3, [r7, #24]
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
20001f62:	69fb      	ldr	r3, [r7, #28]
20001f64:	3304      	adds	r3, #4
20001f66:	2b06      	cmp	r3, #6
20001f68:	d902      	bls.n	20001f70 <NVIC_EncodePriority+0x30>
20001f6a:	69fb      	ldr	r3, [r7, #28]
20001f6c:	3b03      	subs	r3, #3
20001f6e:	e000      	b.n	20001f72 <NVIC_EncodePriority+0x32>
20001f70:	2300      	movs	r3, #0
20001f72:	617b      	str	r3, [r7, #20]

  return (
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
20001f74:	f04f 32ff 	mov.w	r2, #4294967295
20001f78:	69bb      	ldr	r3, [r7, #24]
20001f7a:	fa02 f303 	lsl.w	r3, r2, r3
20001f7e:	43da      	mvns	r2, r3
20001f80:	68bb      	ldr	r3, [r7, #8]
20001f82:	401a      	ands	r2, r3
20001f84:	697b      	ldr	r3, [r7, #20]
20001f86:	409a      	lsls	r2, r3
           ((SubPriority     & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL)))
20001f88:	f04f 31ff 	mov.w	r1, #4294967295
20001f8c:	697b      	ldr	r3, [r7, #20]
20001f8e:	fa01 f303 	lsl.w	r3, r1, r3
20001f92:	43d9      	mvns	r1, r3
20001f94:	687b      	ldr	r3, [r7, #4]
20001f96:	400b      	ands	r3, r1
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
20001f98:	4313      	orrs	r3, r2
         );
}
20001f9a:	4618      	mov	r0, r3
20001f9c:	3724      	adds	r7, #36	; 0x24
20001f9e:	46bd      	mov	sp, r7
20001fa0:	f85d 7b04 	ldr.w	r7, [sp], #4
20001fa4:	4770      	bx	lr

20001fa6 <NVIC_DecodePriority>:
  \param [in]     PriorityGroup  Used priority group.
  \param [out] pPreemptPriority  Preemptive priority value (starting from 0).
  \param [out]     pSubPriority  Subpriority value (starting from 0).
 */
__STATIC_INLINE void NVIC_DecodePriority (uint32_t Priority, uint32_t PriorityGroup, uint32_t* const pPreemptPriority, uint32_t* const pSubPriority)
{
20001fa6:	b480      	push	{r7}
20001fa8:	b089      	sub	sp, #36	; 0x24
20001faa:	af00      	add	r7, sp, #0
20001fac:	60f8      	str	r0, [r7, #12]
20001fae:	60b9      	str	r1, [r7, #8]
20001fb0:	607a      	str	r2, [r7, #4]
20001fb2:	603b      	str	r3, [r7, #0]
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
20001fb4:	68bb      	ldr	r3, [r7, #8]
20001fb6:	f003 0307 	and.w	r3, r3, #7
20001fba:	61fb      	str	r3, [r7, #28]
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
20001fbc:	69fb      	ldr	r3, [r7, #28]
20001fbe:	f1c3 0307 	rsb	r3, r3, #7
20001fc2:	2b04      	cmp	r3, #4
20001fc4:	bf28      	it	cs
20001fc6:	2304      	movcs	r3, #4
20001fc8:	61bb      	str	r3, [r7, #24]
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
20001fca:	69fb      	ldr	r3, [r7, #28]
20001fcc:	3304      	adds	r3, #4
20001fce:	2b06      	cmp	r3, #6
20001fd0:	d902      	bls.n	20001fd8 <NVIC_DecodePriority+0x32>
20001fd2:	69fb      	ldr	r3, [r7, #28]
20001fd4:	3b03      	subs	r3, #3
20001fd6:	e000      	b.n	20001fda <NVIC_DecodePriority+0x34>
20001fd8:	2300      	movs	r3, #0
20001fda:	617b      	str	r3, [r7, #20]

  *pPreemptPriority = (Priority >> SubPriorityBits) & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL);
20001fdc:	68fa      	ldr	r2, [r7, #12]
20001fde:	697b      	ldr	r3, [r7, #20]
20001fe0:	40da      	lsrs	r2, r3
20001fe2:	f04f 31ff 	mov.w	r1, #4294967295
20001fe6:	69bb      	ldr	r3, [r7, #24]
20001fe8:	fa01 f303 	lsl.w	r3, r1, r3
20001fec:	43db      	mvns	r3, r3
20001fee:	401a      	ands	r2, r3
20001ff0:	687b      	ldr	r3, [r7, #4]
20001ff2:	601a      	str	r2, [r3, #0]
  *pSubPriority     = (Priority                   ) & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL);
20001ff4:	f04f 32ff 	mov.w	r2, #4294967295
20001ff8:	697b      	ldr	r3, [r7, #20]
20001ffa:	fa02 f303 	lsl.w	r3, r2, r3
20001ffe:	43da      	mvns	r2, r3
20002000:	68fb      	ldr	r3, [r7, #12]
20002002:	401a      	ands	r2, r3
20002004:	683b      	ldr	r3, [r7, #0]
20002006:	601a      	str	r2, [r3, #0]
}
20002008:	bf00      	nop
2000200a:	3724      	adds	r7, #36	; 0x24
2000200c:	46bd      	mov	sp, r7
2000200e:	f85d 7b04 	ldr.w	r7, [sp], #4
20002012:	4770      	bx	lr

20002014 <__NVIC_SystemReset>:
/**
  \brief   System Reset
  \details Initiates a system reset request to reset the MCU.
 */
__NO_RETURN __STATIC_INLINE void __NVIC_SystemReset(void)
{
20002014:	b480      	push	{r7}
20002016:	af00      	add	r7, sp, #0
  __ASM volatile ("dsb 0xF":::"memory");
20002018:	f3bf 8f4f 	dsb	sy
}
2000201c:	bf00      	nop
  __DSB();                                                          /* Ensure all outstanding memory accesses included
                                                                       buffered write are completed before reset */
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
                           (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |
2000201e:	4b06      	ldr	r3, [pc, #24]	; (20002038 <__NVIC_SystemReset+0x24>)
20002020:	68db      	ldr	r3, [r3, #12]
20002022:	f403 62e0 	and.w	r2, r3, #1792	; 0x700
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
20002026:	4904      	ldr	r1, [pc, #16]	; (20002038 <__NVIC_SystemReset+0x24>)
20002028:	4b04      	ldr	r3, [pc, #16]	; (2000203c <__NVIC_SystemReset+0x28>)
2000202a:	4313      	orrs	r3, r2
2000202c:	60cb      	str	r3, [r1, #12]
  __ASM volatile ("dsb 0xF":::"memory");
2000202e:	f3bf 8f4f 	dsb	sy
}
20002032:	bf00      	nop
                            SCB_AIRCR_SYSRESETREQ_Msk    );         /* Keep priority group unchanged */
  __DSB();                                                          /* Ensure completion of memory access */

  for(;;)                                                           /* wait until reset */
  {
    __NOP();
20002034:	bf00      	nop
20002036:	e7fd      	b.n	20002034 <__NVIC_SystemReset+0x20>
20002038:	e000ed00 	.word	0xe000ed00
2000203c:	05fa0004 	.word	0x05fa0004

20002040 <SysTick_Config>:
  \note    When the variable <b>__Vendor_SysTickConfig</b> is set to 1, then the
           function <b>SysTick_Config</b> is not included. In this case, the file <b><i>device</i>.h</b>
           must contain a vendor-specific implementation of this function.
 */
__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
{
20002040:	b580      	push	{r7, lr}
20002042:	b082      	sub	sp, #8
20002044:	af00      	add	r7, sp, #0
20002046:	6078      	str	r0, [r7, #4]
  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk)
20002048:	687b      	ldr	r3, [r7, #4]
2000204a:	3b01      	subs	r3, #1
2000204c:	f1b3 7f80 	cmp.w	r3, #16777216	; 0x1000000
20002050:	d301      	bcc.n	20002056 <SysTick_Config+0x16>
  {
    return (1UL);                                                   /* Reload value impossible */
20002052:	2301      	movs	r3, #1
20002054:	e00f      	b.n	20002076 <SysTick_Config+0x36>
  }

  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
20002056:	4a0a      	ldr	r2, [pc, #40]	; (20002080 <SysTick_Config+0x40>)
20002058:	687b      	ldr	r3, [r7, #4]
2000205a:	3b01      	subs	r3, #1
2000205c:	6053      	str	r3, [r2, #4]
  NVIC_SetPriority (SysTick_IRQn, (1UL << __NVIC_PRIO_BITS) - 1UL); /* set Priority for Systick Interrupt */
2000205e:	210f      	movs	r1, #15
20002060:	f04f 30ff 	mov.w	r0, #4294967295
20002064:	f7ff ff1a 	bl	20001e9c <__NVIC_SetPriority>
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
20002068:	4b05      	ldr	r3, [pc, #20]	; (20002080 <SysTick_Config+0x40>)
2000206a:	2200      	movs	r2, #0
2000206c:	609a      	str	r2, [r3, #8]
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
2000206e:	4b04      	ldr	r3, [pc, #16]	; (20002080 <SysTick_Config+0x40>)
20002070:	2207      	movs	r2, #7
20002072:	601a      	str	r2, [r3, #0]
                   SysTick_CTRL_TICKINT_Msk   |
                   SysTick_CTRL_ENABLE_Msk;                         /* Enable SysTick IRQ and SysTick Timer */
  return (0UL);                                                     /* Function successful */
20002074:	2300      	movs	r3, #0
}
20002076:	4618      	mov	r0, r3
20002078:	3708      	adds	r7, #8
2000207a:	46bd      	mov	sp, r7
2000207c:	bd80      	pop	{r7, pc}
2000207e:	bf00      	nop
20002080:	e000e010 	.word	0xe000e010

20002084 <HAL_NVIC_SetPriorityGrouping>:
  * @note   When the NVIC_PriorityGroup_0 is selected, IRQ pre-emption is no more possible.
  *         The pending IRQ priority will be managed only by the subpriority.
  * @retval None
  */
void HAL_NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
20002084:	b580      	push	{r7, lr}
20002086:	b082      	sub	sp, #8
20002088:	af00      	add	r7, sp, #0
2000208a:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_NVIC_PRIORITY_GROUP(PriorityGroup));

  /* Set the PRIGROUP[10:8] bits according to the PriorityGroup parameter value */
  NVIC_SetPriorityGrouping(PriorityGroup);
2000208c:	6878      	ldr	r0, [r7, #4]
2000208e:	f7ff fe11 	bl	20001cb4 <__NVIC_SetPriorityGrouping>
}
20002092:	bf00      	nop
20002094:	3708      	adds	r7, #8
20002096:	46bd      	mov	sp, r7
20002098:	bd80      	pop	{r7, pc}

2000209a <HAL_NVIC_SetPriority>:
  *         This parameter can be a value between 0 and 15
  *         A lower priority value indicates a higher priority.
  * @retval None
  */
void HAL_NVIC_SetPriority(IRQn_Type IRQn, uint32_t PreemptPriority, uint32_t SubPriority)
{
2000209a:	b580      	push	{r7, lr}
2000209c:	b086      	sub	sp, #24
2000209e:	af00      	add	r7, sp, #0
200020a0:	4603      	mov	r3, r0
200020a2:	60b9      	str	r1, [r7, #8]
200020a4:	607a      	str	r2, [r7, #4]
200020a6:	73fb      	strb	r3, [r7, #15]

  /* Check the parameters */
  assert_param(IS_NVIC_SUB_PRIORITY(SubPriority));
  assert_param(IS_NVIC_PREEMPTION_PRIORITY(PreemptPriority));

  prioritygroup = NVIC_GetPriorityGrouping();
200020a8:	f7ff fe28 	bl	20001cfc <__NVIC_GetPriorityGrouping>
200020ac:	6178      	str	r0, [r7, #20]

  NVIC_SetPriority(IRQn, NVIC_EncodePriority(prioritygroup, PreemptPriority, SubPriority));
200020ae:	687a      	ldr	r2, [r7, #4]
200020b0:	68b9      	ldr	r1, [r7, #8]
200020b2:	6978      	ldr	r0, [r7, #20]
200020b4:	f7ff ff44 	bl	20001f40 <NVIC_EncodePriority>
200020b8:	4602      	mov	r2, r0
200020ba:	f997 300f 	ldrsb.w	r3, [r7, #15]
200020be:	4611      	mov	r1, r2
200020c0:	4618      	mov	r0, r3
200020c2:	f7ff feeb 	bl	20001e9c <__NVIC_SetPriority>
}
200020c6:	bf00      	nop
200020c8:	3718      	adds	r7, #24
200020ca:	46bd      	mov	sp, r7
200020cc:	bd80      	pop	{r7, pc}

200020ce <HAL_NVIC_EnableIRQ>:
  *         This parameter can be an enumerator of IRQn_Type enumeration
  *         (For the complete STM32 Devices IRQ Channels list, please refer to the appropriate CMSIS device file (stm32g4xxxx.h))
  * @retval None
  */
void HAL_NVIC_EnableIRQ(IRQn_Type IRQn)
{
200020ce:	b580      	push	{r7, lr}
200020d0:	b082      	sub	sp, #8
200020d2:	af00      	add	r7, sp, #0
200020d4:	4603      	mov	r3, r0
200020d6:	71fb      	strb	r3, [r7, #7]
  /* Check the parameters */
  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));
  
  /* Enable interrupt */
  NVIC_EnableIRQ(IRQn);
200020d8:	f997 3007 	ldrsb.w	r3, [r7, #7]
200020dc:	4618      	mov	r0, r3
200020de:	f7ff fe1b 	bl	20001d18 <__NVIC_EnableIRQ>
}
200020e2:	bf00      	nop
200020e4:	3708      	adds	r7, #8
200020e6:	46bd      	mov	sp, r7
200020e8:	bd80      	pop	{r7, pc}

200020ea <HAL_NVIC_DisableIRQ>:
  *         This parameter can be an enumerator of IRQn_Type enumeration
  *         (For the complete STM32 Devices IRQ Channels list, please refer to the appropriate CMSIS device file (stm32g4xxxx.h))
  * @retval None
  */
void HAL_NVIC_DisableIRQ(IRQn_Type IRQn)
{
200020ea:	b580      	push	{r7, lr}
200020ec:	b082      	sub	sp, #8
200020ee:	af00      	add	r7, sp, #0
200020f0:	4603      	mov	r3, r0
200020f2:	71fb      	strb	r3, [r7, #7]
  /* Check the parameters */
  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));
  
  /* Disable interrupt */
  NVIC_DisableIRQ(IRQn);
200020f4:	f997 3007 	ldrsb.w	r3, [r7, #7]
200020f8:	4618      	mov	r0, r3
200020fa:	f7ff fe2b 	bl	20001d54 <__NVIC_DisableIRQ>
}
200020fe:	bf00      	nop
20002100:	3708      	adds	r7, #8
20002102:	46bd      	mov	sp, r7
20002104:	bd80      	pop	{r7, pc}

20002106 <HAL_NVIC_SystemReset>:
/**
  * @brief  Initiate a system reset request to reset the MCU.
  * @retval None
  */
void HAL_NVIC_SystemReset(void)
{
20002106:	b580      	push	{r7, lr}
20002108:	af00      	add	r7, sp, #0
  /* System Reset */
  NVIC_SystemReset();
2000210a:	f7ff ff83 	bl	20002014 <__NVIC_SystemReset>

2000210e <HAL_SYSTICK_Config>:
  * @param  TicksNumb: Specifies the ticks Number of ticks between two interrupts.
  * @retval status:  - 0  Function succeeded.
  *                  - 1  Function failed.
  */
uint32_t HAL_SYSTICK_Config(uint32_t TicksNumb)
{
2000210e:	b580      	push	{r7, lr}
20002110:	b082      	sub	sp, #8
20002112:	af00      	add	r7, sp, #0
20002114:	6078      	str	r0, [r7, #4]
   return SysTick_Config(TicksNumb);
20002116:	6878      	ldr	r0, [r7, #4]
20002118:	f7ff ff92 	bl	20002040 <SysTick_Config>
2000211c:	4603      	mov	r3, r0
}
2000211e:	4618      	mov	r0, r3
20002120:	3708      	adds	r7, #8
20002122:	46bd      	mov	sp, r7
20002124:	bd80      	pop	{r7, pc}

20002126 <HAL_NVIC_GetPriorityGrouping>:
/**
  * @brief  Get the priority grouping field from the NVIC Interrupt Controller.
  * @retval Priority grouping field (SCB->AIRCR [10:8] PRIGROUP field)
  */
uint32_t HAL_NVIC_GetPriorityGrouping(void)
{
20002126:	b580      	push	{r7, lr}
20002128:	af00      	add	r7, sp, #0
  /* Get the PRIGROUP[10:8] field value */
  return NVIC_GetPriorityGrouping();
2000212a:	f7ff fde7 	bl	20001cfc <__NVIC_GetPriorityGrouping>
2000212e:	4603      	mov	r3, r0
}
20002130:	4618      	mov	r0, r3
20002132:	bd80      	pop	{r7, pc}

20002134 <HAL_NVIC_GetPriority>:
  * @param  pPreemptPriority: Pointer on the Preemptive priority value (starting from 0).
  * @param  pSubPriority: Pointer on the Subpriority value (starting from 0).
  * @retval None
  */
void HAL_NVIC_GetPriority(IRQn_Type IRQn, uint32_t PriorityGroup, uint32_t *pPreemptPriority, uint32_t *pSubPriority)
{
20002134:	b580      	push	{r7, lr}
20002136:	b084      	sub	sp, #16
20002138:	af00      	add	r7, sp, #0
2000213a:	60b9      	str	r1, [r7, #8]
2000213c:	607a      	str	r2, [r7, #4]
2000213e:	603b      	str	r3, [r7, #0]
20002140:	4603      	mov	r3, r0
20002142:	73fb      	strb	r3, [r7, #15]
  /* Check the parameters */
  assert_param(IS_NVIC_PRIORITY_GROUP(PriorityGroup));
 /* Get priority for Cortex-M system or device specific interrupts */
  NVIC_DecodePriority(NVIC_GetPriority(IRQn), PriorityGroup, pPreemptPriority, pSubPriority);
20002144:	f997 300f 	ldrsb.w	r3, [r7, #15]
20002148:	4618      	mov	r0, r3
2000214a:	f7ff fed1 	bl	20001ef0 <__NVIC_GetPriority>
2000214e:	683b      	ldr	r3, [r7, #0]
20002150:	687a      	ldr	r2, [r7, #4]
20002152:	68b9      	ldr	r1, [r7, #8]
20002154:	f7ff ff27 	bl	20001fa6 <NVIC_DecodePriority>
}
20002158:	bf00      	nop
2000215a:	3710      	adds	r7, #16
2000215c:	46bd      	mov	sp, r7
2000215e:	bd80      	pop	{r7, pc}

20002160 <HAL_NVIC_SetPendingIRQ>:
  *         This parameter can be an enumerator of IRQn_Type enumeration
  *         (For the complete STM32 Devices IRQ Channels list, please refer to the appropriate CMSIS device file (stm32g4xxxx.h))
  * @retval None
  */
void HAL_NVIC_SetPendingIRQ(IRQn_Type IRQn)
{
20002160:	b580      	push	{r7, lr}
20002162:	b082      	sub	sp, #8
20002164:	af00      	add	r7, sp, #0
20002166:	4603      	mov	r3, r0
20002168:	71fb      	strb	r3, [r7, #7]
  /* Check the parameters */
  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));
  
  /* Set interrupt pending */
  NVIC_SetPendingIRQ(IRQn);
2000216a:	f997 3007 	ldrsb.w	r3, [r7, #7]
2000216e:	4618      	mov	r0, r3
20002170:	f7ff fe36 	bl	20001de0 <__NVIC_SetPendingIRQ>
}
20002174:	bf00      	nop
20002176:	3708      	adds	r7, #8
20002178:	46bd      	mov	sp, r7
2000217a:	bd80      	pop	{r7, pc}

2000217c <HAL_NVIC_GetPendingIRQ>:
  *         (For the complete STM32 Devices IRQ Channels list, please refer to the appropriate CMSIS device file (stm32g4xxxx.h))
  * @retval status: - 0  Interrupt status is not pending.
  *                 - 1  Interrupt status is pending.
  */
uint32_t HAL_NVIC_GetPendingIRQ(IRQn_Type IRQn)
{
2000217c:	b580      	push	{r7, lr}
2000217e:	b082      	sub	sp, #8
20002180:	af00      	add	r7, sp, #0
20002182:	4603      	mov	r3, r0
20002184:	71fb      	strb	r3, [r7, #7]
  /* Check the parameters */
  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));
  
  /* Return 1 if pending else 0 */
  return NVIC_GetPendingIRQ(IRQn);
20002186:	f997 3007 	ldrsb.w	r3, [r7, #7]
2000218a:	4618      	mov	r0, r3
2000218c:	f7ff fe06 	bl	20001d9c <__NVIC_GetPendingIRQ>
20002190:	4603      	mov	r3, r0
}
20002192:	4618      	mov	r0, r3
20002194:	3708      	adds	r7, #8
20002196:	46bd      	mov	sp, r7
20002198:	bd80      	pop	{r7, pc}

2000219a <HAL_NVIC_ClearPendingIRQ>:
  *         This parameter can be an enumerator of IRQn_Type enumeration
  *         (For the complete STM32 Devices IRQ Channels list, please refer to the appropriate CMSIS device file (stm32g4xxxx.h))
  * @retval None
  */
void HAL_NVIC_ClearPendingIRQ(IRQn_Type IRQn)
{
2000219a:	b580      	push	{r7, lr}
2000219c:	b082      	sub	sp, #8
2000219e:	af00      	add	r7, sp, #0
200021a0:	4603      	mov	r3, r0
200021a2:	71fb      	strb	r3, [r7, #7]
  /* Check the parameters */
  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));
  
  /* Clear pending interrupt */
  NVIC_ClearPendingIRQ(IRQn);
200021a4:	f997 3007 	ldrsb.w	r3, [r7, #7]
200021a8:	4618      	mov	r0, r3
200021aa:	f7ff fe37 	bl	20001e1c <__NVIC_ClearPendingIRQ>
}
200021ae:	bf00      	nop
200021b0:	3708      	adds	r7, #8
200021b2:	46bd      	mov	sp, r7
200021b4:	bd80      	pop	{r7, pc}

200021b6 <HAL_NVIC_GetActive>:
  *         (For the complete STM32 Devices IRQ Channels list, please refer to the appropriate CMSIS device file (stm32g4xxxx.h))
  * @retval status: - 0  Interrupt status is not pending.
  *                 - 1  Interrupt status is pending.
  */
uint32_t HAL_NVIC_GetActive(IRQn_Type IRQn)
{
200021b6:	b580      	push	{r7, lr}
200021b8:	b082      	sub	sp, #8
200021ba:	af00      	add	r7, sp, #0
200021bc:	4603      	mov	r3, r0
200021be:	71fb      	strb	r3, [r7, #7]
  /* Return 1 if active else 0 */
  return NVIC_GetActive(IRQn);
200021c0:	f997 3007 	ldrsb.w	r3, [r7, #7]
200021c4:	4618      	mov	r0, r3
200021c6:	f7ff fe47 	bl	20001e58 <__NVIC_GetActive>
200021ca:	4603      	mov	r3, r0
}
200021cc:	4618      	mov	r0, r3
200021ce:	3708      	adds	r7, #8
200021d0:	46bd      	mov	sp, r7
200021d2:	bd80      	pop	{r7, pc}

200021d4 <HAL_SYSTICK_CLKSourceConfig>:
  *             @arg SYSTICK_CLKSOURCE_HCLK_DIV8: AHB clock divided by 8 selected as SysTick clock source.
  *             @arg SYSTICK_CLKSOURCE_HCLK: AHB clock selected as SysTick clock source.
  * @retval None
  */
void HAL_SYSTICK_CLKSourceConfig(uint32_t CLKSource)
{
200021d4:	b480      	push	{r7}
200021d6:	b083      	sub	sp, #12
200021d8:	af00      	add	r7, sp, #0
200021da:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_SYSTICK_CLK_SOURCE(CLKSource));
  if (CLKSource == SYSTICK_CLKSOURCE_HCLK)
200021dc:	687b      	ldr	r3, [r7, #4]
200021de:	2b04      	cmp	r3, #4
200021e0:	d106      	bne.n	200021f0 <HAL_SYSTICK_CLKSourceConfig+0x1c>
  {
    SysTick->CTRL |= SYSTICK_CLKSOURCE_HCLK;
200021e2:	4b09      	ldr	r3, [pc, #36]	; (20002208 <HAL_SYSTICK_CLKSourceConfig+0x34>)
200021e4:	681b      	ldr	r3, [r3, #0]
200021e6:	4a08      	ldr	r2, [pc, #32]	; (20002208 <HAL_SYSTICK_CLKSourceConfig+0x34>)
200021e8:	f043 0304 	orr.w	r3, r3, #4
200021ec:	6013      	str	r3, [r2, #0]
  }
  else
  {
    SysTick->CTRL &= ~SYSTICK_CLKSOURCE_HCLK;
  }
}
200021ee:	e005      	b.n	200021fc <HAL_SYSTICK_CLKSourceConfig+0x28>
    SysTick->CTRL &= ~SYSTICK_CLKSOURCE_HCLK;
200021f0:	4b05      	ldr	r3, [pc, #20]	; (20002208 <HAL_SYSTICK_CLKSourceConfig+0x34>)
200021f2:	681b      	ldr	r3, [r3, #0]
200021f4:	4a04      	ldr	r2, [pc, #16]	; (20002208 <HAL_SYSTICK_CLKSourceConfig+0x34>)
200021f6:	f023 0304 	bic.w	r3, r3, #4
200021fa:	6013      	str	r3, [r2, #0]
}
200021fc:	bf00      	nop
200021fe:	370c      	adds	r7, #12
20002200:	46bd      	mov	sp, r7
20002202:	f85d 7b04 	ldr.w	r7, [sp], #4
20002206:	4770      	bx	lr
20002208:	e000e010 	.word	0xe000e010

2000220c <HAL_SYSTICK_IRQHandler>:
/**
  * @brief  Handle SYSTICK interrupt request.
  * @retval None
  */
void HAL_SYSTICK_IRQHandler(void)
{
2000220c:	b580      	push	{r7, lr}
2000220e:	af00      	add	r7, sp, #0
  HAL_SYSTICK_Callback();
20002210:	f000 f802 	bl	20002218 <HAL_SYSTICK_Callback>
}
20002214:	bf00      	nop
20002216:	bd80      	pop	{r7, pc}

20002218 <HAL_SYSTICK_Callback>:
/**
  * @brief  SYSTICK callback.
  * @retval None
  */
__weak void HAL_SYSTICK_Callback(void)
{
20002218:	b480      	push	{r7}
2000221a:	af00      	add	r7, sp, #0
  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_SYSTICK_Callback could be implemented in the user file
   */
}
2000221c:	bf00      	nop
2000221e:	46bd      	mov	sp, r7
20002220:	f85d 7b04 	ldr.w	r7, [sp], #4
20002224:	4770      	bx	lr
	...

20002228 <HAL_MPU_Enable>:
  *            @arg MPU_PRIVILEGED_DEFAULT
  *            @arg MPU_HFNMI_PRIVDEF
  * @retval None
  */
void HAL_MPU_Enable(uint32_t MPU_Control)
{
20002228:	b480      	push	{r7}
2000222a:	b083      	sub	sp, #12
2000222c:	af00      	add	r7, sp, #0
2000222e:	6078      	str	r0, [r7, #4]
  /* Enable the MPU */
  MPU->CTRL = (MPU_Control | MPU_CTRL_ENABLE_Msk);
20002230:	4a08      	ldr	r2, [pc, #32]	; (20002254 <HAL_MPU_Enable+0x2c>)
20002232:	687b      	ldr	r3, [r7, #4]
20002234:	f043 0301 	orr.w	r3, r3, #1
20002238:	6053      	str	r3, [r2, #4]
  __ASM volatile ("dsb 0xF":::"memory");
2000223a:	f3bf 8f4f 	dsb	sy
}
2000223e:	bf00      	nop
  __ASM volatile ("isb 0xF":::"memory");
20002240:	f3bf 8f6f 	isb	sy
}
20002244:	bf00      	nop

  /* Ensure MPU setting take effects */
  __DSB();
  __ISB();
}
20002246:	bf00      	nop
20002248:	370c      	adds	r7, #12
2000224a:	46bd      	mov	sp, r7
2000224c:	f85d 7b04 	ldr.w	r7, [sp], #4
20002250:	4770      	bx	lr
20002252:	bf00      	nop
20002254:	e000ed90 	.word	0xe000ed90

20002258 <HAL_MPU_Disable>:
/**
  * @brief  Disable the MPU.
  * @retval None
  */
void HAL_MPU_Disable(void)
{
20002258:	b480      	push	{r7}
2000225a:	af00      	add	r7, sp, #0
  __ASM volatile ("dmb 0xF":::"memory");
2000225c:	f3bf 8f5f 	dmb	sy
}
20002260:	bf00      	nop
  /* Make sure outstanding transfers are done */
  __DMB();

  /* Disable the MPU and clear the control register*/
  MPU->CTRL  = 0;
20002262:	4b04      	ldr	r3, [pc, #16]	; (20002274 <HAL_MPU_Disable+0x1c>)
20002264:	2200      	movs	r2, #0
20002266:	605a      	str	r2, [r3, #4]
}
20002268:	bf00      	nop
2000226a:	46bd      	mov	sp, r7
2000226c:	f85d 7b04 	ldr.w	r7, [sp], #4
20002270:	4770      	bx	lr
20002272:	bf00      	nop
20002274:	e000ed90 	.word	0xe000ed90

20002278 <HAL_MPU_ConfigRegion>:
  * @param  MPU_Init: Pointer to a MPU_Region_InitTypeDef structure that contains
  *                the initialization and configuration information.
  * @retval None
  */
void HAL_MPU_ConfigRegion(MPU_Region_InitTypeDef *MPU_Init)
{
20002278:	b480      	push	{r7}
2000227a:	b083      	sub	sp, #12
2000227c:	af00      	add	r7, sp, #0
2000227e:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_MPU_REGION_NUMBER(MPU_Init->Number));
  assert_param(IS_MPU_REGION_ENABLE(MPU_Init->Enable));

  /* Set the Region number */
  MPU->RNR = MPU_Init->Number;
20002280:	687b      	ldr	r3, [r7, #4]
20002282:	785a      	ldrb	r2, [r3, #1]
20002284:	4b1d      	ldr	r3, [pc, #116]	; (200022fc <HAL_MPU_ConfigRegion+0x84>)
20002286:	609a      	str	r2, [r3, #8]

  if ((MPU_Init->Enable) != 0U)
20002288:	687b      	ldr	r3, [r7, #4]
2000228a:	781b      	ldrb	r3, [r3, #0]
2000228c:	2b00      	cmp	r3, #0
2000228e:	d029      	beq.n	200022e4 <HAL_MPU_ConfigRegion+0x6c>
    assert_param(IS_MPU_ACCESS_CACHEABLE(MPU_Init->IsCacheable));
    assert_param(IS_MPU_ACCESS_BUFFERABLE(MPU_Init->IsBufferable));
    assert_param(IS_MPU_SUB_REGION_DISABLE(MPU_Init->SubRegionDisable));
    assert_param(IS_MPU_REGION_SIZE(MPU_Init->Size));

    MPU->RBAR = MPU_Init->BaseAddress;
20002290:	4a1a      	ldr	r2, [pc, #104]	; (200022fc <HAL_MPU_ConfigRegion+0x84>)
20002292:	687b      	ldr	r3, [r7, #4]
20002294:	685b      	ldr	r3, [r3, #4]
20002296:	60d3      	str	r3, [r2, #12]
    MPU->RASR = ((uint32_t)MPU_Init->DisableExec        << MPU_RASR_XN_Pos)   |
20002298:	687b      	ldr	r3, [r7, #4]
2000229a:	7b1b      	ldrb	r3, [r3, #12]
2000229c:	071a      	lsls	r2, r3, #28
                ((uint32_t)MPU_Init->AccessPermission   << MPU_RASR_AP_Pos)   |
2000229e:	687b      	ldr	r3, [r7, #4]
200022a0:	7adb      	ldrb	r3, [r3, #11]
200022a2:	061b      	lsls	r3, r3, #24
    MPU->RASR = ((uint32_t)MPU_Init->DisableExec        << MPU_RASR_XN_Pos)   |
200022a4:	431a      	orrs	r2, r3
                ((uint32_t)MPU_Init->TypeExtField       << MPU_RASR_TEX_Pos)  |
200022a6:	687b      	ldr	r3, [r7, #4]
200022a8:	7a9b      	ldrb	r3, [r3, #10]
200022aa:	04db      	lsls	r3, r3, #19
                ((uint32_t)MPU_Init->AccessPermission   << MPU_RASR_AP_Pos)   |
200022ac:	431a      	orrs	r2, r3
                ((uint32_t)MPU_Init->IsShareable        << MPU_RASR_S_Pos)    |
200022ae:	687b      	ldr	r3, [r7, #4]
200022b0:	7b5b      	ldrb	r3, [r3, #13]
200022b2:	049b      	lsls	r3, r3, #18
                ((uint32_t)MPU_Init->TypeExtField       << MPU_RASR_TEX_Pos)  |
200022b4:	431a      	orrs	r2, r3
                ((uint32_t)MPU_Init->IsCacheable        << MPU_RASR_C_Pos)    |
200022b6:	687b      	ldr	r3, [r7, #4]
200022b8:	7b9b      	ldrb	r3, [r3, #14]
200022ba:	045b      	lsls	r3, r3, #17
                ((uint32_t)MPU_Init->IsShareable        << MPU_RASR_S_Pos)    |
200022bc:	431a      	orrs	r2, r3
                ((uint32_t)MPU_Init->IsBufferable       << MPU_RASR_B_Pos)    |
200022be:	687b      	ldr	r3, [r7, #4]
200022c0:	7bdb      	ldrb	r3, [r3, #15]
200022c2:	041b      	lsls	r3, r3, #16
                ((uint32_t)MPU_Init->IsCacheable        << MPU_RASR_C_Pos)    |
200022c4:	431a      	orrs	r2, r3
                ((uint32_t)MPU_Init->SubRegionDisable   << MPU_RASR_SRD_Pos)  |
200022c6:	687b      	ldr	r3, [r7, #4]
200022c8:	7a5b      	ldrb	r3, [r3, #9]
200022ca:	021b      	lsls	r3, r3, #8
                ((uint32_t)MPU_Init->IsBufferable       << MPU_RASR_B_Pos)    |
200022cc:	431a      	orrs	r2, r3
                ((uint32_t)MPU_Init->Size               << MPU_RASR_SIZE_Pos) |
200022ce:	687b      	ldr	r3, [r7, #4]
200022d0:	7a1b      	ldrb	r3, [r3, #8]
200022d2:	005b      	lsls	r3, r3, #1
                ((uint32_t)MPU_Init->SubRegionDisable   << MPU_RASR_SRD_Pos)  |
200022d4:	4313      	orrs	r3, r2
                ((uint32_t)MPU_Init->Enable             << MPU_RASR_ENABLE_Pos);
200022d6:	687a      	ldr	r2, [r7, #4]
200022d8:	7812      	ldrb	r2, [r2, #0]
200022da:	4611      	mov	r1, r2
    MPU->RASR = ((uint32_t)MPU_Init->DisableExec        << MPU_RASR_XN_Pos)   |
200022dc:	4a07      	ldr	r2, [pc, #28]	; (200022fc <HAL_MPU_ConfigRegion+0x84>)
                ((uint32_t)MPU_Init->Size               << MPU_RASR_SIZE_Pos) |
200022de:	430b      	orrs	r3, r1
    MPU->RASR = ((uint32_t)MPU_Init->DisableExec        << MPU_RASR_XN_Pos)   |
200022e0:	6113      	str	r3, [r2, #16]
  else
  {
    MPU->RBAR = 0x00;
    MPU->RASR = 0x00;
  }
}
200022e2:	e005      	b.n	200022f0 <HAL_MPU_ConfigRegion+0x78>
    MPU->RBAR = 0x00;
200022e4:	4b05      	ldr	r3, [pc, #20]	; (200022fc <HAL_MPU_ConfigRegion+0x84>)
200022e6:	2200      	movs	r2, #0
200022e8:	60da      	str	r2, [r3, #12]
    MPU->RASR = 0x00;
200022ea:	4b04      	ldr	r3, [pc, #16]	; (200022fc <HAL_MPU_ConfigRegion+0x84>)
200022ec:	2200      	movs	r2, #0
200022ee:	611a      	str	r2, [r3, #16]
}
200022f0:	bf00      	nop
200022f2:	370c      	adds	r7, #12
200022f4:	46bd      	mov	sp, r7
200022f6:	f85d 7b04 	ldr.w	r7, [sp], #4
200022fa:	4770      	bx	lr
200022fc:	e000ed90 	.word	0xe000ed90

20002300 <HAL_DMA_Init>:
  * @param  hdma Pointer to a DMA_HandleTypeDef structure that contains
  *               the configuration information for the specified DMA Channel.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMA_Init(DMA_HandleTypeDef *hdma)
{
20002300:	b580      	push	{r7, lr}
20002302:	b084      	sub	sp, #16
20002304:	af00      	add	r7, sp, #0
20002306:	6078      	str	r0, [r7, #4]
  uint32_t tmp;

  /* Check the DMA handle allocation */
  if (hdma == NULL)
20002308:	687b      	ldr	r3, [r7, #4]
2000230a:	2b00      	cmp	r3, #0
2000230c:	d101      	bne.n	20002312 <HAL_DMA_Init+0x12>
  {
    return HAL_ERROR;
2000230e:	2301      	movs	r3, #1
20002310:	e08d      	b.n	2000242e <HAL_DMA_Init+0x12e>
  assert_param(IS_DMA_PRIORITY(hdma->Init.Priority));

  assert_param(IS_DMA_ALL_REQUEST(hdma->Init.Request));

  /* Compute the channel index */
  if ((uint32_t)(hdma->Instance) < (uint32_t)(DMA2_Channel1))
20002312:	687b      	ldr	r3, [r7, #4]
20002314:	681b      	ldr	r3, [r3, #0]
20002316:	461a      	mov	r2, r3
20002318:	4b47      	ldr	r3, [pc, #284]	; (20002438 <HAL_DMA_Init+0x138>)
2000231a:	429a      	cmp	r2, r3
2000231c:	d80f      	bhi.n	2000233e <HAL_DMA_Init+0x3e>
  {
    /* DMA1 */
    hdma->ChannelIndex = (((uint32_t)hdma->Instance - (uint32_t)DMA1_Channel1) / ((uint32_t)DMA1_Channel2 - (uint32_t)DMA1_Channel1)) << 2;
2000231e:	687b      	ldr	r3, [r7, #4]
20002320:	681b      	ldr	r3, [r3, #0]
20002322:	461a      	mov	r2, r3
20002324:	4b45      	ldr	r3, [pc, #276]	; (2000243c <HAL_DMA_Init+0x13c>)
20002326:	4413      	add	r3, r2
20002328:	4a45      	ldr	r2, [pc, #276]	; (20002440 <HAL_DMA_Init+0x140>)
2000232a:	fba2 2303 	umull	r2, r3, r2, r3
2000232e:	091b      	lsrs	r3, r3, #4
20002330:	009a      	lsls	r2, r3, #2
20002332:	687b      	ldr	r3, [r7, #4]
20002334:	645a      	str	r2, [r3, #68]	; 0x44
    hdma->DmaBaseAddress = DMA1;
20002336:	687b      	ldr	r3, [r7, #4]
20002338:	4a42      	ldr	r2, [pc, #264]	; (20002444 <HAL_DMA_Init+0x144>)
2000233a:	641a      	str	r2, [r3, #64]	; 0x40
2000233c:	e00e      	b.n	2000235c <HAL_DMA_Init+0x5c>
  }
  else
  {
    /* DMA2 */
    hdma->ChannelIndex = (((uint32_t)hdma->Instance - (uint32_t)DMA2_Channel1) / ((uint32_t)DMA2_Channel2 - (uint32_t)DMA2_Channel1)) << 2;
2000233e:	687b      	ldr	r3, [r7, #4]
20002340:	681b      	ldr	r3, [r3, #0]
20002342:	461a      	mov	r2, r3
20002344:	4b40      	ldr	r3, [pc, #256]	; (20002448 <HAL_DMA_Init+0x148>)
20002346:	4413      	add	r3, r2
20002348:	4a3d      	ldr	r2, [pc, #244]	; (20002440 <HAL_DMA_Init+0x140>)
2000234a:	fba2 2303 	umull	r2, r3, r2, r3
2000234e:	091b      	lsrs	r3, r3, #4
20002350:	009a      	lsls	r2, r3, #2
20002352:	687b      	ldr	r3, [r7, #4]
20002354:	645a      	str	r2, [r3, #68]	; 0x44
    hdma->DmaBaseAddress = DMA2;
20002356:	687b      	ldr	r3, [r7, #4]
20002358:	4a3c      	ldr	r2, [pc, #240]	; (2000244c <HAL_DMA_Init+0x14c>)
2000235a:	641a      	str	r2, [r3, #64]	; 0x40
  }

  /* Change DMA peripheral state */
  hdma->State = HAL_DMA_STATE_BUSY;
2000235c:	687b      	ldr	r3, [r7, #4]
2000235e:	2202      	movs	r2, #2
20002360:	f883 2025 	strb.w	r2, [r3, #37]	; 0x25

  /* Get the CR register value */
  tmp = hdma->Instance->CCR;
20002364:	687b      	ldr	r3, [r7, #4]
20002366:	681b      	ldr	r3, [r3, #0]
20002368:	681b      	ldr	r3, [r3, #0]
2000236a:	60fb      	str	r3, [r7, #12]

  /* Clear PL, MSIZE, PSIZE, MINC, PINC, CIRC, DIR and MEM2MEM bits */
  tmp &= ((uint32_t)~(DMA_CCR_PL    | DMA_CCR_MSIZE  | DMA_CCR_PSIZE  |
2000236c:	68fb      	ldr	r3, [r7, #12]
2000236e:	f423 43ff 	bic.w	r3, r3, #32640	; 0x7f80
20002372:	f023 0370 	bic.w	r3, r3, #112	; 0x70
20002376:	60fb      	str	r3, [r7, #12]
                      DMA_CCR_MINC  | DMA_CCR_PINC   | DMA_CCR_CIRC   |
                      DMA_CCR_DIR   | DMA_CCR_MEM2MEM));

  /* Prepare the DMA Channel configuration */
  tmp |=  hdma->Init.Direction        |
20002378:	687b      	ldr	r3, [r7, #4]
2000237a:	689a      	ldr	r2, [r3, #8]
          hdma->Init.PeriphInc           | hdma->Init.MemInc           |
2000237c:	687b      	ldr	r3, [r7, #4]
2000237e:	68db      	ldr	r3, [r3, #12]
  tmp |=  hdma->Init.Direction        |
20002380:	431a      	orrs	r2, r3
          hdma->Init.PeriphInc           | hdma->Init.MemInc           |
20002382:	687b      	ldr	r3, [r7, #4]
20002384:	691b      	ldr	r3, [r3, #16]
20002386:	431a      	orrs	r2, r3
          hdma->Init.PeriphDataAlignment | hdma->Init.MemDataAlignment |
20002388:	687b      	ldr	r3, [r7, #4]
2000238a:	695b      	ldr	r3, [r3, #20]
          hdma->Init.PeriphInc           | hdma->Init.MemInc           |
2000238c:	431a      	orrs	r2, r3
          hdma->Init.PeriphDataAlignment | hdma->Init.MemDataAlignment |
2000238e:	687b      	ldr	r3, [r7, #4]
20002390:	699b      	ldr	r3, [r3, #24]
20002392:	431a      	orrs	r2, r3
          hdma->Init.Mode                | hdma->Init.Priority;
20002394:	687b      	ldr	r3, [r7, #4]
20002396:	69db      	ldr	r3, [r3, #28]
          hdma->Init.PeriphDataAlignment | hdma->Init.MemDataAlignment |
20002398:	431a      	orrs	r2, r3
          hdma->Init.Mode                | hdma->Init.Priority;
2000239a:	687b      	ldr	r3, [r7, #4]
2000239c:	6a1b      	ldr	r3, [r3, #32]
2000239e:	4313      	orrs	r3, r2
  tmp |=  hdma->Init.Direction        |
200023a0:	68fa      	ldr	r2, [r7, #12]
200023a2:	4313      	orrs	r3, r2
200023a4:	60fb      	str	r3, [r7, #12]

  /* Write to DMA Channel CR register */
  hdma->Instance->CCR = tmp;
200023a6:	687b      	ldr	r3, [r7, #4]
200023a8:	681b      	ldr	r3, [r3, #0]
200023aa:	68fa      	ldr	r2, [r7, #12]
200023ac:	601a      	str	r2, [r3, #0]

  /* Initialize parameters for DMAMUX channel :
     DMAmuxChannel, DMAmuxChannelStatus and DMAmuxChannelStatusMask
  */
  DMA_CalcDMAMUXChannelBaseAndMask(hdma);
200023ae:	6878      	ldr	r0, [r7, #4]
200023b0:	f000 fce2 	bl	20002d78 <DMA_CalcDMAMUXChannelBaseAndMask>

  if (hdma->Init.Direction == DMA_MEMORY_TO_MEMORY)
200023b4:	687b      	ldr	r3, [r7, #4]
200023b6:	689b      	ldr	r3, [r3, #8]
200023b8:	f5b3 4f80 	cmp.w	r3, #16384	; 0x4000
200023bc:	d102      	bne.n	200023c4 <HAL_DMA_Init+0xc4>
  {
    /* if memory to memory force the request to 0*/
    hdma->Init.Request = DMA_REQUEST_MEM2MEM;
200023be:	687b      	ldr	r3, [r7, #4]
200023c0:	2200      	movs	r2, #0
200023c2:	605a      	str	r2, [r3, #4]
  }

  /* Set peripheral request  to DMAMUX channel */
  hdma->DMAmuxChannel->CCR = (hdma->Init.Request & DMAMUX_CxCR_DMAREQ_ID);
200023c4:	687b      	ldr	r3, [r7, #4]
200023c6:	685a      	ldr	r2, [r3, #4]
200023c8:	687b      	ldr	r3, [r7, #4]
200023ca:	6c9b      	ldr	r3, [r3, #72]	; 0x48
200023cc:	b2d2      	uxtb	r2, r2
200023ce:	601a      	str	r2, [r3, #0]

  /* Clear the DMAMUX synchro overrun flag */
  hdma->DMAmuxChannelStatus->CFR = hdma->DMAmuxChannelStatusMask;
200023d0:	687b      	ldr	r3, [r7, #4]
200023d2:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
200023d4:	687a      	ldr	r2, [r7, #4]
200023d6:	6d12      	ldr	r2, [r2, #80]	; 0x50
200023d8:	605a      	str	r2, [r3, #4]

  if (((hdma->Init.Request >  0U) && (hdma->Init.Request <= DMA_REQUEST_GENERATOR3)))
200023da:	687b      	ldr	r3, [r7, #4]
200023dc:	685b      	ldr	r3, [r3, #4]
200023de:	2b00      	cmp	r3, #0
200023e0:	d010      	beq.n	20002404 <HAL_DMA_Init+0x104>
200023e2:	687b      	ldr	r3, [r7, #4]
200023e4:	685b      	ldr	r3, [r3, #4]
200023e6:	2b04      	cmp	r3, #4
200023e8:	d80c      	bhi.n	20002404 <HAL_DMA_Init+0x104>
  {
    /* Initialize parameters for DMAMUX request generator :
       DMAmuxRequestGen, DMAmuxRequestGenStatus and DMAmuxRequestGenStatusMask
    */
    DMA_CalcDMAMUXRequestGenBaseAndMask(hdma);
200023ea:	6878      	ldr	r0, [r7, #4]
200023ec:	f000 fd02 	bl	20002df4 <DMA_CalcDMAMUXRequestGenBaseAndMask>

    /* Reset the DMAMUX request generator register*/
    hdma->DMAmuxRequestGen->RGCR = 0U;
200023f0:	687b      	ldr	r3, [r7, #4]
200023f2:	6d5b      	ldr	r3, [r3, #84]	; 0x54
200023f4:	2200      	movs	r2, #0
200023f6:	601a      	str	r2, [r3, #0]

    /* Clear the DMAMUX request generator overrun flag */
    hdma->DMAmuxRequestGenStatus->RGCFR = hdma->DMAmuxRequestGenStatusMask;
200023f8:	687b      	ldr	r3, [r7, #4]
200023fa:	6d9b      	ldr	r3, [r3, #88]	; 0x58
200023fc:	687a      	ldr	r2, [r7, #4]
200023fe:	6dd2      	ldr	r2, [r2, #92]	; 0x5c
20002400:	605a      	str	r2, [r3, #4]
20002402:	e008      	b.n	20002416 <HAL_DMA_Init+0x116>
  }
  else
  {
    hdma->DMAmuxRequestGen = 0U;
20002404:	687b      	ldr	r3, [r7, #4]
20002406:	2200      	movs	r2, #0
20002408:	655a      	str	r2, [r3, #84]	; 0x54
    hdma->DMAmuxRequestGenStatus = 0U;
2000240a:	687b      	ldr	r3, [r7, #4]
2000240c:	2200      	movs	r2, #0
2000240e:	659a      	str	r2, [r3, #88]	; 0x58
    hdma->DMAmuxRequestGenStatusMask = 0U;
20002410:	687b      	ldr	r3, [r7, #4]
20002412:	2200      	movs	r2, #0
20002414:	65da      	str	r2, [r3, #92]	; 0x5c
  }

  /* Initialize the error code */
  hdma->ErrorCode = HAL_DMA_ERROR_NONE;
20002416:	687b      	ldr	r3, [r7, #4]
20002418:	2200      	movs	r2, #0
2000241a:	63da      	str	r2, [r3, #60]	; 0x3c

  /* Initialize the DMA state*/
  hdma->State  = HAL_DMA_STATE_READY;
2000241c:	687b      	ldr	r3, [r7, #4]
2000241e:	2201      	movs	r2, #1
20002420:	f883 2025 	strb.w	r2, [r3, #37]	; 0x25

  /* Allocate lock resource and initialize it */
  hdma->Lock = HAL_UNLOCKED;
20002424:	687b      	ldr	r3, [r7, #4]
20002426:	2200      	movs	r2, #0
20002428:	f883 2024 	strb.w	r2, [r3, #36]	; 0x24

  return HAL_OK;
2000242c:	2300      	movs	r3, #0
}
2000242e:	4618      	mov	r0, r3
20002430:	3710      	adds	r7, #16
20002432:	46bd      	mov	sp, r7
20002434:	bd80      	pop	{r7, pc}
20002436:	bf00      	nop
20002438:	40020407 	.word	0x40020407
2000243c:	bffdfff8 	.word	0xbffdfff8
20002440:	cccccccd 	.word	0xcccccccd
20002444:	40020000 	.word	0x40020000
20002448:	bffdfbf8 	.word	0xbffdfbf8
2000244c:	40020400 	.word	0x40020400

20002450 <HAL_DMA_DeInit>:
  * @param  hdma pointer to a DMA_HandleTypeDef structure that contains
  *               the configuration information for the specified DMA Channel.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMA_DeInit(DMA_HandleTypeDef *hdma)
{
20002450:	b580      	push	{r7, lr}
20002452:	b082      	sub	sp, #8
20002454:	af00      	add	r7, sp, #0
20002456:	6078      	str	r0, [r7, #4]

  /* Check the DMA handle allocation */
  if (NULL == hdma)
20002458:	687b      	ldr	r3, [r7, #4]
2000245a:	2b00      	cmp	r3, #0
2000245c:	d101      	bne.n	20002462 <HAL_DMA_DeInit+0x12>
  {
    return HAL_ERROR;
2000245e:	2301      	movs	r3, #1
20002460:	e07b      	b.n	2000255a <HAL_DMA_DeInit+0x10a>

  /* Check the parameters */
  assert_param(IS_DMA_ALL_INSTANCE(hdma->Instance));

  /* Disable the selected DMA Channelx */
  __HAL_DMA_DISABLE(hdma);
20002462:	687b      	ldr	r3, [r7, #4]
20002464:	681b      	ldr	r3, [r3, #0]
20002466:	681a      	ldr	r2, [r3, #0]
20002468:	687b      	ldr	r3, [r7, #4]
2000246a:	681b      	ldr	r3, [r3, #0]
2000246c:	f022 0201 	bic.w	r2, r2, #1
20002470:	601a      	str	r2, [r3, #0]

  /* Compute the channel index */
  if ((uint32_t)(hdma->Instance) < (uint32_t)(DMA2_Channel1))
20002472:	687b      	ldr	r3, [r7, #4]
20002474:	681b      	ldr	r3, [r3, #0]
20002476:	461a      	mov	r2, r3
20002478:	4b3a      	ldr	r3, [pc, #232]	; (20002564 <HAL_DMA_DeInit+0x114>)
2000247a:	429a      	cmp	r2, r3
2000247c:	d80f      	bhi.n	2000249e <HAL_DMA_DeInit+0x4e>
  {
    /* DMA1 */
    hdma->ChannelIndex = (((uint32_t)hdma->Instance - (uint32_t)DMA1_Channel1) / ((uint32_t)DMA1_Channel2 - (uint32_t)DMA1_Channel1)) << 2;
2000247e:	687b      	ldr	r3, [r7, #4]
20002480:	681b      	ldr	r3, [r3, #0]
20002482:	461a      	mov	r2, r3
20002484:	4b38      	ldr	r3, [pc, #224]	; (20002568 <HAL_DMA_DeInit+0x118>)
20002486:	4413      	add	r3, r2
20002488:	4a38      	ldr	r2, [pc, #224]	; (2000256c <HAL_DMA_DeInit+0x11c>)
2000248a:	fba2 2303 	umull	r2, r3, r2, r3
2000248e:	091b      	lsrs	r3, r3, #4
20002490:	009a      	lsls	r2, r3, #2
20002492:	687b      	ldr	r3, [r7, #4]
20002494:	645a      	str	r2, [r3, #68]	; 0x44
    hdma->DmaBaseAddress = DMA1;
20002496:	687b      	ldr	r3, [r7, #4]
20002498:	4a35      	ldr	r2, [pc, #212]	; (20002570 <HAL_DMA_DeInit+0x120>)
2000249a:	641a      	str	r2, [r3, #64]	; 0x40
2000249c:	e00e      	b.n	200024bc <HAL_DMA_DeInit+0x6c>
  }
  else
  {
    /* DMA2 */
    hdma->ChannelIndex = (((uint32_t)hdma->Instance - (uint32_t)DMA2_Channel1) / ((uint32_t)DMA2_Channel2 - (uint32_t)DMA2_Channel1)) << 2;
2000249e:	687b      	ldr	r3, [r7, #4]
200024a0:	681b      	ldr	r3, [r3, #0]
200024a2:	461a      	mov	r2, r3
200024a4:	4b33      	ldr	r3, [pc, #204]	; (20002574 <HAL_DMA_DeInit+0x124>)
200024a6:	4413      	add	r3, r2
200024a8:	4a30      	ldr	r2, [pc, #192]	; (2000256c <HAL_DMA_DeInit+0x11c>)
200024aa:	fba2 2303 	umull	r2, r3, r2, r3
200024ae:	091b      	lsrs	r3, r3, #4
200024b0:	009a      	lsls	r2, r3, #2
200024b2:	687b      	ldr	r3, [r7, #4]
200024b4:	645a      	str	r2, [r3, #68]	; 0x44
    hdma->DmaBaseAddress = DMA2;
200024b6:	687b      	ldr	r3, [r7, #4]
200024b8:	4a2f      	ldr	r2, [pc, #188]	; (20002578 <HAL_DMA_DeInit+0x128>)
200024ba:	641a      	str	r2, [r3, #64]	; 0x40
  }

  /* Reset DMA Channel control register */
  hdma->Instance->CCR  = 0;
200024bc:	687b      	ldr	r3, [r7, #4]
200024be:	681b      	ldr	r3, [r3, #0]
200024c0:	2200      	movs	r2, #0
200024c2:	601a      	str	r2, [r3, #0]

  /* Clear all flags */
  hdma->DmaBaseAddress->IFCR = (DMA_ISR_GIF1 << (hdma->ChannelIndex & 0x1FU));
200024c4:	687b      	ldr	r3, [r7, #4]
200024c6:	6c5b      	ldr	r3, [r3, #68]	; 0x44
200024c8:	f003 021f 	and.w	r2, r3, #31
200024cc:	687b      	ldr	r3, [r7, #4]
200024ce:	6c1b      	ldr	r3, [r3, #64]	; 0x40
200024d0:	2101      	movs	r1, #1
200024d2:	fa01 f202 	lsl.w	r2, r1, r2
200024d6:	605a      	str	r2, [r3, #4]

  /* Initialize parameters for DMAMUX channel :
     DMAmuxChannel, DMAmuxChannelStatus and DMAmuxChannelStatusMask */

  DMA_CalcDMAMUXChannelBaseAndMask(hdma);
200024d8:	6878      	ldr	r0, [r7, #4]
200024da:	f000 fc4d 	bl	20002d78 <DMA_CalcDMAMUXChannelBaseAndMask>

  /* Reset the DMAMUX channel that corresponds to the DMA channel */
  hdma->DMAmuxChannel->CCR = 0;
200024de:	687b      	ldr	r3, [r7, #4]
200024e0:	6c9b      	ldr	r3, [r3, #72]	; 0x48
200024e2:	2200      	movs	r2, #0
200024e4:	601a      	str	r2, [r3, #0]

  /* Clear the DMAMUX synchro overrun flag */
  hdma->DMAmuxChannelStatus->CFR = hdma->DMAmuxChannelStatusMask;
200024e6:	687b      	ldr	r3, [r7, #4]
200024e8:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
200024ea:	687a      	ldr	r2, [r7, #4]
200024ec:	6d12      	ldr	r2, [r2, #80]	; 0x50
200024ee:	605a      	str	r2, [r3, #4]

  /* Reset Request generator parameters if any */
  if (((hdma->Init.Request >  0U) && (hdma->Init.Request <= DMA_REQUEST_GENERATOR3)))
200024f0:	687b      	ldr	r3, [r7, #4]
200024f2:	685b      	ldr	r3, [r3, #4]
200024f4:	2b00      	cmp	r3, #0
200024f6:	d00f      	beq.n	20002518 <HAL_DMA_DeInit+0xc8>
200024f8:	687b      	ldr	r3, [r7, #4]
200024fa:	685b      	ldr	r3, [r3, #4]
200024fc:	2b04      	cmp	r3, #4
200024fe:	d80b      	bhi.n	20002518 <HAL_DMA_DeInit+0xc8>
  {
    /* Initialize parameters for DMAMUX request generator :
       DMAmuxRequestGen, DMAmuxRequestGenStatus and DMAmuxRequestGenStatusMask
    */
    DMA_CalcDMAMUXRequestGenBaseAndMask(hdma);
20002500:	6878      	ldr	r0, [r7, #4]
20002502:	f000 fc77 	bl	20002df4 <DMA_CalcDMAMUXRequestGenBaseAndMask>

    /* Reset the DMAMUX request generator register*/
    hdma->DMAmuxRequestGen->RGCR = 0U;
20002506:	687b      	ldr	r3, [r7, #4]
20002508:	6d5b      	ldr	r3, [r3, #84]	; 0x54
2000250a:	2200      	movs	r2, #0
2000250c:	601a      	str	r2, [r3, #0]

    /* Clear the DMAMUX request generator overrun flag */
    hdma->DMAmuxRequestGenStatus->RGCFR = hdma->DMAmuxRequestGenStatusMask;
2000250e:	687b      	ldr	r3, [r7, #4]
20002510:	6d9b      	ldr	r3, [r3, #88]	; 0x58
20002512:	687a      	ldr	r2, [r7, #4]
20002514:	6dd2      	ldr	r2, [r2, #92]	; 0x5c
20002516:	605a      	str	r2, [r3, #4]
  }

  hdma->DMAmuxRequestGen = 0U;
20002518:	687b      	ldr	r3, [r7, #4]
2000251a:	2200      	movs	r2, #0
2000251c:	655a      	str	r2, [r3, #84]	; 0x54
  hdma->DMAmuxRequestGenStatus = 0U;
2000251e:	687b      	ldr	r3, [r7, #4]
20002520:	2200      	movs	r2, #0
20002522:	659a      	str	r2, [r3, #88]	; 0x58
  hdma->DMAmuxRequestGenStatusMask = 0U;
20002524:	687b      	ldr	r3, [r7, #4]
20002526:	2200      	movs	r2, #0
20002528:	65da      	str	r2, [r3, #92]	; 0x5c

  /* Clean callbacks */
  hdma->XferCpltCallback = NULL;
2000252a:	687b      	ldr	r3, [r7, #4]
2000252c:	2200      	movs	r2, #0
2000252e:	62da      	str	r2, [r3, #44]	; 0x2c
  hdma->XferHalfCpltCallback = NULL;
20002530:	687b      	ldr	r3, [r7, #4]
20002532:	2200      	movs	r2, #0
20002534:	631a      	str	r2, [r3, #48]	; 0x30
  hdma->XferErrorCallback = NULL;
20002536:	687b      	ldr	r3, [r7, #4]
20002538:	2200      	movs	r2, #0
2000253a:	635a      	str	r2, [r3, #52]	; 0x34
  hdma->XferAbortCallback = NULL;
2000253c:	687b      	ldr	r3, [r7, #4]
2000253e:	2200      	movs	r2, #0
20002540:	639a      	str	r2, [r3, #56]	; 0x38

  /* Initialize the error code */
  hdma->ErrorCode = HAL_DMA_ERROR_NONE;
20002542:	687b      	ldr	r3, [r7, #4]
20002544:	2200      	movs	r2, #0
20002546:	63da      	str	r2, [r3, #60]	; 0x3c

  /* Initialize the DMA state */
  hdma->State = HAL_DMA_STATE_RESET;
20002548:	687b      	ldr	r3, [r7, #4]
2000254a:	2200      	movs	r2, #0
2000254c:	f883 2025 	strb.w	r2, [r3, #37]	; 0x25

  /* Release Lock */
  __HAL_UNLOCK(hdma);
20002550:	687b      	ldr	r3, [r7, #4]
20002552:	2200      	movs	r2, #0
20002554:	f883 2024 	strb.w	r2, [r3, #36]	; 0x24

  return HAL_OK;
20002558:	2300      	movs	r3, #0
}
2000255a:	4618      	mov	r0, r3
2000255c:	3708      	adds	r7, #8
2000255e:	46bd      	mov	sp, r7
20002560:	bd80      	pop	{r7, pc}
20002562:	bf00      	nop
20002564:	40020407 	.word	0x40020407
20002568:	bffdfff8 	.word	0xbffdfff8
2000256c:	cccccccd 	.word	0xcccccccd
20002570:	40020000 	.word	0x40020000
20002574:	bffdfbf8 	.word	0xbffdfbf8
20002578:	40020400 	.word	0x40020400

2000257c <HAL_DMA_Start>:
  * @param  DstAddress The destination memory Buffer address
  * @param  DataLength The length of data to be transferred from source to destination (up to 256Kbytes-1)
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMA_Start(DMA_HandleTypeDef *hdma, uint32_t SrcAddress, uint32_t DstAddress, uint32_t DataLength)
{
2000257c:	b580      	push	{r7, lr}
2000257e:	b086      	sub	sp, #24
20002580:	af00      	add	r7, sp, #0
20002582:	60f8      	str	r0, [r7, #12]
20002584:	60b9      	str	r1, [r7, #8]
20002586:	607a      	str	r2, [r7, #4]
20002588:	603b      	str	r3, [r7, #0]
  HAL_StatusTypeDef status = HAL_OK;
2000258a:	2300      	movs	r3, #0
2000258c:	75fb      	strb	r3, [r7, #23]

  /* Check the parameters */
  assert_param(IS_DMA_BUFFER_SIZE(DataLength));

  /* Process locked */
  __HAL_LOCK(hdma);
2000258e:	68fb      	ldr	r3, [r7, #12]
20002590:	f893 3024 	ldrb.w	r3, [r3, #36]	; 0x24
20002594:	2b01      	cmp	r3, #1
20002596:	d101      	bne.n	2000259c <HAL_DMA_Start+0x20>
20002598:	2302      	movs	r3, #2
2000259a:	e02e      	b.n	200025fa <HAL_DMA_Start+0x7e>
2000259c:	68fb      	ldr	r3, [r7, #12]
2000259e:	2201      	movs	r2, #1
200025a0:	f883 2024 	strb.w	r2, [r3, #36]	; 0x24

  if (HAL_DMA_STATE_READY == hdma->State)
200025a4:	68fb      	ldr	r3, [r7, #12]
200025a6:	f893 3025 	ldrb.w	r3, [r3, #37]	; 0x25
200025aa:	b2db      	uxtb	r3, r3
200025ac:	2b01      	cmp	r3, #1
200025ae:	d11d      	bne.n	200025ec <HAL_DMA_Start+0x70>
  {
    /* Change DMA peripheral state */
    hdma->State = HAL_DMA_STATE_BUSY;
200025b0:	68fb      	ldr	r3, [r7, #12]
200025b2:	2202      	movs	r2, #2
200025b4:	f883 2025 	strb.w	r2, [r3, #37]	; 0x25
    hdma->ErrorCode = HAL_DMA_ERROR_NONE;
200025b8:	68fb      	ldr	r3, [r7, #12]
200025ba:	2200      	movs	r2, #0
200025bc:	63da      	str	r2, [r3, #60]	; 0x3c

    /* Disable the peripheral */
    __HAL_DMA_DISABLE(hdma);
200025be:	68fb      	ldr	r3, [r7, #12]
200025c0:	681b      	ldr	r3, [r3, #0]
200025c2:	681a      	ldr	r2, [r3, #0]
200025c4:	68fb      	ldr	r3, [r7, #12]
200025c6:	681b      	ldr	r3, [r3, #0]
200025c8:	f022 0201 	bic.w	r2, r2, #1
200025cc:	601a      	str	r2, [r3, #0]

    /* Configure the source, destination address and the data length & clear flags*/
    DMA_SetConfig(hdma, SrcAddress, DstAddress, DataLength);
200025ce:	683b      	ldr	r3, [r7, #0]
200025d0:	687a      	ldr	r2, [r7, #4]
200025d2:	68b9      	ldr	r1, [r7, #8]
200025d4:	68f8      	ldr	r0, [r7, #12]
200025d6:	f000 fb91 	bl	20002cfc <DMA_SetConfig>

    /* Enable the Peripheral */
    __HAL_DMA_ENABLE(hdma);
200025da:	68fb      	ldr	r3, [r7, #12]
200025dc:	681b      	ldr	r3, [r3, #0]
200025de:	681a      	ldr	r2, [r3, #0]
200025e0:	68fb      	ldr	r3, [r7, #12]
200025e2:	681b      	ldr	r3, [r3, #0]
200025e4:	f042 0201 	orr.w	r2, r2, #1
200025e8:	601a      	str	r2, [r3, #0]
200025ea:	e005      	b.n	200025f8 <HAL_DMA_Start+0x7c>
  }
  else
  {
    /* Process Unlocked */
    __HAL_UNLOCK(hdma);
200025ec:	68fb      	ldr	r3, [r7, #12]
200025ee:	2200      	movs	r2, #0
200025f0:	f883 2024 	strb.w	r2, [r3, #36]	; 0x24
    status = HAL_BUSY;
200025f4:	2302      	movs	r3, #2
200025f6:	75fb      	strb	r3, [r7, #23]
  }
  return status;
200025f8:	7dfb      	ldrb	r3, [r7, #23]
}
200025fa:	4618      	mov	r0, r3
200025fc:	3718      	adds	r7, #24
200025fe:	46bd      	mov	sp, r7
20002600:	bd80      	pop	{r7, pc}

20002602 <HAL_DMA_Start_IT>:
  * @param  DataLength The length of data to be transferred from source to destination (up to 256Kbytes-1)
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMA_Start_IT(DMA_HandleTypeDef *hdma, uint32_t SrcAddress, uint32_t DstAddress,
                                   uint32_t DataLength)
{
20002602:	b580      	push	{r7, lr}
20002604:	b086      	sub	sp, #24
20002606:	af00      	add	r7, sp, #0
20002608:	60f8      	str	r0, [r7, #12]
2000260a:	60b9      	str	r1, [r7, #8]
2000260c:	607a      	str	r2, [r7, #4]
2000260e:	603b      	str	r3, [r7, #0]
  HAL_StatusTypeDef status = HAL_OK;
20002610:	2300      	movs	r3, #0
20002612:	75fb      	strb	r3, [r7, #23]

  /* Check the parameters */
  assert_param(IS_DMA_BUFFER_SIZE(DataLength));

  /* Process locked */
  __HAL_LOCK(hdma);
20002614:	68fb      	ldr	r3, [r7, #12]
20002616:	f893 3024 	ldrb.w	r3, [r3, #36]	; 0x24
2000261a:	2b01      	cmp	r3, #1
2000261c:	d101      	bne.n	20002622 <HAL_DMA_Start_IT+0x20>
2000261e:	2302      	movs	r3, #2
20002620:	e066      	b.n	200026f0 <HAL_DMA_Start_IT+0xee>
20002622:	68fb      	ldr	r3, [r7, #12]
20002624:	2201      	movs	r2, #1
20002626:	f883 2024 	strb.w	r2, [r3, #36]	; 0x24

  if (HAL_DMA_STATE_READY == hdma->State)
2000262a:	68fb      	ldr	r3, [r7, #12]
2000262c:	f893 3025 	ldrb.w	r3, [r3, #37]	; 0x25
20002630:	b2db      	uxtb	r3, r3
20002632:	2b01      	cmp	r3, #1
20002634:	d155      	bne.n	200026e2 <HAL_DMA_Start_IT+0xe0>
  {
    /* Change DMA peripheral state */
    hdma->State = HAL_DMA_STATE_BUSY;
20002636:	68fb      	ldr	r3, [r7, #12]
20002638:	2202      	movs	r2, #2
2000263a:	f883 2025 	strb.w	r2, [r3, #37]	; 0x25
    hdma->ErrorCode = HAL_DMA_ERROR_NONE;
2000263e:	68fb      	ldr	r3, [r7, #12]
20002640:	2200      	movs	r2, #0
20002642:	63da      	str	r2, [r3, #60]	; 0x3c

    /* Disable the peripheral */
    __HAL_DMA_DISABLE(hdma);
20002644:	68fb      	ldr	r3, [r7, #12]
20002646:	681b      	ldr	r3, [r3, #0]
20002648:	681a      	ldr	r2, [r3, #0]
2000264a:	68fb      	ldr	r3, [r7, #12]
2000264c:	681b      	ldr	r3, [r3, #0]
2000264e:	f022 0201 	bic.w	r2, r2, #1
20002652:	601a      	str	r2, [r3, #0]

    /* Configure the source, destination address and the data length & clear flags*/
    DMA_SetConfig(hdma, SrcAddress, DstAddress, DataLength);
20002654:	683b      	ldr	r3, [r7, #0]
20002656:	687a      	ldr	r2, [r7, #4]
20002658:	68b9      	ldr	r1, [r7, #8]
2000265a:	68f8      	ldr	r0, [r7, #12]
2000265c:	f000 fb4e 	bl	20002cfc <DMA_SetConfig>

    /* Enable the transfer complete interrupt */
    /* Enable the transfer Error interrupt */
    if (NULL != hdma->XferHalfCpltCallback)
20002660:	68fb      	ldr	r3, [r7, #12]
20002662:	6b1b      	ldr	r3, [r3, #48]	; 0x30
20002664:	2b00      	cmp	r3, #0
20002666:	d008      	beq.n	2000267a <HAL_DMA_Start_IT+0x78>
    {
      /* Enable the Half transfer complete interrupt as well */
      __HAL_DMA_ENABLE_IT(hdma, (DMA_IT_TC | DMA_IT_HT | DMA_IT_TE));
20002668:	68fb      	ldr	r3, [r7, #12]
2000266a:	681b      	ldr	r3, [r3, #0]
2000266c:	681a      	ldr	r2, [r3, #0]
2000266e:	68fb      	ldr	r3, [r7, #12]
20002670:	681b      	ldr	r3, [r3, #0]
20002672:	f042 020e 	orr.w	r2, r2, #14
20002676:	601a      	str	r2, [r3, #0]
20002678:	e00f      	b.n	2000269a <HAL_DMA_Start_IT+0x98>
    }
    else
    {
      __HAL_DMA_DISABLE_IT(hdma, DMA_IT_HT);
2000267a:	68fb      	ldr	r3, [r7, #12]
2000267c:	681b      	ldr	r3, [r3, #0]
2000267e:	681a      	ldr	r2, [r3, #0]
20002680:	68fb      	ldr	r3, [r7, #12]
20002682:	681b      	ldr	r3, [r3, #0]
20002684:	f022 0204 	bic.w	r2, r2, #4
20002688:	601a      	str	r2, [r3, #0]
      __HAL_DMA_ENABLE_IT(hdma, (DMA_IT_TC | DMA_IT_TE));
2000268a:	68fb      	ldr	r3, [r7, #12]
2000268c:	681b      	ldr	r3, [r3, #0]
2000268e:	681a      	ldr	r2, [r3, #0]
20002690:	68fb      	ldr	r3, [r7, #12]
20002692:	681b      	ldr	r3, [r3, #0]
20002694:	f042 020a 	orr.w	r2, r2, #10
20002698:	601a      	str	r2, [r3, #0]
    }

    /* Check if DMAMUX Synchronization is enabled*/
    if ((hdma->DMAmuxChannel->CCR & DMAMUX_CxCR_SE) != 0U)
2000269a:	68fb      	ldr	r3, [r7, #12]
2000269c:	6c9b      	ldr	r3, [r3, #72]	; 0x48
2000269e:	681b      	ldr	r3, [r3, #0]
200026a0:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
200026a4:	2b00      	cmp	r3, #0
200026a6:	d007      	beq.n	200026b8 <HAL_DMA_Start_IT+0xb6>
    {
      /* Enable DMAMUX sync overrun IT*/
      hdma->DMAmuxChannel->CCR |= DMAMUX_CxCR_SOIE;
200026a8:	68fb      	ldr	r3, [r7, #12]
200026aa:	6c9b      	ldr	r3, [r3, #72]	; 0x48
200026ac:	681a      	ldr	r2, [r3, #0]
200026ae:	68fb      	ldr	r3, [r7, #12]
200026b0:	6c9b      	ldr	r3, [r3, #72]	; 0x48
200026b2:	f442 7280 	orr.w	r2, r2, #256	; 0x100
200026b6:	601a      	str	r2, [r3, #0]
    }

    if (hdma->DMAmuxRequestGen != 0U)
200026b8:	68fb      	ldr	r3, [r7, #12]
200026ba:	6d5b      	ldr	r3, [r3, #84]	; 0x54
200026bc:	2b00      	cmp	r3, #0
200026be:	d007      	beq.n	200026d0 <HAL_DMA_Start_IT+0xce>
    {
      /* if using DMAMUX request generator, enable the DMAMUX request generator overrun IT*/
      /* enable the request gen overrun IT*/
      hdma->DMAmuxRequestGen->RGCR |= DMAMUX_RGxCR_OIE;
200026c0:	68fb      	ldr	r3, [r7, #12]
200026c2:	6d5b      	ldr	r3, [r3, #84]	; 0x54
200026c4:	681a      	ldr	r2, [r3, #0]
200026c6:	68fb      	ldr	r3, [r7, #12]
200026c8:	6d5b      	ldr	r3, [r3, #84]	; 0x54
200026ca:	f442 7280 	orr.w	r2, r2, #256	; 0x100
200026ce:	601a      	str	r2, [r3, #0]
    }

    /* Enable the Peripheral */
    __HAL_DMA_ENABLE(hdma);
200026d0:	68fb      	ldr	r3, [r7, #12]
200026d2:	681b      	ldr	r3, [r3, #0]
200026d4:	681a      	ldr	r2, [r3, #0]
200026d6:	68fb      	ldr	r3, [r7, #12]
200026d8:	681b      	ldr	r3, [r3, #0]
200026da:	f042 0201 	orr.w	r2, r2, #1
200026de:	601a      	str	r2, [r3, #0]
200026e0:	e005      	b.n	200026ee <HAL_DMA_Start_IT+0xec>
  }
  else
  {
    /* Process Unlocked */
    __HAL_UNLOCK(hdma);
200026e2:	68fb      	ldr	r3, [r7, #12]
200026e4:	2200      	movs	r2, #0
200026e6:	f883 2024 	strb.w	r2, [r3, #36]	; 0x24

    /* Remain BUSY */
    status = HAL_BUSY;
200026ea:	2302      	movs	r3, #2
200026ec:	75fb      	strb	r3, [r7, #23]
  }
  return status;
200026ee:	7dfb      	ldrb	r3, [r7, #23]
}
200026f0:	4618      	mov	r0, r3
200026f2:	3718      	adds	r7, #24
200026f4:	46bd      	mov	sp, r7
200026f6:	bd80      	pop	{r7, pc}

200026f8 <HAL_DMA_Abort>:
  * @param  hdma pointer to a DMA_HandleTypeDef structure that contains
  *               the configuration information for the specified DMA Channel.
    * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMA_Abort(DMA_HandleTypeDef *hdma)
{
200026f8:	b480      	push	{r7}
200026fa:	b085      	sub	sp, #20
200026fc:	af00      	add	r7, sp, #0
200026fe:	6078      	str	r0, [r7, #4]
  HAL_StatusTypeDef status = HAL_OK;
20002700:	2300      	movs	r3, #0
20002702:	73fb      	strb	r3, [r7, #15]

  if(hdma->State != HAL_DMA_STATE_BUSY)
20002704:	687b      	ldr	r3, [r7, #4]
20002706:	f893 3025 	ldrb.w	r3, [r3, #37]	; 0x25
2000270a:	b2db      	uxtb	r3, r3
2000270c:	2b02      	cmp	r3, #2
2000270e:	d005      	beq.n	2000271c <HAL_DMA_Abort+0x24>
  {
    /* no transfer ongoing */
    hdma->ErrorCode = HAL_DMA_ERROR_NO_XFER;
20002710:	687b      	ldr	r3, [r7, #4]
20002712:	2204      	movs	r2, #4
20002714:	63da      	str	r2, [r3, #60]	; 0x3c

    status = HAL_ERROR;
20002716:	2301      	movs	r3, #1
20002718:	73fb      	strb	r3, [r7, #15]
2000271a:	e037      	b.n	2000278c <HAL_DMA_Abort+0x94>
  }
  else
  {
     /* Disable DMA IT */
     __HAL_DMA_DISABLE_IT(hdma, (DMA_IT_TC | DMA_IT_HT | DMA_IT_TE));
2000271c:	687b      	ldr	r3, [r7, #4]
2000271e:	681b      	ldr	r3, [r3, #0]
20002720:	681a      	ldr	r2, [r3, #0]
20002722:	687b      	ldr	r3, [r7, #4]
20002724:	681b      	ldr	r3, [r3, #0]
20002726:	f022 020e 	bic.w	r2, r2, #14
2000272a:	601a      	str	r2, [r3, #0]
     
     /* disable the DMAMUX sync overrun IT*/
     hdma->DMAmuxChannel->CCR &= ~DMAMUX_CxCR_SOIE;
2000272c:	687b      	ldr	r3, [r7, #4]
2000272e:	6c9b      	ldr	r3, [r3, #72]	; 0x48
20002730:	681a      	ldr	r2, [r3, #0]
20002732:	687b      	ldr	r3, [r7, #4]
20002734:	6c9b      	ldr	r3, [r3, #72]	; 0x48
20002736:	f422 7280 	bic.w	r2, r2, #256	; 0x100
2000273a:	601a      	str	r2, [r3, #0]
     
     /* Disable the channel */
     __HAL_DMA_DISABLE(hdma);
2000273c:	687b      	ldr	r3, [r7, #4]
2000273e:	681b      	ldr	r3, [r3, #0]
20002740:	681a      	ldr	r2, [r3, #0]
20002742:	687b      	ldr	r3, [r7, #4]
20002744:	681b      	ldr	r3, [r3, #0]
20002746:	f022 0201 	bic.w	r2, r2, #1
2000274a:	601a      	str	r2, [r3, #0]
     
     /* Clear all flags */
     hdma->DmaBaseAddress->IFCR = (DMA_ISR_GIF1 << (hdma->ChannelIndex & 0x1FU));
2000274c:	687b      	ldr	r3, [r7, #4]
2000274e:	6c5b      	ldr	r3, [r3, #68]	; 0x44
20002750:	f003 021f 	and.w	r2, r3, #31
20002754:	687b      	ldr	r3, [r7, #4]
20002756:	6c1b      	ldr	r3, [r3, #64]	; 0x40
20002758:	2101      	movs	r1, #1
2000275a:	fa01 f202 	lsl.w	r2, r1, r2
2000275e:	605a      	str	r2, [r3, #4]
     
     /* Clear the DMAMUX synchro overrun flag */
     hdma->DMAmuxChannelStatus->CFR = hdma->DMAmuxChannelStatusMask;
20002760:	687b      	ldr	r3, [r7, #4]
20002762:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
20002764:	687a      	ldr	r2, [r7, #4]
20002766:	6d12      	ldr	r2, [r2, #80]	; 0x50
20002768:	605a      	str	r2, [r3, #4]
     
     if (hdma->DMAmuxRequestGen != 0U)
2000276a:	687b      	ldr	r3, [r7, #4]
2000276c:	6d5b      	ldr	r3, [r3, #84]	; 0x54
2000276e:	2b00      	cmp	r3, #0
20002770:	d00c      	beq.n	2000278c <HAL_DMA_Abort+0x94>
     {
       /* if using DMAMUX request generator, disable the DMAMUX request generator overrun IT*/
       /* disable the request gen overrun IT*/
       hdma->DMAmuxRequestGen->RGCR &= ~DMAMUX_RGxCR_OIE;
20002772:	687b      	ldr	r3, [r7, #4]
20002774:	6d5b      	ldr	r3, [r3, #84]	; 0x54
20002776:	681a      	ldr	r2, [r3, #0]
20002778:	687b      	ldr	r3, [r7, #4]
2000277a:	6d5b      	ldr	r3, [r3, #84]	; 0x54
2000277c:	f422 7280 	bic.w	r2, r2, #256	; 0x100
20002780:	601a      	str	r2, [r3, #0]
     
       /* Clear the DMAMUX request generator overrun flag */
       hdma->DMAmuxRequestGenStatus->RGCFR = hdma->DMAmuxRequestGenStatusMask;
20002782:	687b      	ldr	r3, [r7, #4]
20002784:	6d9b      	ldr	r3, [r3, #88]	; 0x58
20002786:	687a      	ldr	r2, [r7, #4]
20002788:	6dd2      	ldr	r2, [r2, #92]	; 0x5c
2000278a:	605a      	str	r2, [r3, #4]
     }
  }  
  /* Change the DMA state */
  hdma->State = HAL_DMA_STATE_READY;
2000278c:	687b      	ldr	r3, [r7, #4]
2000278e:	2201      	movs	r2, #1
20002790:	f883 2025 	strb.w	r2, [r3, #37]	; 0x25

  /* Process Unlocked */
  __HAL_UNLOCK(hdma);
20002794:	687b      	ldr	r3, [r7, #4]
20002796:	2200      	movs	r2, #0
20002798:	f883 2024 	strb.w	r2, [r3, #36]	; 0x24

  return status;
2000279c:	7bfb      	ldrb	r3, [r7, #15]
}
2000279e:	4618      	mov	r0, r3
200027a0:	3714      	adds	r7, #20
200027a2:	46bd      	mov	sp, r7
200027a4:	f85d 7b04 	ldr.w	r7, [sp], #4
200027a8:	4770      	bx	lr

200027aa <HAL_DMA_Abort_IT>:
  * @param  hdma pointer to a DMA_HandleTypeDef structure that contains
  *              the configuration information for the specified DMA Channel.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMA_Abort_IT(DMA_HandleTypeDef *hdma)
{
200027aa:	b580      	push	{r7, lr}
200027ac:	b084      	sub	sp, #16
200027ae:	af00      	add	r7, sp, #0
200027b0:	6078      	str	r0, [r7, #4]
  HAL_StatusTypeDef status = HAL_OK;
200027b2:	2300      	movs	r3, #0
200027b4:	73fb      	strb	r3, [r7, #15]

  if (HAL_DMA_STATE_BUSY != hdma->State)
200027b6:	687b      	ldr	r3, [r7, #4]
200027b8:	f893 3025 	ldrb.w	r3, [r3, #37]	; 0x25
200027bc:	b2db      	uxtb	r3, r3
200027be:	2b02      	cmp	r3, #2
200027c0:	d00d      	beq.n	200027de <HAL_DMA_Abort_IT+0x34>
  {
    /* no transfer ongoing */
    hdma->ErrorCode = HAL_DMA_ERROR_NO_XFER;
200027c2:	687b      	ldr	r3, [r7, #4]
200027c4:	2204      	movs	r2, #4
200027c6:	63da      	str	r2, [r3, #60]	; 0x3c

    /* Change the DMA state */
    hdma->State = HAL_DMA_STATE_READY;
200027c8:	687b      	ldr	r3, [r7, #4]
200027ca:	2201      	movs	r2, #1
200027cc:	f883 2025 	strb.w	r2, [r3, #37]	; 0x25

    /* Process Unlocked */
    __HAL_UNLOCK(hdma);
200027d0:	687b      	ldr	r3, [r7, #4]
200027d2:	2200      	movs	r2, #0
200027d4:	f883 2024 	strb.w	r2, [r3, #36]	; 0x24

    status = HAL_ERROR;
200027d8:	2301      	movs	r3, #1
200027da:	73fb      	strb	r3, [r7, #15]
200027dc:	e047      	b.n	2000286e <HAL_DMA_Abort_IT+0xc4>
  }
  else
  {
    /* Disable DMA IT */
    __HAL_DMA_DISABLE_IT(hdma, (DMA_IT_TC | DMA_IT_HT | DMA_IT_TE));
200027de:	687b      	ldr	r3, [r7, #4]
200027e0:	681b      	ldr	r3, [r3, #0]
200027e2:	681a      	ldr	r2, [r3, #0]
200027e4:	687b      	ldr	r3, [r7, #4]
200027e6:	681b      	ldr	r3, [r3, #0]
200027e8:	f022 020e 	bic.w	r2, r2, #14
200027ec:	601a      	str	r2, [r3, #0]

    /* Disable the channel */
    __HAL_DMA_DISABLE(hdma);
200027ee:	687b      	ldr	r3, [r7, #4]
200027f0:	681b      	ldr	r3, [r3, #0]
200027f2:	681a      	ldr	r2, [r3, #0]
200027f4:	687b      	ldr	r3, [r7, #4]
200027f6:	681b      	ldr	r3, [r3, #0]
200027f8:	f022 0201 	bic.w	r2, r2, #1
200027fc:	601a      	str	r2, [r3, #0]

    /* disable the DMAMUX sync overrun IT*/
    hdma->DMAmuxChannel->CCR &= ~DMAMUX_CxCR_SOIE;
200027fe:	687b      	ldr	r3, [r7, #4]
20002800:	6c9b      	ldr	r3, [r3, #72]	; 0x48
20002802:	681a      	ldr	r2, [r3, #0]
20002804:	687b      	ldr	r3, [r7, #4]
20002806:	6c9b      	ldr	r3, [r3, #72]	; 0x48
20002808:	f422 7280 	bic.w	r2, r2, #256	; 0x100
2000280c:	601a      	str	r2, [r3, #0]

    /* Clear all flags */
    hdma->DmaBaseAddress->IFCR = (DMA_ISR_GIF1 << (hdma->ChannelIndex & 0x1FU));
2000280e:	687b      	ldr	r3, [r7, #4]
20002810:	6c5b      	ldr	r3, [r3, #68]	; 0x44
20002812:	f003 021f 	and.w	r2, r3, #31
20002816:	687b      	ldr	r3, [r7, #4]
20002818:	6c1b      	ldr	r3, [r3, #64]	; 0x40
2000281a:	2101      	movs	r1, #1
2000281c:	fa01 f202 	lsl.w	r2, r1, r2
20002820:	605a      	str	r2, [r3, #4]

    /* Clear the DMAMUX synchro overrun flag */
    hdma->DMAmuxChannelStatus->CFR = hdma->DMAmuxChannelStatusMask;
20002822:	687b      	ldr	r3, [r7, #4]
20002824:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
20002826:	687a      	ldr	r2, [r7, #4]
20002828:	6d12      	ldr	r2, [r2, #80]	; 0x50
2000282a:	605a      	str	r2, [r3, #4]

    if (hdma->DMAmuxRequestGen != 0U)
2000282c:	687b      	ldr	r3, [r7, #4]
2000282e:	6d5b      	ldr	r3, [r3, #84]	; 0x54
20002830:	2b00      	cmp	r3, #0
20002832:	d00c      	beq.n	2000284e <HAL_DMA_Abort_IT+0xa4>
    {
      /* if using DMAMUX request generator, disable the DMAMUX request generator overrun IT*/
      /* disable the request gen overrun IT*/
      hdma->DMAmuxRequestGen->RGCR &= ~DMAMUX_RGxCR_OIE;
20002834:	687b      	ldr	r3, [r7, #4]
20002836:	6d5b      	ldr	r3, [r3, #84]	; 0x54
20002838:	681a      	ldr	r2, [r3, #0]
2000283a:	687b      	ldr	r3, [r7, #4]
2000283c:	6d5b      	ldr	r3, [r3, #84]	; 0x54
2000283e:	f422 7280 	bic.w	r2, r2, #256	; 0x100
20002842:	601a      	str	r2, [r3, #0]

      /* Clear the DMAMUX request generator overrun flag */
      hdma->DMAmuxRequestGenStatus->RGCFR = hdma->DMAmuxRequestGenStatusMask;
20002844:	687b      	ldr	r3, [r7, #4]
20002846:	6d9b      	ldr	r3, [r3, #88]	; 0x58
20002848:	687a      	ldr	r2, [r7, #4]
2000284a:	6dd2      	ldr	r2, [r2, #92]	; 0x5c
2000284c:	605a      	str	r2, [r3, #4]
    }

    /* Change the DMA state */
    hdma->State = HAL_DMA_STATE_READY;
2000284e:	687b      	ldr	r3, [r7, #4]
20002850:	2201      	movs	r2, #1
20002852:	f883 2025 	strb.w	r2, [r3, #37]	; 0x25

    /* Process Unlocked */
    __HAL_UNLOCK(hdma);
20002856:	687b      	ldr	r3, [r7, #4]
20002858:	2200      	movs	r2, #0
2000285a:	f883 2024 	strb.w	r2, [r3, #36]	; 0x24

    /* Call User Abort callback */
    if (hdma->XferAbortCallback != NULL)
2000285e:	687b      	ldr	r3, [r7, #4]
20002860:	6b9b      	ldr	r3, [r3, #56]	; 0x38
20002862:	2b00      	cmp	r3, #0
20002864:	d003      	beq.n	2000286e <HAL_DMA_Abort_IT+0xc4>
    {
      hdma->XferAbortCallback(hdma);
20002866:	687b      	ldr	r3, [r7, #4]
20002868:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2000286a:	6878      	ldr	r0, [r7, #4]
2000286c:	4798      	blx	r3
    }
  }
  return status;
2000286e:	7bfb      	ldrb	r3, [r7, #15]
}
20002870:	4618      	mov	r0, r3
20002872:	3710      	adds	r7, #16
20002874:	46bd      	mov	sp, r7
20002876:	bd80      	pop	{r7, pc}

20002878 <HAL_DMA_PollForTransfer>:
  * @param  Timeout       Timeout duration.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMA_PollForTransfer(DMA_HandleTypeDef *hdma, HAL_DMA_LevelCompleteTypeDef CompleteLevel,
                                          uint32_t Timeout)
{
20002878:	b580      	push	{r7, lr}
2000287a:	b086      	sub	sp, #24
2000287c:	af00      	add	r7, sp, #0
2000287e:	60f8      	str	r0, [r7, #12]
20002880:	460b      	mov	r3, r1
20002882:	607a      	str	r2, [r7, #4]
20002884:	72fb      	strb	r3, [r7, #11]
  uint32_t temp;
  uint32_t tickstart;

  if (HAL_DMA_STATE_BUSY != hdma->State)
20002886:	68fb      	ldr	r3, [r7, #12]
20002888:	f893 3025 	ldrb.w	r3, [r3, #37]	; 0x25
2000288c:	b2db      	uxtb	r3, r3
2000288e:	2b02      	cmp	r3, #2
20002890:	d008      	beq.n	200028a4 <HAL_DMA_PollForTransfer+0x2c>
  {
    /* no transfer ongoing */
    hdma->ErrorCode = HAL_DMA_ERROR_NO_XFER;
20002892:	68fb      	ldr	r3, [r7, #12]
20002894:	2204      	movs	r2, #4
20002896:	63da      	str	r2, [r3, #60]	; 0x3c
    __HAL_UNLOCK(hdma);
20002898:	68fb      	ldr	r3, [r7, #12]
2000289a:	2200      	movs	r2, #0
2000289c:	f883 2024 	strb.w	r2, [r3, #36]	; 0x24
    return HAL_ERROR;
200028a0:	2301      	movs	r3, #1
200028a2:	e0be      	b.n	20002a22 <HAL_DMA_PollForTransfer+0x1aa>
  }

  /* Polling mode not supported in circular mode */
  if (0U != (hdma->Instance->CCR & DMA_CCR_CIRC))
200028a4:	68fb      	ldr	r3, [r7, #12]
200028a6:	681b      	ldr	r3, [r3, #0]
200028a8:	681b      	ldr	r3, [r3, #0]
200028aa:	f003 0320 	and.w	r3, r3, #32
200028ae:	2b00      	cmp	r3, #0
200028b0:	d005      	beq.n	200028be <HAL_DMA_PollForTransfer+0x46>
  {
    hdma->ErrorCode = HAL_DMA_ERROR_NOT_SUPPORTED;
200028b2:	68fb      	ldr	r3, [r7, #12]
200028b4:	f44f 7280 	mov.w	r2, #256	; 0x100
200028b8:	63da      	str	r2, [r3, #60]	; 0x3c
    return HAL_ERROR;
200028ba:	2301      	movs	r3, #1
200028bc:	e0b1      	b.n	20002a22 <HAL_DMA_PollForTransfer+0x1aa>
  }

  /* Get the level transfer complete flag */
  if (HAL_DMA_FULL_TRANSFER == CompleteLevel)
200028be:	7afb      	ldrb	r3, [r7, #11]
200028c0:	2b00      	cmp	r3, #0
200028c2:	d108      	bne.n	200028d6 <HAL_DMA_PollForTransfer+0x5e>
  {
    /* Transfer Complete flag */

    temp = (uint32_t)DMA_FLAG_TC1 << (hdma->ChannelIndex & 0x1FU);
200028c4:	68fb      	ldr	r3, [r7, #12]
200028c6:	6c5b      	ldr	r3, [r3, #68]	; 0x44
200028c8:	f003 031f 	and.w	r3, r3, #31
200028cc:	2202      	movs	r2, #2
200028ce:	fa02 f303 	lsl.w	r3, r2, r3
200028d2:	617b      	str	r3, [r7, #20]
200028d4:	e007      	b.n	200028e6 <HAL_DMA_PollForTransfer+0x6e>
  }
  else
  {
    /* Half Transfer Complete flag */
    temp = (uint32_t)DMA_FLAG_HT1 << (hdma->ChannelIndex & 0x1FU);
200028d6:	68fb      	ldr	r3, [r7, #12]
200028d8:	6c5b      	ldr	r3, [r3, #68]	; 0x44
200028da:	f003 031f 	and.w	r3, r3, #31
200028de:	2204      	movs	r2, #4
200028e0:	fa02 f303 	lsl.w	r3, r2, r3
200028e4:	617b      	str	r3, [r7, #20]
  }

  /* Get tick */
  tickstart = HAL_GetTick();
200028e6:	f7fe ffd9 	bl	2000189c <HAL_GetTick>
200028ea:	6138      	str	r0, [r7, #16]

  while (0U == (hdma->DmaBaseAddress->ISR & temp))
200028ec:	e03f      	b.n	2000296e <HAL_DMA_PollForTransfer+0xf6>
  {
    if ((0U != (hdma->DmaBaseAddress->ISR & ((uint32_t)DMA_FLAG_TE1 << (hdma->ChannelIndex & 0x1FU)))))
200028ee:	68fb      	ldr	r3, [r7, #12]
200028f0:	6c1b      	ldr	r3, [r3, #64]	; 0x40
200028f2:	681a      	ldr	r2, [r3, #0]
200028f4:	68fb      	ldr	r3, [r7, #12]
200028f6:	6c5b      	ldr	r3, [r3, #68]	; 0x44
200028f8:	f003 031f 	and.w	r3, r3, #31
200028fc:	2108      	movs	r1, #8
200028fe:	fa01 f303 	lsl.w	r3, r1, r3
20002902:	4013      	ands	r3, r2
20002904:	2b00      	cmp	r3, #0
20002906:	d016      	beq.n	20002936 <HAL_DMA_PollForTransfer+0xbe>
    {
      /* When a DMA transfer error occurs */
      /* A hardware clear of its EN bits is performed */
      /* Clear all flags */
      hdma->DmaBaseAddress->IFCR = ((uint32_t)DMA_ISR_GIF1 << (hdma->ChannelIndex & 0x1FU));
20002908:	68fb      	ldr	r3, [r7, #12]
2000290a:	6c5b      	ldr	r3, [r3, #68]	; 0x44
2000290c:	f003 021f 	and.w	r2, r3, #31
20002910:	68fb      	ldr	r3, [r7, #12]
20002912:	6c1b      	ldr	r3, [r3, #64]	; 0x40
20002914:	2101      	movs	r1, #1
20002916:	fa01 f202 	lsl.w	r2, r1, r2
2000291a:	605a      	str	r2, [r3, #4]

      /* Update error code */
      hdma->ErrorCode = HAL_DMA_ERROR_TE;
2000291c:	68fb      	ldr	r3, [r7, #12]
2000291e:	2201      	movs	r2, #1
20002920:	63da      	str	r2, [r3, #60]	; 0x3c

      /* Change the DMA state */
      hdma->State = HAL_DMA_STATE_READY;
20002922:	68fb      	ldr	r3, [r7, #12]
20002924:	2201      	movs	r2, #1
20002926:	f883 2025 	strb.w	r2, [r3, #37]	; 0x25

      /* Process Unlocked */
      __HAL_UNLOCK(hdma);
2000292a:	68fb      	ldr	r3, [r7, #12]
2000292c:	2200      	movs	r2, #0
2000292e:	f883 2024 	strb.w	r2, [r3, #36]	; 0x24

      return HAL_ERROR;
20002932:	2301      	movs	r3, #1
20002934:	e075      	b.n	20002a22 <HAL_DMA_PollForTransfer+0x1aa>
    }
    /* Check for the Timeout */
    if (Timeout != HAL_MAX_DELAY)
20002936:	687b      	ldr	r3, [r7, #4]
20002938:	f1b3 3fff 	cmp.w	r3, #4294967295
2000293c:	d017      	beq.n	2000296e <HAL_DMA_PollForTransfer+0xf6>
    {
      if (((HAL_GetTick() - tickstart) > Timeout) || (Timeout == 0U))
2000293e:	f7fe ffad 	bl	2000189c <HAL_GetTick>
20002942:	4602      	mov	r2, r0
20002944:	693b      	ldr	r3, [r7, #16]
20002946:	1ad3      	subs	r3, r2, r3
20002948:	687a      	ldr	r2, [r7, #4]
2000294a:	429a      	cmp	r2, r3
2000294c:	d302      	bcc.n	20002954 <HAL_DMA_PollForTransfer+0xdc>
2000294e:	687b      	ldr	r3, [r7, #4]
20002950:	2b00      	cmp	r3, #0
20002952:	d10c      	bne.n	2000296e <HAL_DMA_PollForTransfer+0xf6>
      {
        /* Update error code */
        hdma->ErrorCode = HAL_DMA_ERROR_TIMEOUT;
20002954:	68fb      	ldr	r3, [r7, #12]
20002956:	2220      	movs	r2, #32
20002958:	63da      	str	r2, [r3, #60]	; 0x3c

        /* Change the DMA state */
        hdma->State = HAL_DMA_STATE_READY;
2000295a:	68fb      	ldr	r3, [r7, #12]
2000295c:	2201      	movs	r2, #1
2000295e:	f883 2025 	strb.w	r2, [r3, #37]	; 0x25

        /* Process Unlocked */
        __HAL_UNLOCK(hdma);
20002962:	68fb      	ldr	r3, [r7, #12]
20002964:	2200      	movs	r2, #0
20002966:	f883 2024 	strb.w	r2, [r3, #36]	; 0x24

        return HAL_ERROR;
2000296a:	2301      	movs	r3, #1
2000296c:	e059      	b.n	20002a22 <HAL_DMA_PollForTransfer+0x1aa>
  while (0U == (hdma->DmaBaseAddress->ISR & temp))
2000296e:	68fb      	ldr	r3, [r7, #12]
20002970:	6c1b      	ldr	r3, [r3, #64]	; 0x40
20002972:	681a      	ldr	r2, [r3, #0]
20002974:	697b      	ldr	r3, [r7, #20]
20002976:	4013      	ands	r3, r2
20002978:	2b00      	cmp	r3, #0
2000297a:	d0b8      	beq.n	200028ee <HAL_DMA_PollForTransfer+0x76>
      }
    }
  }

  /*Check for DMAMUX Request generator (if used) overrun status */
  if (hdma->DMAmuxRequestGen != 0U)
2000297c:	68fb      	ldr	r3, [r7, #12]
2000297e:	6d5b      	ldr	r3, [r3, #84]	; 0x54
20002980:	2b00      	cmp	r3, #0
20002982:	d01a      	beq.n	200029ba <HAL_DMA_PollForTransfer+0x142>
  {
    /* if using DMAMUX request generator Check for DMAMUX request generator overrun */
    if ((hdma->DMAmuxRequestGenStatus->RGSR & hdma->DMAmuxRequestGenStatusMask) != 0U)
20002984:	68fb      	ldr	r3, [r7, #12]
20002986:	6d9b      	ldr	r3, [r3, #88]	; 0x58
20002988:	681a      	ldr	r2, [r3, #0]
2000298a:	68fb      	ldr	r3, [r7, #12]
2000298c:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
2000298e:	4013      	ands	r3, r2
20002990:	2b00      	cmp	r3, #0
20002992:	d012      	beq.n	200029ba <HAL_DMA_PollForTransfer+0x142>
    {
      /* Disable the request gen overrun interrupt */
      hdma->DMAmuxRequestGen->RGCR |= DMAMUX_RGxCR_OIE;
20002994:	68fb      	ldr	r3, [r7, #12]
20002996:	6d5b      	ldr	r3, [r3, #84]	; 0x54
20002998:	681a      	ldr	r2, [r3, #0]
2000299a:	68fb      	ldr	r3, [r7, #12]
2000299c:	6d5b      	ldr	r3, [r3, #84]	; 0x54
2000299e:	f442 7280 	orr.w	r2, r2, #256	; 0x100
200029a2:	601a      	str	r2, [r3, #0]

      /* Clear the DMAMUX request generator overrun flag */
      hdma->DMAmuxRequestGenStatus->RGCFR = hdma->DMAmuxRequestGenStatusMask;
200029a4:	68fb      	ldr	r3, [r7, #12]
200029a6:	6d9b      	ldr	r3, [r3, #88]	; 0x58
200029a8:	68fa      	ldr	r2, [r7, #12]
200029aa:	6dd2      	ldr	r2, [r2, #92]	; 0x5c
200029ac:	605a      	str	r2, [r3, #4]

      /* Update error code */
      hdma->ErrorCode |= HAL_DMA_ERROR_REQGEN;
200029ae:	68fb      	ldr	r3, [r7, #12]
200029b0:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
200029b2:	f443 6280 	orr.w	r2, r3, #1024	; 0x400
200029b6:	68fb      	ldr	r3, [r7, #12]
200029b8:	63da      	str	r2, [r3, #60]	; 0x3c
    }
  }

  /* Check for DMAMUX Synchronization overrun */
  if ((hdma->DMAmuxChannelStatus->CSR & hdma->DMAmuxChannelStatusMask) != 0U)
200029ba:	68fb      	ldr	r3, [r7, #12]
200029bc:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
200029be:	681a      	ldr	r2, [r3, #0]
200029c0:	68fb      	ldr	r3, [r7, #12]
200029c2:	6d1b      	ldr	r3, [r3, #80]	; 0x50
200029c4:	4013      	ands	r3, r2
200029c6:	2b00      	cmp	r3, #0
200029c8:	d00a      	beq.n	200029e0 <HAL_DMA_PollForTransfer+0x168>
  {
    /* Clear the DMAMUX synchro overrun flag */
    hdma->DMAmuxChannelStatus->CFR = hdma->DMAmuxChannelStatusMask;
200029ca:	68fb      	ldr	r3, [r7, #12]
200029cc:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
200029ce:	68fa      	ldr	r2, [r7, #12]
200029d0:	6d12      	ldr	r2, [r2, #80]	; 0x50
200029d2:	605a      	str	r2, [r3, #4]

    /* Update error code */
    hdma->ErrorCode |= HAL_DMA_ERROR_SYNC;
200029d4:	68fb      	ldr	r3, [r7, #12]
200029d6:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
200029d8:	f443 7200 	orr.w	r2, r3, #512	; 0x200
200029dc:	68fb      	ldr	r3, [r7, #12]
200029de:	63da      	str	r2, [r3, #60]	; 0x3c
  }

  if (HAL_DMA_FULL_TRANSFER == CompleteLevel)
200029e0:	7afb      	ldrb	r3, [r7, #11]
200029e2:	2b00      	cmp	r3, #0
200029e4:	d10e      	bne.n	20002a04 <HAL_DMA_PollForTransfer+0x18c>
  {
    /* Clear the transfer complete flag */
    hdma->DmaBaseAddress->IFCR = ((uint32_t)DMA_FLAG_TC1 << (hdma->ChannelIndex & 0x1FU));
200029e6:	68fb      	ldr	r3, [r7, #12]
200029e8:	6c5b      	ldr	r3, [r3, #68]	; 0x44
200029ea:	f003 021f 	and.w	r2, r3, #31
200029ee:	68fb      	ldr	r3, [r7, #12]
200029f0:	6c1b      	ldr	r3, [r3, #64]	; 0x40
200029f2:	2102      	movs	r1, #2
200029f4:	fa01 f202 	lsl.w	r2, r1, r2
200029f8:	605a      	str	r2, [r3, #4]

    /* The selected Channelx EN bit is cleared (DMA is disabled and
    all transfers are complete) */
    hdma->State = HAL_DMA_STATE_READY;
200029fa:	68fb      	ldr	r3, [r7, #12]
200029fc:	2201      	movs	r2, #1
200029fe:	f883 2025 	strb.w	r2, [r3, #37]	; 0x25
20002a02:	e009      	b.n	20002a18 <HAL_DMA_PollForTransfer+0x1a0>
  }
  else
  {
    /* Clear the half transfer complete flag */
    hdma->DmaBaseAddress->IFCR = ((uint32_t)DMA_FLAG_HT1 << (hdma->ChannelIndex & 0x1FU));
20002a04:	68fb      	ldr	r3, [r7, #12]
20002a06:	6c5b      	ldr	r3, [r3, #68]	; 0x44
20002a08:	f003 021f 	and.w	r2, r3, #31
20002a0c:	68fb      	ldr	r3, [r7, #12]
20002a0e:	6c1b      	ldr	r3, [r3, #64]	; 0x40
20002a10:	2104      	movs	r1, #4
20002a12:	fa01 f202 	lsl.w	r2, r1, r2
20002a16:	605a      	str	r2, [r3, #4]
  }

  /* Process unlocked */
  __HAL_UNLOCK(hdma);
20002a18:	68fb      	ldr	r3, [r7, #12]
20002a1a:	2200      	movs	r2, #0
20002a1c:	f883 2024 	strb.w	r2, [r3, #36]	; 0x24

  return HAL_OK;
20002a20:	2300      	movs	r3, #0
}
20002a22:	4618      	mov	r0, r3
20002a24:	3718      	adds	r7, #24
20002a26:	46bd      	mov	sp, r7
20002a28:	bd80      	pop	{r7, pc}

20002a2a <HAL_DMA_IRQHandler>:
  * @param  hdma pointer to a DMA_HandleTypeDef structure that contains
  *               the configuration information for the specified DMA Channel.
  * @retval None
  */
void HAL_DMA_IRQHandler(DMA_HandleTypeDef *hdma)
{
20002a2a:	b580      	push	{r7, lr}
20002a2c:	b084      	sub	sp, #16
20002a2e:	af00      	add	r7, sp, #0
20002a30:	6078      	str	r0, [r7, #4]
  uint32_t flag_it = hdma->DmaBaseAddress->ISR;
20002a32:	687b      	ldr	r3, [r7, #4]
20002a34:	6c1b      	ldr	r3, [r3, #64]	; 0x40
20002a36:	681b      	ldr	r3, [r3, #0]
20002a38:	60fb      	str	r3, [r7, #12]
  uint32_t source_it = hdma->Instance->CCR;
20002a3a:	687b      	ldr	r3, [r7, #4]
20002a3c:	681b      	ldr	r3, [r3, #0]
20002a3e:	681b      	ldr	r3, [r3, #0]
20002a40:	60bb      	str	r3, [r7, #8]

  /* Half Transfer Complete Interrupt management ******************************/
  if ((0U != (flag_it & ((uint32_t)DMA_FLAG_HT1 << (hdma->ChannelIndex & 0x1FU)))) && (0U != (source_it & DMA_IT_HT)))
20002a42:	687b      	ldr	r3, [r7, #4]
20002a44:	6c5b      	ldr	r3, [r3, #68]	; 0x44
20002a46:	f003 031f 	and.w	r3, r3, #31
20002a4a:	2204      	movs	r2, #4
20002a4c:	409a      	lsls	r2, r3
20002a4e:	68fb      	ldr	r3, [r7, #12]
20002a50:	4013      	ands	r3, r2
20002a52:	2b00      	cmp	r3, #0
20002a54:	d026      	beq.n	20002aa4 <HAL_DMA_IRQHandler+0x7a>
20002a56:	68bb      	ldr	r3, [r7, #8]
20002a58:	f003 0304 	and.w	r3, r3, #4
20002a5c:	2b00      	cmp	r3, #0
20002a5e:	d021      	beq.n	20002aa4 <HAL_DMA_IRQHandler+0x7a>
  {
    /* Disable the half transfer interrupt if the DMA mode is not CIRCULAR */
    if ((hdma->Instance->CCR & DMA_CCR_CIRC) == 0U)
20002a60:	687b      	ldr	r3, [r7, #4]
20002a62:	681b      	ldr	r3, [r3, #0]
20002a64:	681b      	ldr	r3, [r3, #0]
20002a66:	f003 0320 	and.w	r3, r3, #32
20002a6a:	2b00      	cmp	r3, #0
20002a6c:	d107      	bne.n	20002a7e <HAL_DMA_IRQHandler+0x54>
    {
      /* Disable the half transfer interrupt */
      __HAL_DMA_DISABLE_IT(hdma, DMA_IT_HT);
20002a6e:	687b      	ldr	r3, [r7, #4]
20002a70:	681b      	ldr	r3, [r3, #0]
20002a72:	681a      	ldr	r2, [r3, #0]
20002a74:	687b      	ldr	r3, [r7, #4]
20002a76:	681b      	ldr	r3, [r3, #0]
20002a78:	f022 0204 	bic.w	r2, r2, #4
20002a7c:	601a      	str	r2, [r3, #0]
    }
    /* Clear the half transfer complete flag */
    hdma->DmaBaseAddress->IFCR = ((uint32_t)DMA_ISR_HTIF1 << (hdma->ChannelIndex & 0x1FU));
20002a7e:	687b      	ldr	r3, [r7, #4]
20002a80:	6c5b      	ldr	r3, [r3, #68]	; 0x44
20002a82:	f003 021f 	and.w	r2, r3, #31
20002a86:	687b      	ldr	r3, [r7, #4]
20002a88:	6c1b      	ldr	r3, [r3, #64]	; 0x40
20002a8a:	2104      	movs	r1, #4
20002a8c:	fa01 f202 	lsl.w	r2, r1, r2
20002a90:	605a      	str	r2, [r3, #4]

    /* DMA peripheral state is not updated in Half Transfer */
    /* but in Transfer Complete case */

    if (hdma->XferHalfCpltCallback != NULL)
20002a92:	687b      	ldr	r3, [r7, #4]
20002a94:	6b1b      	ldr	r3, [r3, #48]	; 0x30
20002a96:	2b00      	cmp	r3, #0
20002a98:	d071      	beq.n	20002b7e <HAL_DMA_IRQHandler+0x154>
    {
      /* Half transfer callback */
      hdma->XferHalfCpltCallback(hdma);
20002a9a:	687b      	ldr	r3, [r7, #4]
20002a9c:	6b1b      	ldr	r3, [r3, #48]	; 0x30
20002a9e:	6878      	ldr	r0, [r7, #4]
20002aa0:	4798      	blx	r3
    if (hdma->XferHalfCpltCallback != NULL)
20002aa2:	e06c      	b.n	20002b7e <HAL_DMA_IRQHandler+0x154>
    }
  }
  /* Transfer Complete Interrupt management ***********************************/
  else if ((0U != (flag_it & ((uint32_t)DMA_FLAG_TC1 << (hdma->ChannelIndex & 0x1FU))))
20002aa4:	687b      	ldr	r3, [r7, #4]
20002aa6:	6c5b      	ldr	r3, [r3, #68]	; 0x44
20002aa8:	f003 031f 	and.w	r3, r3, #31
20002aac:	2202      	movs	r2, #2
20002aae:	409a      	lsls	r2, r3
20002ab0:	68fb      	ldr	r3, [r7, #12]
20002ab2:	4013      	ands	r3, r2
20002ab4:	2b00      	cmp	r3, #0
20002ab6:	d02e      	beq.n	20002b16 <HAL_DMA_IRQHandler+0xec>
           && (0U != (source_it & DMA_IT_TC)))
20002ab8:	68bb      	ldr	r3, [r7, #8]
20002aba:	f003 0302 	and.w	r3, r3, #2
20002abe:	2b00      	cmp	r3, #0
20002ac0:	d029      	beq.n	20002b16 <HAL_DMA_IRQHandler+0xec>
  {
    if ((hdma->Instance->CCR & DMA_CCR_CIRC) == 0U)
20002ac2:	687b      	ldr	r3, [r7, #4]
20002ac4:	681b      	ldr	r3, [r3, #0]
20002ac6:	681b      	ldr	r3, [r3, #0]
20002ac8:	f003 0320 	and.w	r3, r3, #32
20002acc:	2b00      	cmp	r3, #0
20002ace:	d10b      	bne.n	20002ae8 <HAL_DMA_IRQHandler+0xbe>
    {
      /* Disable the transfer complete and error interrupt */
      __HAL_DMA_DISABLE_IT(hdma, DMA_IT_TE | DMA_IT_TC);
20002ad0:	687b      	ldr	r3, [r7, #4]
20002ad2:	681b      	ldr	r3, [r3, #0]
20002ad4:	681a      	ldr	r2, [r3, #0]
20002ad6:	687b      	ldr	r3, [r7, #4]
20002ad8:	681b      	ldr	r3, [r3, #0]
20002ada:	f022 020a 	bic.w	r2, r2, #10
20002ade:	601a      	str	r2, [r3, #0]

      /* Change the DMA state */
      hdma->State = HAL_DMA_STATE_READY;
20002ae0:	687b      	ldr	r3, [r7, #4]
20002ae2:	2201      	movs	r2, #1
20002ae4:	f883 2025 	strb.w	r2, [r3, #37]	; 0x25
    }
    /* Clear the transfer complete flag */
    hdma->DmaBaseAddress->IFCR = ((uint32_t)DMA_ISR_TCIF1 << (hdma->ChannelIndex & 0x1FU));
20002ae8:	687b      	ldr	r3, [r7, #4]
20002aea:	6c5b      	ldr	r3, [r3, #68]	; 0x44
20002aec:	f003 021f 	and.w	r2, r3, #31
20002af0:	687b      	ldr	r3, [r7, #4]
20002af2:	6c1b      	ldr	r3, [r3, #64]	; 0x40
20002af4:	2102      	movs	r1, #2
20002af6:	fa01 f202 	lsl.w	r2, r1, r2
20002afa:	605a      	str	r2, [r3, #4]

    /* Process Unlocked */
    __HAL_UNLOCK(hdma);
20002afc:	687b      	ldr	r3, [r7, #4]
20002afe:	2200      	movs	r2, #0
20002b00:	f883 2024 	strb.w	r2, [r3, #36]	; 0x24

    if (hdma->XferCpltCallback != NULL)
20002b04:	687b      	ldr	r3, [r7, #4]
20002b06:	6adb      	ldr	r3, [r3, #44]	; 0x2c
20002b08:	2b00      	cmp	r3, #0
20002b0a:	d038      	beq.n	20002b7e <HAL_DMA_IRQHandler+0x154>
    {
      /* Transfer complete callback */
      hdma->XferCpltCallback(hdma);
20002b0c:	687b      	ldr	r3, [r7, #4]
20002b0e:	6adb      	ldr	r3, [r3, #44]	; 0x2c
20002b10:	6878      	ldr	r0, [r7, #4]
20002b12:	4798      	blx	r3
    if (hdma->XferCpltCallback != NULL)
20002b14:	e033      	b.n	20002b7e <HAL_DMA_IRQHandler+0x154>
    }
  }
  /* Transfer Error Interrupt management **************************************/
  else if ((0U != (flag_it & ((uint32_t)DMA_FLAG_TE1 << (hdma->ChannelIndex & 0x1FU))))
20002b16:	687b      	ldr	r3, [r7, #4]
20002b18:	6c5b      	ldr	r3, [r3, #68]	; 0x44
20002b1a:	f003 031f 	and.w	r3, r3, #31
20002b1e:	2208      	movs	r2, #8
20002b20:	409a      	lsls	r2, r3
20002b22:	68fb      	ldr	r3, [r7, #12]
20002b24:	4013      	ands	r3, r2
20002b26:	2b00      	cmp	r3, #0
20002b28:	d02a      	beq.n	20002b80 <HAL_DMA_IRQHandler+0x156>
           && (0U != (source_it & DMA_IT_TE)))
20002b2a:	68bb      	ldr	r3, [r7, #8]
20002b2c:	f003 0308 	and.w	r3, r3, #8
20002b30:	2b00      	cmp	r3, #0
20002b32:	d025      	beq.n	20002b80 <HAL_DMA_IRQHandler+0x156>
  {
    /* When a DMA transfer error occurs */
    /* A hardware clear of its EN bits is performed */
    /* Disable ALL DMA IT */
    __HAL_DMA_DISABLE_IT(hdma, (DMA_IT_TC | DMA_IT_HT | DMA_IT_TE));
20002b34:	687b      	ldr	r3, [r7, #4]
20002b36:	681b      	ldr	r3, [r3, #0]
20002b38:	681a      	ldr	r2, [r3, #0]
20002b3a:	687b      	ldr	r3, [r7, #4]
20002b3c:	681b      	ldr	r3, [r3, #0]
20002b3e:	f022 020e 	bic.w	r2, r2, #14
20002b42:	601a      	str	r2, [r3, #0]

    /* Clear all flags */
    hdma->DmaBaseAddress->IFCR = ((uint32_t)DMA_ISR_GIF1 << (hdma->ChannelIndex & 0x1FU));
20002b44:	687b      	ldr	r3, [r7, #4]
20002b46:	6c5b      	ldr	r3, [r3, #68]	; 0x44
20002b48:	f003 021f 	and.w	r2, r3, #31
20002b4c:	687b      	ldr	r3, [r7, #4]
20002b4e:	6c1b      	ldr	r3, [r3, #64]	; 0x40
20002b50:	2101      	movs	r1, #1
20002b52:	fa01 f202 	lsl.w	r2, r1, r2
20002b56:	605a      	str	r2, [r3, #4]

    /* Update error code */
    hdma->ErrorCode = HAL_DMA_ERROR_TE;
20002b58:	687b      	ldr	r3, [r7, #4]
20002b5a:	2201      	movs	r2, #1
20002b5c:	63da      	str	r2, [r3, #60]	; 0x3c

    /* Change the DMA state */
    hdma->State = HAL_DMA_STATE_READY;
20002b5e:	687b      	ldr	r3, [r7, #4]
20002b60:	2201      	movs	r2, #1
20002b62:	f883 2025 	strb.w	r2, [r3, #37]	; 0x25

    /* Process Unlocked */
    __HAL_UNLOCK(hdma);
20002b66:	687b      	ldr	r3, [r7, #4]
20002b68:	2200      	movs	r2, #0
20002b6a:	f883 2024 	strb.w	r2, [r3, #36]	; 0x24

    if (hdma->XferErrorCallback != NULL)
20002b6e:	687b      	ldr	r3, [r7, #4]
20002b70:	6b5b      	ldr	r3, [r3, #52]	; 0x34
20002b72:	2b00      	cmp	r3, #0
20002b74:	d004      	beq.n	20002b80 <HAL_DMA_IRQHandler+0x156>
    {
      /* Transfer error callback */
      hdma->XferErrorCallback(hdma);
20002b76:	687b      	ldr	r3, [r7, #4]
20002b78:	6b5b      	ldr	r3, [r3, #52]	; 0x34
20002b7a:	6878      	ldr	r0, [r7, #4]
20002b7c:	4798      	blx	r3
  }
  else
  {
    /* Nothing To Do */
  }
  return;
20002b7e:	bf00      	nop
20002b80:	bf00      	nop
}
20002b82:	3710      	adds	r7, #16
20002b84:	46bd      	mov	sp, r7
20002b86:	bd80      	pop	{r7, pc}

20002b88 <HAL_DMA_RegisterCallback>:
  * @param  pCallback            pointer to private callbacsk function which has pointer to
  *                               a DMA_HandleTypeDef structure as parameter.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMA_RegisterCallback(DMA_HandleTypeDef *hdma, HAL_DMA_CallbackIDTypeDef CallbackID, void (* pCallback)(DMA_HandleTypeDef *_hdma))
{
20002b88:	b480      	push	{r7}
20002b8a:	b087      	sub	sp, #28
20002b8c:	af00      	add	r7, sp, #0
20002b8e:	60f8      	str	r0, [r7, #12]
20002b90:	460b      	mov	r3, r1
20002b92:	607a      	str	r2, [r7, #4]
20002b94:	72fb      	strb	r3, [r7, #11]
  HAL_StatusTypeDef status = HAL_OK;
20002b96:	2300      	movs	r3, #0
20002b98:	75fb      	strb	r3, [r7, #23]

  /* Process locked */
  __HAL_LOCK(hdma);
20002b9a:	68fb      	ldr	r3, [r7, #12]
20002b9c:	f893 3024 	ldrb.w	r3, [r3, #36]	; 0x24
20002ba0:	2b01      	cmp	r3, #1
20002ba2:	d101      	bne.n	20002ba8 <HAL_DMA_RegisterCallback+0x20>
20002ba4:	2302      	movs	r3, #2
20002ba6:	e031      	b.n	20002c0c <HAL_DMA_RegisterCallback+0x84>
20002ba8:	68fb      	ldr	r3, [r7, #12]
20002baa:	2201      	movs	r2, #1
20002bac:	f883 2024 	strb.w	r2, [r3, #36]	; 0x24

  if (HAL_DMA_STATE_READY == hdma->State)
20002bb0:	68fb      	ldr	r3, [r7, #12]
20002bb2:	f893 3025 	ldrb.w	r3, [r3, #37]	; 0x25
20002bb6:	b2db      	uxtb	r3, r3
20002bb8:	2b01      	cmp	r3, #1
20002bba:	d120      	bne.n	20002bfe <HAL_DMA_RegisterCallback+0x76>
  {
    switch (CallbackID)
20002bbc:	7afb      	ldrb	r3, [r7, #11]
20002bbe:	2b03      	cmp	r3, #3
20002bc0:	d81a      	bhi.n	20002bf8 <HAL_DMA_RegisterCallback+0x70>
20002bc2:	a201      	add	r2, pc, #4	; (adr r2, 20002bc8 <HAL_DMA_RegisterCallback+0x40>)
20002bc4:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
20002bc8:	20002bd9 	.word	0x20002bd9
20002bcc:	20002be1 	.word	0x20002be1
20002bd0:	20002be9 	.word	0x20002be9
20002bd4:	20002bf1 	.word	0x20002bf1
    {
      case  HAL_DMA_XFER_CPLT_CB_ID:
        hdma->XferCpltCallback = pCallback;
20002bd8:	68fb      	ldr	r3, [r7, #12]
20002bda:	687a      	ldr	r2, [r7, #4]
20002bdc:	62da      	str	r2, [r3, #44]	; 0x2c
        break;
20002bde:	e010      	b.n	20002c02 <HAL_DMA_RegisterCallback+0x7a>

      case  HAL_DMA_XFER_HALFCPLT_CB_ID:
        hdma->XferHalfCpltCallback = pCallback;
20002be0:	68fb      	ldr	r3, [r7, #12]
20002be2:	687a      	ldr	r2, [r7, #4]
20002be4:	631a      	str	r2, [r3, #48]	; 0x30
        break;
20002be6:	e00c      	b.n	20002c02 <HAL_DMA_RegisterCallback+0x7a>

      case  HAL_DMA_XFER_ERROR_CB_ID:
        hdma->XferErrorCallback = pCallback;
20002be8:	68fb      	ldr	r3, [r7, #12]
20002bea:	687a      	ldr	r2, [r7, #4]
20002bec:	635a      	str	r2, [r3, #52]	; 0x34
        break;
20002bee:	e008      	b.n	20002c02 <HAL_DMA_RegisterCallback+0x7a>

      case  HAL_DMA_XFER_ABORT_CB_ID:
        hdma->XferAbortCallback = pCallback;
20002bf0:	68fb      	ldr	r3, [r7, #12]
20002bf2:	687a      	ldr	r2, [r7, #4]
20002bf4:	639a      	str	r2, [r3, #56]	; 0x38
        break;
20002bf6:	e004      	b.n	20002c02 <HAL_DMA_RegisterCallback+0x7a>

      default:
        status = HAL_ERROR;
20002bf8:	2301      	movs	r3, #1
20002bfa:	75fb      	strb	r3, [r7, #23]
        break;
20002bfc:	e001      	b.n	20002c02 <HAL_DMA_RegisterCallback+0x7a>
    }
  }
  else
  {
    status = HAL_ERROR;
20002bfe:	2301      	movs	r3, #1
20002c00:	75fb      	strb	r3, [r7, #23]
  }

  /* Release Lock */
  __HAL_UNLOCK(hdma);
20002c02:	68fb      	ldr	r3, [r7, #12]
20002c04:	2200      	movs	r2, #0
20002c06:	f883 2024 	strb.w	r2, [r3, #36]	; 0x24

  return status;
20002c0a:	7dfb      	ldrb	r3, [r7, #23]
}
20002c0c:	4618      	mov	r0, r3
20002c0e:	371c      	adds	r7, #28
20002c10:	46bd      	mov	sp, r7
20002c12:	f85d 7b04 	ldr.w	r7, [sp], #4
20002c16:	4770      	bx	lr

20002c18 <HAL_DMA_UnRegisterCallback>:
  * @param  CallbackID           User Callback identifier
  *                               a HAL_DMA_CallbackIDTypeDef ENUM as parameter.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMA_UnRegisterCallback(DMA_HandleTypeDef *hdma, HAL_DMA_CallbackIDTypeDef CallbackID)
{
20002c18:	b480      	push	{r7}
20002c1a:	b085      	sub	sp, #20
20002c1c:	af00      	add	r7, sp, #0
20002c1e:	6078      	str	r0, [r7, #4]
20002c20:	460b      	mov	r3, r1
20002c22:	70fb      	strb	r3, [r7, #3]
  HAL_StatusTypeDef status = HAL_OK;
20002c24:	2300      	movs	r3, #0
20002c26:	73fb      	strb	r3, [r7, #15]

  /* Process locked */
  __HAL_LOCK(hdma);
20002c28:	687b      	ldr	r3, [r7, #4]
20002c2a:	f893 3024 	ldrb.w	r3, [r3, #36]	; 0x24
20002c2e:	2b01      	cmp	r3, #1
20002c30:	d101      	bne.n	20002c36 <HAL_DMA_UnRegisterCallback+0x1e>
20002c32:	2302      	movs	r3, #2
20002c34:	e041      	b.n	20002cba <HAL_DMA_UnRegisterCallback+0xa2>
20002c36:	687b      	ldr	r3, [r7, #4]
20002c38:	2201      	movs	r2, #1
20002c3a:	f883 2024 	strb.w	r2, [r3, #36]	; 0x24

  if (HAL_DMA_STATE_READY == hdma->State)
20002c3e:	687b      	ldr	r3, [r7, #4]
20002c40:	f893 3025 	ldrb.w	r3, [r3, #37]	; 0x25
20002c44:	b2db      	uxtb	r3, r3
20002c46:	2b01      	cmp	r3, #1
20002c48:	d130      	bne.n	20002cac <HAL_DMA_UnRegisterCallback+0x94>
  {
    switch (CallbackID)
20002c4a:	78fb      	ldrb	r3, [r7, #3]
20002c4c:	2b04      	cmp	r3, #4
20002c4e:	d82a      	bhi.n	20002ca6 <HAL_DMA_UnRegisterCallback+0x8e>
20002c50:	a201      	add	r2, pc, #4	; (adr r2, 20002c58 <HAL_DMA_UnRegisterCallback+0x40>)
20002c52:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
20002c56:	bf00      	nop
20002c58:	20002c6d 	.word	0x20002c6d
20002c5c:	20002c75 	.word	0x20002c75
20002c60:	20002c7d 	.word	0x20002c7d
20002c64:	20002c85 	.word	0x20002c85
20002c68:	20002c8d 	.word	0x20002c8d
    {
      case  HAL_DMA_XFER_CPLT_CB_ID:
        hdma->XferCpltCallback = NULL;
20002c6c:	687b      	ldr	r3, [r7, #4]
20002c6e:	2200      	movs	r2, #0
20002c70:	62da      	str	r2, [r3, #44]	; 0x2c
        break;
20002c72:	e01d      	b.n	20002cb0 <HAL_DMA_UnRegisterCallback+0x98>

      case  HAL_DMA_XFER_HALFCPLT_CB_ID:
        hdma->XferHalfCpltCallback = NULL;
20002c74:	687b      	ldr	r3, [r7, #4]
20002c76:	2200      	movs	r2, #0
20002c78:	631a      	str	r2, [r3, #48]	; 0x30
        break;
20002c7a:	e019      	b.n	20002cb0 <HAL_DMA_UnRegisterCallback+0x98>

      case  HAL_DMA_XFER_ERROR_CB_ID:
        hdma->XferErrorCallback = NULL;
20002c7c:	687b      	ldr	r3, [r7, #4]
20002c7e:	2200      	movs	r2, #0
20002c80:	635a      	str	r2, [r3, #52]	; 0x34
        break;
20002c82:	e015      	b.n	20002cb0 <HAL_DMA_UnRegisterCallback+0x98>

      case  HAL_DMA_XFER_ABORT_CB_ID:
        hdma->XferAbortCallback = NULL;
20002c84:	687b      	ldr	r3, [r7, #4]
20002c86:	2200      	movs	r2, #0
20002c88:	639a      	str	r2, [r3, #56]	; 0x38
        break;
20002c8a:	e011      	b.n	20002cb0 <HAL_DMA_UnRegisterCallback+0x98>

      case   HAL_DMA_XFER_ALL_CB_ID:
        hdma->XferCpltCallback = NULL;
20002c8c:	687b      	ldr	r3, [r7, #4]
20002c8e:	2200      	movs	r2, #0
20002c90:	62da      	str	r2, [r3, #44]	; 0x2c
        hdma->XferHalfCpltCallback = NULL;
20002c92:	687b      	ldr	r3, [r7, #4]
20002c94:	2200      	movs	r2, #0
20002c96:	631a      	str	r2, [r3, #48]	; 0x30
        hdma->XferErrorCallback = NULL;
20002c98:	687b      	ldr	r3, [r7, #4]
20002c9a:	2200      	movs	r2, #0
20002c9c:	635a      	str	r2, [r3, #52]	; 0x34
        hdma->XferAbortCallback = NULL;
20002c9e:	687b      	ldr	r3, [r7, #4]
20002ca0:	2200      	movs	r2, #0
20002ca2:	639a      	str	r2, [r3, #56]	; 0x38
        break;
20002ca4:	e004      	b.n	20002cb0 <HAL_DMA_UnRegisterCallback+0x98>

      default:
        status = HAL_ERROR;
20002ca6:	2301      	movs	r3, #1
20002ca8:	73fb      	strb	r3, [r7, #15]
        break;
20002caa:	e001      	b.n	20002cb0 <HAL_DMA_UnRegisterCallback+0x98>
    }
  }
  else
  {
    status = HAL_ERROR;
20002cac:	2301      	movs	r3, #1
20002cae:	73fb      	strb	r3, [r7, #15]
  }

  /* Release Lock */
  __HAL_UNLOCK(hdma);
20002cb0:	687b      	ldr	r3, [r7, #4]
20002cb2:	2200      	movs	r2, #0
20002cb4:	f883 2024 	strb.w	r2, [r3, #36]	; 0x24

  return status;
20002cb8:	7bfb      	ldrb	r3, [r7, #15]
}
20002cba:	4618      	mov	r0, r3
20002cbc:	3714      	adds	r7, #20
20002cbe:	46bd      	mov	sp, r7
20002cc0:	f85d 7b04 	ldr.w	r7, [sp], #4
20002cc4:	4770      	bx	lr
20002cc6:	bf00      	nop

20002cc8 <HAL_DMA_GetState>:
  * @param  hdma pointer to a DMA_HandleTypeDef structure that contains
  *               the configuration information for the specified DMA Channel.
  * @retval HAL state
  */
HAL_DMA_StateTypeDef HAL_DMA_GetState(DMA_HandleTypeDef *hdma)
{
20002cc8:	b480      	push	{r7}
20002cca:	b083      	sub	sp, #12
20002ccc:	af00      	add	r7, sp, #0
20002cce:	6078      	str	r0, [r7, #4]
  /* Return DMA handle state */
  return hdma->State;
20002cd0:	687b      	ldr	r3, [r7, #4]
20002cd2:	f893 3025 	ldrb.w	r3, [r3, #37]	; 0x25
20002cd6:	b2db      	uxtb	r3, r3
}
20002cd8:	4618      	mov	r0, r3
20002cda:	370c      	adds	r7, #12
20002cdc:	46bd      	mov	sp, r7
20002cde:	f85d 7b04 	ldr.w	r7, [sp], #4
20002ce2:	4770      	bx	lr

20002ce4 <HAL_DMA_GetError>:
  * @param  hdma : pointer to a DMA_HandleTypeDef structure that contains
  *              the configuration information for the specified DMA Channel.
  * @retval DMA Error Code
  */
uint32_t HAL_DMA_GetError(DMA_HandleTypeDef *hdma)
{
20002ce4:	b480      	push	{r7}
20002ce6:	b083      	sub	sp, #12
20002ce8:	af00      	add	r7, sp, #0
20002cea:	6078      	str	r0, [r7, #4]
  return hdma->ErrorCode;
20002cec:	687b      	ldr	r3, [r7, #4]
20002cee:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
}
20002cf0:	4618      	mov	r0, r3
20002cf2:	370c      	adds	r7, #12
20002cf4:	46bd      	mov	sp, r7
20002cf6:	f85d 7b04 	ldr.w	r7, [sp], #4
20002cfa:	4770      	bx	lr

20002cfc <DMA_SetConfig>:
  * @param  DstAddress The destination memory Buffer address
  * @param  DataLength The length of data to be transferred from source to destination
  * @retval HAL status
  */
static void DMA_SetConfig(DMA_HandleTypeDef *hdma, uint32_t SrcAddress, uint32_t DstAddress, uint32_t DataLength)
{
20002cfc:	b480      	push	{r7}
20002cfe:	b085      	sub	sp, #20
20002d00:	af00      	add	r7, sp, #0
20002d02:	60f8      	str	r0, [r7, #12]
20002d04:	60b9      	str	r1, [r7, #8]
20002d06:	607a      	str	r2, [r7, #4]
20002d08:	603b      	str	r3, [r7, #0]
  /* Clear the DMAMUX synchro overrun flag */
  hdma->DMAmuxChannelStatus->CFR = hdma->DMAmuxChannelStatusMask;
20002d0a:	68fb      	ldr	r3, [r7, #12]
20002d0c:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
20002d0e:	68fa      	ldr	r2, [r7, #12]
20002d10:	6d12      	ldr	r2, [r2, #80]	; 0x50
20002d12:	605a      	str	r2, [r3, #4]

  if (hdma->DMAmuxRequestGen != 0U)
20002d14:	68fb      	ldr	r3, [r7, #12]
20002d16:	6d5b      	ldr	r3, [r3, #84]	; 0x54
20002d18:	2b00      	cmp	r3, #0
20002d1a:	d004      	beq.n	20002d26 <DMA_SetConfig+0x2a>
  {
    /* Clear the DMAMUX request generator overrun flag */
    hdma->DMAmuxRequestGenStatus->RGCFR = hdma->DMAmuxRequestGenStatusMask;
20002d1c:	68fb      	ldr	r3, [r7, #12]
20002d1e:	6d9b      	ldr	r3, [r3, #88]	; 0x58
20002d20:	68fa      	ldr	r2, [r7, #12]
20002d22:	6dd2      	ldr	r2, [r2, #92]	; 0x5c
20002d24:	605a      	str	r2, [r3, #4]
  }

  /* Clear all flags */
  hdma->DmaBaseAddress->IFCR = (DMA_ISR_GIF1 << (hdma->ChannelIndex & 0x1FU));
20002d26:	68fb      	ldr	r3, [r7, #12]
20002d28:	6c5b      	ldr	r3, [r3, #68]	; 0x44
20002d2a:	f003 021f 	and.w	r2, r3, #31
20002d2e:	68fb      	ldr	r3, [r7, #12]
20002d30:	6c1b      	ldr	r3, [r3, #64]	; 0x40
20002d32:	2101      	movs	r1, #1
20002d34:	fa01 f202 	lsl.w	r2, r1, r2
20002d38:	605a      	str	r2, [r3, #4]

  /* Configure DMA Channel data length */
  hdma->Instance->CNDTR = DataLength;
20002d3a:	68fb      	ldr	r3, [r7, #12]
20002d3c:	681b      	ldr	r3, [r3, #0]
20002d3e:	683a      	ldr	r2, [r7, #0]
20002d40:	605a      	str	r2, [r3, #4]

  /* Memory to Peripheral */
  if ((hdma->Init.Direction) == DMA_MEMORY_TO_PERIPH)
20002d42:	68fb      	ldr	r3, [r7, #12]
20002d44:	689b      	ldr	r3, [r3, #8]
20002d46:	2b10      	cmp	r3, #16
20002d48:	d108      	bne.n	20002d5c <DMA_SetConfig+0x60>
  {
    /* Configure DMA Channel destination address */
    hdma->Instance->CPAR = DstAddress;
20002d4a:	68fb      	ldr	r3, [r7, #12]
20002d4c:	681b      	ldr	r3, [r3, #0]
20002d4e:	687a      	ldr	r2, [r7, #4]
20002d50:	609a      	str	r2, [r3, #8]

    /* Configure DMA Channel source address */
    hdma->Instance->CMAR = SrcAddress;
20002d52:	68fb      	ldr	r3, [r7, #12]
20002d54:	681b      	ldr	r3, [r3, #0]
20002d56:	68ba      	ldr	r2, [r7, #8]
20002d58:	60da      	str	r2, [r3, #12]
    hdma->Instance->CPAR = SrcAddress;

    /* Configure DMA Channel destination address */
    hdma->Instance->CMAR = DstAddress;
  }
}
20002d5a:	e007      	b.n	20002d6c <DMA_SetConfig+0x70>
    hdma->Instance->CPAR = SrcAddress;
20002d5c:	68fb      	ldr	r3, [r7, #12]
20002d5e:	681b      	ldr	r3, [r3, #0]
20002d60:	68ba      	ldr	r2, [r7, #8]
20002d62:	609a      	str	r2, [r3, #8]
    hdma->Instance->CMAR = DstAddress;
20002d64:	68fb      	ldr	r3, [r7, #12]
20002d66:	681b      	ldr	r3, [r3, #0]
20002d68:	687a      	ldr	r2, [r7, #4]
20002d6a:	60da      	str	r2, [r3, #12]
}
20002d6c:	bf00      	nop
20002d6e:	3714      	adds	r7, #20
20002d70:	46bd      	mov	sp, r7
20002d72:	f85d 7b04 	ldr.w	r7, [sp], #4
20002d76:	4770      	bx	lr

20002d78 <DMA_CalcDMAMUXChannelBaseAndMask>:
  * @param  hdma        pointer to a DMA_HandleTypeDef structure that contains
  *                     the configuration information for the specified DMA Stream.
  * @retval None
  */
static void DMA_CalcDMAMUXChannelBaseAndMask(DMA_HandleTypeDef *hdma)
{
20002d78:	b480      	push	{r7}
20002d7a:	b087      	sub	sp, #28
20002d7c:	af00      	add	r7, sp, #0
20002d7e:	6078      	str	r0, [r7, #4]
  uint32_t dmamux_base_addr;
  uint32_t channel_number;
  DMAMUX_Channel_TypeDef *DMAMUX1_ChannelBase;

  /* check if instance is not outside the DMA channel range */
  if ((uint32_t)hdma->Instance < (uint32_t)DMA2_Channel1)
20002d80:	687b      	ldr	r3, [r7, #4]
20002d82:	681b      	ldr	r3, [r3, #0]
20002d84:	461a      	mov	r2, r3
20002d86:	4b16      	ldr	r3, [pc, #88]	; (20002de0 <DMA_CalcDMAMUXChannelBaseAndMask+0x68>)
20002d88:	429a      	cmp	r2, r3
20002d8a:	d802      	bhi.n	20002d92 <DMA_CalcDMAMUXChannelBaseAndMask+0x1a>
  {
    /* DMA1 */
    DMAMUX1_ChannelBase = DMAMUX1_Channel0;
20002d8c:	4b15      	ldr	r3, [pc, #84]	; (20002de4 <DMA_CalcDMAMUXChannelBaseAndMask+0x6c>)
20002d8e:	617b      	str	r3, [r7, #20]
20002d90:	e001      	b.n	20002d96 <DMA_CalcDMAMUXChannelBaseAndMask+0x1e>
  }
  else
  {
    /* DMA2 */
#if defined (STM32G471xx) || defined (STM32G473xx) || defined (STM32G474xx) || defined (STM32G483xx) || defined (STM32G484xx) || defined (STM32G491xx) || defined (STM32G4A1xx)
    DMAMUX1_ChannelBase = DMAMUX1_Channel8;
20002d92:	4b15      	ldr	r3, [pc, #84]	; (20002de8 <DMA_CalcDMAMUXChannelBaseAndMask+0x70>)
20002d94:	617b      	str	r3, [r7, #20]
    DMAMUX1_ChannelBase = DMAMUX1_Channel6;
#else
    DMAMUX1_ChannelBase = DMAMUX1_Channel7;
#endif /* STM32G4x1xx) */
  }
  dmamux_base_addr = (uint32_t)DMAMUX1_ChannelBase;
20002d96:	697b      	ldr	r3, [r7, #20]
20002d98:	613b      	str	r3, [r7, #16]
  channel_number = (((uint32_t)hdma->Instance & 0xFFU) - 8U) / 20U;
20002d9a:	687b      	ldr	r3, [r7, #4]
20002d9c:	681b      	ldr	r3, [r3, #0]
20002d9e:	b2db      	uxtb	r3, r3
20002da0:	3b08      	subs	r3, #8
20002da2:	4a12      	ldr	r2, [pc, #72]	; (20002dec <DMA_CalcDMAMUXChannelBaseAndMask+0x74>)
20002da4:	fba2 2303 	umull	r2, r3, r2, r3
20002da8:	091b      	lsrs	r3, r3, #4
20002daa:	60fb      	str	r3, [r7, #12]
  hdma->DMAmuxChannel = (DMAMUX_Channel_TypeDef *)(uint32_t)(dmamux_base_addr + ((hdma->ChannelIndex >> 2U) * ((uint32_t)DMAMUX1_Channel1 - (uint32_t)DMAMUX1_Channel0)));
20002dac:	687b      	ldr	r3, [r7, #4]
20002dae:	6c5b      	ldr	r3, [r3, #68]	; 0x44
20002db0:	089b      	lsrs	r3, r3, #2
20002db2:	009a      	lsls	r2, r3, #2
20002db4:	693b      	ldr	r3, [r7, #16]
20002db6:	4413      	add	r3, r2
20002db8:	461a      	mov	r2, r3
20002dba:	687b      	ldr	r3, [r7, #4]
20002dbc:	649a      	str	r2, [r3, #72]	; 0x48
  hdma->DMAmuxChannelStatus = DMAMUX1_ChannelStatus;
20002dbe:	687b      	ldr	r3, [r7, #4]
20002dc0:	4a0b      	ldr	r2, [pc, #44]	; (20002df0 <DMA_CalcDMAMUXChannelBaseAndMask+0x78>)
20002dc2:	64da      	str	r2, [r3, #76]	; 0x4c
  hdma->DMAmuxChannelStatusMask = 1UL << (channel_number & 0x1FU);
20002dc4:	68fb      	ldr	r3, [r7, #12]
20002dc6:	f003 031f 	and.w	r3, r3, #31
20002dca:	2201      	movs	r2, #1
20002dcc:	409a      	lsls	r2, r3
20002dce:	687b      	ldr	r3, [r7, #4]
20002dd0:	651a      	str	r2, [r3, #80]	; 0x50
}
20002dd2:	bf00      	nop
20002dd4:	371c      	adds	r7, #28
20002dd6:	46bd      	mov	sp, r7
20002dd8:	f85d 7b04 	ldr.w	r7, [sp], #4
20002ddc:	4770      	bx	lr
20002dde:	bf00      	nop
20002de0:	40020407 	.word	0x40020407
20002de4:	40020800 	.word	0x40020800
20002de8:	40020820 	.word	0x40020820
20002dec:	cccccccd 	.word	0xcccccccd
20002df0:	40020880 	.word	0x40020880

20002df4 <DMA_CalcDMAMUXRequestGenBaseAndMask>:
  *                     the configuration information for the specified DMA Channel.
  * @retval None
  */

static void DMA_CalcDMAMUXRequestGenBaseAndMask(DMA_HandleTypeDef *hdma)
{
20002df4:	b480      	push	{r7}
20002df6:	b085      	sub	sp, #20
20002df8:	af00      	add	r7, sp, #0
20002dfa:	6078      	str	r0, [r7, #4]
  uint32_t request =  hdma->Init.Request & DMAMUX_CxCR_DMAREQ_ID;
20002dfc:	687b      	ldr	r3, [r7, #4]
20002dfe:	685b      	ldr	r3, [r3, #4]
20002e00:	b2db      	uxtb	r3, r3
20002e02:	60fb      	str	r3, [r7, #12]

  /* DMA Channels are connected to DMAMUX1 request generator blocks*/
  hdma->DMAmuxRequestGen = (DMAMUX_RequestGen_TypeDef *)((uint32_t)(((uint32_t)DMAMUX1_RequestGenerator0) + ((request - 1U) * 4U)));
20002e04:	68fa      	ldr	r2, [r7, #12]
20002e06:	4b0b      	ldr	r3, [pc, #44]	; (20002e34 <DMA_CalcDMAMUXRequestGenBaseAndMask+0x40>)
20002e08:	4413      	add	r3, r2
20002e0a:	009b      	lsls	r3, r3, #2
20002e0c:	461a      	mov	r2, r3
20002e0e:	687b      	ldr	r3, [r7, #4]
20002e10:	655a      	str	r2, [r3, #84]	; 0x54

  hdma->DMAmuxRequestGenStatus = DMAMUX1_RequestGenStatus;
20002e12:	687b      	ldr	r3, [r7, #4]
20002e14:	4a08      	ldr	r2, [pc, #32]	; (20002e38 <DMA_CalcDMAMUXRequestGenBaseAndMask+0x44>)
20002e16:	659a      	str	r2, [r3, #88]	; 0x58

  hdma->DMAmuxRequestGenStatusMask = 1UL << ((request - 1U) & 0x1FU);
20002e18:	68fb      	ldr	r3, [r7, #12]
20002e1a:	3b01      	subs	r3, #1
20002e1c:	f003 031f 	and.w	r3, r3, #31
20002e20:	2201      	movs	r2, #1
20002e22:	409a      	lsls	r2, r3
20002e24:	687b      	ldr	r3, [r7, #4]
20002e26:	65da      	str	r2, [r3, #92]	; 0x5c
}
20002e28:	bf00      	nop
20002e2a:	3714      	adds	r7, #20
20002e2c:	46bd      	mov	sp, r7
20002e2e:	f85d 7b04 	ldr.w	r7, [sp], #4
20002e32:	4770      	bx	lr
20002e34:	1000823f 	.word	0x1000823f
20002e38:	40020940 	.word	0x40020940

20002e3c <HAL_DMAEx_ConfigMuxSync>:
  *                     the configuration information for the specified DMA channel.
  * @param  pSyncConfig : pointer to HAL_DMA_MuxSyncConfigTypeDef : contains the DMAMUX synchronization parameters
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMAEx_ConfigMuxSync(DMA_HandleTypeDef *hdma, HAL_DMA_MuxSyncConfigTypeDef *pSyncConfig)
{
20002e3c:	b480      	push	{r7}
20002e3e:	b083      	sub	sp, #12
20002e40:	af00      	add	r7, sp, #0
20002e42:	6078      	str	r0, [r7, #4]
20002e44:	6039      	str	r1, [r7, #0]
  assert_param(IS_DMAMUX_SYNC_STATE(pSyncConfig->SyncEnable));
  assert_param(IS_DMAMUX_SYNC_EVENT(pSyncConfig->EventEnable));
  assert_param(IS_DMAMUX_SYNC_REQUEST_NUMBER(pSyncConfig->RequestNumber));

  /*Check if the DMA state is ready */
  if (hdma->State == HAL_DMA_STATE_READY)
20002e46:	687b      	ldr	r3, [r7, #4]
20002e48:	f893 3025 	ldrb.w	r3, [r3, #37]	; 0x25
20002e4c:	b2db      	uxtb	r3, r3
20002e4e:	2b01      	cmp	r3, #1
20002e50:	d12b      	bne.n	20002eaa <HAL_DMAEx_ConfigMuxSync+0x6e>
  {
    /* Process Locked */
    __HAL_LOCK(hdma);
20002e52:	687b      	ldr	r3, [r7, #4]
20002e54:	f893 3024 	ldrb.w	r3, [r3, #36]	; 0x24
20002e58:	2b01      	cmp	r3, #1
20002e5a:	d101      	bne.n	20002e60 <HAL_DMAEx_ConfigMuxSync+0x24>
20002e5c:	2302      	movs	r3, #2
20002e5e:	e025      	b.n	20002eac <HAL_DMAEx_ConfigMuxSync+0x70>
20002e60:	687b      	ldr	r3, [r7, #4]
20002e62:	2201      	movs	r2, #1
20002e64:	f883 2024 	strb.w	r2, [r3, #36]	; 0x24

    /* Set the new synchronization parameters (and keep the request ID filled during the Init)*/
    MODIFY_REG(hdma->DMAmuxChannel->CCR, \
20002e68:	687b      	ldr	r3, [r7, #4]
20002e6a:	6c9b      	ldr	r3, [r3, #72]	; 0x48
20002e6c:	681b      	ldr	r3, [r3, #0]
20002e6e:	b2d9      	uxtb	r1, r3
20002e70:	683b      	ldr	r3, [r7, #0]
20002e72:	681b      	ldr	r3, [r3, #0]
20002e74:	061a      	lsls	r2, r3, #24
20002e76:	683b      	ldr	r3, [r7, #0]
20002e78:	68db      	ldr	r3, [r3, #12]
20002e7a:	3b01      	subs	r3, #1
20002e7c:	04db      	lsls	r3, r3, #19
20002e7e:	431a      	orrs	r2, r3
20002e80:	683b      	ldr	r3, [r7, #0]
20002e82:	685b      	ldr	r3, [r3, #4]
20002e84:	431a      	orrs	r2, r3
20002e86:	683b      	ldr	r3, [r7, #0]
20002e88:	7a1b      	ldrb	r3, [r3, #8]
20002e8a:	041b      	lsls	r3, r3, #16
20002e8c:	431a      	orrs	r2, r3
20002e8e:	683b      	ldr	r3, [r7, #0]
20002e90:	7a5b      	ldrb	r3, [r3, #9]
20002e92:	025b      	lsls	r3, r3, #9
20002e94:	431a      	orrs	r2, r3
20002e96:	687b      	ldr	r3, [r7, #4]
20002e98:	6c9b      	ldr	r3, [r3, #72]	; 0x48
20002e9a:	430a      	orrs	r2, r1
20002e9c:	601a      	str	r2, [r3, #0]
               ((pSyncConfig->SyncSignalID) << DMAMUX_CxCR_SYNC_ID_Pos) | ((pSyncConfig->RequestNumber - 1U) << DMAMUX_CxCR_NBREQ_Pos) | \
               pSyncConfig->SyncPolarity | ((uint32_t)pSyncConfig->SyncEnable << DMAMUX_CxCR_SE_Pos) | \
               ((uint32_t)pSyncConfig->EventEnable << DMAMUX_CxCR_EGE_Pos));

    /* Process UnLocked */
    __HAL_UNLOCK(hdma);
20002e9e:	687b      	ldr	r3, [r7, #4]
20002ea0:	2200      	movs	r2, #0
20002ea2:	f883 2024 	strb.w	r2, [r3, #36]	; 0x24

    return HAL_OK;
20002ea6:	2300      	movs	r3, #0
20002ea8:	e000      	b.n	20002eac <HAL_DMAEx_ConfigMuxSync+0x70>
  }
  else
  {
    /*DMA State not Ready*/
    return HAL_ERROR;
20002eaa:	2301      	movs	r3, #1
  }
}
20002eac:	4618      	mov	r0, r3
20002eae:	370c      	adds	r7, #12
20002eb0:	46bd      	mov	sp, r7
20002eb2:	f85d 7b04 	ldr.w	r7, [sp], #4
20002eb6:	4770      	bx	lr

20002eb8 <HAL_DMAEx_ConfigMuxRequestGenerator>:
  *
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMAEx_ConfigMuxRequestGenerator(DMA_HandleTypeDef *hdma,
                                                      HAL_DMA_MuxRequestGeneratorConfigTypeDef *pRequestGeneratorConfig)
{
20002eb8:	b480      	push	{r7}
20002eba:	b087      	sub	sp, #28
20002ebc:	af00      	add	r7, sp, #0
20002ebe:	6078      	str	r0, [r7, #4]
20002ec0:	6039      	str	r1, [r7, #0]
  assert_param(IS_DMAMUX_REQUEST_GEN_REQUEST_NUMBER(pRequestGeneratorConfig->RequestNumber));

  /* check if the DMA state is ready
     and DMA is using a DMAMUX request generator block
  */
  if ((hdma->State == HAL_DMA_STATE_READY) && (hdma->DMAmuxRequestGen != 0U))
20002ec2:	687b      	ldr	r3, [r7, #4]
20002ec4:	f893 3025 	ldrb.w	r3, [r3, #37]	; 0x25
20002ec8:	b2db      	uxtb	r3, r3
20002eca:	2b01      	cmp	r3, #1
20002ecc:	d137      	bne.n	20002f3e <HAL_DMAEx_ConfigMuxRequestGenerator+0x86>
20002ece:	687b      	ldr	r3, [r7, #4]
20002ed0:	6d5b      	ldr	r3, [r3, #84]	; 0x54
20002ed2:	2b00      	cmp	r3, #0
20002ed4:	d033      	beq.n	20002f3e <HAL_DMAEx_ConfigMuxRequestGenerator+0x86>
  {
    /* Process Locked */
    __HAL_LOCK(hdma);
20002ed6:	687b      	ldr	r3, [r7, #4]
20002ed8:	f893 3024 	ldrb.w	r3, [r3, #36]	; 0x24
20002edc:	2b01      	cmp	r3, #1
20002ede:	d101      	bne.n	20002ee4 <HAL_DMAEx_ConfigMuxRequestGenerator+0x2c>
20002ee0:	2302      	movs	r3, #2
20002ee2:	e02d      	b.n	20002f40 <HAL_DMAEx_ConfigMuxRequestGenerator+0x88>
20002ee4:	687b      	ldr	r3, [r7, #4]
20002ee6:	2201      	movs	r2, #1
20002ee8:	f883 2024 	strb.w	r2, [r3, #36]	; 0x24

    /* Set the request generator new parameters */
    hdma->DMAmuxRequestGen->RGCR = pRequestGeneratorConfig->SignalID | \
20002eec:	683b      	ldr	r3, [r7, #0]
20002eee:	681a      	ldr	r2, [r3, #0]
                                   ((pRequestGeneratorConfig->RequestNumber - 1U) << (POSITION_VAL(DMAMUX_RGxCR_GNBREQ) & 0x1FU)) | \
20002ef0:	683b      	ldr	r3, [r7, #0]
20002ef2:	689b      	ldr	r3, [r3, #8]
20002ef4:	1e59      	subs	r1, r3, #1
20002ef6:	f44f 0378 	mov.w	r3, #16252928	; 0xf80000
20002efa:	613b      	str	r3, [r7, #16]
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
20002efc:	693b      	ldr	r3, [r7, #16]
20002efe:	fa93 f3a3 	rbit	r3, r3
20002f02:	60fb      	str	r3, [r7, #12]
  return result;
20002f04:	68fb      	ldr	r3, [r7, #12]
20002f06:	617b      	str	r3, [r7, #20]
  if (value == 0U)
20002f08:	697b      	ldr	r3, [r7, #20]
20002f0a:	2b00      	cmp	r3, #0
20002f0c:	d101      	bne.n	20002f12 <HAL_DMAEx_ConfigMuxRequestGenerator+0x5a>
    return 32U;
20002f0e:	2320      	movs	r3, #32
20002f10:	e003      	b.n	20002f1a <HAL_DMAEx_ConfigMuxRequestGenerator+0x62>
  return __builtin_clz(value);
20002f12:	697b      	ldr	r3, [r7, #20]
20002f14:	fab3 f383 	clz	r3, r3
20002f18:	b2db      	uxtb	r3, r3
20002f1a:	f003 031f 	and.w	r3, r3, #31
20002f1e:	fa01 f303 	lsl.w	r3, r1, r3
    hdma->DMAmuxRequestGen->RGCR = pRequestGeneratorConfig->SignalID | \
20002f22:	ea42 0103 	orr.w	r1, r2, r3
                                   pRequestGeneratorConfig->Polarity;
20002f26:	683b      	ldr	r3, [r7, #0]
20002f28:	685a      	ldr	r2, [r3, #4]
    hdma->DMAmuxRequestGen->RGCR = pRequestGeneratorConfig->SignalID | \
20002f2a:	687b      	ldr	r3, [r7, #4]
20002f2c:	6d5b      	ldr	r3, [r3, #84]	; 0x54
                                   ((pRequestGeneratorConfig->RequestNumber - 1U) << (POSITION_VAL(DMAMUX_RGxCR_GNBREQ) & 0x1FU)) | \
20002f2e:	430a      	orrs	r2, r1
    hdma->DMAmuxRequestGen->RGCR = pRequestGeneratorConfig->SignalID | \
20002f30:	601a      	str	r2, [r3, #0]
    /* Process UnLocked */
    __HAL_UNLOCK(hdma);
20002f32:	687b      	ldr	r3, [r7, #4]
20002f34:	2200      	movs	r2, #0
20002f36:	f883 2024 	strb.w	r2, [r3, #36]	; 0x24

    return HAL_OK;
20002f3a:	2300      	movs	r3, #0
20002f3c:	e000      	b.n	20002f40 <HAL_DMAEx_ConfigMuxRequestGenerator+0x88>
  }
  else
  {
    return HAL_ERROR;
20002f3e:	2301      	movs	r3, #1
  }
}
20002f40:	4618      	mov	r0, r3
20002f42:	371c      	adds	r7, #28
20002f44:	46bd      	mov	sp, r7
20002f46:	f85d 7b04 	ldr.w	r7, [sp], #4
20002f4a:	4770      	bx	lr

20002f4c <HAL_DMAEx_EnableMuxRequestGenerator>:
  * @param  hdma:       pointer to a DMA_HandleTypeDef structure that contains
  *                     the configuration information for the specified DMA channel.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMAEx_EnableMuxRequestGenerator(DMA_HandleTypeDef *hdma)
{
20002f4c:	b480      	push	{r7}
20002f4e:	b083      	sub	sp, #12
20002f50:	af00      	add	r7, sp, #0
20002f52:	6078      	str	r0, [r7, #4]
  assert_param(IS_DMA_ALL_INSTANCE(hdma->Instance));

  /* check if the DMA state is ready
     and DMA is using a DMAMUX request generator block
  */
  if ((hdma->State != HAL_DMA_STATE_RESET) && (hdma->DMAmuxRequestGen != 0))
20002f54:	687b      	ldr	r3, [r7, #4]
20002f56:	f893 3025 	ldrb.w	r3, [r3, #37]	; 0x25
20002f5a:	b2db      	uxtb	r3, r3
20002f5c:	2b00      	cmp	r3, #0
20002f5e:	d00d      	beq.n	20002f7c <HAL_DMAEx_EnableMuxRequestGenerator+0x30>
20002f60:	687b      	ldr	r3, [r7, #4]
20002f62:	6d5b      	ldr	r3, [r3, #84]	; 0x54
20002f64:	2b00      	cmp	r3, #0
20002f66:	d009      	beq.n	20002f7c <HAL_DMAEx_EnableMuxRequestGenerator+0x30>
  {

    /* Enable the request generator*/
    hdma->DMAmuxRequestGen->RGCR |= DMAMUX_RGxCR_GE;
20002f68:	687b      	ldr	r3, [r7, #4]
20002f6a:	6d5b      	ldr	r3, [r3, #84]	; 0x54
20002f6c:	681a      	ldr	r2, [r3, #0]
20002f6e:	687b      	ldr	r3, [r7, #4]
20002f70:	6d5b      	ldr	r3, [r3, #84]	; 0x54
20002f72:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
20002f76:	601a      	str	r2, [r3, #0]

    return HAL_OK;
20002f78:	2300      	movs	r3, #0
20002f7a:	e000      	b.n	20002f7e <HAL_DMAEx_EnableMuxRequestGenerator+0x32>
  }
  else
  {
    return HAL_ERROR;
20002f7c:	2301      	movs	r3, #1
  }
}
20002f7e:	4618      	mov	r0, r3
20002f80:	370c      	adds	r7, #12
20002f82:	46bd      	mov	sp, r7
20002f84:	f85d 7b04 	ldr.w	r7, [sp], #4
20002f88:	4770      	bx	lr

20002f8a <HAL_DMAEx_DisableMuxRequestGenerator>:
  * @param  hdma:       pointer to a DMA_HandleTypeDef structure that contains
  *                     the configuration information for the specified DMA channel.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMAEx_DisableMuxRequestGenerator(DMA_HandleTypeDef *hdma)
{
20002f8a:	b480      	push	{r7}
20002f8c:	b083      	sub	sp, #12
20002f8e:	af00      	add	r7, sp, #0
20002f90:	6078      	str	r0, [r7, #4]
  assert_param(IS_DMA_ALL_INSTANCE(hdma->Instance));

  /* check if the DMA state is ready
     and DMA is using a DMAMUX request generator block
  */
  if ((hdma->State != HAL_DMA_STATE_RESET) && (hdma->DMAmuxRequestGen != 0))
20002f92:	687b      	ldr	r3, [r7, #4]
20002f94:	f893 3025 	ldrb.w	r3, [r3, #37]	; 0x25
20002f98:	b2db      	uxtb	r3, r3
20002f9a:	2b00      	cmp	r3, #0
20002f9c:	d00d      	beq.n	20002fba <HAL_DMAEx_DisableMuxRequestGenerator+0x30>
20002f9e:	687b      	ldr	r3, [r7, #4]
20002fa0:	6d5b      	ldr	r3, [r3, #84]	; 0x54
20002fa2:	2b00      	cmp	r3, #0
20002fa4:	d009      	beq.n	20002fba <HAL_DMAEx_DisableMuxRequestGenerator+0x30>
  {

    /* Disable the request generator*/
    hdma->DMAmuxRequestGen->RGCR &= ~DMAMUX_RGxCR_GE;
20002fa6:	687b      	ldr	r3, [r7, #4]
20002fa8:	6d5b      	ldr	r3, [r3, #84]	; 0x54
20002faa:	681a      	ldr	r2, [r3, #0]
20002fac:	687b      	ldr	r3, [r7, #4]
20002fae:	6d5b      	ldr	r3, [r3, #84]	; 0x54
20002fb0:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
20002fb4:	601a      	str	r2, [r3, #0]

    return HAL_OK;
20002fb6:	2300      	movs	r3, #0
20002fb8:	e000      	b.n	20002fbc <HAL_DMAEx_DisableMuxRequestGenerator+0x32>
  }
  else
  {
    return HAL_ERROR;
20002fba:	2301      	movs	r3, #1
  }
}
20002fbc:	4618      	mov	r0, r3
20002fbe:	370c      	adds	r7, #12
20002fc0:	46bd      	mov	sp, r7
20002fc2:	f85d 7b04 	ldr.w	r7, [sp], #4
20002fc6:	4770      	bx	lr

20002fc8 <HAL_DMAEx_MUX_IRQHandler>:
  * @param  hdma: pointer to a DMA_HandleTypeDef structure that contains
  *               the configuration information for the specified DMA channel.
  * @retval None
  */
void HAL_DMAEx_MUX_IRQHandler(DMA_HandleTypeDef *hdma)
{
20002fc8:	b580      	push	{r7, lr}
20002fca:	b082      	sub	sp, #8
20002fcc:	af00      	add	r7, sp, #0
20002fce:	6078      	str	r0, [r7, #4]
  /* Check for DMAMUX Synchronization overrun */
  if ((hdma->DMAmuxChannelStatus->CSR & hdma->DMAmuxChannelStatusMask) != 0U)
20002fd0:	687b      	ldr	r3, [r7, #4]
20002fd2:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
20002fd4:	681a      	ldr	r2, [r3, #0]
20002fd6:	687b      	ldr	r3, [r7, #4]
20002fd8:	6d1b      	ldr	r3, [r3, #80]	; 0x50
20002fda:	4013      	ands	r3, r2
20002fdc:	2b00      	cmp	r3, #0
20002fde:	d01a      	beq.n	20003016 <HAL_DMAEx_MUX_IRQHandler+0x4e>
  {
    /* Disable the synchro overrun interrupt */
    hdma->DMAmuxChannel->CCR &= ~DMAMUX_CxCR_SOIE;
20002fe0:	687b      	ldr	r3, [r7, #4]
20002fe2:	6c9b      	ldr	r3, [r3, #72]	; 0x48
20002fe4:	681a      	ldr	r2, [r3, #0]
20002fe6:	687b      	ldr	r3, [r7, #4]
20002fe8:	6c9b      	ldr	r3, [r3, #72]	; 0x48
20002fea:	f422 7280 	bic.w	r2, r2, #256	; 0x100
20002fee:	601a      	str	r2, [r3, #0]

    /* Clear the DMAMUX synchro overrun flag */
    hdma->DMAmuxChannelStatus->CFR = hdma->DMAmuxChannelStatusMask;
20002ff0:	687b      	ldr	r3, [r7, #4]
20002ff2:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
20002ff4:	687a      	ldr	r2, [r7, #4]
20002ff6:	6d12      	ldr	r2, [r2, #80]	; 0x50
20002ff8:	605a      	str	r2, [r3, #4]

    /* Update error code */
    hdma->ErrorCode |= HAL_DMA_ERROR_SYNC;
20002ffa:	687b      	ldr	r3, [r7, #4]
20002ffc:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
20002ffe:	f443 7200 	orr.w	r2, r3, #512	; 0x200
20003002:	687b      	ldr	r3, [r7, #4]
20003004:	63da      	str	r2, [r3, #60]	; 0x3c

    if (hdma->XferErrorCallback != NULL)
20003006:	687b      	ldr	r3, [r7, #4]
20003008:	6b5b      	ldr	r3, [r3, #52]	; 0x34
2000300a:	2b00      	cmp	r3, #0
2000300c:	d003      	beq.n	20003016 <HAL_DMAEx_MUX_IRQHandler+0x4e>
    {
      /* Transfer error callback */
      hdma->XferErrorCallback(hdma);
2000300e:	687b      	ldr	r3, [r7, #4]
20003010:	6b5b      	ldr	r3, [r3, #52]	; 0x34
20003012:	6878      	ldr	r0, [r7, #4]
20003014:	4798      	blx	r3
    }
  }

  if (hdma->DMAmuxRequestGen != 0)
20003016:	687b      	ldr	r3, [r7, #4]
20003018:	6d5b      	ldr	r3, [r3, #84]	; 0x54
2000301a:	2b00      	cmp	r3, #0
2000301c:	d022      	beq.n	20003064 <HAL_DMAEx_MUX_IRQHandler+0x9c>
  {
    /* if using a DMAMUX request generator block Check for DMAMUX request generator overrun */
    if ((hdma->DMAmuxRequestGenStatus->RGSR & hdma->DMAmuxRequestGenStatusMask) != 0U)
2000301e:	687b      	ldr	r3, [r7, #4]
20003020:	6d9b      	ldr	r3, [r3, #88]	; 0x58
20003022:	681a      	ldr	r2, [r3, #0]
20003024:	687b      	ldr	r3, [r7, #4]
20003026:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
20003028:	4013      	ands	r3, r2
2000302a:	2b00      	cmp	r3, #0
2000302c:	d01a      	beq.n	20003064 <HAL_DMAEx_MUX_IRQHandler+0x9c>
    {
      /* Disable the request gen overrun interrupt */
      hdma->DMAmuxRequestGen->RGCR &= ~DMAMUX_RGxCR_OIE;
2000302e:	687b      	ldr	r3, [r7, #4]
20003030:	6d5b      	ldr	r3, [r3, #84]	; 0x54
20003032:	681a      	ldr	r2, [r3, #0]
20003034:	687b      	ldr	r3, [r7, #4]
20003036:	6d5b      	ldr	r3, [r3, #84]	; 0x54
20003038:	f422 7280 	bic.w	r2, r2, #256	; 0x100
2000303c:	601a      	str	r2, [r3, #0]

      /* Clear the DMAMUX request generator overrun flag */
      hdma->DMAmuxRequestGenStatus->RGCFR = hdma->DMAmuxRequestGenStatusMask;
2000303e:	687b      	ldr	r3, [r7, #4]
20003040:	6d9b      	ldr	r3, [r3, #88]	; 0x58
20003042:	687a      	ldr	r2, [r7, #4]
20003044:	6dd2      	ldr	r2, [r2, #92]	; 0x5c
20003046:	605a      	str	r2, [r3, #4]

      /* Update error code */
      hdma->ErrorCode |= HAL_DMA_ERROR_REQGEN;
20003048:	687b      	ldr	r3, [r7, #4]
2000304a:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2000304c:	f443 6280 	orr.w	r2, r3, #1024	; 0x400
20003050:	687b      	ldr	r3, [r7, #4]
20003052:	63da      	str	r2, [r3, #60]	; 0x3c

      if (hdma->XferErrorCallback != NULL)
20003054:	687b      	ldr	r3, [r7, #4]
20003056:	6b5b      	ldr	r3, [r3, #52]	; 0x34
20003058:	2b00      	cmp	r3, #0
2000305a:	d003      	beq.n	20003064 <HAL_DMAEx_MUX_IRQHandler+0x9c>
      {
        /* Transfer error callback */
        hdma->XferErrorCallback(hdma);
2000305c:	687b      	ldr	r3, [r7, #4]
2000305e:	6b5b      	ldr	r3, [r3, #52]	; 0x34
20003060:	6878      	ldr	r0, [r7, #4]
20003062:	4798      	blx	r3
      }
    }
  }
}
20003064:	bf00      	nop
20003066:	3708      	adds	r7, #8
20003068:	46bd      	mov	sp, r7
2000306a:	bd80      	pop	{r7, pc}

2000306c <HAL_EXTI_SetConfigLine>:
  * @param  hexti Exti handle.
  * @param  pExtiConfig Pointer on EXTI configuration to be set.
  * @retval HAL Status.
  */
HAL_StatusTypeDef HAL_EXTI_SetConfigLine(EXTI_HandleTypeDef *hexti, EXTI_ConfigTypeDef *pExtiConfig)
{
2000306c:	b480      	push	{r7}
2000306e:	b089      	sub	sp, #36	; 0x24
20003070:	af00      	add	r7, sp, #0
20003072:	6078      	str	r0, [r7, #4]
20003074:	6039      	str	r1, [r7, #0]
  uint32_t linepos;
  uint32_t maskline;
  uint32_t offset;

  /* Check null pointer */
  if ((hexti == NULL) || (pExtiConfig == NULL))
20003076:	687b      	ldr	r3, [r7, #4]
20003078:	2b00      	cmp	r3, #0
2000307a:	d002      	beq.n	20003082 <HAL_EXTI_SetConfigLine+0x16>
2000307c:	683b      	ldr	r3, [r7, #0]
2000307e:	2b00      	cmp	r3, #0
20003080:	d101      	bne.n	20003086 <HAL_EXTI_SetConfigLine+0x1a>
  {
    return HAL_ERROR;
20003082:	2301      	movs	r3, #1
20003084:	e0b3      	b.n	200031ee <HAL_EXTI_SetConfigLine+0x182>
  /* Check parameters */
  assert_param(IS_EXTI_LINE(pExtiConfig->Line));
  assert_param(IS_EXTI_MODE(pExtiConfig->Mode));

  /* Assign line number to handle */
  hexti->Line = pExtiConfig->Line;
20003086:	683b      	ldr	r3, [r7, #0]
20003088:	681a      	ldr	r2, [r3, #0]
2000308a:	687b      	ldr	r3, [r7, #4]
2000308c:	601a      	str	r2, [r3, #0]

  /* Compute line register offset */
  offset = ((pExtiConfig->Line & EXTI_REG_MASK) >> EXTI_REG_SHIFT);
2000308e:	683b      	ldr	r3, [r7, #0]
20003090:	681b      	ldr	r3, [r3, #0]
20003092:	0c1b      	lsrs	r3, r3, #16
20003094:	f003 0301 	and.w	r3, r3, #1
20003098:	61bb      	str	r3, [r7, #24]
  /* Compute line position */
  linepos = (pExtiConfig->Line & EXTI_PIN_MASK);
2000309a:	683b      	ldr	r3, [r7, #0]
2000309c:	681b      	ldr	r3, [r3, #0]
2000309e:	f003 031f 	and.w	r3, r3, #31
200030a2:	617b      	str	r3, [r7, #20]
  /* Compute line mask */
  maskline = (1uL << linepos);
200030a4:	2201      	movs	r2, #1
200030a6:	697b      	ldr	r3, [r7, #20]
200030a8:	fa02 f303 	lsl.w	r3, r2, r3
200030ac:	613b      	str	r3, [r7, #16]

  /* Configure triggers for configurable lines */
  if ((pExtiConfig->Line & EXTI_CONFIG) != 0x00u)
200030ae:	683b      	ldr	r3, [r7, #0]
200030b0:	681b      	ldr	r3, [r3, #0]
200030b2:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
200030b6:	2b00      	cmp	r3, #0
200030b8:	d060      	beq.n	2000317c <HAL_EXTI_SetConfigLine+0x110>
  {
    assert_param(IS_EXTI_TRIGGER(pExtiConfig->Trigger));

    /* Configure rising trigger */
    regaddr = (&EXTI->RTSR1 + (EXTI_CONFIG_OFFSET * offset));
200030ba:	69bb      	ldr	r3, [r7, #24]
200030bc:	015a      	lsls	r2, r3, #5
200030be:	4b4f      	ldr	r3, [pc, #316]	; (200031fc <HAL_EXTI_SetConfigLine+0x190>)
200030c0:	4413      	add	r3, r2
200030c2:	60fb      	str	r3, [r7, #12]
    regval = *regaddr;
200030c4:	68fb      	ldr	r3, [r7, #12]
200030c6:	681b      	ldr	r3, [r3, #0]
200030c8:	61fb      	str	r3, [r7, #28]

    /* Mask or set line */
    if ((pExtiConfig->Trigger & EXTI_TRIGGER_RISING) != 0x00u)
200030ca:	683b      	ldr	r3, [r7, #0]
200030cc:	689b      	ldr	r3, [r3, #8]
200030ce:	f003 0301 	and.w	r3, r3, #1
200030d2:	2b00      	cmp	r3, #0
200030d4:	d004      	beq.n	200030e0 <HAL_EXTI_SetConfigLine+0x74>
    {
      regval |= maskline;
200030d6:	69fa      	ldr	r2, [r7, #28]
200030d8:	693b      	ldr	r3, [r7, #16]
200030da:	4313      	orrs	r3, r2
200030dc:	61fb      	str	r3, [r7, #28]
200030de:	e004      	b.n	200030ea <HAL_EXTI_SetConfigLine+0x7e>
    }
    else
    {
      regval &= ~maskline;
200030e0:	693b      	ldr	r3, [r7, #16]
200030e2:	43db      	mvns	r3, r3
200030e4:	69fa      	ldr	r2, [r7, #28]
200030e6:	4013      	ands	r3, r2
200030e8:	61fb      	str	r3, [r7, #28]
    }

    /* Store rising trigger mode */
    *regaddr = regval;
200030ea:	68fb      	ldr	r3, [r7, #12]
200030ec:	69fa      	ldr	r2, [r7, #28]
200030ee:	601a      	str	r2, [r3, #0]

    /* Configure falling trigger */
    regaddr = (&EXTI->FTSR1 + (EXTI_CONFIG_OFFSET * offset));
200030f0:	69bb      	ldr	r3, [r7, #24]
200030f2:	015a      	lsls	r2, r3, #5
200030f4:	4b42      	ldr	r3, [pc, #264]	; (20003200 <HAL_EXTI_SetConfigLine+0x194>)
200030f6:	4413      	add	r3, r2
200030f8:	60fb      	str	r3, [r7, #12]
    regval = *regaddr;
200030fa:	68fb      	ldr	r3, [r7, #12]
200030fc:	681b      	ldr	r3, [r3, #0]
200030fe:	61fb      	str	r3, [r7, #28]

    /* Mask or set line */
    if ((pExtiConfig->Trigger & EXTI_TRIGGER_FALLING) != 0x00u)
20003100:	683b      	ldr	r3, [r7, #0]
20003102:	689b      	ldr	r3, [r3, #8]
20003104:	f003 0302 	and.w	r3, r3, #2
20003108:	2b00      	cmp	r3, #0
2000310a:	d004      	beq.n	20003116 <HAL_EXTI_SetConfigLine+0xaa>
    {
      regval |= maskline;
2000310c:	69fa      	ldr	r2, [r7, #28]
2000310e:	693b      	ldr	r3, [r7, #16]
20003110:	4313      	orrs	r3, r2
20003112:	61fb      	str	r3, [r7, #28]
20003114:	e004      	b.n	20003120 <HAL_EXTI_SetConfigLine+0xb4>
    }
    else
    {
      regval &= ~maskline;
20003116:	693b      	ldr	r3, [r7, #16]
20003118:	43db      	mvns	r3, r3
2000311a:	69fa      	ldr	r2, [r7, #28]
2000311c:	4013      	ands	r3, r2
2000311e:	61fb      	str	r3, [r7, #28]
    }

    /* Store falling trigger mode */
    *regaddr = regval;
20003120:	68fb      	ldr	r3, [r7, #12]
20003122:	69fa      	ldr	r2, [r7, #28]
20003124:	601a      	str	r2, [r3, #0]

    /* Configure gpio port selection in case of gpio exti line */
    if ((pExtiConfig->Line & EXTI_GPIO) == EXTI_GPIO)
20003126:	683b      	ldr	r3, [r7, #0]
20003128:	681b      	ldr	r3, [r3, #0]
2000312a:	f003 63c0 	and.w	r3, r3, #100663296	; 0x6000000
2000312e:	f1b3 6fc0 	cmp.w	r3, #100663296	; 0x6000000
20003132:	d123      	bne.n	2000317c <HAL_EXTI_SetConfigLine+0x110>
    {
      assert_param(IS_EXTI_GPIO_PORT(pExtiConfig->GPIOSel));
      assert_param(IS_EXTI_GPIO_PIN(linepos));

      regval = SYSCFG->EXTICR[linepos >> 2u];
20003134:	4a33      	ldr	r2, [pc, #204]	; (20003204 <HAL_EXTI_SetConfigLine+0x198>)
20003136:	697b      	ldr	r3, [r7, #20]
20003138:	089b      	lsrs	r3, r3, #2
2000313a:	3302      	adds	r3, #2
2000313c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
20003140:	61fb      	str	r3, [r7, #28]
      regval &= ~(SYSCFG_EXTICR1_EXTI0 << (SYSCFG_EXTICR1_EXTI1_Pos * (linepos & 0x03u)));
20003142:	697b      	ldr	r3, [r7, #20]
20003144:	f003 0303 	and.w	r3, r3, #3
20003148:	009b      	lsls	r3, r3, #2
2000314a:	2207      	movs	r2, #7
2000314c:	fa02 f303 	lsl.w	r3, r2, r3
20003150:	43db      	mvns	r3, r3
20003152:	69fa      	ldr	r2, [r7, #28]
20003154:	4013      	ands	r3, r2
20003156:	61fb      	str	r3, [r7, #28]
      regval |= (pExtiConfig->GPIOSel << (SYSCFG_EXTICR1_EXTI1_Pos * (linepos & 0x03u)));
20003158:	683b      	ldr	r3, [r7, #0]
2000315a:	68da      	ldr	r2, [r3, #12]
2000315c:	697b      	ldr	r3, [r7, #20]
2000315e:	f003 0303 	and.w	r3, r3, #3
20003162:	009b      	lsls	r3, r3, #2
20003164:	fa02 f303 	lsl.w	r3, r2, r3
20003168:	69fa      	ldr	r2, [r7, #28]
2000316a:	4313      	orrs	r3, r2
2000316c:	61fb      	str	r3, [r7, #28]
      SYSCFG->EXTICR[linepos >> 2u] = regval;
2000316e:	4925      	ldr	r1, [pc, #148]	; (20003204 <HAL_EXTI_SetConfigLine+0x198>)
20003170:	697b      	ldr	r3, [r7, #20]
20003172:	089b      	lsrs	r3, r3, #2
20003174:	3302      	adds	r3, #2
20003176:	69fa      	ldr	r2, [r7, #28]
20003178:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
  }

  /* Configure interrupt mode : read current mode */
  regaddr = (&EXTI->IMR1 + (EXTI_MODE_OFFSET * offset));
2000317c:	69bb      	ldr	r3, [r7, #24]
2000317e:	015b      	lsls	r3, r3, #5
20003180:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
20003184:	f503 3382 	add.w	r3, r3, #66560	; 0x10400
20003188:	60fb      	str	r3, [r7, #12]
  regval = *regaddr;
2000318a:	68fb      	ldr	r3, [r7, #12]
2000318c:	681b      	ldr	r3, [r3, #0]
2000318e:	61fb      	str	r3, [r7, #28]

  /* Mask or set line */
  if ((pExtiConfig->Mode & EXTI_MODE_INTERRUPT) != 0x00u)
20003190:	683b      	ldr	r3, [r7, #0]
20003192:	685b      	ldr	r3, [r3, #4]
20003194:	f003 0301 	and.w	r3, r3, #1
20003198:	2b00      	cmp	r3, #0
2000319a:	d004      	beq.n	200031a6 <HAL_EXTI_SetConfigLine+0x13a>
  {
    regval |= maskline;
2000319c:	69fa      	ldr	r2, [r7, #28]
2000319e:	693b      	ldr	r3, [r7, #16]
200031a0:	4313      	orrs	r3, r2
200031a2:	61fb      	str	r3, [r7, #28]
200031a4:	e004      	b.n	200031b0 <HAL_EXTI_SetConfigLine+0x144>
  }
  else
  {
    regval &= ~maskline;
200031a6:	693b      	ldr	r3, [r7, #16]
200031a8:	43db      	mvns	r3, r3
200031aa:	69fa      	ldr	r2, [r7, #28]
200031ac:	4013      	ands	r3, r2
200031ae:	61fb      	str	r3, [r7, #28]
  }

  /* Store interrupt mode */
  *regaddr = regval;
200031b0:	68fb      	ldr	r3, [r7, #12]
200031b2:	69fa      	ldr	r2, [r7, #28]
200031b4:	601a      	str	r2, [r3, #0]

  /* Configure event mode : read current mode */
  regaddr = (&EXTI->EMR1 + (EXTI_MODE_OFFSET * offset));
200031b6:	69bb      	ldr	r3, [r7, #24]
200031b8:	015a      	lsls	r2, r3, #5
200031ba:	4b13      	ldr	r3, [pc, #76]	; (20003208 <HAL_EXTI_SetConfigLine+0x19c>)
200031bc:	4413      	add	r3, r2
200031be:	60fb      	str	r3, [r7, #12]
  regval = *regaddr;
200031c0:	68fb      	ldr	r3, [r7, #12]
200031c2:	681b      	ldr	r3, [r3, #0]
200031c4:	61fb      	str	r3, [r7, #28]

  /* Mask or set line */
  if ((pExtiConfig->Mode & EXTI_MODE_EVENT) != 0x00u)
200031c6:	683b      	ldr	r3, [r7, #0]
200031c8:	685b      	ldr	r3, [r3, #4]
200031ca:	f003 0302 	and.w	r3, r3, #2
200031ce:	2b00      	cmp	r3, #0
200031d0:	d004      	beq.n	200031dc <HAL_EXTI_SetConfigLine+0x170>
  {
    regval |= maskline;
200031d2:	69fa      	ldr	r2, [r7, #28]
200031d4:	693b      	ldr	r3, [r7, #16]
200031d6:	4313      	orrs	r3, r2
200031d8:	61fb      	str	r3, [r7, #28]
200031da:	e004      	b.n	200031e6 <HAL_EXTI_SetConfigLine+0x17a>
  }
  else
  {
    regval &= ~maskline;
200031dc:	693b      	ldr	r3, [r7, #16]
200031de:	43db      	mvns	r3, r3
200031e0:	69fa      	ldr	r2, [r7, #28]
200031e2:	4013      	ands	r3, r2
200031e4:	61fb      	str	r3, [r7, #28]
  }

  /* Store event mode */
  *regaddr = regval;
200031e6:	68fb      	ldr	r3, [r7, #12]
200031e8:	69fa      	ldr	r2, [r7, #28]
200031ea:	601a      	str	r2, [r3, #0]

  return HAL_OK;
200031ec:	2300      	movs	r3, #0
}
200031ee:	4618      	mov	r0, r3
200031f0:	3724      	adds	r7, #36	; 0x24
200031f2:	46bd      	mov	sp, r7
200031f4:	f85d 7b04 	ldr.w	r7, [sp], #4
200031f8:	4770      	bx	lr
200031fa:	bf00      	nop
200031fc:	40010408 	.word	0x40010408
20003200:	4001040c 	.word	0x4001040c
20003204:	40010000 	.word	0x40010000
20003208:	40010404 	.word	0x40010404

2000320c <HAL_EXTI_GetConfigLine>:
  * @param  hexti Exti handle.
  * @param  pExtiConfig Pointer on structure to store Exti configuration.
  * @retval HAL Status.
  */
HAL_StatusTypeDef HAL_EXTI_GetConfigLine(EXTI_HandleTypeDef *hexti, EXTI_ConfigTypeDef *pExtiConfig)
{
2000320c:	b480      	push	{r7}
2000320e:	b089      	sub	sp, #36	; 0x24
20003210:	af00      	add	r7, sp, #0
20003212:	6078      	str	r0, [r7, #4]
20003214:	6039      	str	r1, [r7, #0]
  uint32_t linepos;
  uint32_t maskline;
  uint32_t offset;

  /* Check null pointer */
  if ((hexti == NULL) || (pExtiConfig == NULL))
20003216:	687b      	ldr	r3, [r7, #4]
20003218:	2b00      	cmp	r3, #0
2000321a:	d002      	beq.n	20003222 <HAL_EXTI_GetConfigLine+0x16>
2000321c:	683b      	ldr	r3, [r7, #0]
2000321e:	2b00      	cmp	r3, #0
20003220:	d101      	bne.n	20003226 <HAL_EXTI_GetConfigLine+0x1a>
  {
    return HAL_ERROR;
20003222:	2301      	movs	r3, #1
20003224:	e08b      	b.n	2000333e <HAL_EXTI_GetConfigLine+0x132>

  /* Check the parameter */
  assert_param(IS_EXTI_LINE(hexti->Line));

  /* Store handle line number to configuration structure */
  pExtiConfig->Line = hexti->Line;
20003226:	687b      	ldr	r3, [r7, #4]
20003228:	681a      	ldr	r2, [r3, #0]
2000322a:	683b      	ldr	r3, [r7, #0]
2000322c:	601a      	str	r2, [r3, #0]

  /* Compute line register offset and line mask */
  offset = ((pExtiConfig->Line & EXTI_REG_MASK) >> EXTI_REG_SHIFT);
2000322e:	683b      	ldr	r3, [r7, #0]
20003230:	681b      	ldr	r3, [r3, #0]
20003232:	0c1b      	lsrs	r3, r3, #16
20003234:	f003 0301 	and.w	r3, r3, #1
20003238:	61fb      	str	r3, [r7, #28]
  /* Compute line position */
  linepos = (pExtiConfig->Line & EXTI_PIN_MASK);
2000323a:	683b      	ldr	r3, [r7, #0]
2000323c:	681b      	ldr	r3, [r3, #0]
2000323e:	f003 031f 	and.w	r3, r3, #31
20003242:	61bb      	str	r3, [r7, #24]
  /* Compute mask */
  maskline = (1uL << linepos);
20003244:	2201      	movs	r2, #1
20003246:	69bb      	ldr	r3, [r7, #24]
20003248:	fa02 f303 	lsl.w	r3, r2, r3
2000324c:	617b      	str	r3, [r7, #20]

  /* 1] Get core mode : interrupt */
  regaddr = (&EXTI->IMR1 + (EXTI_MODE_OFFSET * offset));
2000324e:	69fb      	ldr	r3, [r7, #28]
20003250:	015b      	lsls	r3, r3, #5
20003252:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
20003256:	f503 3382 	add.w	r3, r3, #66560	; 0x10400
2000325a:	613b      	str	r3, [r7, #16]
  regval = *regaddr;
2000325c:	693b      	ldr	r3, [r7, #16]
2000325e:	681b      	ldr	r3, [r3, #0]
20003260:	60fb      	str	r3, [r7, #12]

  /* Check if selected line is enable */
  if ((regval & maskline) != 0x00u)
20003262:	68fa      	ldr	r2, [r7, #12]
20003264:	697b      	ldr	r3, [r7, #20]
20003266:	4013      	ands	r3, r2
20003268:	2b00      	cmp	r3, #0
2000326a:	d003      	beq.n	20003274 <HAL_EXTI_GetConfigLine+0x68>
  {
    pExtiConfig->Mode = EXTI_MODE_INTERRUPT;
2000326c:	683b      	ldr	r3, [r7, #0]
2000326e:	2201      	movs	r2, #1
20003270:	605a      	str	r2, [r3, #4]
20003272:	e002      	b.n	2000327a <HAL_EXTI_GetConfigLine+0x6e>
  }
  else
  {
    pExtiConfig->Mode = EXTI_MODE_NONE;
20003274:	683b      	ldr	r3, [r7, #0]
20003276:	2200      	movs	r2, #0
20003278:	605a      	str	r2, [r3, #4]
  }

  /* Get event mode */
  regaddr = (&EXTI->EMR1 + (EXTI_MODE_OFFSET * offset));
2000327a:	69fb      	ldr	r3, [r7, #28]
2000327c:	015a      	lsls	r2, r3, #5
2000327e:	4b33      	ldr	r3, [pc, #204]	; (2000334c <HAL_EXTI_GetConfigLine+0x140>)
20003280:	4413      	add	r3, r2
20003282:	613b      	str	r3, [r7, #16]
  regval = *regaddr;
20003284:	693b      	ldr	r3, [r7, #16]
20003286:	681b      	ldr	r3, [r3, #0]
20003288:	60fb      	str	r3, [r7, #12]

  /* Check if selected line is enable */
  if ((regval & maskline) != 0x00u)
2000328a:	68fa      	ldr	r2, [r7, #12]
2000328c:	697b      	ldr	r3, [r7, #20]
2000328e:	4013      	ands	r3, r2
20003290:	2b00      	cmp	r3, #0
20003292:	d005      	beq.n	200032a0 <HAL_EXTI_GetConfigLine+0x94>
  {
    pExtiConfig->Mode |= EXTI_MODE_EVENT;
20003294:	683b      	ldr	r3, [r7, #0]
20003296:	685b      	ldr	r3, [r3, #4]
20003298:	f043 0202 	orr.w	r2, r3, #2
2000329c:	683b      	ldr	r3, [r7, #0]
2000329e:	605a      	str	r2, [r3, #4]
  }

  /* 2] Get trigger for configurable lines : rising */
  if ((pExtiConfig->Line & EXTI_CONFIG) != 0x00u)
200032a0:	683b      	ldr	r3, [r7, #0]
200032a2:	681b      	ldr	r3, [r3, #0]
200032a4:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
200032a8:	2b00      	cmp	r3, #0
200032aa:	d041      	beq.n	20003330 <HAL_EXTI_GetConfigLine+0x124>
  {
    regaddr = (&EXTI->RTSR1 + (EXTI_CONFIG_OFFSET * offset));
200032ac:	69fb      	ldr	r3, [r7, #28]
200032ae:	015a      	lsls	r2, r3, #5
200032b0:	4b27      	ldr	r3, [pc, #156]	; (20003350 <HAL_EXTI_GetConfigLine+0x144>)
200032b2:	4413      	add	r3, r2
200032b4:	613b      	str	r3, [r7, #16]
    regval = *regaddr;
200032b6:	693b      	ldr	r3, [r7, #16]
200032b8:	681b      	ldr	r3, [r3, #0]
200032ba:	60fb      	str	r3, [r7, #12]

    /* Check if configuration of selected line is enable */
    if ((regval & maskline) != 0x00u)
200032bc:	68fa      	ldr	r2, [r7, #12]
200032be:	697b      	ldr	r3, [r7, #20]
200032c0:	4013      	ands	r3, r2
200032c2:	2b00      	cmp	r3, #0
200032c4:	d003      	beq.n	200032ce <HAL_EXTI_GetConfigLine+0xc2>
    {
      pExtiConfig->Trigger = EXTI_TRIGGER_RISING;
200032c6:	683b      	ldr	r3, [r7, #0]
200032c8:	2201      	movs	r2, #1
200032ca:	609a      	str	r2, [r3, #8]
200032cc:	e002      	b.n	200032d4 <HAL_EXTI_GetConfigLine+0xc8>
    }
    else
    {
      pExtiConfig->Trigger = EXTI_TRIGGER_NONE;
200032ce:	683b      	ldr	r3, [r7, #0]
200032d0:	2200      	movs	r2, #0
200032d2:	609a      	str	r2, [r3, #8]
    }

    /* Get falling configuration */
    regaddr = (&EXTI->FTSR1 + (EXTI_CONFIG_OFFSET * offset));
200032d4:	69fb      	ldr	r3, [r7, #28]
200032d6:	015a      	lsls	r2, r3, #5
200032d8:	4b1e      	ldr	r3, [pc, #120]	; (20003354 <HAL_EXTI_GetConfigLine+0x148>)
200032da:	4413      	add	r3, r2
200032dc:	613b      	str	r3, [r7, #16]
    regval = *regaddr;
200032de:	693b      	ldr	r3, [r7, #16]
200032e0:	681b      	ldr	r3, [r3, #0]
200032e2:	60fb      	str	r3, [r7, #12]

    /* Check if configuration of selected line is enable */
    if ((regval & maskline) != 0x00u)
200032e4:	68fa      	ldr	r2, [r7, #12]
200032e6:	697b      	ldr	r3, [r7, #20]
200032e8:	4013      	ands	r3, r2
200032ea:	2b00      	cmp	r3, #0
200032ec:	d005      	beq.n	200032fa <HAL_EXTI_GetConfigLine+0xee>
    {
      pExtiConfig->Trigger |= EXTI_TRIGGER_FALLING;
200032ee:	683b      	ldr	r3, [r7, #0]
200032f0:	689b      	ldr	r3, [r3, #8]
200032f2:	f043 0202 	orr.w	r2, r3, #2
200032f6:	683b      	ldr	r3, [r7, #0]
200032f8:	609a      	str	r2, [r3, #8]
    }

    /* Get Gpio port selection for gpio lines */
    if ((pExtiConfig->Line & EXTI_GPIO) == EXTI_GPIO)
200032fa:	683b      	ldr	r3, [r7, #0]
200032fc:	681b      	ldr	r3, [r3, #0]
200032fe:	f003 63c0 	and.w	r3, r3, #100663296	; 0x6000000
20003302:	f1b3 6fc0 	cmp.w	r3, #100663296	; 0x6000000
20003306:	d10f      	bne.n	20003328 <HAL_EXTI_GetConfigLine+0x11c>
    {
      assert_param(IS_EXTI_GPIO_PIN(linepos));

      regval = SYSCFG->EXTICR[linepos >> 2u];
20003308:	4a13      	ldr	r2, [pc, #76]	; (20003358 <HAL_EXTI_GetConfigLine+0x14c>)
2000330a:	69bb      	ldr	r3, [r7, #24]
2000330c:	089b      	lsrs	r3, r3, #2
2000330e:	3302      	adds	r3, #2
20003310:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
20003314:	60fb      	str	r3, [r7, #12]
      pExtiConfig->GPIOSel = ((regval >> (SYSCFG_EXTICR1_EXTI1_Pos * ((linepos & 0x03u)))));
20003316:	69bb      	ldr	r3, [r7, #24]
20003318:	f003 0303 	and.w	r3, r3, #3
2000331c:	009b      	lsls	r3, r3, #2
2000331e:	68fa      	ldr	r2, [r7, #12]
20003320:	40da      	lsrs	r2, r3
20003322:	683b      	ldr	r3, [r7, #0]
20003324:	60da      	str	r2, [r3, #12]
20003326:	e009      	b.n	2000333c <HAL_EXTI_GetConfigLine+0x130>
    }
    else
    {
      pExtiConfig->GPIOSel = 0x00u;
20003328:	683b      	ldr	r3, [r7, #0]
2000332a:	2200      	movs	r2, #0
2000332c:	60da      	str	r2, [r3, #12]
2000332e:	e005      	b.n	2000333c <HAL_EXTI_GetConfigLine+0x130>
    }
  }
  else
  {
    pExtiConfig->Trigger = EXTI_TRIGGER_NONE;
20003330:	683b      	ldr	r3, [r7, #0]
20003332:	2200      	movs	r2, #0
20003334:	609a      	str	r2, [r3, #8]
    pExtiConfig->GPIOSel = 0x00u;
20003336:	683b      	ldr	r3, [r7, #0]
20003338:	2200      	movs	r2, #0
2000333a:	60da      	str	r2, [r3, #12]
  }

  return HAL_OK;
2000333c:	2300      	movs	r3, #0
}
2000333e:	4618      	mov	r0, r3
20003340:	3724      	adds	r7, #36	; 0x24
20003342:	46bd      	mov	sp, r7
20003344:	f85d 7b04 	ldr.w	r7, [sp], #4
20003348:	4770      	bx	lr
2000334a:	bf00      	nop
2000334c:	40010404 	.word	0x40010404
20003350:	40010408 	.word	0x40010408
20003354:	4001040c 	.word	0x4001040c
20003358:	40010000 	.word	0x40010000

2000335c <HAL_EXTI_ClearConfigLine>:
  * @brief  Clear whole configuration of a dedicated Exti line.
  * @param  hexti Exti handle.
  * @retval HAL Status.
  */
HAL_StatusTypeDef HAL_EXTI_ClearConfigLine(EXTI_HandleTypeDef *hexti)
{
2000335c:	b480      	push	{r7}
2000335e:	b089      	sub	sp, #36	; 0x24
20003360:	af00      	add	r7, sp, #0
20003362:	6078      	str	r0, [r7, #4]
  uint32_t linepos;
  uint32_t maskline;
  uint32_t offset;

  /* Check null pointer */
  if (hexti == NULL)
20003364:	687b      	ldr	r3, [r7, #4]
20003366:	2b00      	cmp	r3, #0
20003368:	d101      	bne.n	2000336e <HAL_EXTI_ClearConfigLine+0x12>
  {
    return HAL_ERROR;
2000336a:	2301      	movs	r3, #1
2000336c:	e070      	b.n	20003450 <HAL_EXTI_ClearConfigLine+0xf4>

  /* Check the parameter */
  assert_param(IS_EXTI_LINE(hexti->Line));

  /* compute line register offset and line mask */
  offset = ((hexti->Line & EXTI_REG_MASK) >> EXTI_REG_SHIFT);
2000336e:	687b      	ldr	r3, [r7, #4]
20003370:	681b      	ldr	r3, [r3, #0]
20003372:	0c1b      	lsrs	r3, r3, #16
20003374:	f003 0301 	and.w	r3, r3, #1
20003378:	61fb      	str	r3, [r7, #28]
  /* compute line position */
  linepos = (hexti->Line & EXTI_PIN_MASK);
2000337a:	687b      	ldr	r3, [r7, #4]
2000337c:	681b      	ldr	r3, [r3, #0]
2000337e:	f003 031f 	and.w	r3, r3, #31
20003382:	61bb      	str	r3, [r7, #24]
  /* compute line mask */
  maskline = (1uL << linepos);
20003384:	2201      	movs	r2, #1
20003386:	69bb      	ldr	r3, [r7, #24]
20003388:	fa02 f303 	lsl.w	r3, r2, r3
2000338c:	617b      	str	r3, [r7, #20]

  /* 1] Clear interrupt mode */
  regaddr = (&EXTI->IMR1 + (EXTI_MODE_OFFSET * offset));
2000338e:	69fb      	ldr	r3, [r7, #28]
20003390:	015b      	lsls	r3, r3, #5
20003392:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
20003396:	f503 3382 	add.w	r3, r3, #66560	; 0x10400
2000339a:	613b      	str	r3, [r7, #16]
  regval = (*regaddr & ~maskline);
2000339c:	693b      	ldr	r3, [r7, #16]
2000339e:	681a      	ldr	r2, [r3, #0]
200033a0:	697b      	ldr	r3, [r7, #20]
200033a2:	43db      	mvns	r3, r3
200033a4:	4013      	ands	r3, r2
200033a6:	60fb      	str	r3, [r7, #12]
  *regaddr = regval;
200033a8:	693b      	ldr	r3, [r7, #16]
200033aa:	68fa      	ldr	r2, [r7, #12]
200033ac:	601a      	str	r2, [r3, #0]

  /* 2] Clear event mode */
  regaddr = (&EXTI->EMR1 + (EXTI_MODE_OFFSET * offset));
200033ae:	69fb      	ldr	r3, [r7, #28]
200033b0:	015a      	lsls	r2, r3, #5
200033b2:	4b2a      	ldr	r3, [pc, #168]	; (2000345c <HAL_EXTI_ClearConfigLine+0x100>)
200033b4:	4413      	add	r3, r2
200033b6:	613b      	str	r3, [r7, #16]
  regval = (*regaddr & ~maskline);
200033b8:	693b      	ldr	r3, [r7, #16]
200033ba:	681a      	ldr	r2, [r3, #0]
200033bc:	697b      	ldr	r3, [r7, #20]
200033be:	43db      	mvns	r3, r3
200033c0:	4013      	ands	r3, r2
200033c2:	60fb      	str	r3, [r7, #12]
  *regaddr = regval;
200033c4:	693b      	ldr	r3, [r7, #16]
200033c6:	68fa      	ldr	r2, [r7, #12]
200033c8:	601a      	str	r2, [r3, #0]

  /* 3] Clear triggers in case of configurable lines */
  if ((hexti->Line & EXTI_CONFIG) != 0x00u)
200033ca:	687b      	ldr	r3, [r7, #4]
200033cc:	681b      	ldr	r3, [r3, #0]
200033ce:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
200033d2:	2b00      	cmp	r3, #0
200033d4:	d03b      	beq.n	2000344e <HAL_EXTI_ClearConfigLine+0xf2>
  {
    regaddr = (&EXTI->RTSR1 + (EXTI_CONFIG_OFFSET * offset));
200033d6:	69fb      	ldr	r3, [r7, #28]
200033d8:	015a      	lsls	r2, r3, #5
200033da:	4b21      	ldr	r3, [pc, #132]	; (20003460 <HAL_EXTI_ClearConfigLine+0x104>)
200033dc:	4413      	add	r3, r2
200033de:	613b      	str	r3, [r7, #16]
    regval = (*regaddr & ~maskline);
200033e0:	693b      	ldr	r3, [r7, #16]
200033e2:	681a      	ldr	r2, [r3, #0]
200033e4:	697b      	ldr	r3, [r7, #20]
200033e6:	43db      	mvns	r3, r3
200033e8:	4013      	ands	r3, r2
200033ea:	60fb      	str	r3, [r7, #12]
    *regaddr = regval;
200033ec:	693b      	ldr	r3, [r7, #16]
200033ee:	68fa      	ldr	r2, [r7, #12]
200033f0:	601a      	str	r2, [r3, #0]

    regaddr = (&EXTI->FTSR1 + (EXTI_CONFIG_OFFSET * offset));
200033f2:	69fb      	ldr	r3, [r7, #28]
200033f4:	015a      	lsls	r2, r3, #5
200033f6:	4b1b      	ldr	r3, [pc, #108]	; (20003464 <HAL_EXTI_ClearConfigLine+0x108>)
200033f8:	4413      	add	r3, r2
200033fa:	613b      	str	r3, [r7, #16]
    regval = (*regaddr & ~maskline);
200033fc:	693b      	ldr	r3, [r7, #16]
200033fe:	681a      	ldr	r2, [r3, #0]
20003400:	697b      	ldr	r3, [r7, #20]
20003402:	43db      	mvns	r3, r3
20003404:	4013      	ands	r3, r2
20003406:	60fb      	str	r3, [r7, #12]
    *regaddr = regval;
20003408:	693b      	ldr	r3, [r7, #16]
2000340a:	68fa      	ldr	r2, [r7, #12]
2000340c:	601a      	str	r2, [r3, #0]

    /* Get Gpio port selection for gpio lines */
    if ((hexti->Line & EXTI_GPIO) == EXTI_GPIO)
2000340e:	687b      	ldr	r3, [r7, #4]
20003410:	681b      	ldr	r3, [r3, #0]
20003412:	f003 63c0 	and.w	r3, r3, #100663296	; 0x6000000
20003416:	f1b3 6fc0 	cmp.w	r3, #100663296	; 0x6000000
2000341a:	d118      	bne.n	2000344e <HAL_EXTI_ClearConfigLine+0xf2>
    {
      assert_param(IS_EXTI_GPIO_PIN(linepos));

      regval = SYSCFG->EXTICR[linepos >> 2u];
2000341c:	4a12      	ldr	r2, [pc, #72]	; (20003468 <HAL_EXTI_ClearConfigLine+0x10c>)
2000341e:	69bb      	ldr	r3, [r7, #24]
20003420:	089b      	lsrs	r3, r3, #2
20003422:	3302      	adds	r3, #2
20003424:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
20003428:	60fb      	str	r3, [r7, #12]
      regval &= ~(SYSCFG_EXTICR1_EXTI0 << (SYSCFG_EXTICR1_EXTI1_Pos * (linepos & 0x03u)));
2000342a:	69bb      	ldr	r3, [r7, #24]
2000342c:	f003 0303 	and.w	r3, r3, #3
20003430:	009b      	lsls	r3, r3, #2
20003432:	2207      	movs	r2, #7
20003434:	fa02 f303 	lsl.w	r3, r2, r3
20003438:	43db      	mvns	r3, r3
2000343a:	68fa      	ldr	r2, [r7, #12]
2000343c:	4013      	ands	r3, r2
2000343e:	60fb      	str	r3, [r7, #12]
      SYSCFG->EXTICR[linepos >> 2u] = regval;
20003440:	4909      	ldr	r1, [pc, #36]	; (20003468 <HAL_EXTI_ClearConfigLine+0x10c>)
20003442:	69bb      	ldr	r3, [r7, #24]
20003444:	089b      	lsrs	r3, r3, #2
20003446:	3302      	adds	r3, #2
20003448:	68fa      	ldr	r2, [r7, #12]
2000344a:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
  }

  return HAL_OK;
2000344e:	2300      	movs	r3, #0
}
20003450:	4618      	mov	r0, r3
20003452:	3724      	adds	r7, #36	; 0x24
20003454:	46bd      	mov	sp, r7
20003456:	f85d 7b04 	ldr.w	r7, [sp], #4
2000345a:	4770      	bx	lr
2000345c:	40010404 	.word	0x40010404
20003460:	40010408 	.word	0x40010408
20003464:	4001040c 	.word	0x4001040c
20003468:	40010000 	.word	0x40010000

2000346c <HAL_EXTI_RegisterCallback>:
  *         This parameter can be one of @arg @ref EXTI_CallbackIDTypeDef values.
  * @param  pPendingCbfn function pointer to be stored as callback.
  * @retval HAL Status.
  */
HAL_StatusTypeDef HAL_EXTI_RegisterCallback(EXTI_HandleTypeDef *hexti, EXTI_CallbackIDTypeDef CallbackID, void (*pPendingCbfn)(void))
{
2000346c:	b480      	push	{r7}
2000346e:	b087      	sub	sp, #28
20003470:	af00      	add	r7, sp, #0
20003472:	60f8      	str	r0, [r7, #12]
20003474:	460b      	mov	r3, r1
20003476:	607a      	str	r2, [r7, #4]
20003478:	72fb      	strb	r3, [r7, #11]
  HAL_StatusTypeDef status = HAL_OK;
2000347a:	2300      	movs	r3, #0
2000347c:	75fb      	strb	r3, [r7, #23]

  /* Check the parameters */
  assert_param(IS_EXTI_CB(CallbackID));

  switch (CallbackID)
2000347e:	7afb      	ldrb	r3, [r7, #11]
20003480:	2b00      	cmp	r3, #0
20003482:	d103      	bne.n	2000348c <HAL_EXTI_RegisterCallback+0x20>
  {
    /* set common callback */
    case  HAL_EXTI_COMMON_CB_ID:
      hexti->PendingCallback = pPendingCbfn;
20003484:	68fb      	ldr	r3, [r7, #12]
20003486:	687a      	ldr	r2, [r7, #4]
20003488:	605a      	str	r2, [r3, #4]
      break;
2000348a:	e005      	b.n	20003498 <HAL_EXTI_RegisterCallback+0x2c>

    default:
      hexti->PendingCallback = NULL;
2000348c:	68fb      	ldr	r3, [r7, #12]
2000348e:	2200      	movs	r2, #0
20003490:	605a      	str	r2, [r3, #4]
      status = HAL_ERROR;
20003492:	2301      	movs	r3, #1
20003494:	75fb      	strb	r3, [r7, #23]
      break;
20003496:	bf00      	nop
  }

  return status;
20003498:	7dfb      	ldrb	r3, [r7, #23]
}
2000349a:	4618      	mov	r0, r3
2000349c:	371c      	adds	r7, #28
2000349e:	46bd      	mov	sp, r7
200034a0:	f85d 7b04 	ldr.w	r7, [sp], #4
200034a4:	4770      	bx	lr

200034a6 <HAL_EXTI_GetHandle>:
  * @param  ExtiLine Exti line number.
  *         This parameter can be from 0 to @ref EXTI_LINE_NB.
  * @retval HAL Status.
  */
HAL_StatusTypeDef HAL_EXTI_GetHandle(EXTI_HandleTypeDef *hexti, uint32_t ExtiLine)
{
200034a6:	b480      	push	{r7}
200034a8:	b083      	sub	sp, #12
200034aa:	af00      	add	r7, sp, #0
200034ac:	6078      	str	r0, [r7, #4]
200034ae:	6039      	str	r1, [r7, #0]
  /* Check the parameters */
  assert_param(IS_EXTI_LINE(ExtiLine));

  /* Check null pointer */
  if (hexti == NULL)
200034b0:	687b      	ldr	r3, [r7, #4]
200034b2:	2b00      	cmp	r3, #0
200034b4:	d101      	bne.n	200034ba <HAL_EXTI_GetHandle+0x14>
  {
    return HAL_ERROR;
200034b6:	2301      	movs	r3, #1
200034b8:	e003      	b.n	200034c2 <HAL_EXTI_GetHandle+0x1c>
  }
  else
  {
    /* Store line number as handle private field */
    hexti->Line = ExtiLine;
200034ba:	687b      	ldr	r3, [r7, #4]
200034bc:	683a      	ldr	r2, [r7, #0]
200034be:	601a      	str	r2, [r3, #0]

    return HAL_OK;
200034c0:	2300      	movs	r3, #0
  }
}
200034c2:	4618      	mov	r0, r3
200034c4:	370c      	adds	r7, #12
200034c6:	46bd      	mov	sp, r7
200034c8:	f85d 7b04 	ldr.w	r7, [sp], #4
200034cc:	4770      	bx	lr
	...

200034d0 <HAL_EXTI_IRQHandler>:
  * @brief  Handle EXTI interrupt request.
  * @param  hexti Exti handle.
  * @retval none.
  */
void HAL_EXTI_IRQHandler(EXTI_HandleTypeDef *hexti)
{
200034d0:	b580      	push	{r7, lr}
200034d2:	b086      	sub	sp, #24
200034d4:	af00      	add	r7, sp, #0
200034d6:	6078      	str	r0, [r7, #4]
  uint32_t regval;
  uint32_t maskline;
  uint32_t offset;

  /* Compute line register offset */
  offset = ((hexti->Line & EXTI_REG_MASK) >> EXTI_REG_SHIFT);
200034d8:	687b      	ldr	r3, [r7, #4]
200034da:	681b      	ldr	r3, [r3, #0]
200034dc:	0c1b      	lsrs	r3, r3, #16
200034de:	f003 0301 	and.w	r3, r3, #1
200034e2:	617b      	str	r3, [r7, #20]
  /* compute line mask */
  maskline = (1uL << (hexti->Line & EXTI_PIN_MASK));
200034e4:	687b      	ldr	r3, [r7, #4]
200034e6:	681b      	ldr	r3, [r3, #0]
200034e8:	f003 031f 	and.w	r3, r3, #31
200034ec:	2201      	movs	r2, #1
200034ee:	fa02 f303 	lsl.w	r3, r2, r3
200034f2:	613b      	str	r3, [r7, #16]

  /* Get pending bit  */
  regaddr = (&EXTI->PR1 + (EXTI_CONFIG_OFFSET * offset));
200034f4:	697b      	ldr	r3, [r7, #20]
200034f6:	015a      	lsls	r2, r3, #5
200034f8:	4b0c      	ldr	r3, [pc, #48]	; (2000352c <HAL_EXTI_IRQHandler+0x5c>)
200034fa:	4413      	add	r3, r2
200034fc:	60fb      	str	r3, [r7, #12]
  regval = (*regaddr & maskline);
200034fe:	68fb      	ldr	r3, [r7, #12]
20003500:	681b      	ldr	r3, [r3, #0]
20003502:	693a      	ldr	r2, [r7, #16]
20003504:	4013      	ands	r3, r2
20003506:	60bb      	str	r3, [r7, #8]

  if (regval != 0x00u)
20003508:	68bb      	ldr	r3, [r7, #8]
2000350a:	2b00      	cmp	r3, #0
2000350c:	d009      	beq.n	20003522 <HAL_EXTI_IRQHandler+0x52>
  {
    /* Clear pending bit */
    *regaddr = maskline;
2000350e:	68fb      	ldr	r3, [r7, #12]
20003510:	693a      	ldr	r2, [r7, #16]
20003512:	601a      	str	r2, [r3, #0]

    /* Call pending callback */
    if (hexti->PendingCallback != NULL)
20003514:	687b      	ldr	r3, [r7, #4]
20003516:	685b      	ldr	r3, [r3, #4]
20003518:	2b00      	cmp	r3, #0
2000351a:	d002      	beq.n	20003522 <HAL_EXTI_IRQHandler+0x52>
    {
      hexti->PendingCallback();
2000351c:	687b      	ldr	r3, [r7, #4]
2000351e:	685b      	ldr	r3, [r3, #4]
20003520:	4798      	blx	r3
    }
  }
}
20003522:	bf00      	nop
20003524:	3718      	adds	r7, #24
20003526:	46bd      	mov	sp, r7
20003528:	bd80      	pop	{r7, pc}
2000352a:	bf00      	nop
2000352c:	40010414 	.word	0x40010414

20003530 <HAL_EXTI_GetPending>:
  * @param  hexti Exti handle.
  * @param  Edge unused
  * @retval 1 if interrupt is pending else 0.
  */
uint32_t HAL_EXTI_GetPending(EXTI_HandleTypeDef *hexti, uint32_t Edge)
{
20003530:	b480      	push	{r7}
20003532:	b089      	sub	sp, #36	; 0x24
20003534:	af00      	add	r7, sp, #0
20003536:	6078      	str	r0, [r7, #4]
20003538:	6039      	str	r1, [r7, #0]
  assert_param(IS_EXTI_LINE(hexti->Line));
  assert_param(IS_EXTI_CONFIG_LINE(hexti->Line));
  UNUSED(Edge);

  /* Compute line register offset */
  offset = ((hexti->Line & EXTI_REG_MASK) >> EXTI_REG_SHIFT);
2000353a:	687b      	ldr	r3, [r7, #4]
2000353c:	681b      	ldr	r3, [r3, #0]
2000353e:	0c1b      	lsrs	r3, r3, #16
20003540:	f003 0301 	and.w	r3, r3, #1
20003544:	61fb      	str	r3, [r7, #28]
  /* Compute line position */
  linepos = (hexti->Line & EXTI_PIN_MASK);
20003546:	687b      	ldr	r3, [r7, #4]
20003548:	681b      	ldr	r3, [r3, #0]
2000354a:	f003 031f 	and.w	r3, r3, #31
2000354e:	61bb      	str	r3, [r7, #24]
  /* Compute line mask */
  maskline = (1uL << linepos);
20003550:	2201      	movs	r2, #1
20003552:	69bb      	ldr	r3, [r7, #24]
20003554:	fa02 f303 	lsl.w	r3, r2, r3
20003558:	617b      	str	r3, [r7, #20]

  /* Get pending bit */
  regaddr = (&EXTI->PR1 + (EXTI_CONFIG_OFFSET * offset));
2000355a:	69fb      	ldr	r3, [r7, #28]
2000355c:	015a      	lsls	r2, r3, #5
2000355e:	4b09      	ldr	r3, [pc, #36]	; (20003584 <HAL_EXTI_GetPending+0x54>)
20003560:	4413      	add	r3, r2
20003562:	613b      	str	r3, [r7, #16]

  /* return 1 if bit is set else 0 */
  regval = ((*regaddr & maskline) >> linepos);
20003564:	693b      	ldr	r3, [r7, #16]
20003566:	681a      	ldr	r2, [r3, #0]
20003568:	697b      	ldr	r3, [r7, #20]
2000356a:	401a      	ands	r2, r3
2000356c:	69bb      	ldr	r3, [r7, #24]
2000356e:	fa22 f303 	lsr.w	r3, r2, r3
20003572:	60fb      	str	r3, [r7, #12]
  return regval;
20003574:	68fb      	ldr	r3, [r7, #12]
}
20003576:	4618      	mov	r0, r3
20003578:	3724      	adds	r7, #36	; 0x24
2000357a:	46bd      	mov	sp, r7
2000357c:	f85d 7b04 	ldr.w	r7, [sp], #4
20003580:	4770      	bx	lr
20003582:	bf00      	nop
20003584:	40010414 	.word	0x40010414

20003588 <HAL_EXTI_ClearPending>:
  * @param  hexti Exti handle.
  * @param  Edge unused
  * @retval None.
  */
void HAL_EXTI_ClearPending(EXTI_HandleTypeDef *hexti, uint32_t Edge)
{
20003588:	b480      	push	{r7}
2000358a:	b087      	sub	sp, #28
2000358c:	af00      	add	r7, sp, #0
2000358e:	6078      	str	r0, [r7, #4]
20003590:	6039      	str	r1, [r7, #0]
  assert_param(IS_EXTI_LINE(hexti->Line));
  assert_param(IS_EXTI_CONFIG_LINE(hexti->Line));
  UNUSED(Edge);

  /* Compute line register offset */
  offset = ((hexti->Line & EXTI_REG_MASK) >> EXTI_REG_SHIFT);
20003592:	687b      	ldr	r3, [r7, #4]
20003594:	681b      	ldr	r3, [r3, #0]
20003596:	0c1b      	lsrs	r3, r3, #16
20003598:	f003 0301 	and.w	r3, r3, #1
2000359c:	617b      	str	r3, [r7, #20]
  /* Compute line mask */
  maskline = (1uL << (hexti->Line & EXTI_PIN_MASK));
2000359e:	687b      	ldr	r3, [r7, #4]
200035a0:	681b      	ldr	r3, [r3, #0]
200035a2:	f003 031f 	and.w	r3, r3, #31
200035a6:	2201      	movs	r2, #1
200035a8:	fa02 f303 	lsl.w	r3, r2, r3
200035ac:	613b      	str	r3, [r7, #16]

  /* Get pending register address */
  regaddr = (&EXTI->PR1 + (EXTI_CONFIG_OFFSET * offset));
200035ae:	697b      	ldr	r3, [r7, #20]
200035b0:	015a      	lsls	r2, r3, #5
200035b2:	4b06      	ldr	r3, [pc, #24]	; (200035cc <HAL_EXTI_ClearPending+0x44>)
200035b4:	4413      	add	r3, r2
200035b6:	60fb      	str	r3, [r7, #12]

  /* Clear Pending bit */
  *regaddr =  maskline;
200035b8:	68fb      	ldr	r3, [r7, #12]
200035ba:	693a      	ldr	r2, [r7, #16]
200035bc:	601a      	str	r2, [r3, #0]
}
200035be:	bf00      	nop
200035c0:	371c      	adds	r7, #28
200035c2:	46bd      	mov	sp, r7
200035c4:	f85d 7b04 	ldr.w	r7, [sp], #4
200035c8:	4770      	bx	lr
200035ca:	bf00      	nop
200035cc:	40010414 	.word	0x40010414

200035d0 <HAL_EXTI_GenerateSWI>:
  * @brief  Generate a software interrupt for a dedicated line.
  * @param  hexti Exti handle.
  * @retval None.
  */
void HAL_EXTI_GenerateSWI(EXTI_HandleTypeDef *hexti)
{
200035d0:	b480      	push	{r7}
200035d2:	b087      	sub	sp, #28
200035d4:	af00      	add	r7, sp, #0
200035d6:	6078      	str	r0, [r7, #4]
  /* Check parameter */
  assert_param(IS_EXTI_LINE(hexti->Line));
  assert_param(IS_EXTI_CONFIG_LINE(hexti->Line));

  /* compute line register offset */
  offset = ((hexti->Line & EXTI_REG_MASK) >> EXTI_REG_SHIFT);
200035d8:	687b      	ldr	r3, [r7, #4]
200035da:	681b      	ldr	r3, [r3, #0]
200035dc:	0c1b      	lsrs	r3, r3, #16
200035de:	f003 0301 	and.w	r3, r3, #1
200035e2:	617b      	str	r3, [r7, #20]
  /* compute line mask */
  maskline = (1uL << (hexti->Line & EXTI_PIN_MASK));
200035e4:	687b      	ldr	r3, [r7, #4]
200035e6:	681b      	ldr	r3, [r3, #0]
200035e8:	f003 031f 	and.w	r3, r3, #31
200035ec:	2201      	movs	r2, #1
200035ee:	fa02 f303 	lsl.w	r3, r2, r3
200035f2:	613b      	str	r3, [r7, #16]

  regaddr = (&EXTI->SWIER1 + (EXTI_CONFIG_OFFSET * offset));
200035f4:	697b      	ldr	r3, [r7, #20]
200035f6:	015a      	lsls	r2, r3, #5
200035f8:	4b05      	ldr	r3, [pc, #20]	; (20003610 <HAL_EXTI_GenerateSWI+0x40>)
200035fa:	4413      	add	r3, r2
200035fc:	60fb      	str	r3, [r7, #12]
  *regaddr = maskline;
200035fe:	68fb      	ldr	r3, [r7, #12]
20003600:	693a      	ldr	r2, [r7, #16]
20003602:	601a      	str	r2, [r3, #0]
}
20003604:	bf00      	nop
20003606:	371c      	adds	r7, #28
20003608:	46bd      	mov	sp, r7
2000360a:	f85d 7b04 	ldr.w	r7, [sp], #4
2000360e:	4770      	bx	lr
20003610:	40010410 	.word	0x40010410

20003614 <HAL_FLASH_Program>:
  *         are stored the data for the row fast program.
  *
  * @retval HAL_Status
  */
HAL_StatusTypeDef HAL_FLASH_Program(uint32_t TypeProgram, uint32_t Address, uint64_t Data)
{
20003614:	b580      	push	{r7, lr}
20003616:	b086      	sub	sp, #24
20003618:	af00      	add	r7, sp, #0
2000361a:	60f8      	str	r0, [r7, #12]
2000361c:	60b9      	str	r1, [r7, #8]
2000361e:	e9c7 2300 	strd	r2, r3, [r7]
  HAL_StatusTypeDef status;
  uint32_t prog_bit = 0;
20003622:	2300      	movs	r3, #0
20003624:	613b      	str	r3, [r7, #16]

  /* Check the parameters */
  assert_param(IS_FLASH_TYPEPROGRAM(TypeProgram));

  /* Process Locked */
  __HAL_LOCK(&pFlash);
20003626:	4b24      	ldr	r3, [pc, #144]	; (200036b8 <HAL_FLASH_Program+0xa4>)
20003628:	781b      	ldrb	r3, [r3, #0]
2000362a:	2b01      	cmp	r3, #1
2000362c:	d101      	bne.n	20003632 <HAL_FLASH_Program+0x1e>
2000362e:	2302      	movs	r3, #2
20003630:	e03e      	b.n	200036b0 <HAL_FLASH_Program+0x9c>
20003632:	4b21      	ldr	r3, [pc, #132]	; (200036b8 <HAL_FLASH_Program+0xa4>)
20003634:	2201      	movs	r2, #1
20003636:	701a      	strb	r2, [r3, #0]

  /* Wait for last operation to be completed */
  status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
20003638:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
2000363c:	f000 fa14 	bl	20003a68 <FLASH_WaitForLastOperation>
20003640:	4603      	mov	r3, r0
20003642:	75fb      	strb	r3, [r7, #23]

  if (status == HAL_OK)
20003644:	7dfb      	ldrb	r3, [r7, #23]
20003646:	2b00      	cmp	r3, #0
20003648:	d12e      	bne.n	200036a8 <HAL_FLASH_Program+0x94>
  {
    pFlash.ErrorCode = HAL_FLASH_ERROR_NONE;
2000364a:	4b1b      	ldr	r3, [pc, #108]	; (200036b8 <HAL_FLASH_Program+0xa4>)
2000364c:	2200      	movs	r2, #0
2000364e:	605a      	str	r2, [r3, #4]

    if (TypeProgram == FLASH_TYPEPROGRAM_DOUBLEWORD)
20003650:	68fb      	ldr	r3, [r7, #12]
20003652:	2b00      	cmp	r3, #0
20003654:	d107      	bne.n	20003666 <HAL_FLASH_Program+0x52>
    {
      /* Program double-word (64-bit) at a specified address */
      FLASH_Program_DoubleWord(Address, Data);
20003656:	e9d7 2300 	ldrd	r2, r3, [r7]
2000365a:	68b8      	ldr	r0, [r7, #8]
2000365c:	f000 fa58 	bl	20003b10 <FLASH_Program_DoubleWord>
      prog_bit = FLASH_CR_PG;
20003660:	2301      	movs	r3, #1
20003662:	613b      	str	r3, [r7, #16]
20003664:	e010      	b.n	20003688 <HAL_FLASH_Program+0x74>
    }
    else if ((TypeProgram == FLASH_TYPEPROGRAM_FAST) || (TypeProgram == FLASH_TYPEPROGRAM_FAST_AND_LAST))
20003666:	68fb      	ldr	r3, [r7, #12]
20003668:	2b01      	cmp	r3, #1
2000366a:	d002      	beq.n	20003672 <HAL_FLASH_Program+0x5e>
2000366c:	68fb      	ldr	r3, [r7, #12]
2000366e:	2b02      	cmp	r3, #2
20003670:	d10a      	bne.n	20003688 <HAL_FLASH_Program+0x74>
    {
      /* Fast program a 32 row double-word (64-bit) at a specified address */
      FLASH_Program_Fast(Address, (uint32_t)Data);
20003672:	683b      	ldr	r3, [r7, #0]
20003674:	4619      	mov	r1, r3
20003676:	68b8      	ldr	r0, [r7, #8]
20003678:	f000 fa70 	bl	20003b5c <FLASH_Program_Fast>

      /* If it is the last row, the bit will be cleared at the end of the operation */
      if (TypeProgram == FLASH_TYPEPROGRAM_FAST_AND_LAST)
2000367c:	68fb      	ldr	r3, [r7, #12]
2000367e:	2b02      	cmp	r3, #2
20003680:	d102      	bne.n	20003688 <HAL_FLASH_Program+0x74>
      {
        prog_bit = FLASH_CR_FSTPG;
20003682:	f44f 2380 	mov.w	r3, #262144	; 0x40000
20003686:	613b      	str	r3, [r7, #16]
    {
      /* Nothing to do */
    }

    /* Wait for last operation to be completed */
    status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
20003688:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
2000368c:	f000 f9ec 	bl	20003a68 <FLASH_WaitForLastOperation>
20003690:	4603      	mov	r3, r0
20003692:	75fb      	strb	r3, [r7, #23]

    /* If the program operation is completed, disable the PG or FSTPG Bit */
    if (prog_bit != 0U)
20003694:	693b      	ldr	r3, [r7, #16]
20003696:	2b00      	cmp	r3, #0
20003698:	d006      	beq.n	200036a8 <HAL_FLASH_Program+0x94>
    {
      CLEAR_BIT(FLASH->CR, prog_bit);
2000369a:	4b08      	ldr	r3, [pc, #32]	; (200036bc <HAL_FLASH_Program+0xa8>)
2000369c:	695a      	ldr	r2, [r3, #20]
2000369e:	693b      	ldr	r3, [r7, #16]
200036a0:	43db      	mvns	r3, r3
200036a2:	4906      	ldr	r1, [pc, #24]	; (200036bc <HAL_FLASH_Program+0xa8>)
200036a4:	4013      	ands	r3, r2
200036a6:	614b      	str	r3, [r1, #20]
    }
  }

  /* Process Unlocked */
  __HAL_UNLOCK(&pFlash);
200036a8:	4b03      	ldr	r3, [pc, #12]	; (200036b8 <HAL_FLASH_Program+0xa4>)
200036aa:	2200      	movs	r2, #0
200036ac:	701a      	strb	r2, [r3, #0]

  /* return status */
  return status;
200036ae:	7dfb      	ldrb	r3, [r7, #23]
}
200036b0:	4618      	mov	r0, r3
200036b2:	3718      	adds	r7, #24
200036b4:	46bd      	mov	sp, r7
200036b6:	bd80      	pop	{r7, pc}
200036b8:	200003fc 	.word	0x200003fc
200036bc:	40022000 	.word	0x40022000

200036c0 <HAL_FLASH_Program_IT>:
  *         are stored the data for the row fast program.
  *
  * @retval HAL_Status
  */
HAL_StatusTypeDef HAL_FLASH_Program_IT(uint32_t TypeProgram, uint32_t Address, uint64_t Data)
{
200036c0:	b580      	push	{r7, lr}
200036c2:	b086      	sub	sp, #24
200036c4:	af00      	add	r7, sp, #0
200036c6:	60f8      	str	r0, [r7, #12]
200036c8:	60b9      	str	r1, [r7, #8]
200036ca:	e9c7 2300 	strd	r2, r3, [r7]

  /* Check the parameters */
  assert_param(IS_FLASH_TYPEPROGRAM(TypeProgram));

  /* Process Locked */
  __HAL_LOCK(&pFlash);
200036ce:	4b22      	ldr	r3, [pc, #136]	; (20003758 <HAL_FLASH_Program_IT+0x98>)
200036d0:	781b      	ldrb	r3, [r3, #0]
200036d2:	2b01      	cmp	r3, #1
200036d4:	d101      	bne.n	200036da <HAL_FLASH_Program_IT+0x1a>
200036d6:	2302      	movs	r3, #2
200036d8:	e03a      	b.n	20003750 <HAL_FLASH_Program_IT+0x90>
200036da:	4b1f      	ldr	r3, [pc, #124]	; (20003758 <HAL_FLASH_Program_IT+0x98>)
200036dc:	2201      	movs	r2, #1
200036de:	701a      	strb	r2, [r3, #0]

  /* Reset error code */
  pFlash.ErrorCode = HAL_FLASH_ERROR_NONE;
200036e0:	4b1d      	ldr	r3, [pc, #116]	; (20003758 <HAL_FLASH_Program_IT+0x98>)
200036e2:	2200      	movs	r2, #0
200036e4:	605a      	str	r2, [r3, #4]

  /* Wait for last operation to be completed */
  status = FLASH_WaitForLastOperation(FLASH_TIMEOUT_VALUE);
200036e6:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
200036ea:	f000 f9bd 	bl	20003a68 <FLASH_WaitForLastOperation>
200036ee:	4603      	mov	r3, r0
200036f0:	75fb      	strb	r3, [r7, #23]

  if (status != HAL_OK)
200036f2:	7dfb      	ldrb	r3, [r7, #23]
200036f4:	2b00      	cmp	r3, #0
200036f6:	d003      	beq.n	20003700 <HAL_FLASH_Program_IT+0x40>
  {
    /* Process Unlocked */
    __HAL_UNLOCK(&pFlash);
200036f8:	4b17      	ldr	r3, [pc, #92]	; (20003758 <HAL_FLASH_Program_IT+0x98>)
200036fa:	2200      	movs	r2, #0
200036fc:	701a      	strb	r2, [r3, #0]
200036fe:	e026      	b.n	2000374e <HAL_FLASH_Program_IT+0x8e>
  }
  else
  {
    /* Set internal variables used by the IRQ handler */
    if (TypeProgram == FLASH_TYPEPROGRAM_FAST_AND_LAST)
20003700:	68fb      	ldr	r3, [r7, #12]
20003702:	2b02      	cmp	r3, #2
20003704:	d103      	bne.n	2000370e <HAL_FLASH_Program_IT+0x4e>
    {
      pFlash.ProcedureOnGoing = FLASH_PROC_PROGRAM_LAST;
20003706:	4b14      	ldr	r3, [pc, #80]	; (20003758 <HAL_FLASH_Program_IT+0x98>)
20003708:	2204      	movs	r2, #4
2000370a:	721a      	strb	r2, [r3, #8]
2000370c:	e002      	b.n	20003714 <HAL_FLASH_Program_IT+0x54>
    }
    else
    {
      pFlash.ProcedureOnGoing = FLASH_PROC_PROGRAM;
2000370e:	4b12      	ldr	r3, [pc, #72]	; (20003758 <HAL_FLASH_Program_IT+0x98>)
20003710:	2203      	movs	r2, #3
20003712:	721a      	strb	r2, [r3, #8]
    }
    pFlash.Address = Address;
20003714:	4a10      	ldr	r2, [pc, #64]	; (20003758 <HAL_FLASH_Program_IT+0x98>)
20003716:	68bb      	ldr	r3, [r7, #8]
20003718:	60d3      	str	r3, [r2, #12]

    /* Enable End of Operation and Error interrupts */
    __HAL_FLASH_ENABLE_IT(FLASH_IT_EOP | FLASH_IT_OPERR);
2000371a:	4b10      	ldr	r3, [pc, #64]	; (2000375c <HAL_FLASH_Program_IT+0x9c>)
2000371c:	695b      	ldr	r3, [r3, #20]
2000371e:	4a0f      	ldr	r2, [pc, #60]	; (2000375c <HAL_FLASH_Program_IT+0x9c>)
20003720:	f043 7340 	orr.w	r3, r3, #50331648	; 0x3000000
20003724:	6153      	str	r3, [r2, #20]

    if (TypeProgram == FLASH_TYPEPROGRAM_DOUBLEWORD)
20003726:	68fb      	ldr	r3, [r7, #12]
20003728:	2b00      	cmp	r3, #0
2000372a:	d105      	bne.n	20003738 <HAL_FLASH_Program_IT+0x78>
    {
      /* Program double-word (64-bit) at a specified address */
      FLASH_Program_DoubleWord(Address, Data);
2000372c:	e9d7 2300 	ldrd	r2, r3, [r7]
20003730:	68b8      	ldr	r0, [r7, #8]
20003732:	f000 f9ed 	bl	20003b10 <FLASH_Program_DoubleWord>
20003736:	e00a      	b.n	2000374e <HAL_FLASH_Program_IT+0x8e>
    }
    else if ((TypeProgram == FLASH_TYPEPROGRAM_FAST) || (TypeProgram == FLASH_TYPEPROGRAM_FAST_AND_LAST))
20003738:	68fb      	ldr	r3, [r7, #12]
2000373a:	2b01      	cmp	r3, #1
2000373c:	d002      	beq.n	20003744 <HAL_FLASH_Program_IT+0x84>
2000373e:	68fb      	ldr	r3, [r7, #12]
20003740:	2b02      	cmp	r3, #2
20003742:	d104      	bne.n	2000374e <HAL_FLASH_Program_IT+0x8e>
    {
      /* Fast program a 32 row double-word (64-bit) at a specified address */
      FLASH_Program_Fast(Address, (uint32_t)Data);
20003744:	683b      	ldr	r3, [r7, #0]
20003746:	4619      	mov	r1, r3
20003748:	68b8      	ldr	r0, [r7, #8]
2000374a:	f000 fa07 	bl	20003b5c <FLASH_Program_Fast>
    {
      /* Nothing to do */
    }
  }

  return status;
2000374e:	7dfb      	ldrb	r3, [r7, #23]
}
20003750:	4618      	mov	r0, r3
20003752:	3718      	adds	r7, #24
20003754:	46bd      	mov	sp, r7
20003756:	bd80      	pop	{r7, pc}
20003758:	200003fc 	.word	0x200003fc
2000375c:	40022000 	.word	0x40022000

20003760 <HAL_FLASH_IRQHandler>:
/**
  * @brief  Handle FLASH interrupt request.
  * @retval None
  */
void HAL_FLASH_IRQHandler(void)
{
20003760:	b580      	push	{r7, lr}
20003762:	b084      	sub	sp, #16
20003764:	af00      	add	r7, sp, #0
  uint32_t tmp_page;
  uint32_t error;
  FLASH_ProcedureTypeDef procedure;

  /* If the operation is completed, disable the PG, PNB, MER1, MER2 and PER Bit */
  CLEAR_BIT(FLASH->CR, (FLASH_CR_PG | FLASH_CR_MER1 | FLASH_CR_PER | FLASH_CR_PNB));
20003766:	4b66      	ldr	r3, [pc, #408]	; (20003900 <HAL_FLASH_IRQHandler+0x1a0>)
20003768:	695b      	ldr	r3, [r3, #20]
2000376a:	4a65      	ldr	r2, [pc, #404]	; (20003900 <HAL_FLASH_IRQHandler+0x1a0>)
2000376c:	f423 737f 	bic.w	r3, r3, #1020	; 0x3fc
20003770:	f023 0303 	bic.w	r3, r3, #3
20003774:	6153      	str	r3, [r2, #20]
#if defined (FLASH_OPTR_DBANK)
  CLEAR_BIT(FLASH->CR, FLASH_CR_MER2);
20003776:	4b62      	ldr	r3, [pc, #392]	; (20003900 <HAL_FLASH_IRQHandler+0x1a0>)
20003778:	695b      	ldr	r3, [r3, #20]
2000377a:	4a61      	ldr	r2, [pc, #388]	; (20003900 <HAL_FLASH_IRQHandler+0x1a0>)
2000377c:	f423 4300 	bic.w	r3, r3, #32768	; 0x8000
20003780:	6153      	str	r3, [r2, #20]
#endif

  /* Disable the FSTPG Bit only if it is the last row programmed */
  if (pFlash.ProcedureOnGoing == FLASH_PROC_PROGRAM_LAST)
20003782:	4b60      	ldr	r3, [pc, #384]	; (20003904 <HAL_FLASH_IRQHandler+0x1a4>)
20003784:	7a1b      	ldrb	r3, [r3, #8]
20003786:	b2db      	uxtb	r3, r3
20003788:	2b04      	cmp	r3, #4
2000378a:	d105      	bne.n	20003798 <HAL_FLASH_IRQHandler+0x38>
  {
    CLEAR_BIT(FLASH->CR, FLASH_CR_FSTPG);
2000378c:	4b5c      	ldr	r3, [pc, #368]	; (20003900 <HAL_FLASH_IRQHandler+0x1a0>)
2000378e:	695b      	ldr	r3, [r3, #20]
20003790:	4a5b      	ldr	r2, [pc, #364]	; (20003900 <HAL_FLASH_IRQHandler+0x1a0>)
20003792:	f423 2380 	bic.w	r3, r3, #262144	; 0x40000
20003796:	6153      	str	r3, [r2, #20]
  }

  /* Check FLASH operation error flags */
  error = (FLASH->SR & FLASH_FLAG_SR_ERRORS);
20003798:	4b59      	ldr	r3, [pc, #356]	; (20003900 <HAL_FLASH_IRQHandler+0x1a0>)
2000379a:	691a      	ldr	r2, [r3, #16]
2000379c:	f24c 33fa 	movw	r3, #50170	; 0xc3fa
200037a0:	4013      	ands	r3, r2
200037a2:	60fb      	str	r3, [r7, #12]

  if (error != 0U)
200037a4:	68fb      	ldr	r3, [r7, #12]
200037a6:	2b00      	cmp	r3, #0
200037a8:	d041      	beq.n	2000382e <HAL_FLASH_IRQHandler+0xce>
  {
    /* Save the error code */
    pFlash.ErrorCode |= error;
200037aa:	4b56      	ldr	r3, [pc, #344]	; (20003904 <HAL_FLASH_IRQHandler+0x1a4>)
200037ac:	685a      	ldr	r2, [r3, #4]
200037ae:	68fb      	ldr	r3, [r7, #12]
200037b0:	4313      	orrs	r3, r2
200037b2:	4a54      	ldr	r2, [pc, #336]	; (20003904 <HAL_FLASH_IRQHandler+0x1a4>)
200037b4:	6053      	str	r3, [r2, #4]

    /* Clear error programming flags */
    __HAL_FLASH_CLEAR_FLAG(error);
200037b6:	68fb      	ldr	r3, [r7, #12]
200037b8:	f003 4370 	and.w	r3, r3, #4026531840	; 0xf0000000
200037bc:	2b00      	cmp	r3, #0
200037be:	d007      	beq.n	200037d0 <HAL_FLASH_IRQHandler+0x70>
200037c0:	4b4f      	ldr	r3, [pc, #316]	; (20003900 <HAL_FLASH_IRQHandler+0x1a0>)
200037c2:	699a      	ldr	r2, [r3, #24]
200037c4:	68fb      	ldr	r3, [r7, #12]
200037c6:	f003 4370 	and.w	r3, r3, #4026531840	; 0xf0000000
200037ca:	494d      	ldr	r1, [pc, #308]	; (20003900 <HAL_FLASH_IRQHandler+0x1a0>)
200037cc:	4313      	orrs	r3, r2
200037ce:	618b      	str	r3, [r1, #24]
200037d0:	68fb      	ldr	r3, [r7, #12]
200037d2:	f023 4370 	bic.w	r3, r3, #4026531840	; 0xf0000000
200037d6:	2b00      	cmp	r3, #0
200037d8:	d004      	beq.n	200037e4 <HAL_FLASH_IRQHandler+0x84>
200037da:	4a49      	ldr	r2, [pc, #292]	; (20003900 <HAL_FLASH_IRQHandler+0x1a0>)
200037dc:	68fb      	ldr	r3, [r7, #12]
200037de:	f023 4370 	bic.w	r3, r3, #4026531840	; 0xf0000000
200037e2:	6113      	str	r3, [r2, #16]

    /* Flush the caches to be sure of the data consistency */
    FLASH_FlushCaches() ;
200037e4:	f000 fcd6 	bl	20004194 <FLASH_FlushCaches>

    /* FLASH error interrupt user callback */
    procedure = pFlash.ProcedureOnGoing;
200037e8:	4b46      	ldr	r3, [pc, #280]	; (20003904 <HAL_FLASH_IRQHandler+0x1a4>)
200037ea:	7a1b      	ldrb	r3, [r3, #8]
200037ec:	72fb      	strb	r3, [r7, #11]
    if (procedure == FLASH_PROC_PAGE_ERASE)
200037ee:	7afb      	ldrb	r3, [r7, #11]
200037f0:	2b01      	cmp	r3, #1
200037f2:	d105      	bne.n	20003800 <HAL_FLASH_IRQHandler+0xa0>
    {
      HAL_FLASH_OperationErrorCallback(pFlash.Page);
200037f4:	4b43      	ldr	r3, [pc, #268]	; (20003904 <HAL_FLASH_IRQHandler+0x1a4>)
200037f6:	695b      	ldr	r3, [r3, #20]
200037f8:	4618      	mov	r0, r3
200037fa:	f000 f88f 	bl	2000391c <HAL_FLASH_OperationErrorCallback>
200037fe:	e013      	b.n	20003828 <HAL_FLASH_IRQHandler+0xc8>
    }
    else if (procedure == FLASH_PROC_MASS_ERASE)
20003800:	7afb      	ldrb	r3, [r7, #11]
20003802:	2b02      	cmp	r3, #2
20003804:	d105      	bne.n	20003812 <HAL_FLASH_IRQHandler+0xb2>
    {
      HAL_FLASH_OperationErrorCallback(pFlash.Bank);
20003806:	4b3f      	ldr	r3, [pc, #252]	; (20003904 <HAL_FLASH_IRQHandler+0x1a4>)
20003808:	691b      	ldr	r3, [r3, #16]
2000380a:	4618      	mov	r0, r3
2000380c:	f000 f886 	bl	2000391c <HAL_FLASH_OperationErrorCallback>
20003810:	e00a      	b.n	20003828 <HAL_FLASH_IRQHandler+0xc8>
    }
    else if ((procedure == FLASH_PROC_PROGRAM) ||
20003812:	7afb      	ldrb	r3, [r7, #11]
20003814:	2b03      	cmp	r3, #3
20003816:	d002      	beq.n	2000381e <HAL_FLASH_IRQHandler+0xbe>
20003818:	7afb      	ldrb	r3, [r7, #11]
2000381a:	2b04      	cmp	r3, #4
2000381c:	d104      	bne.n	20003828 <HAL_FLASH_IRQHandler+0xc8>
             (procedure == FLASH_PROC_PROGRAM_LAST))
    {
      HAL_FLASH_OperationErrorCallback(pFlash.Address);
2000381e:	4b39      	ldr	r3, [pc, #228]	; (20003904 <HAL_FLASH_IRQHandler+0x1a4>)
20003820:	68db      	ldr	r3, [r3, #12]
20003822:	4618      	mov	r0, r3
20003824:	f000 f87a 	bl	2000391c <HAL_FLASH_OperationErrorCallback>
    {
      /* Nothing to do */
    }

    /*Stop the procedure ongoing*/
    pFlash.ProcedureOnGoing = FLASH_PROC_NONE;
20003828:	4b36      	ldr	r3, [pc, #216]	; (20003904 <HAL_FLASH_IRQHandler+0x1a4>)
2000382a:	2200      	movs	r2, #0
2000382c:	721a      	strb	r2, [r3, #8]
  }

  /* Check FLASH End of Operation flag  */
  if (__HAL_FLASH_GET_FLAG(FLASH_FLAG_EOP))
2000382e:	4b34      	ldr	r3, [pc, #208]	; (20003900 <HAL_FLASH_IRQHandler+0x1a0>)
20003830:	691b      	ldr	r3, [r3, #16]
20003832:	f003 0301 	and.w	r3, r3, #1
20003836:	2b01      	cmp	r3, #1
20003838:	d14f      	bne.n	200038da <HAL_FLASH_IRQHandler+0x17a>
  {
    /* Clear FLASH End of Operation pending bit */
    __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_EOP);
2000383a:	4b31      	ldr	r3, [pc, #196]	; (20003900 <HAL_FLASH_IRQHandler+0x1a0>)
2000383c:	2201      	movs	r2, #1
2000383e:	611a      	str	r2, [r3, #16]

    if (pFlash.ProcedureOnGoing == FLASH_PROC_PAGE_ERASE)
20003840:	4b30      	ldr	r3, [pc, #192]	; (20003904 <HAL_FLASH_IRQHandler+0x1a4>)
20003842:	7a1b      	ldrb	r3, [r3, #8]
20003844:	b2db      	uxtb	r3, r3
20003846:	2b01      	cmp	r3, #1
20003848:	d12b      	bne.n	200038a2 <HAL_FLASH_IRQHandler+0x142>
    {
      /* Nb of pages to erased can be decreased */
      pFlash.NbPagesToErase--;
2000384a:	4b2e      	ldr	r3, [pc, #184]	; (20003904 <HAL_FLASH_IRQHandler+0x1a4>)
2000384c:	699b      	ldr	r3, [r3, #24]
2000384e:	3b01      	subs	r3, #1
20003850:	4a2c      	ldr	r2, [pc, #176]	; (20003904 <HAL_FLASH_IRQHandler+0x1a4>)
20003852:	6193      	str	r3, [r2, #24]

      /* Check if there are still pages to erase*/
      if (pFlash.NbPagesToErase != 0U)
20003854:	4b2b      	ldr	r3, [pc, #172]	; (20003904 <HAL_FLASH_IRQHandler+0x1a4>)
20003856:	699b      	ldr	r3, [r3, #24]
20003858:	2b00      	cmp	r3, #0
2000385a:	d013      	beq.n	20003884 <HAL_FLASH_IRQHandler+0x124>
      {
        /* Indicate user which page has been erased*/
        HAL_FLASH_EndOfOperationCallback(pFlash.Page);
2000385c:	4b29      	ldr	r3, [pc, #164]	; (20003904 <HAL_FLASH_IRQHandler+0x1a4>)
2000385e:	695b      	ldr	r3, [r3, #20]
20003860:	4618      	mov	r0, r3
20003862:	f000 f851 	bl	20003908 <HAL_FLASH_EndOfOperationCallback>

        /* Increment page number */
        pFlash.Page++;
20003866:	4b27      	ldr	r3, [pc, #156]	; (20003904 <HAL_FLASH_IRQHandler+0x1a4>)
20003868:	695b      	ldr	r3, [r3, #20]
2000386a:	3301      	adds	r3, #1
2000386c:	4a25      	ldr	r2, [pc, #148]	; (20003904 <HAL_FLASH_IRQHandler+0x1a4>)
2000386e:	6153      	str	r3, [r2, #20]
        tmp_page = pFlash.Page;
20003870:	4b24      	ldr	r3, [pc, #144]	; (20003904 <HAL_FLASH_IRQHandler+0x1a4>)
20003872:	695b      	ldr	r3, [r3, #20]
20003874:	607b      	str	r3, [r7, #4]
        FLASH_PageErase(tmp_page, pFlash.Bank);
20003876:	4b23      	ldr	r3, [pc, #140]	; (20003904 <HAL_FLASH_IRQHandler+0x1a4>)
20003878:	691b      	ldr	r3, [r3, #16]
2000387a:	4619      	mov	r1, r3
2000387c:	6878      	ldr	r0, [r7, #4]
2000387e:	f000 fc45 	bl	2000410c <FLASH_PageErase>
20003882:	e02a      	b.n	200038da <HAL_FLASH_IRQHandler+0x17a>
      }
      else
      {
        /* No more pages to Erase */
        /* Reset Address and stop Erase pages procedure */
        pFlash.Page = 0xFFFFFFFFU;
20003884:	4b1f      	ldr	r3, [pc, #124]	; (20003904 <HAL_FLASH_IRQHandler+0x1a4>)
20003886:	f04f 32ff 	mov.w	r2, #4294967295
2000388a:	615a      	str	r2, [r3, #20]
        pFlash.ProcedureOnGoing = FLASH_PROC_NONE;
2000388c:	4b1d      	ldr	r3, [pc, #116]	; (20003904 <HAL_FLASH_IRQHandler+0x1a4>)
2000388e:	2200      	movs	r2, #0
20003890:	721a      	strb	r2, [r3, #8]

        /* Flush the caches to be sure of the data consistency */
        FLASH_FlushCaches() ;
20003892:	f000 fc7f 	bl	20004194 <FLASH_FlushCaches>

        /* FLASH EOP interrupt user callback */
        HAL_FLASH_EndOfOperationCallback(pFlash.Page);
20003896:	4b1b      	ldr	r3, [pc, #108]	; (20003904 <HAL_FLASH_IRQHandler+0x1a4>)
20003898:	695b      	ldr	r3, [r3, #20]
2000389a:	4618      	mov	r0, r3
2000389c:	f000 f834 	bl	20003908 <HAL_FLASH_EndOfOperationCallback>
200038a0:	e01b      	b.n	200038da <HAL_FLASH_IRQHandler+0x17a>
      }
    }
    else
    {
      /* Flush the caches to be sure of the data consistency */
      FLASH_FlushCaches() ;
200038a2:	f000 fc77 	bl	20004194 <FLASH_FlushCaches>

      procedure = pFlash.ProcedureOnGoing;
200038a6:	4b17      	ldr	r3, [pc, #92]	; (20003904 <HAL_FLASH_IRQHandler+0x1a4>)
200038a8:	7a1b      	ldrb	r3, [r3, #8]
200038aa:	72fb      	strb	r3, [r7, #11]
      if (procedure == FLASH_PROC_MASS_ERASE)
200038ac:	7afb      	ldrb	r3, [r7, #11]
200038ae:	2b02      	cmp	r3, #2
200038b0:	d105      	bne.n	200038be <HAL_FLASH_IRQHandler+0x15e>
      {
        /* MassErase ended. Return the selected bank */
        /* FLASH EOP interrupt user callback */
        HAL_FLASH_EndOfOperationCallback(pFlash.Bank);
200038b2:	4b14      	ldr	r3, [pc, #80]	; (20003904 <HAL_FLASH_IRQHandler+0x1a4>)
200038b4:	691b      	ldr	r3, [r3, #16]
200038b6:	4618      	mov	r0, r3
200038b8:	f000 f826 	bl	20003908 <HAL_FLASH_EndOfOperationCallback>
200038bc:	e00a      	b.n	200038d4 <HAL_FLASH_IRQHandler+0x174>
      }
      else if ((procedure == FLASH_PROC_PROGRAM) ||
200038be:	7afb      	ldrb	r3, [r7, #11]
200038c0:	2b03      	cmp	r3, #3
200038c2:	d002      	beq.n	200038ca <HAL_FLASH_IRQHandler+0x16a>
200038c4:	7afb      	ldrb	r3, [r7, #11]
200038c6:	2b04      	cmp	r3, #4
200038c8:	d104      	bne.n	200038d4 <HAL_FLASH_IRQHandler+0x174>
               (procedure == FLASH_PROC_PROGRAM_LAST))
      {
        /* Program ended. Return the selected address */
        /* FLASH EOP interrupt user callback */
        HAL_FLASH_EndOfOperationCallback(pFlash.Address);
200038ca:	4b0e      	ldr	r3, [pc, #56]	; (20003904 <HAL_FLASH_IRQHandler+0x1a4>)
200038cc:	68db      	ldr	r3, [r3, #12]
200038ce:	4618      	mov	r0, r3
200038d0:	f000 f81a 	bl	20003908 <HAL_FLASH_EndOfOperationCallback>
      {
        /* Nothing to do */
      }

      /*Clear the procedure ongoing*/
      pFlash.ProcedureOnGoing = FLASH_PROC_NONE;
200038d4:	4b0b      	ldr	r3, [pc, #44]	; (20003904 <HAL_FLASH_IRQHandler+0x1a4>)
200038d6:	2200      	movs	r2, #0
200038d8:	721a      	strb	r2, [r3, #8]
    }
  }

  if (pFlash.ProcedureOnGoing == FLASH_PROC_NONE)
200038da:	4b0a      	ldr	r3, [pc, #40]	; (20003904 <HAL_FLASH_IRQHandler+0x1a4>)
200038dc:	7a1b      	ldrb	r3, [r3, #8]
200038de:	b2db      	uxtb	r3, r3
200038e0:	2b00      	cmp	r3, #0
200038e2:	d108      	bne.n	200038f6 <HAL_FLASH_IRQHandler+0x196>
  {
    /* Disable End of Operation and Error interrupts */
    __HAL_FLASH_DISABLE_IT(FLASH_IT_EOP | FLASH_IT_OPERR);
200038e4:	4b06      	ldr	r3, [pc, #24]	; (20003900 <HAL_FLASH_IRQHandler+0x1a0>)
200038e6:	695b      	ldr	r3, [r3, #20]
200038e8:	4a05      	ldr	r2, [pc, #20]	; (20003900 <HAL_FLASH_IRQHandler+0x1a0>)
200038ea:	f023 7340 	bic.w	r3, r3, #50331648	; 0x3000000
200038ee:	6153      	str	r3, [r2, #20]

    /* Process Unlocked */
    __HAL_UNLOCK(&pFlash);
200038f0:	4b04      	ldr	r3, [pc, #16]	; (20003904 <HAL_FLASH_IRQHandler+0x1a4>)
200038f2:	2200      	movs	r2, #0
200038f4:	701a      	strb	r2, [r3, #0]
  }
}
200038f6:	bf00      	nop
200038f8:	3710      	adds	r7, #16
200038fa:	46bd      	mov	sp, r7
200038fc:	bd80      	pop	{r7, pc}
200038fe:	bf00      	nop
20003900:	40022000 	.word	0x40022000
20003904:	200003fc 	.word	0x200003fc

20003908 <HAL_FLASH_EndOfOperationCallback>:
  *                            (if 0xFFFFFFFF, it means that all the selected pages have been erased)
  *           @arg Program: Address which was selected for data program
  * @retval None
  */
__weak void HAL_FLASH_EndOfOperationCallback(uint32_t ReturnValue)
{
20003908:	b480      	push	{r7}
2000390a:	b083      	sub	sp, #12
2000390c:	af00      	add	r7, sp, #0
2000390e:	6078      	str	r0, [r7, #4]
  UNUSED(ReturnValue);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_FLASH_EndOfOperationCallback could be implemented in the user file
   */
}
20003910:	bf00      	nop
20003912:	370c      	adds	r7, #12
20003914:	46bd      	mov	sp, r7
20003916:	f85d 7b04 	ldr.w	r7, [sp], #4
2000391a:	4770      	bx	lr

2000391c <HAL_FLASH_OperationErrorCallback>:
  *           @arg Page Erase: Page number which returned an error
  *           @arg Program: Address which was selected for data program
  * @retval None
  */
__weak void HAL_FLASH_OperationErrorCallback(uint32_t ReturnValue)
{
2000391c:	b480      	push	{r7}
2000391e:	b083      	sub	sp, #12
20003920:	af00      	add	r7, sp, #0
20003922:	6078      	str	r0, [r7, #4]
  UNUSED(ReturnValue);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_FLASH_OperationErrorCallback could be implemented in the user file
   */
}
20003924:	bf00      	nop
20003926:	370c      	adds	r7, #12
20003928:	46bd      	mov	sp, r7
2000392a:	f85d 7b04 	ldr.w	r7, [sp], #4
2000392e:	4770      	bx	lr

20003930 <HAL_FLASH_Unlock>:
/**
  * @brief  Unlock the FLASH control register access.
  * @retval HAL_Status
  */
HAL_StatusTypeDef HAL_FLASH_Unlock(void)
{
20003930:	b480      	push	{r7}
20003932:	b083      	sub	sp, #12
20003934:	af00      	add	r7, sp, #0
  HAL_StatusTypeDef status = HAL_OK;
20003936:	2300      	movs	r3, #0
20003938:	71fb      	strb	r3, [r7, #7]

  if (READ_BIT(FLASH->CR, FLASH_CR_LOCK) != 0U)
2000393a:	4b0b      	ldr	r3, [pc, #44]	; (20003968 <HAL_FLASH_Unlock+0x38>)
2000393c:	695b      	ldr	r3, [r3, #20]
2000393e:	2b00      	cmp	r3, #0
20003940:	da0b      	bge.n	2000395a <HAL_FLASH_Unlock+0x2a>
  {
    /* Authorize the FLASH Registers access */
    WRITE_REG(FLASH->KEYR, FLASH_KEY1);
20003942:	4b09      	ldr	r3, [pc, #36]	; (20003968 <HAL_FLASH_Unlock+0x38>)
20003944:	4a09      	ldr	r2, [pc, #36]	; (2000396c <HAL_FLASH_Unlock+0x3c>)
20003946:	609a      	str	r2, [r3, #8]
    WRITE_REG(FLASH->KEYR, FLASH_KEY2);
20003948:	4b07      	ldr	r3, [pc, #28]	; (20003968 <HAL_FLASH_Unlock+0x38>)
2000394a:	4a09      	ldr	r2, [pc, #36]	; (20003970 <HAL_FLASH_Unlock+0x40>)
2000394c:	609a      	str	r2, [r3, #8]

    /* verify Flash is unlocked */
    if (READ_BIT(FLASH->CR, FLASH_CR_LOCK) != 0U)
2000394e:	4b06      	ldr	r3, [pc, #24]	; (20003968 <HAL_FLASH_Unlock+0x38>)
20003950:	695b      	ldr	r3, [r3, #20]
20003952:	2b00      	cmp	r3, #0
20003954:	da01      	bge.n	2000395a <HAL_FLASH_Unlock+0x2a>
    {
      status = HAL_ERROR;
20003956:	2301      	movs	r3, #1
20003958:	71fb      	strb	r3, [r7, #7]
    }
  }

  return status;
2000395a:	79fb      	ldrb	r3, [r7, #7]
}
2000395c:	4618      	mov	r0, r3
2000395e:	370c      	adds	r7, #12
20003960:	46bd      	mov	sp, r7
20003962:	f85d 7b04 	ldr.w	r7, [sp], #4
20003966:	4770      	bx	lr
20003968:	40022000 	.word	0x40022000
2000396c:	45670123 	.word	0x45670123
20003970:	cdef89ab 	.word	0xcdef89ab

20003974 <HAL_FLASH_Lock>:
/**
  * @brief  Lock the FLASH control register access.
  * @retval HAL_Status
  */
HAL_StatusTypeDef HAL_FLASH_Lock(void)
{
20003974:	b480      	push	{r7}
20003976:	b083      	sub	sp, #12
20003978:	af00      	add	r7, sp, #0
  HAL_StatusTypeDef status = HAL_ERROR;
2000397a:	2301      	movs	r3, #1
2000397c:	71fb      	strb	r3, [r7, #7]

  /* Set the LOCK Bit to lock the FLASH Registers access */
  SET_BIT(FLASH->CR, FLASH_CR_LOCK);
2000397e:	4b09      	ldr	r3, [pc, #36]	; (200039a4 <HAL_FLASH_Lock+0x30>)
20003980:	695b      	ldr	r3, [r3, #20]
20003982:	4a08      	ldr	r2, [pc, #32]	; (200039a4 <HAL_FLASH_Lock+0x30>)
20003984:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
20003988:	6153      	str	r3, [r2, #20]

  /* verify Flash is locked */
  if (READ_BIT(FLASH->CR, FLASH_CR_LOCK) != 0U)
2000398a:	4b06      	ldr	r3, [pc, #24]	; (200039a4 <HAL_FLASH_Lock+0x30>)
2000398c:	695b      	ldr	r3, [r3, #20]
2000398e:	2b00      	cmp	r3, #0
20003990:	da01      	bge.n	20003996 <HAL_FLASH_Lock+0x22>
  {
    status = HAL_OK;
20003992:	2300      	movs	r3, #0
20003994:	71fb      	strb	r3, [r7, #7]
  }

  return status;
20003996:	79fb      	ldrb	r3, [r7, #7]
}
20003998:	4618      	mov	r0, r3
2000399a:	370c      	adds	r7, #12
2000399c:	46bd      	mov	sp, r7
2000399e:	f85d 7b04 	ldr.w	r7, [sp], #4
200039a2:	4770      	bx	lr
200039a4:	40022000 	.word	0x40022000

200039a8 <HAL_FLASH_OB_Unlock>:
/**
  * @brief  Unlock the FLASH Option Bytes Registers access.
  * @retval HAL_Status
  */
HAL_StatusTypeDef HAL_FLASH_OB_Unlock(void)
{
200039a8:	b480      	push	{r7}
200039aa:	b083      	sub	sp, #12
200039ac:	af00      	add	r7, sp, #0
  HAL_StatusTypeDef status = HAL_OK;
200039ae:	2300      	movs	r3, #0
200039b0:	71fb      	strb	r3, [r7, #7]

  if (READ_BIT(FLASH->CR, FLASH_CR_OPTLOCK) != 0U)
200039b2:	4b0d      	ldr	r3, [pc, #52]	; (200039e8 <HAL_FLASH_OB_Unlock+0x40>)
200039b4:	695b      	ldr	r3, [r3, #20]
200039b6:	f003 4380 	and.w	r3, r3, #1073741824	; 0x40000000
200039ba:	2b00      	cmp	r3, #0
200039bc:	d00d      	beq.n	200039da <HAL_FLASH_OB_Unlock+0x32>
  {
    /* Authorizes the Option Byte register programming */
    WRITE_REG(FLASH->OPTKEYR, FLASH_OPTKEY1);
200039be:	4b0a      	ldr	r3, [pc, #40]	; (200039e8 <HAL_FLASH_OB_Unlock+0x40>)
200039c0:	4a0a      	ldr	r2, [pc, #40]	; (200039ec <HAL_FLASH_OB_Unlock+0x44>)
200039c2:	60da      	str	r2, [r3, #12]
    WRITE_REG(FLASH->OPTKEYR, FLASH_OPTKEY2);
200039c4:	4b08      	ldr	r3, [pc, #32]	; (200039e8 <HAL_FLASH_OB_Unlock+0x40>)
200039c6:	4a0a      	ldr	r2, [pc, #40]	; (200039f0 <HAL_FLASH_OB_Unlock+0x48>)
200039c8:	60da      	str	r2, [r3, #12]

    /* verify option bytes are unlocked */
    if (READ_BIT(FLASH->CR, FLASH_CR_OPTLOCK) != 0U)
200039ca:	4b07      	ldr	r3, [pc, #28]	; (200039e8 <HAL_FLASH_OB_Unlock+0x40>)
200039cc:	695b      	ldr	r3, [r3, #20]
200039ce:	f003 4380 	and.w	r3, r3, #1073741824	; 0x40000000
200039d2:	2b00      	cmp	r3, #0
200039d4:	d001      	beq.n	200039da <HAL_FLASH_OB_Unlock+0x32>
    {
      status = HAL_ERROR;
200039d6:	2301      	movs	r3, #1
200039d8:	71fb      	strb	r3, [r7, #7]
    }
  }

  return status;
200039da:	79fb      	ldrb	r3, [r7, #7]
}
200039dc:	4618      	mov	r0, r3
200039de:	370c      	adds	r7, #12
200039e0:	46bd      	mov	sp, r7
200039e2:	f85d 7b04 	ldr.w	r7, [sp], #4
200039e6:	4770      	bx	lr
200039e8:	40022000 	.word	0x40022000
200039ec:	08192a3b 	.word	0x08192a3b
200039f0:	4c5d6e7f 	.word	0x4c5d6e7f

200039f4 <HAL_FLASH_OB_Lock>:
/**
  * @brief  Lock the FLASH Option Bytes Registers access.
  * @retval HAL_Status
  */
HAL_StatusTypeDef HAL_FLASH_OB_Lock(void)
{
200039f4:	b480      	push	{r7}
200039f6:	b083      	sub	sp, #12
200039f8:	af00      	add	r7, sp, #0
  HAL_StatusTypeDef status = HAL_ERROR;
200039fa:	2301      	movs	r3, #1
200039fc:	71fb      	strb	r3, [r7, #7]

  /* Set the OPTLOCK Bit to lock the FLASH Option Byte Registers access */
  SET_BIT(FLASH->CR, FLASH_CR_OPTLOCK);
200039fe:	4b0a      	ldr	r3, [pc, #40]	; (20003a28 <HAL_FLASH_OB_Lock+0x34>)
20003a00:	695b      	ldr	r3, [r3, #20]
20003a02:	4a09      	ldr	r2, [pc, #36]	; (20003a28 <HAL_FLASH_OB_Lock+0x34>)
20003a04:	f043 4380 	orr.w	r3, r3, #1073741824	; 0x40000000
20003a08:	6153      	str	r3, [r2, #20]

  /* Verify option bytes are locked */
  if (READ_BIT(FLASH->CR, FLASH_CR_OPTLOCK) != 0U)
20003a0a:	4b07      	ldr	r3, [pc, #28]	; (20003a28 <HAL_FLASH_OB_Lock+0x34>)
20003a0c:	695b      	ldr	r3, [r3, #20]
20003a0e:	f003 4380 	and.w	r3, r3, #1073741824	; 0x40000000
20003a12:	2b00      	cmp	r3, #0
20003a14:	d001      	beq.n	20003a1a <HAL_FLASH_OB_Lock+0x26>
  {
    status = HAL_OK;
20003a16:	2300      	movs	r3, #0
20003a18:	71fb      	strb	r3, [r7, #7]
  }

  return status;
20003a1a:	79fb      	ldrb	r3, [r7, #7]
}
20003a1c:	4618      	mov	r0, r3
20003a1e:	370c      	adds	r7, #12
20003a20:	46bd      	mov	sp, r7
20003a22:	f85d 7b04 	ldr.w	r7, [sp], #4
20003a26:	4770      	bx	lr
20003a28:	40022000 	.word	0x40022000

20003a2c <HAL_FLASH_OB_Launch>:
/**
  * @brief  Launch the option byte loading.
  * @retval HAL_Status
  */
HAL_StatusTypeDef HAL_FLASH_OB_Launch(void)
{
20003a2c:	b580      	push	{r7, lr}
20003a2e:	af00      	add	r7, sp, #0
  /* Set the bit to force the option byte reloading */
  SET_BIT(FLASH->CR, FLASH_CR_OBL_LAUNCH);
20003a30:	4b06      	ldr	r3, [pc, #24]	; (20003a4c <HAL_FLASH_OB_Launch+0x20>)
20003a32:	695b      	ldr	r3, [r3, #20]
20003a34:	4a05      	ldr	r2, [pc, #20]	; (20003a4c <HAL_FLASH_OB_Launch+0x20>)
20003a36:	f043 6300 	orr.w	r3, r3, #134217728	; 0x8000000
20003a3a:	6153      	str	r3, [r2, #20]

  /* Wait for last operation to be completed */
  return (FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE));
20003a3c:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
20003a40:	f000 f812 	bl	20003a68 <FLASH_WaitForLastOperation>
20003a44:	4603      	mov	r3, r0
}
20003a46:	4618      	mov	r0, r3
20003a48:	bd80      	pop	{r7, pc}
20003a4a:	bf00      	nop
20003a4c:	40022000 	.word	0x40022000

20003a50 <HAL_FLASH_GetError>:
  *            @arg HAL_FLASH_ERROR_FAST: FLASH Fast programming error
  *            @arg HAL_FLASH_ERROR_RD: FLASH PCROP read error
  *            @arg HAL_FLASH_ERROR_OPTV: FLASH Option validity error
  */
uint32_t HAL_FLASH_GetError(void)
{
20003a50:	b480      	push	{r7}
20003a52:	af00      	add	r7, sp, #0
  return pFlash.ErrorCode;
20003a54:	4b03      	ldr	r3, [pc, #12]	; (20003a64 <HAL_FLASH_GetError+0x14>)
20003a56:	685b      	ldr	r3, [r3, #4]
}
20003a58:	4618      	mov	r0, r3
20003a5a:	46bd      	mov	sp, r7
20003a5c:	f85d 7b04 	ldr.w	r7, [sp], #4
20003a60:	4770      	bx	lr
20003a62:	bf00      	nop
20003a64:	200003fc 	.word	0x200003fc

20003a68 <FLASH_WaitForLastOperation>:
  * @brief  Wait for a FLASH operation to complete.
  * @param  Timeout maximum flash operation timeout.
  * @retval HAL_Status
  */
HAL_StatusTypeDef FLASH_WaitForLastOperation(uint32_t Timeout)
{
20003a68:	b580      	push	{r7, lr}
20003a6a:	b084      	sub	sp, #16
20003a6c:	af00      	add	r7, sp, #0
20003a6e:	6078      	str	r0, [r7, #4]
  /* Wait for the FLASH operation to complete by polling on BUSY flag to be reset.
     Even if the FLASH operation fails, the BUSY flag will be reset and an error
     flag will be set */

  uint32_t tickstart = HAL_GetTick();
20003a70:	f7fd ff14 	bl	2000189c <HAL_GetTick>
20003a74:	60f8      	str	r0, [r7, #12]
  uint32_t error;

  while (__HAL_FLASH_GET_FLAG(FLASH_FLAG_BSY))
20003a76:	e009      	b.n	20003a8c <FLASH_WaitForLastOperation+0x24>
  {
    if ((HAL_GetTick() - tickstart) > Timeout)
20003a78:	f7fd ff10 	bl	2000189c <HAL_GetTick>
20003a7c:	4602      	mov	r2, r0
20003a7e:	68fb      	ldr	r3, [r7, #12]
20003a80:	1ad3      	subs	r3, r2, r3
20003a82:	687a      	ldr	r2, [r7, #4]
20003a84:	429a      	cmp	r2, r3
20003a86:	d201      	bcs.n	20003a8c <FLASH_WaitForLastOperation+0x24>
    {
      return HAL_TIMEOUT;
20003a88:	2303      	movs	r3, #3
20003a8a:	e038      	b.n	20003afe <FLASH_WaitForLastOperation+0x96>
  while (__HAL_FLASH_GET_FLAG(FLASH_FLAG_BSY))
20003a8c:	4b1e      	ldr	r3, [pc, #120]	; (20003b08 <FLASH_WaitForLastOperation+0xa0>)
20003a8e:	691b      	ldr	r3, [r3, #16]
20003a90:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
20003a94:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
20003a98:	d0ee      	beq.n	20003a78 <FLASH_WaitForLastOperation+0x10>
    }
  }

  /* Check FLASH operation error flags */
  error = (FLASH->SR & FLASH_FLAG_SR_ERRORS);
20003a9a:	4b1b      	ldr	r3, [pc, #108]	; (20003b08 <FLASH_WaitForLastOperation+0xa0>)
20003a9c:	691a      	ldr	r2, [r3, #16]
20003a9e:	f24c 33fa 	movw	r3, #50170	; 0xc3fa
20003aa2:	4013      	ands	r3, r2
20003aa4:	60bb      	str	r3, [r7, #8]
  if (error != 0u)
20003aa6:	68bb      	ldr	r3, [r7, #8]
20003aa8:	2b00      	cmp	r3, #0
20003aaa:	d01e      	beq.n	20003aea <FLASH_WaitForLastOperation+0x82>
  {
    /* Save the error code */
    pFlash.ErrorCode |= error;
20003aac:	4b17      	ldr	r3, [pc, #92]	; (20003b0c <FLASH_WaitForLastOperation+0xa4>)
20003aae:	685a      	ldr	r2, [r3, #4]
20003ab0:	68bb      	ldr	r3, [r7, #8]
20003ab2:	4313      	orrs	r3, r2
20003ab4:	4a15      	ldr	r2, [pc, #84]	; (20003b0c <FLASH_WaitForLastOperation+0xa4>)
20003ab6:	6053      	str	r3, [r2, #4]

    /* Clear error programming flags */
    __HAL_FLASH_CLEAR_FLAG(error);
20003ab8:	68bb      	ldr	r3, [r7, #8]
20003aba:	f003 4370 	and.w	r3, r3, #4026531840	; 0xf0000000
20003abe:	2b00      	cmp	r3, #0
20003ac0:	d007      	beq.n	20003ad2 <FLASH_WaitForLastOperation+0x6a>
20003ac2:	4b11      	ldr	r3, [pc, #68]	; (20003b08 <FLASH_WaitForLastOperation+0xa0>)
20003ac4:	699a      	ldr	r2, [r3, #24]
20003ac6:	68bb      	ldr	r3, [r7, #8]
20003ac8:	f003 4370 	and.w	r3, r3, #4026531840	; 0xf0000000
20003acc:	490e      	ldr	r1, [pc, #56]	; (20003b08 <FLASH_WaitForLastOperation+0xa0>)
20003ace:	4313      	orrs	r3, r2
20003ad0:	618b      	str	r3, [r1, #24]
20003ad2:	68bb      	ldr	r3, [r7, #8]
20003ad4:	f023 4370 	bic.w	r3, r3, #4026531840	; 0xf0000000
20003ad8:	2b00      	cmp	r3, #0
20003ada:	d004      	beq.n	20003ae6 <FLASH_WaitForLastOperation+0x7e>
20003adc:	4a0a      	ldr	r2, [pc, #40]	; (20003b08 <FLASH_WaitForLastOperation+0xa0>)
20003ade:	68bb      	ldr	r3, [r7, #8]
20003ae0:	f023 4370 	bic.w	r3, r3, #4026531840	; 0xf0000000
20003ae4:	6113      	str	r3, [r2, #16]

    return HAL_ERROR;
20003ae6:	2301      	movs	r3, #1
20003ae8:	e009      	b.n	20003afe <FLASH_WaitForLastOperation+0x96>
  }

  /* Check FLASH End of Operation flag  */
  if (__HAL_FLASH_GET_FLAG(FLASH_FLAG_EOP))
20003aea:	4b07      	ldr	r3, [pc, #28]	; (20003b08 <FLASH_WaitForLastOperation+0xa0>)
20003aec:	691b      	ldr	r3, [r3, #16]
20003aee:	f003 0301 	and.w	r3, r3, #1
20003af2:	2b01      	cmp	r3, #1
20003af4:	d102      	bne.n	20003afc <FLASH_WaitForLastOperation+0x94>
  {
    /* Clear FLASH End of Operation pending bit */
    __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_EOP);
20003af6:	4b04      	ldr	r3, [pc, #16]	; (20003b08 <FLASH_WaitForLastOperation+0xa0>)
20003af8:	2201      	movs	r2, #1
20003afa:	611a      	str	r2, [r3, #16]
  }

  /* If there is an error flag set */
  return HAL_OK;
20003afc:	2300      	movs	r3, #0
}
20003afe:	4618      	mov	r0, r3
20003b00:	3710      	adds	r7, #16
20003b02:	46bd      	mov	sp, r7
20003b04:	bd80      	pop	{r7, pc}
20003b06:	bf00      	nop
20003b08:	40022000 	.word	0x40022000
20003b0c:	200003fc 	.word	0x200003fc

20003b10 <FLASH_Program_DoubleWord>:
  * @param  Address specifies the address to be programmed.
  * @param  Data specifies the data to be programmed.
  * @retval None
  */
static void FLASH_Program_DoubleWord(uint32_t Address, uint64_t Data)
{
20003b10:	b480      	push	{r7}
20003b12:	b085      	sub	sp, #20
20003b14:	af00      	add	r7, sp, #0
20003b16:	60f8      	str	r0, [r7, #12]
20003b18:	e9c7 2300 	strd	r2, r3, [r7]
  /* Check the parameters */
  assert_param(IS_FLASH_PROGRAM_ADDRESS(Address));

  /* Set PG bit */
  SET_BIT(FLASH->CR, FLASH_CR_PG);
20003b1c:	4b0e      	ldr	r3, [pc, #56]	; (20003b58 <FLASH_Program_DoubleWord+0x48>)
20003b1e:	695b      	ldr	r3, [r3, #20]
20003b20:	4a0d      	ldr	r2, [pc, #52]	; (20003b58 <FLASH_Program_DoubleWord+0x48>)
20003b22:	f043 0301 	orr.w	r3, r3, #1
20003b26:	6153      	str	r3, [r2, #20]

  /* Program first word */
  *(uint32_t *)Address = (uint32_t)Data;
20003b28:	68fb      	ldr	r3, [r7, #12]
20003b2a:	683a      	ldr	r2, [r7, #0]
20003b2c:	601a      	str	r2, [r3, #0]
  __ASM volatile ("isb 0xF":::"memory");
20003b2e:	f3bf 8f6f 	isb	sy
}
20003b32:	bf00      	nop
  /* Barrier to ensure programming is performed in 2 steps, in right order
    (independently of compiler optimization behavior) */
  __ISB();

  /* Program second word */
  *(uint32_t *)(Address + 4U) = (uint32_t)(Data >> 32U);
20003b34:	e9d7 0100 	ldrd	r0, r1, [r7]
20003b38:	f04f 0200 	mov.w	r2, #0
20003b3c:	f04f 0300 	mov.w	r3, #0
20003b40:	000a      	movs	r2, r1
20003b42:	2300      	movs	r3, #0
20003b44:	68f9      	ldr	r1, [r7, #12]
20003b46:	3104      	adds	r1, #4
20003b48:	4613      	mov	r3, r2
20003b4a:	600b      	str	r3, [r1, #0]
}
20003b4c:	bf00      	nop
20003b4e:	3714      	adds	r7, #20
20003b50:	46bd      	mov	sp, r7
20003b52:	f85d 7b04 	ldr.w	r7, [sp], #4
20003b56:	4770      	bx	lr
20003b58:	40022000 	.word	0x40022000

20003b5c <FLASH_Program_Fast>:
  * @param  Address specifies the address to be programmed.
  * @param  DataAddress specifies the address where the data are stored.
  * @retval None
  */
static void FLASH_Program_Fast(uint32_t Address, uint32_t DataAddress)
{
20003b5c:	b480      	push	{r7}
20003b5e:	b089      	sub	sp, #36	; 0x24
20003b60:	af00      	add	r7, sp, #0
20003b62:	6078      	str	r0, [r7, #4]
20003b64:	6039      	str	r1, [r7, #0]
  uint8_t row_index = (2 * FLASH_NB_DOUBLE_WORDS_IN_ROW);
20003b66:	2340      	movs	r3, #64	; 0x40
20003b68:	77fb      	strb	r3, [r7, #31]
  uint32_t *dest_addr = (uint32_t *)Address;
20003b6a:	687b      	ldr	r3, [r7, #4]
20003b6c:	61bb      	str	r3, [r7, #24]
  uint32_t *src_addr = (uint32_t *)DataAddress;
20003b6e:	683b      	ldr	r3, [r7, #0]
20003b70:	617b      	str	r3, [r7, #20]

  /* Check the parameters */
  assert_param(IS_FLASH_MAIN_MEM_ADDRESS(Address));

  /* Set FSTPG bit */
  SET_BIT(FLASH->CR, FLASH_CR_FSTPG);
20003b72:	4b14      	ldr	r3, [pc, #80]	; (20003bc4 <FLASH_Program_Fast+0x68>)
20003b74:	695b      	ldr	r3, [r3, #20]
20003b76:	4a13      	ldr	r2, [pc, #76]	; (20003bc4 <FLASH_Program_Fast+0x68>)
20003b78:	f443 2380 	orr.w	r3, r3, #262144	; 0x40000
20003b7c:	6153      	str	r3, [r2, #20]
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
20003b7e:	f3ef 8310 	mrs	r3, PRIMASK
20003b82:	60fb      	str	r3, [r7, #12]
  return(result);
20003b84:	68fb      	ldr	r3, [r7, #12]

  /* Enter critical section: Disable interrupts to avoid any interruption during the loop */
  primask_bit = __get_PRIMASK();
20003b86:	613b      	str	r3, [r7, #16]
  __ASM volatile ("cpsid i" : : : "memory");
20003b88:	b672      	cpsid	i
}
20003b8a:	bf00      	nop
  __disable_irq();

  /* Program the double words of the row */
  do
  {
    *dest_addr = *src_addr;
20003b8c:	697b      	ldr	r3, [r7, #20]
20003b8e:	681a      	ldr	r2, [r3, #0]
20003b90:	69bb      	ldr	r3, [r7, #24]
20003b92:	601a      	str	r2, [r3, #0]
    dest_addr++;
20003b94:	69bb      	ldr	r3, [r7, #24]
20003b96:	3304      	adds	r3, #4
20003b98:	61bb      	str	r3, [r7, #24]
    src_addr++;
20003b9a:	697b      	ldr	r3, [r7, #20]
20003b9c:	3304      	adds	r3, #4
20003b9e:	617b      	str	r3, [r7, #20]
    row_index--;
20003ba0:	7ffb      	ldrb	r3, [r7, #31]
20003ba2:	3b01      	subs	r3, #1
20003ba4:	77fb      	strb	r3, [r7, #31]
  }
  while (row_index != 0U);
20003ba6:	7ffb      	ldrb	r3, [r7, #31]
20003ba8:	2b00      	cmp	r3, #0
20003baa:	d1ef      	bne.n	20003b8c <FLASH_Program_Fast+0x30>
20003bac:	693b      	ldr	r3, [r7, #16]
20003bae:	60bb      	str	r3, [r7, #8]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
20003bb0:	68bb      	ldr	r3, [r7, #8]
20003bb2:	f383 8810 	msr	PRIMASK, r3
}
20003bb6:	bf00      	nop

  /* Exit critical section: restore previous priority mask */
  __set_PRIMASK(primask_bit);
}
20003bb8:	bf00      	nop
20003bba:	3724      	adds	r7, #36	; 0x24
20003bbc:	46bd      	mov	sp, r7
20003bbe:	f85d 7b04 	ldr.w	r7, [sp], #4
20003bc2:	4770      	bx	lr
20003bc4:	40022000 	.word	0x40022000

20003bc8 <HAL_FLASHEx_Erase>:
  *         information on faulty page in case of error (0xFFFFFFFF means that all
  *         the pages have been correctly erased).
  * @retval HAL_Status
  */
HAL_StatusTypeDef HAL_FLASHEx_Erase(FLASH_EraseInitTypeDef *pEraseInit, uint32_t *PageError)
{
20003bc8:	b580      	push	{r7, lr}
20003bca:	b084      	sub	sp, #16
20003bcc:	af00      	add	r7, sp, #0
20003bce:	6078      	str	r0, [r7, #4]
20003bd0:	6039      	str	r1, [r7, #0]

  /* Check the parameters */
  assert_param(IS_FLASH_TYPEERASE(pEraseInit->TypeErase));

  /* Process Locked */
  __HAL_LOCK(&pFlash);
20003bd2:	4b4c      	ldr	r3, [pc, #304]	; (20003d04 <HAL_FLASHEx_Erase+0x13c>)
20003bd4:	781b      	ldrb	r3, [r3, #0]
20003bd6:	2b01      	cmp	r3, #1
20003bd8:	d101      	bne.n	20003bde <HAL_FLASHEx_Erase+0x16>
20003bda:	2302      	movs	r3, #2
20003bdc:	e08d      	b.n	20003cfa <HAL_FLASHEx_Erase+0x132>
20003bde:	4b49      	ldr	r3, [pc, #292]	; (20003d04 <HAL_FLASHEx_Erase+0x13c>)
20003be0:	2201      	movs	r2, #1
20003be2:	701a      	strb	r2, [r3, #0]

  /* Wait for last operation to be completed */
  status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
20003be4:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
20003be8:	f7ff ff3e 	bl	20003a68 <FLASH_WaitForLastOperation>
20003bec:	4603      	mov	r3, r0
20003bee:	73fb      	strb	r3, [r7, #15]

  if (status == HAL_OK)
20003bf0:	7bfb      	ldrb	r3, [r7, #15]
20003bf2:	2b00      	cmp	r3, #0
20003bf4:	d17d      	bne.n	20003cf2 <HAL_FLASHEx_Erase+0x12a>
  {
    pFlash.ErrorCode = HAL_FLASH_ERROR_NONE;
20003bf6:	4b43      	ldr	r3, [pc, #268]	; (20003d04 <HAL_FLASHEx_Erase+0x13c>)
20003bf8:	2200      	movs	r2, #0
20003bfa:	605a      	str	r2, [r3, #4]

    /* Deactivate the cache if they are activated to avoid data misbehavior */
    if (READ_BIT(FLASH->ACR, FLASH_ACR_ICEN) != 0U)
20003bfc:	4b42      	ldr	r3, [pc, #264]	; (20003d08 <HAL_FLASHEx_Erase+0x140>)
20003bfe:	681b      	ldr	r3, [r3, #0]
20003c00:	f403 7300 	and.w	r3, r3, #512	; 0x200
20003c04:	2b00      	cmp	r3, #0
20003c06:	d019      	beq.n	20003c3c <HAL_FLASHEx_Erase+0x74>
    {
      /* Disable instruction cache  */
      __HAL_FLASH_INSTRUCTION_CACHE_DISABLE();
20003c08:	4b3f      	ldr	r3, [pc, #252]	; (20003d08 <HAL_FLASHEx_Erase+0x140>)
20003c0a:	681b      	ldr	r3, [r3, #0]
20003c0c:	4a3e      	ldr	r2, [pc, #248]	; (20003d08 <HAL_FLASHEx_Erase+0x140>)
20003c0e:	f423 7300 	bic.w	r3, r3, #512	; 0x200
20003c12:	6013      	str	r3, [r2, #0]

      if (READ_BIT(FLASH->ACR, FLASH_ACR_DCEN) != 0U)
20003c14:	4b3c      	ldr	r3, [pc, #240]	; (20003d08 <HAL_FLASHEx_Erase+0x140>)
20003c16:	681b      	ldr	r3, [r3, #0]
20003c18:	f403 6380 	and.w	r3, r3, #1024	; 0x400
20003c1c:	2b00      	cmp	r3, #0
20003c1e:	d009      	beq.n	20003c34 <HAL_FLASHEx_Erase+0x6c>
      {
        /* Disable data cache  */
        __HAL_FLASH_DATA_CACHE_DISABLE();
20003c20:	4b39      	ldr	r3, [pc, #228]	; (20003d08 <HAL_FLASHEx_Erase+0x140>)
20003c22:	681b      	ldr	r3, [r3, #0]
20003c24:	4a38      	ldr	r2, [pc, #224]	; (20003d08 <HAL_FLASHEx_Erase+0x140>)
20003c26:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
20003c2a:	6013      	str	r3, [r2, #0]
        pFlash.CacheToReactivate = FLASH_CACHE_ICACHE_DCACHE_ENABLED;
20003c2c:	4b35      	ldr	r3, [pc, #212]	; (20003d04 <HAL_FLASHEx_Erase+0x13c>)
20003c2e:	2203      	movs	r2, #3
20003c30:	771a      	strb	r2, [r3, #28]
20003c32:	e016      	b.n	20003c62 <HAL_FLASHEx_Erase+0x9a>
      }
      else
      {
        pFlash.CacheToReactivate = FLASH_CACHE_ICACHE_ENABLED;
20003c34:	4b33      	ldr	r3, [pc, #204]	; (20003d04 <HAL_FLASHEx_Erase+0x13c>)
20003c36:	2201      	movs	r2, #1
20003c38:	771a      	strb	r2, [r3, #28]
20003c3a:	e012      	b.n	20003c62 <HAL_FLASHEx_Erase+0x9a>
      }
    }
    else if (READ_BIT(FLASH->ACR, FLASH_ACR_DCEN) != 0U)
20003c3c:	4b32      	ldr	r3, [pc, #200]	; (20003d08 <HAL_FLASHEx_Erase+0x140>)
20003c3e:	681b      	ldr	r3, [r3, #0]
20003c40:	f403 6380 	and.w	r3, r3, #1024	; 0x400
20003c44:	2b00      	cmp	r3, #0
20003c46:	d009      	beq.n	20003c5c <HAL_FLASHEx_Erase+0x94>
    {
      /* Disable data cache  */
      __HAL_FLASH_DATA_CACHE_DISABLE();
20003c48:	4b2f      	ldr	r3, [pc, #188]	; (20003d08 <HAL_FLASHEx_Erase+0x140>)
20003c4a:	681b      	ldr	r3, [r3, #0]
20003c4c:	4a2e      	ldr	r2, [pc, #184]	; (20003d08 <HAL_FLASHEx_Erase+0x140>)
20003c4e:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
20003c52:	6013      	str	r3, [r2, #0]
      pFlash.CacheToReactivate = FLASH_CACHE_DCACHE_ENABLED;
20003c54:	4b2b      	ldr	r3, [pc, #172]	; (20003d04 <HAL_FLASHEx_Erase+0x13c>)
20003c56:	2202      	movs	r2, #2
20003c58:	771a      	strb	r2, [r3, #28]
20003c5a:	e002      	b.n	20003c62 <HAL_FLASHEx_Erase+0x9a>
    }
    else
    {
      pFlash.CacheToReactivate = FLASH_CACHE_DISABLED;
20003c5c:	4b29      	ldr	r3, [pc, #164]	; (20003d04 <HAL_FLASHEx_Erase+0x13c>)
20003c5e:	2200      	movs	r2, #0
20003c60:	771a      	strb	r2, [r3, #28]
    }

    if (pEraseInit->TypeErase == FLASH_TYPEERASE_MASSERASE)
20003c62:	687b      	ldr	r3, [r7, #4]
20003c64:	681b      	ldr	r3, [r3, #0]
20003c66:	2b01      	cmp	r3, #1
20003c68:	d113      	bne.n	20003c92 <HAL_FLASHEx_Erase+0xca>
    {
      /* Mass erase to be done */
      FLASH_MassErase(pEraseInit->Banks);
20003c6a:	687b      	ldr	r3, [r7, #4]
20003c6c:	685b      	ldr	r3, [r3, #4]
20003c6e:	4618      	mov	r0, r3
20003c70:	f000 fa14 	bl	2000409c <FLASH_MassErase>

      /* Wait for last operation to be completed */
      status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
20003c74:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
20003c78:	f7ff fef6 	bl	20003a68 <FLASH_WaitForLastOperation>
20003c7c:	4603      	mov	r3, r0
20003c7e:	73fb      	strb	r3, [r7, #15]

#if defined (FLASH_OPTR_DBANK)
      /* If the erase operation is completed, disable the MER1 and MER2 Bits */
      CLEAR_BIT(FLASH->CR, (FLASH_CR_MER1 | FLASH_CR_MER2));
20003c80:	4b21      	ldr	r3, [pc, #132]	; (20003d08 <HAL_FLASHEx_Erase+0x140>)
20003c82:	695b      	ldr	r3, [r3, #20]
20003c84:	4a20      	ldr	r2, [pc, #128]	; (20003d08 <HAL_FLASHEx_Erase+0x140>)
20003c86:	f423 4300 	bic.w	r3, r3, #32768	; 0x8000
20003c8a:	f023 0304 	bic.w	r3, r3, #4
20003c8e:	6153      	str	r3, [r2, #20]
20003c90:	e02d      	b.n	20003cee <HAL_FLASHEx_Erase+0x126>
#endif
    }
    else
    {
      /*Initialization of PageError variable*/
      *PageError = 0xFFFFFFFFU;
20003c92:	683b      	ldr	r3, [r7, #0]
20003c94:	f04f 32ff 	mov.w	r2, #4294967295
20003c98:	601a      	str	r2, [r3, #0]

      for (page_index = pEraseInit->Page; page_index < (pEraseInit->Page + pEraseInit->NbPages); page_index++)
20003c9a:	687b      	ldr	r3, [r7, #4]
20003c9c:	689b      	ldr	r3, [r3, #8]
20003c9e:	60bb      	str	r3, [r7, #8]
20003ca0:	e01d      	b.n	20003cde <HAL_FLASHEx_Erase+0x116>
      {
        FLASH_PageErase(page_index, pEraseInit->Banks);
20003ca2:	687b      	ldr	r3, [r7, #4]
20003ca4:	685b      	ldr	r3, [r3, #4]
20003ca6:	4619      	mov	r1, r3
20003ca8:	68b8      	ldr	r0, [r7, #8]
20003caa:	f000 fa2f 	bl	2000410c <FLASH_PageErase>

        /* Wait for last operation to be completed */
        status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
20003cae:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
20003cb2:	f7ff fed9 	bl	20003a68 <FLASH_WaitForLastOperation>
20003cb6:	4603      	mov	r3, r0
20003cb8:	73fb      	strb	r3, [r7, #15]

        /* If the erase operation is completed, disable the PER Bit */
        CLEAR_BIT(FLASH->CR, (FLASH_CR_PER | FLASH_CR_PNB));
20003cba:	4b13      	ldr	r3, [pc, #76]	; (20003d08 <HAL_FLASHEx_Erase+0x140>)
20003cbc:	695b      	ldr	r3, [r3, #20]
20003cbe:	4a12      	ldr	r2, [pc, #72]	; (20003d08 <HAL_FLASHEx_Erase+0x140>)
20003cc0:	f423 737e 	bic.w	r3, r3, #1016	; 0x3f8
20003cc4:	f023 0302 	bic.w	r3, r3, #2
20003cc8:	6153      	str	r3, [r2, #20]

        if (status != HAL_OK)
20003cca:	7bfb      	ldrb	r3, [r7, #15]
20003ccc:	2b00      	cmp	r3, #0
20003cce:	d003      	beq.n	20003cd8 <HAL_FLASHEx_Erase+0x110>
        {
          /* In case of error, stop erase procedure and return the faulty page */
          *PageError = page_index;
20003cd0:	683b      	ldr	r3, [r7, #0]
20003cd2:	68ba      	ldr	r2, [r7, #8]
20003cd4:	601a      	str	r2, [r3, #0]
          break;
20003cd6:	e00a      	b.n	20003cee <HAL_FLASHEx_Erase+0x126>
      for (page_index = pEraseInit->Page; page_index < (pEraseInit->Page + pEraseInit->NbPages); page_index++)
20003cd8:	68bb      	ldr	r3, [r7, #8]
20003cda:	3301      	adds	r3, #1
20003cdc:	60bb      	str	r3, [r7, #8]
20003cde:	687b      	ldr	r3, [r7, #4]
20003ce0:	689a      	ldr	r2, [r3, #8]
20003ce2:	687b      	ldr	r3, [r7, #4]
20003ce4:	68db      	ldr	r3, [r3, #12]
20003ce6:	4413      	add	r3, r2
20003ce8:	68ba      	ldr	r2, [r7, #8]
20003cea:	429a      	cmp	r2, r3
20003cec:	d3d9      	bcc.n	20003ca2 <HAL_FLASHEx_Erase+0xda>
        }
      }
    }

    /* Flush the caches to be sure of the data consistency */
    FLASH_FlushCaches();
20003cee:	f000 fa51 	bl	20004194 <FLASH_FlushCaches>
  }

  /* Process Unlocked */
  __HAL_UNLOCK(&pFlash);
20003cf2:	4b04      	ldr	r3, [pc, #16]	; (20003d04 <HAL_FLASHEx_Erase+0x13c>)
20003cf4:	2200      	movs	r2, #0
20003cf6:	701a      	strb	r2, [r3, #0]

  return status;
20003cf8:	7bfb      	ldrb	r3, [r7, #15]
}
20003cfa:	4618      	mov	r0, r3
20003cfc:	3710      	adds	r7, #16
20003cfe:	46bd      	mov	sp, r7
20003d00:	bd80      	pop	{r7, pc}
20003d02:	bf00      	nop
20003d04:	200003fc 	.word	0x200003fc
20003d08:	40022000 	.word	0x40022000

20003d0c <HAL_FLASHEx_Erase_IT>:
  * @param  pEraseInit pointer to an FLASH_EraseInitTypeDef structure that
  *         contains the configuration information for the erasing.
  * @retval HAL_Status
  */
HAL_StatusTypeDef HAL_FLASHEx_Erase_IT(FLASH_EraseInitTypeDef *pEraseInit)
{
20003d0c:	b580      	push	{r7, lr}
20003d0e:	b084      	sub	sp, #16
20003d10:	af00      	add	r7, sp, #0
20003d12:	6078      	str	r0, [r7, #4]
  HAL_StatusTypeDef status = HAL_OK;
20003d14:	2300      	movs	r3, #0
20003d16:	73fb      	strb	r3, [r7, #15]

  /* Process Locked */
  __HAL_LOCK(&pFlash);
20003d18:	4b36      	ldr	r3, [pc, #216]	; (20003df4 <HAL_FLASHEx_Erase_IT+0xe8>)
20003d1a:	781b      	ldrb	r3, [r3, #0]
20003d1c:	2b01      	cmp	r3, #1
20003d1e:	d101      	bne.n	20003d24 <HAL_FLASHEx_Erase_IT+0x18>
20003d20:	2302      	movs	r3, #2
20003d22:	e063      	b.n	20003dec <HAL_FLASHEx_Erase_IT+0xe0>
20003d24:	4b33      	ldr	r3, [pc, #204]	; (20003df4 <HAL_FLASHEx_Erase_IT+0xe8>)
20003d26:	2201      	movs	r2, #1
20003d28:	701a      	strb	r2, [r3, #0]

  /* Check the parameters */
  assert_param(IS_FLASH_TYPEERASE(pEraseInit->TypeErase));

  pFlash.ErrorCode = HAL_FLASH_ERROR_NONE;
20003d2a:	4b32      	ldr	r3, [pc, #200]	; (20003df4 <HAL_FLASHEx_Erase_IT+0xe8>)
20003d2c:	2200      	movs	r2, #0
20003d2e:	605a      	str	r2, [r3, #4]

  /* Deactivate the cache if they are activated to avoid data misbehavior */
  if (READ_BIT(FLASH->ACR, FLASH_ACR_ICEN) != 0U)
20003d30:	4b31      	ldr	r3, [pc, #196]	; (20003df8 <HAL_FLASHEx_Erase_IT+0xec>)
20003d32:	681b      	ldr	r3, [r3, #0]
20003d34:	f403 7300 	and.w	r3, r3, #512	; 0x200
20003d38:	2b00      	cmp	r3, #0
20003d3a:	d019      	beq.n	20003d70 <HAL_FLASHEx_Erase_IT+0x64>
  {
    /* Disable instruction cache  */
    __HAL_FLASH_INSTRUCTION_CACHE_DISABLE();
20003d3c:	4b2e      	ldr	r3, [pc, #184]	; (20003df8 <HAL_FLASHEx_Erase_IT+0xec>)
20003d3e:	681b      	ldr	r3, [r3, #0]
20003d40:	4a2d      	ldr	r2, [pc, #180]	; (20003df8 <HAL_FLASHEx_Erase_IT+0xec>)
20003d42:	f423 7300 	bic.w	r3, r3, #512	; 0x200
20003d46:	6013      	str	r3, [r2, #0]

    if (READ_BIT(FLASH->ACR, FLASH_ACR_DCEN) != 0U)
20003d48:	4b2b      	ldr	r3, [pc, #172]	; (20003df8 <HAL_FLASHEx_Erase_IT+0xec>)
20003d4a:	681b      	ldr	r3, [r3, #0]
20003d4c:	f403 6380 	and.w	r3, r3, #1024	; 0x400
20003d50:	2b00      	cmp	r3, #0
20003d52:	d009      	beq.n	20003d68 <HAL_FLASHEx_Erase_IT+0x5c>
    {
      /* Disable data cache  */
      __HAL_FLASH_DATA_CACHE_DISABLE();
20003d54:	4b28      	ldr	r3, [pc, #160]	; (20003df8 <HAL_FLASHEx_Erase_IT+0xec>)
20003d56:	681b      	ldr	r3, [r3, #0]
20003d58:	4a27      	ldr	r2, [pc, #156]	; (20003df8 <HAL_FLASHEx_Erase_IT+0xec>)
20003d5a:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
20003d5e:	6013      	str	r3, [r2, #0]
      pFlash.CacheToReactivate = FLASH_CACHE_ICACHE_DCACHE_ENABLED;
20003d60:	4b24      	ldr	r3, [pc, #144]	; (20003df4 <HAL_FLASHEx_Erase_IT+0xe8>)
20003d62:	2203      	movs	r2, #3
20003d64:	771a      	strb	r2, [r3, #28]
20003d66:	e016      	b.n	20003d96 <HAL_FLASHEx_Erase_IT+0x8a>
    }
    else
    {
      pFlash.CacheToReactivate = FLASH_CACHE_ICACHE_ENABLED;
20003d68:	4b22      	ldr	r3, [pc, #136]	; (20003df4 <HAL_FLASHEx_Erase_IT+0xe8>)
20003d6a:	2201      	movs	r2, #1
20003d6c:	771a      	strb	r2, [r3, #28]
20003d6e:	e012      	b.n	20003d96 <HAL_FLASHEx_Erase_IT+0x8a>
    }
  }
  else if (READ_BIT(FLASH->ACR, FLASH_ACR_DCEN) != 0U)
20003d70:	4b21      	ldr	r3, [pc, #132]	; (20003df8 <HAL_FLASHEx_Erase_IT+0xec>)
20003d72:	681b      	ldr	r3, [r3, #0]
20003d74:	f403 6380 	and.w	r3, r3, #1024	; 0x400
20003d78:	2b00      	cmp	r3, #0
20003d7a:	d009      	beq.n	20003d90 <HAL_FLASHEx_Erase_IT+0x84>
  {
    /* Disable data cache  */
    __HAL_FLASH_DATA_CACHE_DISABLE();
20003d7c:	4b1e      	ldr	r3, [pc, #120]	; (20003df8 <HAL_FLASHEx_Erase_IT+0xec>)
20003d7e:	681b      	ldr	r3, [r3, #0]
20003d80:	4a1d      	ldr	r2, [pc, #116]	; (20003df8 <HAL_FLASHEx_Erase_IT+0xec>)
20003d82:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
20003d86:	6013      	str	r3, [r2, #0]
    pFlash.CacheToReactivate = FLASH_CACHE_DCACHE_ENABLED;
20003d88:	4b1a      	ldr	r3, [pc, #104]	; (20003df4 <HAL_FLASHEx_Erase_IT+0xe8>)
20003d8a:	2202      	movs	r2, #2
20003d8c:	771a      	strb	r2, [r3, #28]
20003d8e:	e002      	b.n	20003d96 <HAL_FLASHEx_Erase_IT+0x8a>
  }
  else
  {
    pFlash.CacheToReactivate = FLASH_CACHE_DISABLED;
20003d90:	4b18      	ldr	r3, [pc, #96]	; (20003df4 <HAL_FLASHEx_Erase_IT+0xe8>)
20003d92:	2200      	movs	r2, #0
20003d94:	771a      	strb	r2, [r3, #28]
  }

  /* Enable End of Operation and Error interrupts */
  __HAL_FLASH_ENABLE_IT(FLASH_IT_EOP | FLASH_IT_OPERR);
20003d96:	4b18      	ldr	r3, [pc, #96]	; (20003df8 <HAL_FLASHEx_Erase_IT+0xec>)
20003d98:	695b      	ldr	r3, [r3, #20]
20003d9a:	4a17      	ldr	r2, [pc, #92]	; (20003df8 <HAL_FLASHEx_Erase_IT+0xec>)
20003d9c:	f043 7340 	orr.w	r3, r3, #50331648	; 0x3000000
20003da0:	6153      	str	r3, [r2, #20]

  pFlash.Bank = pEraseInit->Banks;
20003da2:	687b      	ldr	r3, [r7, #4]
20003da4:	685b      	ldr	r3, [r3, #4]
20003da6:	4a13      	ldr	r2, [pc, #76]	; (20003df4 <HAL_FLASHEx_Erase_IT+0xe8>)
20003da8:	6113      	str	r3, [r2, #16]

  if (pEraseInit->TypeErase == FLASH_TYPEERASE_MASSERASE)
20003daa:	687b      	ldr	r3, [r7, #4]
20003dac:	681b      	ldr	r3, [r3, #0]
20003dae:	2b01      	cmp	r3, #1
20003db0:	d108      	bne.n	20003dc4 <HAL_FLASHEx_Erase_IT+0xb8>
  {
    /* Mass erase to be done */
    pFlash.ProcedureOnGoing = FLASH_PROC_MASS_ERASE;
20003db2:	4b10      	ldr	r3, [pc, #64]	; (20003df4 <HAL_FLASHEx_Erase_IT+0xe8>)
20003db4:	2202      	movs	r2, #2
20003db6:	721a      	strb	r2, [r3, #8]
    FLASH_MassErase(pEraseInit->Banks);
20003db8:	687b      	ldr	r3, [r7, #4]
20003dba:	685b      	ldr	r3, [r3, #4]
20003dbc:	4618      	mov	r0, r3
20003dbe:	f000 f96d 	bl	2000409c <FLASH_MassErase>
20003dc2:	e012      	b.n	20003dea <HAL_FLASHEx_Erase_IT+0xde>
  }
  else
  {
    /* Erase by page to be done */
    pFlash.ProcedureOnGoing = FLASH_PROC_PAGE_ERASE;
20003dc4:	4b0b      	ldr	r3, [pc, #44]	; (20003df4 <HAL_FLASHEx_Erase_IT+0xe8>)
20003dc6:	2201      	movs	r2, #1
20003dc8:	721a      	strb	r2, [r3, #8]
    pFlash.NbPagesToErase = pEraseInit->NbPages;
20003dca:	687b      	ldr	r3, [r7, #4]
20003dcc:	68db      	ldr	r3, [r3, #12]
20003dce:	4a09      	ldr	r2, [pc, #36]	; (20003df4 <HAL_FLASHEx_Erase_IT+0xe8>)
20003dd0:	6193      	str	r3, [r2, #24]
    pFlash.Page = pEraseInit->Page;
20003dd2:	687b      	ldr	r3, [r7, #4]
20003dd4:	689b      	ldr	r3, [r3, #8]
20003dd6:	4a07      	ldr	r2, [pc, #28]	; (20003df4 <HAL_FLASHEx_Erase_IT+0xe8>)
20003dd8:	6153      	str	r3, [r2, #20]

    /*Erase 1st page and wait for IT */
    FLASH_PageErase(pEraseInit->Page, pEraseInit->Banks);
20003dda:	687b      	ldr	r3, [r7, #4]
20003ddc:	689a      	ldr	r2, [r3, #8]
20003dde:	687b      	ldr	r3, [r7, #4]
20003de0:	685b      	ldr	r3, [r3, #4]
20003de2:	4619      	mov	r1, r3
20003de4:	4610      	mov	r0, r2
20003de6:	f000 f991 	bl	2000410c <FLASH_PageErase>
  }

  return status;
20003dea:	7bfb      	ldrb	r3, [r7, #15]
}
20003dec:	4618      	mov	r0, r3
20003dee:	3710      	adds	r7, #16
20003df0:	46bd      	mov	sp, r7
20003df2:	bd80      	pop	{r7, pc}
20003df4:	200003fc 	.word	0x200003fc
20003df8:	40022000 	.word	0x40022000

20003dfc <HAL_FLASHEx_OBProgram>:
  *         - after an option bytes launch through the call of HAL_FLASH_OB_Launch()
  *         - after a power reset (BOR reset or exit from Standby/Shutdown modes)
  * @retval HAL_Status
  */
HAL_StatusTypeDef HAL_FLASHEx_OBProgram(FLASH_OBProgramInitTypeDef *pOBInit)
{
20003dfc:	b580      	push	{r7, lr}
20003dfe:	b084      	sub	sp, #16
20003e00:	af00      	add	r7, sp, #0
20003e02:	6078      	str	r0, [r7, #4]
  HAL_StatusTypeDef status = HAL_OK;
20003e04:	2300      	movs	r3, #0
20003e06:	73fb      	strb	r3, [r7, #15]

  /* Check the parameters */
  assert_param(IS_OPTIONBYTE(pOBInit->OptionType));

  /* Process Locked */
  __HAL_LOCK(&pFlash);
20003e08:	4b43      	ldr	r3, [pc, #268]	; (20003f18 <HAL_FLASHEx_OBProgram+0x11c>)
20003e0a:	781b      	ldrb	r3, [r3, #0]
20003e0c:	2b01      	cmp	r3, #1
20003e0e:	d101      	bne.n	20003e14 <HAL_FLASHEx_OBProgram+0x18>
20003e10:	2302      	movs	r3, #2
20003e12:	e07d      	b.n	20003f10 <HAL_FLASHEx_OBProgram+0x114>
20003e14:	4b40      	ldr	r3, [pc, #256]	; (20003f18 <HAL_FLASHEx_OBProgram+0x11c>)
20003e16:	2201      	movs	r2, #1
20003e18:	701a      	strb	r2, [r3, #0]

  pFlash.ErrorCode = HAL_FLASH_ERROR_NONE;
20003e1a:	4b3f      	ldr	r3, [pc, #252]	; (20003f18 <HAL_FLASHEx_OBProgram+0x11c>)
20003e1c:	2200      	movs	r2, #0
20003e1e:	605a      	str	r2, [r3, #4]

  /* Write protection configuration */
  if ((pOBInit->OptionType & OPTIONBYTE_WRP) != 0U)
20003e20:	687b      	ldr	r3, [r7, #4]
20003e22:	681b      	ldr	r3, [r3, #0]
20003e24:	f003 0301 	and.w	r3, r3, #1
20003e28:	2b00      	cmp	r3, #0
20003e2a:	d00d      	beq.n	20003e48 <HAL_FLASHEx_OBProgram+0x4c>
  {
    /* Configure of Write protection on the selected area */
    if (FLASH_OB_WRPConfig(pOBInit->WRPArea, pOBInit->WRPStartOffset, pOBInit->WRPEndOffset) != HAL_OK)
20003e2c:	687b      	ldr	r3, [r7, #4]
20003e2e:	6858      	ldr	r0, [r3, #4]
20003e30:	687b      	ldr	r3, [r7, #4]
20003e32:	6899      	ldr	r1, [r3, #8]
20003e34:	687b      	ldr	r3, [r7, #4]
20003e36:	68db      	ldr	r3, [r3, #12]
20003e38:	461a      	mov	r2, r3
20003e3a:	f000 f9ef 	bl	2000421c <FLASH_OB_WRPConfig>
20003e3e:	4603      	mov	r3, r0
20003e40:	2b00      	cmp	r3, #0
20003e42:	d001      	beq.n	20003e48 <HAL_FLASHEx_OBProgram+0x4c>
    {
      status = HAL_ERROR;
20003e44:	2301      	movs	r3, #1
20003e46:	73fb      	strb	r3, [r7, #15]
    }
  }

  /* Read protection configuration */
  if ((pOBInit->OptionType & OPTIONBYTE_RDP) != 0U)
20003e48:	687b      	ldr	r3, [r7, #4]
20003e4a:	681b      	ldr	r3, [r3, #0]
20003e4c:	f003 0302 	and.w	r3, r3, #2
20003e50:	2b00      	cmp	r3, #0
20003e52:	d009      	beq.n	20003e68 <HAL_FLASHEx_OBProgram+0x6c>
  {
    /* Configure the Read protection level */
    if (FLASH_OB_RDPConfig(pOBInit->RDPLevel) != HAL_OK)
20003e54:	687b      	ldr	r3, [r7, #4]
20003e56:	691b      	ldr	r3, [r3, #16]
20003e58:	4618      	mov	r0, r3
20003e5a:	f000 fa29 	bl	200042b0 <FLASH_OB_RDPConfig>
20003e5e:	4603      	mov	r3, r0
20003e60:	2b00      	cmp	r3, #0
20003e62:	d001      	beq.n	20003e68 <HAL_FLASHEx_OBProgram+0x6c>
    {
      status = HAL_ERROR;
20003e64:	2301      	movs	r3, #1
20003e66:	73fb      	strb	r3, [r7, #15]
    }
  }

  /* User Configuration */
  if ((pOBInit->OptionType & OPTIONBYTE_USER) != 0U)
20003e68:	687b      	ldr	r3, [r7, #4]
20003e6a:	681b      	ldr	r3, [r3, #0]
20003e6c:	f003 0304 	and.w	r3, r3, #4
20003e70:	2b00      	cmp	r3, #0
20003e72:	d00c      	beq.n	20003e8e <HAL_FLASHEx_OBProgram+0x92>
  {
    /* Configure the user option bytes */
    if (FLASH_OB_UserConfig(pOBInit->USERType, pOBInit->USERConfig) != HAL_OK)
20003e74:	687b      	ldr	r3, [r7, #4]
20003e76:	695a      	ldr	r2, [r3, #20]
20003e78:	687b      	ldr	r3, [r7, #4]
20003e7a:	699b      	ldr	r3, [r3, #24]
20003e7c:	4619      	mov	r1, r3
20003e7e:	4610      	mov	r0, r2
20003e80:	f000 fa3e 	bl	20004300 <FLASH_OB_UserConfig>
20003e84:	4603      	mov	r3, r0
20003e86:	2b00      	cmp	r3, #0
20003e88:	d001      	beq.n	20003e8e <HAL_FLASHEx_OBProgram+0x92>
    {
      status = HAL_ERROR;
20003e8a:	2301      	movs	r3, #1
20003e8c:	73fb      	strb	r3, [r7, #15]
    }
  }

  /* PCROP Configuration */
  if ((pOBInit->OptionType & OPTIONBYTE_PCROP) != 0U)
20003e8e:	687b      	ldr	r3, [r7, #4]
20003e90:	681b      	ldr	r3, [r3, #0]
20003e92:	f003 0308 	and.w	r3, r3, #8
20003e96:	2b00      	cmp	r3, #0
20003e98:	d013      	beq.n	20003ec2 <HAL_FLASHEx_OBProgram+0xc6>
  {
    if (pOBInit->PCROPStartAddr != pOBInit->PCROPEndAddr)
20003e9a:	687b      	ldr	r3, [r7, #4]
20003e9c:	6a1a      	ldr	r2, [r3, #32]
20003e9e:	687b      	ldr	r3, [r7, #4]
20003ea0:	6a5b      	ldr	r3, [r3, #36]	; 0x24
20003ea2:	429a      	cmp	r2, r3
20003ea4:	d00d      	beq.n	20003ec2 <HAL_FLASHEx_OBProgram+0xc6>
    {
      /* Configure the Proprietary code readout protection */
      if (FLASH_OB_PCROPConfig(pOBInit->PCROPConfig, pOBInit->PCROPStartAddr, pOBInit->PCROPEndAddr) != HAL_OK)
20003ea6:	687b      	ldr	r3, [r7, #4]
20003ea8:	69d8      	ldr	r0, [r3, #28]
20003eaa:	687b      	ldr	r3, [r7, #4]
20003eac:	6a19      	ldr	r1, [r3, #32]
20003eae:	687b      	ldr	r3, [r7, #4]
20003eb0:	6a5b      	ldr	r3, [r3, #36]	; 0x24
20003eb2:	461a      	mov	r2, r3
20003eb4:	f000 fb44 	bl	20004540 <FLASH_OB_PCROPConfig>
20003eb8:	4603      	mov	r3, r0
20003eba:	2b00      	cmp	r3, #0
20003ebc:	d001      	beq.n	20003ec2 <HAL_FLASHEx_OBProgram+0xc6>
      {
        status = HAL_ERROR;
20003ebe:	2301      	movs	r3, #1
20003ec0:	73fb      	strb	r3, [r7, #15]
      }
    }
  }

  /* Securable memory Configuration */
  if ((pOBInit->OptionType & OPTIONBYTE_SEC) != 0U)
20003ec2:	687b      	ldr	r3, [r7, #4]
20003ec4:	681b      	ldr	r3, [r3, #0]
20003ec6:	f003 0320 	and.w	r3, r3, #32
20003eca:	2b00      	cmp	r3, #0
20003ecc:	d00c      	beq.n	20003ee8 <HAL_FLASHEx_OBProgram+0xec>
  {
    /* Configure the securable memory area */
    if (FLASH_OB_SecMemConfig(pOBInit->SecBank, pOBInit->SecSize) != HAL_OK)
20003ece:	687b      	ldr	r3, [r7, #4]
20003ed0:	6ada      	ldr	r2, [r3, #44]	; 0x2c
20003ed2:	687b      	ldr	r3, [r7, #4]
20003ed4:	6b1b      	ldr	r3, [r3, #48]	; 0x30
20003ed6:	4619      	mov	r1, r3
20003ed8:	4610      	mov	r0, r2
20003eda:	f000 fc2b 	bl	20004734 <FLASH_OB_SecMemConfig>
20003ede:	4603      	mov	r3, r0
20003ee0:	2b00      	cmp	r3, #0
20003ee2:	d001      	beq.n	20003ee8 <HAL_FLASHEx_OBProgram+0xec>
    {
      status = HAL_ERROR;
20003ee4:	2301      	movs	r3, #1
20003ee6:	73fb      	strb	r3, [r7, #15]
    }
  }

  /* Boot Entry Point Configuration */
  if ((pOBInit->OptionType & OPTIONBYTE_BOOT_LOCK) != 0U)
20003ee8:	687b      	ldr	r3, [r7, #4]
20003eea:	681b      	ldr	r3, [r3, #0]
20003eec:	f003 0310 	and.w	r3, r3, #16
20003ef0:	2b00      	cmp	r3, #0
20003ef2:	d009      	beq.n	20003f08 <HAL_FLASHEx_OBProgram+0x10c>
  {
    /* Configure the boot unique entry point option */
    if (FLASH_OB_BootLockConfig(pOBInit->BootEntryPoint) != HAL_OK)
20003ef4:	687b      	ldr	r3, [r7, #4]
20003ef6:	6a9b      	ldr	r3, [r3, #40]	; 0x28
20003ef8:	4618      	mov	r0, r3
20003efa:	f000 fc53 	bl	200047a4 <FLASH_OB_BootLockConfig>
20003efe:	4603      	mov	r3, r0
20003f00:	2b00      	cmp	r3, #0
20003f02:	d001      	beq.n	20003f08 <HAL_FLASHEx_OBProgram+0x10c>
    {
      status = HAL_ERROR;
20003f04:	2301      	movs	r3, #1
20003f06:	73fb      	strb	r3, [r7, #15]
    }
  }

  /* Process Unlocked */
  __HAL_UNLOCK(&pFlash);
20003f08:	4b03      	ldr	r3, [pc, #12]	; (20003f18 <HAL_FLASHEx_OBProgram+0x11c>)
20003f0a:	2200      	movs	r2, #0
20003f0c:	701a      	strb	r2, [r3, #0]

  return status;
20003f0e:	7bfb      	ldrb	r3, [r7, #15]
}
20003f10:	4618      	mov	r0, r3
20003f12:	3710      	adds	r7, #16
20003f14:	46bd      	mov	sp, r7
20003f16:	bd80      	pop	{r7, pc}
20003f18:	200003fc 	.word	0x200003fc

20003f1c <HAL_FLASHEx_OBGetConfig>:
  * @note   The fields pOBInit->WRPArea and pOBInit->PCROPConfig should indicate
  *         which area is requested for the WRP and PCROP, else no information will be returned.
  * @retval None
  */
void HAL_FLASHEx_OBGetConfig(FLASH_OBProgramInitTypeDef *pOBInit)
{
20003f1c:	b580      	push	{r7, lr}
20003f1e:	b082      	sub	sp, #8
20003f20:	af00      	add	r7, sp, #0
20003f22:	6078      	str	r0, [r7, #4]
  pOBInit->OptionType = (OPTIONBYTE_RDP | OPTIONBYTE_USER);
20003f24:	687b      	ldr	r3, [r7, #4]
20003f26:	2206      	movs	r2, #6
20003f28:	601a      	str	r2, [r3, #0]

#if defined (FLASH_OPTR_DBANK)
  if ((pOBInit->WRPArea == OB_WRPAREA_BANK1_AREAA) || (pOBInit->WRPArea == OB_WRPAREA_BANK1_AREAB) ||
20003f2a:	687b      	ldr	r3, [r7, #4]
20003f2c:	685b      	ldr	r3, [r3, #4]
20003f2e:	2b00      	cmp	r3, #0
20003f30:	d00b      	beq.n	20003f4a <HAL_FLASHEx_OBGetConfig+0x2e>
20003f32:	687b      	ldr	r3, [r7, #4]
20003f34:	685b      	ldr	r3, [r3, #4]
20003f36:	2b01      	cmp	r3, #1
20003f38:	d007      	beq.n	20003f4a <HAL_FLASHEx_OBGetConfig+0x2e>
      (pOBInit->WRPArea == OB_WRPAREA_BANK2_AREAA) || (pOBInit->WRPArea == OB_WRPAREA_BANK2_AREAB))
20003f3a:	687b      	ldr	r3, [r7, #4]
20003f3c:	685b      	ldr	r3, [r3, #4]
  if ((pOBInit->WRPArea == OB_WRPAREA_BANK1_AREAA) || (pOBInit->WRPArea == OB_WRPAREA_BANK1_AREAB) ||
20003f3e:	2b02      	cmp	r3, #2
20003f40:	d003      	beq.n	20003f4a <HAL_FLASHEx_OBGetConfig+0x2e>
      (pOBInit->WRPArea == OB_WRPAREA_BANK2_AREAA) || (pOBInit->WRPArea == OB_WRPAREA_BANK2_AREAB))
20003f42:	687b      	ldr	r3, [r7, #4]
20003f44:	685b      	ldr	r3, [r3, #4]
20003f46:	2b04      	cmp	r3, #4
20003f48:	d10f      	bne.n	20003f6a <HAL_FLASHEx_OBGetConfig+0x4e>
#else
  if ((pOBInit->WRPArea == OB_WRPAREA_BANK1_AREAA) || (pOBInit->WRPArea == OB_WRPAREA_BANK1_AREAB))
#endif
  {
    pOBInit->OptionType |= OPTIONBYTE_WRP;
20003f4a:	687b      	ldr	r3, [r7, #4]
20003f4c:	681b      	ldr	r3, [r3, #0]
20003f4e:	f043 0201 	orr.w	r2, r3, #1
20003f52:	687b      	ldr	r3, [r7, #4]
20003f54:	601a      	str	r2, [r3, #0]
    /* Get write protection on the selected area */
    FLASH_OB_GetWRP(pOBInit->WRPArea, &(pOBInit->WRPStartOffset), &(pOBInit->WRPEndOffset));
20003f56:	687b      	ldr	r3, [r7, #4]
20003f58:	6858      	ldr	r0, [r3, #4]
20003f5a:	687b      	ldr	r3, [r7, #4]
20003f5c:	f103 0108 	add.w	r1, r3, #8
20003f60:	687b      	ldr	r3, [r7, #4]
20003f62:	330c      	adds	r3, #12
20003f64:	461a      	mov	r2, r3
20003f66:	f000 fc71 	bl	2000484c <FLASH_OB_GetWRP>
  }

  /* Get Read protection level */
  pOBInit->RDPLevel = FLASH_OB_GetRDP();
20003f6a:	f000 fcc1 	bl	200048f0 <FLASH_OB_GetRDP>
20003f6e:	4602      	mov	r2, r0
20003f70:	687b      	ldr	r3, [r7, #4]
20003f72:	611a      	str	r2, [r3, #16]

  /* Get the user option bytes */
  pOBInit->USERConfig = FLASH_OB_GetUser();
20003f74:	f000 fcd4 	bl	20004920 <FLASH_OB_GetUser>
20003f78:	4602      	mov	r2, r0
20003f7a:	687b      	ldr	r3, [r7, #4]
20003f7c:	619a      	str	r2, [r3, #24]

#if defined (FLASH_OPTR_DBANK)
  if ((pOBInit->PCROPConfig == FLASH_BANK_1) || (pOBInit->PCROPConfig == FLASH_BANK_2))
20003f7e:	687b      	ldr	r3, [r7, #4]
20003f80:	69db      	ldr	r3, [r3, #28]
20003f82:	2b01      	cmp	r3, #1
20003f84:	d003      	beq.n	20003f8e <HAL_FLASHEx_OBGetConfig+0x72>
20003f86:	687b      	ldr	r3, [r7, #4]
20003f88:	69db      	ldr	r3, [r3, #28]
20003f8a:	2b02      	cmp	r3, #2
20003f8c:	d110      	bne.n	20003fb0 <HAL_FLASHEx_OBGetConfig+0x94>
#else
  if (pOBInit->PCROPConfig == FLASH_BANK_1)
#endif
  {
    pOBInit->OptionType |= OPTIONBYTE_PCROP;
20003f8e:	687b      	ldr	r3, [r7, #4]
20003f90:	681b      	ldr	r3, [r3, #0]
20003f92:	f043 0208 	orr.w	r2, r3, #8
20003f96:	687b      	ldr	r3, [r7, #4]
20003f98:	601a      	str	r2, [r3, #0]
    /* Get the Proprietary code readout protection */
    FLASH_OB_GetPCROP(&(pOBInit->PCROPConfig), &(pOBInit->PCROPStartAddr), &(pOBInit->PCROPEndAddr));
20003f9a:	687b      	ldr	r3, [r7, #4]
20003f9c:	f103 001c 	add.w	r0, r3, #28
20003fa0:	687b      	ldr	r3, [r7, #4]
20003fa2:	f103 0120 	add.w	r1, r3, #32
20003fa6:	687b      	ldr	r3, [r7, #4]
20003fa8:	3324      	adds	r3, #36	; 0x24
20003faa:	461a      	mov	r2, r3
20003fac:	f000 fccc 	bl	20004948 <FLASH_OB_GetPCROP>
  }

  pOBInit->OptionType |= OPTIONBYTE_BOOT_LOCK;
20003fb0:	687b      	ldr	r3, [r7, #4]
20003fb2:	681b      	ldr	r3, [r3, #0]
20003fb4:	f043 0210 	orr.w	r2, r3, #16
20003fb8:	687b      	ldr	r3, [r7, #4]
20003fba:	601a      	str	r2, [r3, #0]

  /* Get the boot entry point */
  pOBInit->BootEntryPoint = FLASH_OB_GetBootLock();
20003fbc:	f000 fc38 	bl	20004830 <FLASH_OB_GetBootLock>
20003fc0:	4602      	mov	r2, r0
20003fc2:	687b      	ldr	r3, [r7, #4]
20003fc4:	629a      	str	r2, [r3, #40]	; 0x28

  /* Get the securable memory area configuration */
#if defined (FLASH_OPTR_DBANK)
  if ((pOBInit->SecBank == FLASH_BANK_1) || (pOBInit->SecBank == FLASH_BANK_2))
20003fc6:	687b      	ldr	r3, [r7, #4]
20003fc8:	6adb      	ldr	r3, [r3, #44]	; 0x2c
20003fca:	2b01      	cmp	r3, #1
20003fcc:	d003      	beq.n	20003fd6 <HAL_FLASHEx_OBGetConfig+0xba>
20003fce:	687b      	ldr	r3, [r7, #4]
20003fd0:	6adb      	ldr	r3, [r3, #44]	; 0x2c
20003fd2:	2b02      	cmp	r3, #2
20003fd4:	d10d      	bne.n	20003ff2 <HAL_FLASHEx_OBGetConfig+0xd6>
#else
  if (pOBInit->SecBank == FLASH_BANK_1)
#endif
  {
    pOBInit->OptionType |= OPTIONBYTE_SEC;
20003fd6:	687b      	ldr	r3, [r7, #4]
20003fd8:	681b      	ldr	r3, [r3, #0]
20003fda:	f043 0220 	orr.w	r2, r3, #32
20003fde:	687b      	ldr	r3, [r7, #4]
20003fe0:	601a      	str	r2, [r3, #0]
    FLASH_OB_GetSecMem(pOBInit->SecBank, &(pOBInit->SecSize));
20003fe2:	687b      	ldr	r3, [r7, #4]
20003fe4:	6ada      	ldr	r2, [r3, #44]	; 0x2c
20003fe6:	687b      	ldr	r3, [r7, #4]
20003fe8:	3330      	adds	r3, #48	; 0x30
20003fea:	4619      	mov	r1, r3
20003fec:	4610      	mov	r0, r2
20003fee:	f000 fc01 	bl	200047f4 <FLASH_OB_GetSecMem>
  }
}
20003ff2:	bf00      	nop
20003ff4:	3708      	adds	r7, #8
20003ff6:	46bd      	mov	sp, r7
20003ff8:	bd80      	pop	{r7, pc}
	...

20003ffc <HAL_FLASHEx_EnableSecMemProtection>:
  *            @arg FLASH_BANK_BOTH: Bank1 and Bank2 to be protected (*)
  * @note   (*) availability depends on devices
  * @retval HAL Status
  */
HAL_StatusTypeDef HAL_FLASHEx_EnableSecMemProtection(uint32_t Bank)
{
20003ffc:	b480      	push	{r7}
20003ffe:	b083      	sub	sp, #12
20004000:	af00      	add	r7, sp, #0
20004002:	6078      	str	r0, [r7, #4]
#if defined (FLASH_OPTR_DBANK)
  if (READ_BIT(FLASH->OPTR, FLASH_OPTR_DBANK) != 0U)
20004004:	4b14      	ldr	r3, [pc, #80]	; (20004058 <HAL_FLASHEx_EnableSecMemProtection+0x5c>)
20004006:	6a1b      	ldr	r3, [r3, #32]
20004008:	f403 0380 	and.w	r3, r3, #4194304	; 0x400000
2000400c:	2b00      	cmp	r3, #0
2000400e:	d016      	beq.n	2000403e <HAL_FLASHEx_EnableSecMemProtection+0x42>
  {
    /* Check the parameters */
    assert_param(IS_FLASH_BANK(Bank));

    /* Enable the Securable Memory Protection Bit for the bank 1 if requested */
    if ((Bank & FLASH_BANK_1) != 0U)
20004010:	687b      	ldr	r3, [r7, #4]
20004012:	f003 0301 	and.w	r3, r3, #1
20004016:	2b00      	cmp	r3, #0
20004018:	d005      	beq.n	20004026 <HAL_FLASHEx_EnableSecMemProtection+0x2a>
    {
      SET_BIT(FLASH->CR, FLASH_CR_SEC_PROT1);
2000401a:	4b0f      	ldr	r3, [pc, #60]	; (20004058 <HAL_FLASHEx_EnableSecMemProtection+0x5c>)
2000401c:	695b      	ldr	r3, [r3, #20]
2000401e:	4a0e      	ldr	r2, [pc, #56]	; (20004058 <HAL_FLASHEx_EnableSecMemProtection+0x5c>)
20004020:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
20004024:	6153      	str	r3, [r2, #20]
    }

    /* Enable the Securable Memory Protection Bit for the bank 2 if requested */
    if ((Bank & FLASH_BANK_2) != 0U)
20004026:	687b      	ldr	r3, [r7, #4]
20004028:	f003 0302 	and.w	r3, r3, #2
2000402c:	2b00      	cmp	r3, #0
2000402e:	d00c      	beq.n	2000404a <HAL_FLASHEx_EnableSecMemProtection+0x4e>
    {
      SET_BIT(FLASH->CR, FLASH_CR_SEC_PROT2);
20004030:	4b09      	ldr	r3, [pc, #36]	; (20004058 <HAL_FLASHEx_EnableSecMemProtection+0x5c>)
20004032:	695b      	ldr	r3, [r3, #20]
20004034:	4a08      	ldr	r2, [pc, #32]	; (20004058 <HAL_FLASHEx_EnableSecMemProtection+0x5c>)
20004036:	f043 5300 	orr.w	r3, r3, #536870912	; 0x20000000
2000403a:	6153      	str	r3, [r2, #20]
2000403c:	e005      	b.n	2000404a <HAL_FLASHEx_EnableSecMemProtection+0x4e>
    }
  }
  else
#endif
  {
    SET_BIT(FLASH->CR, FLASH_CR_SEC_PROT1);
2000403e:	4b06      	ldr	r3, [pc, #24]	; (20004058 <HAL_FLASHEx_EnableSecMemProtection+0x5c>)
20004040:	695b      	ldr	r3, [r3, #20]
20004042:	4a05      	ldr	r2, [pc, #20]	; (20004058 <HAL_FLASHEx_EnableSecMemProtection+0x5c>)
20004044:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
20004048:	6153      	str	r3, [r2, #20]
  }

  return HAL_OK;
2000404a:	2300      	movs	r3, #0
}
2000404c:	4618      	mov	r0, r3
2000404e:	370c      	adds	r7, #12
20004050:	46bd      	mov	sp, r7
20004052:	f85d 7b04 	ldr.w	r7, [sp], #4
20004056:	4770      	bx	lr
20004058:	40022000 	.word	0x40022000

2000405c <HAL_FLASHEx_EnableDebugger>:
  * @brief  Enable Debugger.
  * @note   After calling this API, flash interface allow debugger intrusion.
  * @retval None
  */
void HAL_FLASHEx_EnableDebugger(void)
{
2000405c:	b480      	push	{r7}
2000405e:	af00      	add	r7, sp, #0
  FLASH->ACR |= FLASH_ACR_DBG_SWEN;
20004060:	4b05      	ldr	r3, [pc, #20]	; (20004078 <HAL_FLASHEx_EnableDebugger+0x1c>)
20004062:	681b      	ldr	r3, [r3, #0]
20004064:	4a04      	ldr	r2, [pc, #16]	; (20004078 <HAL_FLASHEx_EnableDebugger+0x1c>)
20004066:	f443 2380 	orr.w	r3, r3, #262144	; 0x40000
2000406a:	6013      	str	r3, [r2, #0]
}
2000406c:	bf00      	nop
2000406e:	46bd      	mov	sp, r7
20004070:	f85d 7b04 	ldr.w	r7, [sp], #4
20004074:	4770      	bx	lr
20004076:	bf00      	nop
20004078:	40022000 	.word	0x40022000

2000407c <HAL_FLASHEx_DisableDebugger>:
  * @note   After calling this API, Debugger is disabled: it's no more possible to
  *         break, see CPU register, etc...
  * @retval None
  */
void HAL_FLASHEx_DisableDebugger(void)
{
2000407c:	b480      	push	{r7}
2000407e:	af00      	add	r7, sp, #0
  FLASH->ACR &= ~FLASH_ACR_DBG_SWEN;
20004080:	4b05      	ldr	r3, [pc, #20]	; (20004098 <HAL_FLASHEx_DisableDebugger+0x1c>)
20004082:	681b      	ldr	r3, [r3, #0]
20004084:	4a04      	ldr	r2, [pc, #16]	; (20004098 <HAL_FLASHEx_DisableDebugger+0x1c>)
20004086:	f423 2380 	bic.w	r3, r3, #262144	; 0x40000
2000408a:	6013      	str	r3, [r2, #0]
}
2000408c:	bf00      	nop
2000408e:	46bd      	mov	sp, r7
20004090:	f85d 7b04 	ldr.w	r7, [sp], #4
20004094:	4770      	bx	lr
20004096:	bf00      	nop
20004098:	40022000 	.word	0x40022000

2000409c <FLASH_MassErase>:
  *            @arg FLASH_BANK_BOTH: Bank1 and Bank2 to be erased (*)
  * @note   (*) availability depends on devices
  * @retval None
  */
static void FLASH_MassErase(uint32_t Banks)
{
2000409c:	b480      	push	{r7}
2000409e:	b083      	sub	sp, #12
200040a0:	af00      	add	r7, sp, #0
200040a2:	6078      	str	r0, [r7, #4]
#if defined (FLASH_OPTR_DBANK)
  if (READ_BIT(FLASH->OPTR, FLASH_OPTR_DBANK) != 0U)
200040a4:	4b18      	ldr	r3, [pc, #96]	; (20004108 <FLASH_MassErase+0x6c>)
200040a6:	6a1b      	ldr	r3, [r3, #32]
200040a8:	f403 0380 	and.w	r3, r3, #4194304	; 0x400000
200040ac:	2b00      	cmp	r3, #0
200040ae:	d016      	beq.n	200040de <FLASH_MassErase+0x42>
  {
    /* Check the parameters */
    assert_param(IS_FLASH_BANK(Banks));

    /* Set the Mass Erase Bit for the bank 1 if requested */
    if ((Banks & FLASH_BANK_1) != 0U)
200040b0:	687b      	ldr	r3, [r7, #4]
200040b2:	f003 0301 	and.w	r3, r3, #1
200040b6:	2b00      	cmp	r3, #0
200040b8:	d005      	beq.n	200040c6 <FLASH_MassErase+0x2a>
    {
      SET_BIT(FLASH->CR, FLASH_CR_MER1);
200040ba:	4b13      	ldr	r3, [pc, #76]	; (20004108 <FLASH_MassErase+0x6c>)
200040bc:	695b      	ldr	r3, [r3, #20]
200040be:	4a12      	ldr	r2, [pc, #72]	; (20004108 <FLASH_MassErase+0x6c>)
200040c0:	f043 0304 	orr.w	r3, r3, #4
200040c4:	6153      	str	r3, [r2, #20]
    }

#if defined (FLASH_OPTR_DBANK)
    /* Set the Mass Erase Bit for the bank 2 if requested */
    if ((Banks & FLASH_BANK_2) != 0U)
200040c6:	687b      	ldr	r3, [r7, #4]
200040c8:	f003 0302 	and.w	r3, r3, #2
200040cc:	2b00      	cmp	r3, #0
200040ce:	d00e      	beq.n	200040ee <FLASH_MassErase+0x52>
    {
      SET_BIT(FLASH->CR, FLASH_CR_MER2);
200040d0:	4b0d      	ldr	r3, [pc, #52]	; (20004108 <FLASH_MassErase+0x6c>)
200040d2:	695b      	ldr	r3, [r3, #20]
200040d4:	4a0c      	ldr	r2, [pc, #48]	; (20004108 <FLASH_MassErase+0x6c>)
200040d6:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
200040da:	6153      	str	r3, [r2, #20]
200040dc:	e007      	b.n	200040ee <FLASH_MassErase+0x52>
#endif
  }
#if defined (FLASH_OPTR_DBANK)
  else
  {
    SET_BIT(FLASH->CR, (FLASH_CR_MER1 | FLASH_CR_MER2));
200040de:	4b0a      	ldr	r3, [pc, #40]	; (20004108 <FLASH_MassErase+0x6c>)
200040e0:	695b      	ldr	r3, [r3, #20]
200040e2:	4a09      	ldr	r2, [pc, #36]	; (20004108 <FLASH_MassErase+0x6c>)
200040e4:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
200040e8:	f043 0304 	orr.w	r3, r3, #4
200040ec:	6153      	str	r3, [r2, #20]
  }
#endif

  /* Proceed to erase all sectors */
  SET_BIT(FLASH->CR, FLASH_CR_STRT);
200040ee:	4b06      	ldr	r3, [pc, #24]	; (20004108 <FLASH_MassErase+0x6c>)
200040f0:	695b      	ldr	r3, [r3, #20]
200040f2:	4a05      	ldr	r2, [pc, #20]	; (20004108 <FLASH_MassErase+0x6c>)
200040f4:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
200040f8:	6153      	str	r3, [r2, #20]
}
200040fa:	bf00      	nop
200040fc:	370c      	adds	r7, #12
200040fe:	46bd      	mov	sp, r7
20004100:	f85d 7b04 	ldr.w	r7, [sp], #4
20004104:	4770      	bx	lr
20004106:	bf00      	nop
20004108:	40022000 	.word	0x40022000

2000410c <FLASH_PageErase>:
  *            @arg FLASH_BANK_2: Page in bank 2 to be erased (*)
  * @note   (*) availability depends on devices
  * @retval None
  */
void FLASH_PageErase(uint32_t Page, uint32_t Banks)
{
2000410c:	b480      	push	{r7}
2000410e:	b083      	sub	sp, #12
20004110:	af00      	add	r7, sp, #0
20004112:	6078      	str	r0, [r7, #4]
20004114:	6039      	str	r1, [r7, #0]
  /* Check the parameters */
  assert_param(IS_FLASH_PAGE(Page));

#if defined (FLASH_OPTR_DBANK)
  if (READ_BIT(FLASH->OPTR, FLASH_OPTR_DBANK) == 0U)
20004116:	4b1e      	ldr	r3, [pc, #120]	; (20004190 <FLASH_PageErase+0x84>)
20004118:	6a1b      	ldr	r3, [r3, #32]
2000411a:	f403 0380 	and.w	r3, r3, #4194304	; 0x400000
2000411e:	2b00      	cmp	r3, #0
20004120:	d106      	bne.n	20004130 <FLASH_PageErase+0x24>
  {
    CLEAR_BIT(FLASH->CR, FLASH_CR_BKER);
20004122:	4b1b      	ldr	r3, [pc, #108]	; (20004190 <FLASH_PageErase+0x84>)
20004124:	695b      	ldr	r3, [r3, #20]
20004126:	4a1a      	ldr	r2, [pc, #104]	; (20004190 <FLASH_PageErase+0x84>)
20004128:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
2000412c:	6153      	str	r3, [r2, #20]
2000412e:	e011      	b.n	20004154 <FLASH_PageErase+0x48>
  }
  else
  {
    assert_param(IS_FLASH_BANK_EXCLUSIVE(Banks));

    if ((Banks & FLASH_BANK_1) != 0U)
20004130:	683b      	ldr	r3, [r7, #0]
20004132:	f003 0301 	and.w	r3, r3, #1
20004136:	2b00      	cmp	r3, #0
20004138:	d006      	beq.n	20004148 <FLASH_PageErase+0x3c>
    {
      CLEAR_BIT(FLASH->CR, FLASH_CR_BKER);
2000413a:	4b15      	ldr	r3, [pc, #84]	; (20004190 <FLASH_PageErase+0x84>)
2000413c:	695b      	ldr	r3, [r3, #20]
2000413e:	4a14      	ldr	r2, [pc, #80]	; (20004190 <FLASH_PageErase+0x84>)
20004140:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
20004144:	6153      	str	r3, [r2, #20]
20004146:	e005      	b.n	20004154 <FLASH_PageErase+0x48>
    }
    else
    {
      SET_BIT(FLASH->CR, FLASH_CR_BKER);
20004148:	4b11      	ldr	r3, [pc, #68]	; (20004190 <FLASH_PageErase+0x84>)
2000414a:	695b      	ldr	r3, [r3, #20]
2000414c:	4a10      	ldr	r2, [pc, #64]	; (20004190 <FLASH_PageErase+0x84>)
2000414e:	f443 6300 	orr.w	r3, r3, #2048	; 0x800
20004152:	6153      	str	r3, [r2, #20]
    }
  }
#endif

  /* Proceed to erase the page */
  MODIFY_REG(FLASH->CR, FLASH_CR_PNB, ((Page & 0xFFU) << FLASH_CR_PNB_Pos));
20004154:	4b0e      	ldr	r3, [pc, #56]	; (20004190 <FLASH_PageErase+0x84>)
20004156:	695b      	ldr	r3, [r3, #20]
20004158:	f423 727e 	bic.w	r2, r3, #1016	; 0x3f8
2000415c:	687b      	ldr	r3, [r7, #4]
2000415e:	00db      	lsls	r3, r3, #3
20004160:	f403 63ff 	and.w	r3, r3, #2040	; 0x7f8
20004164:	490a      	ldr	r1, [pc, #40]	; (20004190 <FLASH_PageErase+0x84>)
20004166:	4313      	orrs	r3, r2
20004168:	614b      	str	r3, [r1, #20]
  SET_BIT(FLASH->CR, FLASH_CR_PER);
2000416a:	4b09      	ldr	r3, [pc, #36]	; (20004190 <FLASH_PageErase+0x84>)
2000416c:	695b      	ldr	r3, [r3, #20]
2000416e:	4a08      	ldr	r2, [pc, #32]	; (20004190 <FLASH_PageErase+0x84>)
20004170:	f043 0302 	orr.w	r3, r3, #2
20004174:	6153      	str	r3, [r2, #20]
  SET_BIT(FLASH->CR, FLASH_CR_STRT);
20004176:	4b06      	ldr	r3, [pc, #24]	; (20004190 <FLASH_PageErase+0x84>)
20004178:	695b      	ldr	r3, [r3, #20]
2000417a:	4a05      	ldr	r2, [pc, #20]	; (20004190 <FLASH_PageErase+0x84>)
2000417c:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
20004180:	6153      	str	r3, [r2, #20]
}
20004182:	bf00      	nop
20004184:	370c      	adds	r7, #12
20004186:	46bd      	mov	sp, r7
20004188:	f85d 7b04 	ldr.w	r7, [sp], #4
2000418c:	4770      	bx	lr
2000418e:	bf00      	nop
20004190:	40022000 	.word	0x40022000

20004194 <FLASH_FlushCaches>:
/**
  * @brief  Flush the instruction and data caches.
  * @retval None
  */
void FLASH_FlushCaches(void)
{
20004194:	b480      	push	{r7}
20004196:	b083      	sub	sp, #12
20004198:	af00      	add	r7, sp, #0
  FLASH_CacheTypeDef cache = pFlash.CacheToReactivate;
2000419a:	4b1e      	ldr	r3, [pc, #120]	; (20004214 <FLASH_FlushCaches+0x80>)
2000419c:	7f1b      	ldrb	r3, [r3, #28]
2000419e:	71fb      	strb	r3, [r7, #7]

  /* Flush instruction cache  */
  if ((cache == FLASH_CACHE_ICACHE_ENABLED) ||
200041a0:	79fb      	ldrb	r3, [r7, #7]
200041a2:	2b01      	cmp	r3, #1
200041a4:	d002      	beq.n	200041ac <FLASH_FlushCaches+0x18>
200041a6:	79fb      	ldrb	r3, [r7, #7]
200041a8:	2b03      	cmp	r3, #3
200041aa:	d111      	bne.n	200041d0 <FLASH_FlushCaches+0x3c>
      (cache == FLASH_CACHE_ICACHE_DCACHE_ENABLED))
  {
    /* Reset instruction cache */
    __HAL_FLASH_INSTRUCTION_CACHE_RESET();
200041ac:	4b1a      	ldr	r3, [pc, #104]	; (20004218 <FLASH_FlushCaches+0x84>)
200041ae:	681b      	ldr	r3, [r3, #0]
200041b0:	4a19      	ldr	r2, [pc, #100]	; (20004218 <FLASH_FlushCaches+0x84>)
200041b2:	f443 6300 	orr.w	r3, r3, #2048	; 0x800
200041b6:	6013      	str	r3, [r2, #0]
200041b8:	4b17      	ldr	r3, [pc, #92]	; (20004218 <FLASH_FlushCaches+0x84>)
200041ba:	681b      	ldr	r3, [r3, #0]
200041bc:	4a16      	ldr	r2, [pc, #88]	; (20004218 <FLASH_FlushCaches+0x84>)
200041be:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
200041c2:	6013      	str	r3, [r2, #0]
    /* Enable instruction cache */
    __HAL_FLASH_INSTRUCTION_CACHE_ENABLE();
200041c4:	4b14      	ldr	r3, [pc, #80]	; (20004218 <FLASH_FlushCaches+0x84>)
200041c6:	681b      	ldr	r3, [r3, #0]
200041c8:	4a13      	ldr	r2, [pc, #76]	; (20004218 <FLASH_FlushCaches+0x84>)
200041ca:	f443 7300 	orr.w	r3, r3, #512	; 0x200
200041ce:	6013      	str	r3, [r2, #0]
  }

  /* Flush data cache */
  if ((cache == FLASH_CACHE_DCACHE_ENABLED) ||
200041d0:	79fb      	ldrb	r3, [r7, #7]
200041d2:	2b02      	cmp	r3, #2
200041d4:	d002      	beq.n	200041dc <FLASH_FlushCaches+0x48>
200041d6:	79fb      	ldrb	r3, [r7, #7]
200041d8:	2b03      	cmp	r3, #3
200041da:	d111      	bne.n	20004200 <FLASH_FlushCaches+0x6c>
      (cache == FLASH_CACHE_ICACHE_DCACHE_ENABLED))
  {
    /* Reset data cache */
    __HAL_FLASH_DATA_CACHE_RESET();
200041dc:	4b0e      	ldr	r3, [pc, #56]	; (20004218 <FLASH_FlushCaches+0x84>)
200041de:	681b      	ldr	r3, [r3, #0]
200041e0:	4a0d      	ldr	r2, [pc, #52]	; (20004218 <FLASH_FlushCaches+0x84>)
200041e2:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
200041e6:	6013      	str	r3, [r2, #0]
200041e8:	4b0b      	ldr	r3, [pc, #44]	; (20004218 <FLASH_FlushCaches+0x84>)
200041ea:	681b      	ldr	r3, [r3, #0]
200041ec:	4a0a      	ldr	r2, [pc, #40]	; (20004218 <FLASH_FlushCaches+0x84>)
200041ee:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
200041f2:	6013      	str	r3, [r2, #0]
    /* Enable data cache */
    __HAL_FLASH_DATA_CACHE_ENABLE();
200041f4:	4b08      	ldr	r3, [pc, #32]	; (20004218 <FLASH_FlushCaches+0x84>)
200041f6:	681b      	ldr	r3, [r3, #0]
200041f8:	4a07      	ldr	r2, [pc, #28]	; (20004218 <FLASH_FlushCaches+0x84>)
200041fa:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
200041fe:	6013      	str	r3, [r2, #0]
  }

  /* Reset internal variable */
  pFlash.CacheToReactivate = FLASH_CACHE_DISABLED;
20004200:	4b04      	ldr	r3, [pc, #16]	; (20004214 <FLASH_FlushCaches+0x80>)
20004202:	2200      	movs	r2, #0
20004204:	771a      	strb	r2, [r3, #28]
}
20004206:	bf00      	nop
20004208:	370c      	adds	r7, #12
2000420a:	46bd      	mov	sp, r7
2000420c:	f85d 7b04 	ldr.w	r7, [sp], #4
20004210:	4770      	bx	lr
20004212:	bf00      	nop
20004214:	200003fc 	.word	0x200003fc
20004218:	40022000 	.word	0x40022000

2000421c <FLASH_OB_WRPConfig>:
  * @param  WRDPEndOffset specifies the end page of the write protected area.
  *         This parameter can be page number between WRPStartOffset and (max number of pages in the bank - 1).
  * @retval HAL_Status
  */
static HAL_StatusTypeDef FLASH_OB_WRPConfig(uint32_t WRPArea, uint32_t WRPStartOffset, uint32_t WRDPEndOffset)
{
2000421c:	b580      	push	{r7, lr}
2000421e:	b086      	sub	sp, #24
20004220:	af00      	add	r7, sp, #0
20004222:	60f8      	str	r0, [r7, #12]
20004224:	60b9      	str	r1, [r7, #8]
20004226:	607a      	str	r2, [r7, #4]
  assert_param(IS_OB_WRPAREA(WRPArea));
  assert_param(IS_FLASH_PAGE(WRPStartOffset));
  assert_param(IS_FLASH_PAGE(WRDPEndOffset));

  /* Wait for last operation to be completed */
  status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
20004228:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
2000422c:	f7ff fc1c 	bl	20003a68 <FLASH_WaitForLastOperation>
20004230:	4603      	mov	r3, r0
20004232:	75fb      	strb	r3, [r7, #23]

  if (status == HAL_OK)
20004234:	7dfb      	ldrb	r3, [r7, #23]
20004236:	2b00      	cmp	r3, #0
20004238:	d132      	bne.n	200042a0 <FLASH_OB_WRPConfig+0x84>
  {
    /* Configure the write protected area */
    if (WRPArea == OB_WRPAREA_BANK1_AREAA)
2000423a:	68fb      	ldr	r3, [r7, #12]
2000423c:	2b00      	cmp	r3, #0
2000423e:	d106      	bne.n	2000424e <FLASH_OB_WRPConfig+0x32>
    {
      FLASH->WRP1AR = ((WRDPEndOffset << FLASH_WRP1AR_WRP1A_END_Pos) | WRPStartOffset);
20004240:	687b      	ldr	r3, [r7, #4]
20004242:	041a      	lsls	r2, r3, #16
20004244:	4919      	ldr	r1, [pc, #100]	; (200042ac <FLASH_OB_WRPConfig+0x90>)
20004246:	68bb      	ldr	r3, [r7, #8]
20004248:	4313      	orrs	r3, r2
2000424a:	62cb      	str	r3, [r1, #44]	; 0x2c
2000424c:	e01c      	b.n	20004288 <FLASH_OB_WRPConfig+0x6c>
    }
    else if (WRPArea == OB_WRPAREA_BANK1_AREAB)
2000424e:	68fb      	ldr	r3, [r7, #12]
20004250:	2b01      	cmp	r3, #1
20004252:	d106      	bne.n	20004262 <FLASH_OB_WRPConfig+0x46>
    {
      FLASH->WRP1BR = ((WRDPEndOffset << FLASH_WRP1BR_WRP1B_END_Pos) | WRPStartOffset);
20004254:	687b      	ldr	r3, [r7, #4]
20004256:	041a      	lsls	r2, r3, #16
20004258:	4914      	ldr	r1, [pc, #80]	; (200042ac <FLASH_OB_WRPConfig+0x90>)
2000425a:	68bb      	ldr	r3, [r7, #8]
2000425c:	4313      	orrs	r3, r2
2000425e:	630b      	str	r3, [r1, #48]	; 0x30
20004260:	e012      	b.n	20004288 <FLASH_OB_WRPConfig+0x6c>
    }
#if defined (FLASH_OPTR_DBANK)
    else if (WRPArea == OB_WRPAREA_BANK2_AREAA)
20004262:	68fb      	ldr	r3, [r7, #12]
20004264:	2b02      	cmp	r3, #2
20004266:	d106      	bne.n	20004276 <FLASH_OB_WRPConfig+0x5a>
    {
      FLASH->WRP2AR = ((WRDPEndOffset << FLASH_WRP2AR_WRP2A_END_Pos) | WRPStartOffset);
20004268:	687b      	ldr	r3, [r7, #4]
2000426a:	041a      	lsls	r2, r3, #16
2000426c:	490f      	ldr	r1, [pc, #60]	; (200042ac <FLASH_OB_WRPConfig+0x90>)
2000426e:	68bb      	ldr	r3, [r7, #8]
20004270:	4313      	orrs	r3, r2
20004272:	64cb      	str	r3, [r1, #76]	; 0x4c
20004274:	e008      	b.n	20004288 <FLASH_OB_WRPConfig+0x6c>
    }
    else if (WRPArea == OB_WRPAREA_BANK2_AREAB)
20004276:	68fb      	ldr	r3, [r7, #12]
20004278:	2b04      	cmp	r3, #4
2000427a:	d105      	bne.n	20004288 <FLASH_OB_WRPConfig+0x6c>
    {
      FLASH->WRP2BR = ((WRDPEndOffset << FLASH_WRP2BR_WRP2B_END_Pos) | WRPStartOffset);
2000427c:	687b      	ldr	r3, [r7, #4]
2000427e:	041a      	lsls	r2, r3, #16
20004280:	490a      	ldr	r1, [pc, #40]	; (200042ac <FLASH_OB_WRPConfig+0x90>)
20004282:	68bb      	ldr	r3, [r7, #8]
20004284:	4313      	orrs	r3, r2
20004286:	650b      	str	r3, [r1, #80]	; 0x50
    {
      /* Nothing to do */
    }

    /* Set OPTSTRT Bit */
    SET_BIT(FLASH->CR, FLASH_CR_OPTSTRT);
20004288:	4b08      	ldr	r3, [pc, #32]	; (200042ac <FLASH_OB_WRPConfig+0x90>)
2000428a:	695b      	ldr	r3, [r3, #20]
2000428c:	4a07      	ldr	r2, [pc, #28]	; (200042ac <FLASH_OB_WRPConfig+0x90>)
2000428e:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
20004292:	6153      	str	r3, [r2, #20]

    /* Wait for last operation to be completed */
    status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
20004294:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
20004298:	f7ff fbe6 	bl	20003a68 <FLASH_WaitForLastOperation>
2000429c:	4603      	mov	r3, r0
2000429e:	75fb      	strb	r3, [r7, #23]
  }

  return status;
200042a0:	7dfb      	ldrb	r3, [r7, #23]
}
200042a2:	4618      	mov	r0, r3
200042a4:	3718      	adds	r7, #24
200042a6:	46bd      	mov	sp, r7
200042a8:	bd80      	pop	{r7, pc}
200042aa:	bf00      	nop
200042ac:	40022000 	.word	0x40022000

200042b0 <FLASH_OB_RDPConfig>:
  *            @arg OB_RDP_LEVEL_2: Full chip protection
  *
  * @retval HAL_Status
  */
static HAL_StatusTypeDef FLASH_OB_RDPConfig(uint32_t RDPLevel)
{
200042b0:	b580      	push	{r7, lr}
200042b2:	b084      	sub	sp, #16
200042b4:	af00      	add	r7, sp, #0
200042b6:	6078      	str	r0, [r7, #4]

  /* Check the parameters */
  assert_param(IS_OB_RDP_LEVEL(RDPLevel));

  /* Wait for last operation to be completed */
  status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
200042b8:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
200042bc:	f7ff fbd4 	bl	20003a68 <FLASH_WaitForLastOperation>
200042c0:	4603      	mov	r3, r0
200042c2:	73fb      	strb	r3, [r7, #15]

  if (status == HAL_OK)
200042c4:	7bfb      	ldrb	r3, [r7, #15]
200042c6:	2b00      	cmp	r3, #0
200042c8:	d113      	bne.n	200042f2 <FLASH_OB_RDPConfig+0x42>
  {
    /* Configure the RDP level in the option bytes register */
    MODIFY_REG(FLASH->OPTR, FLASH_OPTR_RDP, RDPLevel);
200042ca:	4b0c      	ldr	r3, [pc, #48]	; (200042fc <FLASH_OB_RDPConfig+0x4c>)
200042cc:	6a1b      	ldr	r3, [r3, #32]
200042ce:	f023 02ff 	bic.w	r2, r3, #255	; 0xff
200042d2:	490a      	ldr	r1, [pc, #40]	; (200042fc <FLASH_OB_RDPConfig+0x4c>)
200042d4:	687b      	ldr	r3, [r7, #4]
200042d6:	4313      	orrs	r3, r2
200042d8:	620b      	str	r3, [r1, #32]

    /* Set OPTSTRT Bit */
    SET_BIT(FLASH->CR, FLASH_CR_OPTSTRT);
200042da:	4b08      	ldr	r3, [pc, #32]	; (200042fc <FLASH_OB_RDPConfig+0x4c>)
200042dc:	695b      	ldr	r3, [r3, #20]
200042de:	4a07      	ldr	r2, [pc, #28]	; (200042fc <FLASH_OB_RDPConfig+0x4c>)
200042e0:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
200042e4:	6153      	str	r3, [r2, #20]

    /* Wait for last operation to be completed */
    status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
200042e6:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
200042ea:	f7ff fbbd 	bl	20003a68 <FLASH_WaitForLastOperation>
200042ee:	4603      	mov	r3, r0
200042f0:	73fb      	strb	r3, [r7, #15]
  }

  return status;
200042f2:	7bfb      	ldrb	r3, [r7, #15]
}
200042f4:	4618      	mov	r0, r3
200042f6:	3710      	adds	r7, #16
200042f8:	46bd      	mov	sp, r7
200042fa:	bd80      	pop	{r7, pc}
200042fc:	40022000 	.word	0x40022000

20004300 <FLASH_OB_UserConfig>:
  *         @ref FLASH_OB_USER_NRST_MODE, @ref FLASH_OB_USER_INTERNAL_RESET_HOLDER
  * @note   (*) availability depends on devices
  * @retval HAL_Status
  */
static HAL_StatusTypeDef FLASH_OB_UserConfig(uint32_t UserType, uint32_t UserConfig)
{
20004300:	b580      	push	{r7, lr}
20004302:	b086      	sub	sp, #24
20004304:	af00      	add	r7, sp, #0
20004306:	6078      	str	r0, [r7, #4]
20004308:	6039      	str	r1, [r7, #0]
  uint32_t optr_reg_val = 0;
2000430a:	2300      	movs	r3, #0
2000430c:	617b      	str	r3, [r7, #20]
  uint32_t optr_reg_mask = 0;
2000430e:	2300      	movs	r3, #0
20004310:	613b      	str	r3, [r7, #16]

  /* Check the parameters */
  assert_param(IS_OB_USER_TYPE(UserType));

  /* Wait for last operation to be completed */
  status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
20004312:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
20004316:	f7ff fba7 	bl	20003a68 <FLASH_WaitForLastOperation>
2000431a:	4603      	mov	r3, r0
2000431c:	73fb      	strb	r3, [r7, #15]

  if (status == HAL_OK)
2000431e:	7bfb      	ldrb	r3, [r7, #15]
20004320:	2b00      	cmp	r3, #0
20004322:	f040 8105 	bne.w	20004530 <FLASH_OB_UserConfig+0x230>
  {
    if ((UserType & OB_USER_BOR_LEV) != 0U)
20004326:	687b      	ldr	r3, [r7, #4]
20004328:	f003 0301 	and.w	r3, r3, #1
2000432c:	2b00      	cmp	r3, #0
2000432e:	d009      	beq.n	20004344 <FLASH_OB_UserConfig+0x44>
    {
      /* BOR level option byte should be modified */
      assert_param(IS_OB_USER_BOR_LEVEL(UserConfig & FLASH_OPTR_BOR_LEV));

      /* Set value and mask for BOR level option byte */
      optr_reg_val |= (UserConfig & FLASH_OPTR_BOR_LEV);
20004330:	683b      	ldr	r3, [r7, #0]
20004332:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
20004336:	697a      	ldr	r2, [r7, #20]
20004338:	4313      	orrs	r3, r2
2000433a:	617b      	str	r3, [r7, #20]
      optr_reg_mask |= FLASH_OPTR_BOR_LEV;
2000433c:	693b      	ldr	r3, [r7, #16]
2000433e:	f443 63e0 	orr.w	r3, r3, #1792	; 0x700
20004342:	613b      	str	r3, [r7, #16]
    }

    if ((UserType & OB_USER_nRST_STOP) != 0U)
20004344:	687b      	ldr	r3, [r7, #4]
20004346:	f003 0302 	and.w	r3, r3, #2
2000434a:	2b00      	cmp	r3, #0
2000434c:	d009      	beq.n	20004362 <FLASH_OB_UserConfig+0x62>
    {
      /* nRST_STOP option byte should be modified */
      assert_param(IS_OB_USER_STOP(UserConfig & FLASH_OPTR_nRST_STOP));

      /* Set value and mask for nRST_STOP option byte */
      optr_reg_val |= (UserConfig & FLASH_OPTR_nRST_STOP);
2000434e:	683b      	ldr	r3, [r7, #0]
20004350:	f403 5380 	and.w	r3, r3, #4096	; 0x1000
20004354:	697a      	ldr	r2, [r7, #20]
20004356:	4313      	orrs	r3, r2
20004358:	617b      	str	r3, [r7, #20]
      optr_reg_mask |= FLASH_OPTR_nRST_STOP;
2000435a:	693b      	ldr	r3, [r7, #16]
2000435c:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
20004360:	613b      	str	r3, [r7, #16]
    }

    if ((UserType & OB_USER_nRST_STDBY) != 0U)
20004362:	687b      	ldr	r3, [r7, #4]
20004364:	f003 0304 	and.w	r3, r3, #4
20004368:	2b00      	cmp	r3, #0
2000436a:	d009      	beq.n	20004380 <FLASH_OB_UserConfig+0x80>
    {
      /* nRST_STDBY option byte should be modified */
      assert_param(IS_OB_USER_STANDBY(UserConfig & FLASH_OPTR_nRST_STDBY));

      /* Set value and mask for nRST_STDBY option byte */
      optr_reg_val |= (UserConfig & FLASH_OPTR_nRST_STDBY);
2000436c:	683b      	ldr	r3, [r7, #0]
2000436e:	f403 5300 	and.w	r3, r3, #8192	; 0x2000
20004372:	697a      	ldr	r2, [r7, #20]
20004374:	4313      	orrs	r3, r2
20004376:	617b      	str	r3, [r7, #20]
      optr_reg_mask |= FLASH_OPTR_nRST_STDBY;
20004378:	693b      	ldr	r3, [r7, #16]
2000437a:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
2000437e:	613b      	str	r3, [r7, #16]
    }

    if ((UserType & OB_USER_nRST_SHDW) != 0U)
20004380:	687b      	ldr	r3, [r7, #4]
20004382:	f403 5380 	and.w	r3, r3, #4096	; 0x1000
20004386:	2b00      	cmp	r3, #0
20004388:	d009      	beq.n	2000439e <FLASH_OB_UserConfig+0x9e>
    {
      /* nRST_SHDW option byte should be modified */
      assert_param(IS_OB_USER_SHUTDOWN(UserConfig & FLASH_OPTR_nRST_SHDW));

      /* Set value and mask for nRST_SHDW option byte */
      optr_reg_val |= (UserConfig & FLASH_OPTR_nRST_SHDW);
2000438a:	683b      	ldr	r3, [r7, #0]
2000438c:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
20004390:	697a      	ldr	r2, [r7, #20]
20004392:	4313      	orrs	r3, r2
20004394:	617b      	str	r3, [r7, #20]
      optr_reg_mask |= FLASH_OPTR_nRST_SHDW;
20004396:	693b      	ldr	r3, [r7, #16]
20004398:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
2000439c:	613b      	str	r3, [r7, #16]
    }

    if ((UserType & OB_USER_IWDG_SW) != 0U)
2000439e:	687b      	ldr	r3, [r7, #4]
200043a0:	f003 0308 	and.w	r3, r3, #8
200043a4:	2b00      	cmp	r3, #0
200043a6:	d009      	beq.n	200043bc <FLASH_OB_UserConfig+0xbc>
    {
      /* IWDG_SW option byte should be modified */
      assert_param(IS_OB_USER_IWDG(UserConfig & FLASH_OPTR_IWDG_SW));

      /* Set value and mask for IWDG_SW option byte */
      optr_reg_val |= (UserConfig & FLASH_OPTR_IWDG_SW);
200043a8:	683b      	ldr	r3, [r7, #0]
200043aa:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
200043ae:	697a      	ldr	r2, [r7, #20]
200043b0:	4313      	orrs	r3, r2
200043b2:	617b      	str	r3, [r7, #20]
      optr_reg_mask |= FLASH_OPTR_IWDG_SW;
200043b4:	693b      	ldr	r3, [r7, #16]
200043b6:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
200043ba:	613b      	str	r3, [r7, #16]
    }

    if ((UserType & OB_USER_IWDG_STOP) != 0U)
200043bc:	687b      	ldr	r3, [r7, #4]
200043be:	f003 0310 	and.w	r3, r3, #16
200043c2:	2b00      	cmp	r3, #0
200043c4:	d009      	beq.n	200043da <FLASH_OB_UserConfig+0xda>
    {
      /* IWDG_STOP option byte should be modified */
      assert_param(IS_OB_USER_IWDG_STOP(UserConfig & FLASH_OPTR_IWDG_STOP));

      /* Set value and mask for IWDG_STOP option byte */
      optr_reg_val |= (UserConfig & FLASH_OPTR_IWDG_STOP);
200043c6:	683b      	ldr	r3, [r7, #0]
200043c8:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
200043cc:	697a      	ldr	r2, [r7, #20]
200043ce:	4313      	orrs	r3, r2
200043d0:	617b      	str	r3, [r7, #20]
      optr_reg_mask |= FLASH_OPTR_IWDG_STOP;
200043d2:	693b      	ldr	r3, [r7, #16]
200043d4:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
200043d8:	613b      	str	r3, [r7, #16]
    }

    if ((UserType & OB_USER_IWDG_STDBY) != 0U)
200043da:	687b      	ldr	r3, [r7, #4]
200043dc:	f003 0320 	and.w	r3, r3, #32
200043e0:	2b00      	cmp	r3, #0
200043e2:	d009      	beq.n	200043f8 <FLASH_OB_UserConfig+0xf8>
    {
      /* IWDG_STDBY option byte should be modified */
      assert_param(IS_OB_USER_IWDG_STDBY(UserConfig & FLASH_OPTR_IWDG_STDBY));

      /* Set value and mask for IWDG_STDBY option byte */
      optr_reg_val |= (UserConfig & FLASH_OPTR_IWDG_STDBY);
200043e4:	683b      	ldr	r3, [r7, #0]
200043e6:	f403 2380 	and.w	r3, r3, #262144	; 0x40000
200043ea:	697a      	ldr	r2, [r7, #20]
200043ec:	4313      	orrs	r3, r2
200043ee:	617b      	str	r3, [r7, #20]
      optr_reg_mask |= FLASH_OPTR_IWDG_STDBY;
200043f0:	693b      	ldr	r3, [r7, #16]
200043f2:	f443 2380 	orr.w	r3, r3, #262144	; 0x40000
200043f6:	613b      	str	r3, [r7, #16]
    }

    if ((UserType & OB_USER_WWDG_SW) != 0U)
200043f8:	687b      	ldr	r3, [r7, #4]
200043fa:	f003 0340 	and.w	r3, r3, #64	; 0x40
200043fe:	2b00      	cmp	r3, #0
20004400:	d009      	beq.n	20004416 <FLASH_OB_UserConfig+0x116>
    {
      /* WWDG_SW option byte should be modified */
      assert_param(IS_OB_USER_WWDG(UserConfig & FLASH_OPTR_WWDG_SW));

      /* Set value and mask for WWDG_SW option byte */
      optr_reg_val |= (UserConfig & FLASH_OPTR_WWDG_SW);
20004402:	683b      	ldr	r3, [r7, #0]
20004404:	f403 2300 	and.w	r3, r3, #524288	; 0x80000
20004408:	697a      	ldr	r2, [r7, #20]
2000440a:	4313      	orrs	r3, r2
2000440c:	617b      	str	r3, [r7, #20]
      optr_reg_mask |= FLASH_OPTR_WWDG_SW;
2000440e:	693b      	ldr	r3, [r7, #16]
20004410:	f443 2300 	orr.w	r3, r3, #524288	; 0x80000
20004414:	613b      	str	r3, [r7, #16]
    }

#if defined (FLASH_OPTR_BFB2)
    if ((UserType & OB_USER_BFB2) != 0U)
20004416:	687b      	ldr	r3, [r7, #4]
20004418:	f003 0380 	and.w	r3, r3, #128	; 0x80
2000441c:	2b00      	cmp	r3, #0
2000441e:	d009      	beq.n	20004434 <FLASH_OB_UserConfig+0x134>
    {
      /* BFB2 option byte should be modified */
      assert_param(IS_OB_USER_BFB2(UserConfig & FLASH_OPTR_BFB2));

      /* Set value and mask for BFB2 option byte */
      optr_reg_val |= (UserConfig & FLASH_OPTR_BFB2);
20004420:	683b      	ldr	r3, [r7, #0]
20004422:	f403 1380 	and.w	r3, r3, #1048576	; 0x100000
20004426:	697a      	ldr	r2, [r7, #20]
20004428:	4313      	orrs	r3, r2
2000442a:	617b      	str	r3, [r7, #20]
      optr_reg_mask |= FLASH_OPTR_BFB2;
2000442c:	693b      	ldr	r3, [r7, #16]
2000442e:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
20004432:	613b      	str	r3, [r7, #16]
    }
#endif

    if ((UserType & OB_USER_nBOOT1) != 0U)
20004434:	687b      	ldr	r3, [r7, #4]
20004436:	f403 7300 	and.w	r3, r3, #512	; 0x200
2000443a:	2b00      	cmp	r3, #0
2000443c:	d009      	beq.n	20004452 <FLASH_OB_UserConfig+0x152>
    {
      /* nBOOT1 option byte should be modified */
      assert_param(IS_OB_USER_BOOT1(UserConfig & FLASH_OPTR_nBOOT1));

      /* Set value and mask for nBOOT1 option byte */
      optr_reg_val |= (UserConfig & FLASH_OPTR_nBOOT1);
2000443e:	683b      	ldr	r3, [r7, #0]
20004440:	f403 0300 	and.w	r3, r3, #8388608	; 0x800000
20004444:	697a      	ldr	r2, [r7, #20]
20004446:	4313      	orrs	r3, r2
20004448:	617b      	str	r3, [r7, #20]
      optr_reg_mask |= FLASH_OPTR_nBOOT1;
2000444a:	693b      	ldr	r3, [r7, #16]
2000444c:	f443 0300 	orr.w	r3, r3, #8388608	; 0x800000
20004450:	613b      	str	r3, [r7, #16]
    }

    if ((UserType & OB_USER_SRAM_PE) != 0U)
20004452:	687b      	ldr	r3, [r7, #4]
20004454:	f403 6380 	and.w	r3, r3, #1024	; 0x400
20004458:	2b00      	cmp	r3, #0
2000445a:	d009      	beq.n	20004470 <FLASH_OB_UserConfig+0x170>
    {
      /* SRAM_PE option byte should be modified */
      assert_param(IS_OB_USER_SRAM_PARITY(UserConfig & FLASH_OPTR_SRAM_PE));

      /* Set value and mask for SRAM_PE option byte */
      optr_reg_val |= (UserConfig & FLASH_OPTR_SRAM_PE);
2000445c:	683b      	ldr	r3, [r7, #0]
2000445e:	f003 7380 	and.w	r3, r3, #16777216	; 0x1000000
20004462:	697a      	ldr	r2, [r7, #20]
20004464:	4313      	orrs	r3, r2
20004466:	617b      	str	r3, [r7, #20]
      optr_reg_mask |= FLASH_OPTR_SRAM_PE;
20004468:	693b      	ldr	r3, [r7, #16]
2000446a:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
2000446e:	613b      	str	r3, [r7, #16]
    }

    if ((UserType & OB_USER_CCMSRAM_RST) != 0U)
20004470:	687b      	ldr	r3, [r7, #4]
20004472:	f403 6300 	and.w	r3, r3, #2048	; 0x800
20004476:	2b00      	cmp	r3, #0
20004478:	d009      	beq.n	2000448e <FLASH_OB_UserConfig+0x18e>
    {
      /* CCMSRAM_RST option byte should be modified */
      assert_param(IS_OB_USER_CCMSRAM_RST(UserConfig & FLASH_OPTR_CCMSRAM_RST));

      /* Set value and mask for CCMSRAM_RST option byte */
      optr_reg_val |= (UserConfig & FLASH_OPTR_CCMSRAM_RST);
2000447a:	683b      	ldr	r3, [r7, #0]
2000447c:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
20004480:	697a      	ldr	r2, [r7, #20]
20004482:	4313      	orrs	r3, r2
20004484:	617b      	str	r3, [r7, #20]
      optr_reg_mask |= FLASH_OPTR_CCMSRAM_RST;
20004486:	693b      	ldr	r3, [r7, #16]
20004488:	f043 7300 	orr.w	r3, r3, #33554432	; 0x2000000
2000448c:	613b      	str	r3, [r7, #16]
    }

    if ((UserType & OB_USER_nSWBOOT0) != 0U)
2000448e:	687b      	ldr	r3, [r7, #4]
20004490:	f403 5300 	and.w	r3, r3, #8192	; 0x2000
20004494:	2b00      	cmp	r3, #0
20004496:	d009      	beq.n	200044ac <FLASH_OB_UserConfig+0x1ac>
    {
      /* nSWBOOT0 option byte should be modified */
      assert_param(IS_OB_USER_SWBOOT0(UserConfig & FLASH_OPTR_nSWBOOT0));

      /* Set value and mask for nSWBOOT0 option byte */
      optr_reg_val |= (UserConfig & FLASH_OPTR_nSWBOOT0);
20004498:	683b      	ldr	r3, [r7, #0]
2000449a:	f003 6380 	and.w	r3, r3, #67108864	; 0x4000000
2000449e:	697a      	ldr	r2, [r7, #20]
200044a0:	4313      	orrs	r3, r2
200044a2:	617b      	str	r3, [r7, #20]
      optr_reg_mask |= FLASH_OPTR_nSWBOOT0;
200044a4:	693b      	ldr	r3, [r7, #16]
200044a6:	f043 6380 	orr.w	r3, r3, #67108864	; 0x4000000
200044aa:	613b      	str	r3, [r7, #16]
    }

    if ((UserType & OB_USER_nBOOT0) != 0U)
200044ac:	687b      	ldr	r3, [r7, #4]
200044ae:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
200044b2:	2b00      	cmp	r3, #0
200044b4:	d009      	beq.n	200044ca <FLASH_OB_UserConfig+0x1ca>
    {
      /* nBOOT0 option byte should be modified */
      assert_param(IS_OB_USER_BOOT0(UserConfig & FLASH_OPTR_nBOOT0));

      /* Set value and mask for nBOOT0 option byte */
      optr_reg_val |= (UserConfig & FLASH_OPTR_nBOOT0);
200044b6:	683b      	ldr	r3, [r7, #0]
200044b8:	f003 6300 	and.w	r3, r3, #134217728	; 0x8000000
200044bc:	697a      	ldr	r2, [r7, #20]
200044be:	4313      	orrs	r3, r2
200044c0:	617b      	str	r3, [r7, #20]
      optr_reg_mask |= FLASH_OPTR_nBOOT0;
200044c2:	693b      	ldr	r3, [r7, #16]
200044c4:	f043 6300 	orr.w	r3, r3, #134217728	; 0x8000000
200044c8:	613b      	str	r3, [r7, #16]
    }

    if ((UserType & OB_USER_NRST_MODE) != 0U)
200044ca:	687b      	ldr	r3, [r7, #4]
200044cc:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
200044d0:	2b00      	cmp	r3, #0
200044d2:	d009      	beq.n	200044e8 <FLASH_OB_UserConfig+0x1e8>
    {
      /* Reset Configuration option byte should be modified */
      assert_param(IS_OB_USER_NRST_MODE(UserConfig & FLASH_OPTR_NRST_MODE));

      /* Set value and mask for Reset Configuration option byte */
      optr_reg_val |= (UserConfig & FLASH_OPTR_NRST_MODE);
200044d4:	683b      	ldr	r3, [r7, #0]
200044d6:	f003 5340 	and.w	r3, r3, #805306368	; 0x30000000
200044da:	697a      	ldr	r2, [r7, #20]
200044dc:	4313      	orrs	r3, r2
200044de:	617b      	str	r3, [r7, #20]
      optr_reg_mask |= FLASH_OPTR_NRST_MODE;
200044e0:	693b      	ldr	r3, [r7, #16]
200044e2:	f043 5340 	orr.w	r3, r3, #805306368	; 0x30000000
200044e6:	613b      	str	r3, [r7, #16]
    }

    if ((UserType & OB_USER_IRHEN) != 0U)
200044e8:	687b      	ldr	r3, [r7, #4]
200044ea:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
200044ee:	2b00      	cmp	r3, #0
200044f0:	d009      	beq.n	20004506 <FLASH_OB_UserConfig+0x206>
    {
      /* IRH option byte should be modified */
      assert_param(IS_OB_USER_IRHEN(UserConfig & FLASH_OPTR_IRHEN));

      /* Set value and mask for IRH option byte */
      optr_reg_val |= (UserConfig & FLASH_OPTR_IRHEN);
200044f2:	683b      	ldr	r3, [r7, #0]
200044f4:	f003 4380 	and.w	r3, r3, #1073741824	; 0x40000000
200044f8:	697a      	ldr	r2, [r7, #20]
200044fa:	4313      	orrs	r3, r2
200044fc:	617b      	str	r3, [r7, #20]
      optr_reg_mask |= FLASH_OPTR_IRHEN;
200044fe:	693b      	ldr	r3, [r7, #16]
20004500:	f043 4380 	orr.w	r3, r3, #1073741824	; 0x40000000
20004504:	613b      	str	r3, [r7, #16]
    }

    /* Configure the option bytes register */
    MODIFY_REG(FLASH->OPTR, optr_reg_mask, optr_reg_val);
20004506:	4b0d      	ldr	r3, [pc, #52]	; (2000453c <FLASH_OB_UserConfig+0x23c>)
20004508:	6a1a      	ldr	r2, [r3, #32]
2000450a:	693b      	ldr	r3, [r7, #16]
2000450c:	43db      	mvns	r3, r3
2000450e:	401a      	ands	r2, r3
20004510:	490a      	ldr	r1, [pc, #40]	; (2000453c <FLASH_OB_UserConfig+0x23c>)
20004512:	697b      	ldr	r3, [r7, #20]
20004514:	4313      	orrs	r3, r2
20004516:	620b      	str	r3, [r1, #32]

    /* Set OPTSTRT Bit */
    SET_BIT(FLASH->CR, FLASH_CR_OPTSTRT);
20004518:	4b08      	ldr	r3, [pc, #32]	; (2000453c <FLASH_OB_UserConfig+0x23c>)
2000451a:	695b      	ldr	r3, [r3, #20]
2000451c:	4a07      	ldr	r2, [pc, #28]	; (2000453c <FLASH_OB_UserConfig+0x23c>)
2000451e:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
20004522:	6153      	str	r3, [r2, #20]

    /* Wait for last operation to be completed */
    status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
20004524:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
20004528:	f7ff fa9e 	bl	20003a68 <FLASH_WaitForLastOperation>
2000452c:	4603      	mov	r3, r0
2000452e:	73fb      	strb	r3, [r7, #15]
  }

  return status;
20004530:	7bfb      	ldrb	r3, [r7, #15]
}
20004532:	4618      	mov	r0, r3
20004534:	3718      	adds	r7, #24
20004536:	46bd      	mov	sp, r7
20004538:	bd80      	pop	{r7, pc}
2000453a:	bf00      	nop
2000453c:	40022000 	.word	0x40022000

20004540 <FLASH_OB_PCROPConfig>:
  * @param  PCROPEndAddr specifies the end address of the Proprietary code readout protection.
  *         This parameter can be an address between PCROPStartAddr and end of the bank.
  * @retval HAL_Status
  */
static HAL_StatusTypeDef FLASH_OB_PCROPConfig(uint32_t PCROPConfig, uint32_t PCROPStartAddr, uint32_t PCROPEndAddr)
{
20004540:	b580      	push	{r7, lr}
20004542:	b088      	sub	sp, #32
20004544:	af00      	add	r7, sp, #0
20004546:	60f8      	str	r0, [r7, #12]
20004548:	60b9      	str	r1, [r7, #8]
2000454a:	607a      	str	r2, [r7, #4]
  assert_param(IS_OB_PCROP_RDP(PCROPConfig & FLASH_PCROP1ER_PCROP_RDP));
  assert_param(IS_FLASH_MAIN_MEM_ADDRESS(PCROPStartAddr));
  assert_param(IS_FLASH_MAIN_MEM_ADDRESS(PCROPEndAddr));

  /* Wait for last operation to be completed */
  status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
2000454c:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
20004550:	f7ff fa8a 	bl	20003a68 <FLASH_WaitForLastOperation>
20004554:	4603      	mov	r3, r0
20004556:	77fb      	strb	r3, [r7, #31]

  if (status == HAL_OK)
20004558:	7ffb      	ldrb	r3, [r7, #31]
2000455a:	2b00      	cmp	r3, #0
2000455c:	f040 80da 	bne.w	20004714 <FLASH_OB_PCROPConfig+0x1d4>
  {
#if defined (FLASH_OPTR_DBANK)
    /* Get the information about the bank swapping */
    if (READ_BIT(SYSCFG->MEMRMP, SYSCFG_MEMRMP_FB_MODE) == 0U)
20004560:	4b6f      	ldr	r3, [pc, #444]	; (20004720 <FLASH_OB_PCROPConfig+0x1e0>)
20004562:	681b      	ldr	r3, [r3, #0]
20004564:	f403 7380 	and.w	r3, r3, #256	; 0x100
20004568:	2b00      	cmp	r3, #0
2000456a:	d114      	bne.n	20004596 <FLASH_OB_PCROPConfig+0x56>
    {
      bank1_addr = FLASH_BASE;
2000456c:	f04f 6300 	mov.w	r3, #134217728	; 0x8000000
20004570:	61bb      	str	r3, [r7, #24]
      bank2_addr = FLASH_BASE + FLASH_BANK_SIZE;
20004572:	4b6c      	ldr	r3, [pc, #432]	; (20004724 <FLASH_OB_PCROPConfig+0x1e4>)
20004574:	881b      	ldrh	r3, [r3, #0]
20004576:	f64f 72ff 	movw	r2, #65535	; 0xffff
2000457a:	4293      	cmp	r3, r2
2000457c:	d008      	beq.n	20004590 <FLASH_OB_PCROPConfig+0x50>
2000457e:	4b69      	ldr	r3, [pc, #420]	; (20004724 <FLASH_OB_PCROPConfig+0x1e4>)
20004580:	681b      	ldr	r3, [r3, #0]
20004582:	029b      	lsls	r3, r3, #10
20004584:	085a      	lsrs	r2, r3, #1
20004586:	4b68      	ldr	r3, [pc, #416]	; (20004728 <FLASH_OB_PCROPConfig+0x1e8>)
20004588:	4013      	ands	r3, r2
2000458a:	f103 6300 	add.w	r3, r3, #134217728	; 0x8000000
2000458e:	e000      	b.n	20004592 <FLASH_OB_PCROPConfig+0x52>
20004590:	4b66      	ldr	r3, [pc, #408]	; (2000472c <FLASH_OB_PCROPConfig+0x1ec>)
20004592:	617b      	str	r3, [r7, #20]
20004594:	e013      	b.n	200045be <FLASH_OB_PCROPConfig+0x7e>
    }
    else
    {
      bank1_addr = FLASH_BASE + FLASH_BANK_SIZE;
20004596:	4b63      	ldr	r3, [pc, #396]	; (20004724 <FLASH_OB_PCROPConfig+0x1e4>)
20004598:	881b      	ldrh	r3, [r3, #0]
2000459a:	f64f 72ff 	movw	r2, #65535	; 0xffff
2000459e:	4293      	cmp	r3, r2
200045a0:	d008      	beq.n	200045b4 <FLASH_OB_PCROPConfig+0x74>
200045a2:	4b60      	ldr	r3, [pc, #384]	; (20004724 <FLASH_OB_PCROPConfig+0x1e4>)
200045a4:	681b      	ldr	r3, [r3, #0]
200045a6:	029b      	lsls	r3, r3, #10
200045a8:	085a      	lsrs	r2, r3, #1
200045aa:	4b5f      	ldr	r3, [pc, #380]	; (20004728 <FLASH_OB_PCROPConfig+0x1e8>)
200045ac:	4013      	ands	r3, r2
200045ae:	f103 6300 	add.w	r3, r3, #134217728	; 0x8000000
200045b2:	e000      	b.n	200045b6 <FLASH_OB_PCROPConfig+0x76>
200045b4:	4b5d      	ldr	r3, [pc, #372]	; (2000472c <FLASH_OB_PCROPConfig+0x1ec>)
200045b6:	61bb      	str	r3, [r7, #24]
      bank2_addr = FLASH_BASE;
200045b8:	f04f 6300 	mov.w	r3, #134217728	; 0x8000000
200045bc:	617b      	str	r3, [r7, #20]
#else
    bank1_addr = FLASH_BASE;
#endif

#if defined (FLASH_OPTR_DBANK)
    if (READ_BIT(FLASH->OPTR, FLASH_OPTR_DBANK) == 0U)
200045be:	4b5c      	ldr	r3, [pc, #368]	; (20004730 <FLASH_OB_PCROPConfig+0x1f0>)
200045c0:	6a1b      	ldr	r3, [r3, #32]
200045c2:	f403 0380 	and.w	r3, r3, #4194304	; 0x400000
200045c6:	2b00      	cmp	r3, #0
200045c8:	d147      	bne.n	2000465a <FLASH_OB_PCROPConfig+0x11a>
    {
      /* Configure the Proprietary code readout protection */
      if ((PCROPConfig & FLASH_BANK_BOTH) == FLASH_BANK_1)
200045ca:	68fb      	ldr	r3, [r7, #12]
200045cc:	f003 0303 	and.w	r3, r3, #3
200045d0:	2b01      	cmp	r3, #1
200045d2:	d11e      	bne.n	20004612 <FLASH_OB_PCROPConfig+0xd2>
      {
        reg_value = ((PCROPStartAddr - FLASH_BASE) >> 4);
200045d4:	68bb      	ldr	r3, [r7, #8]
200045d6:	f103 4378 	add.w	r3, r3, #4160749568	; 0xf8000000
200045da:	091b      	lsrs	r3, r3, #4
200045dc:	613b      	str	r3, [r7, #16]
        MODIFY_REG(FLASH->PCROP1SR, FLASH_PCROP1SR_PCROP1_STRT, reg_value);
200045de:	4b54      	ldr	r3, [pc, #336]	; (20004730 <FLASH_OB_PCROPConfig+0x1f0>)
200045e0:	6a5b      	ldr	r3, [r3, #36]	; 0x24
200045e2:	f423 43ff 	bic.w	r3, r3, #32640	; 0x7f80
200045e6:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
200045ea:	4951      	ldr	r1, [pc, #324]	; (20004730 <FLASH_OB_PCROPConfig+0x1f0>)
200045ec:	693a      	ldr	r2, [r7, #16]
200045ee:	4313      	orrs	r3, r2
200045f0:	624b      	str	r3, [r1, #36]	; 0x24

        reg_value = ((PCROPEndAddr - FLASH_BASE) >> 4);
200045f2:	687b      	ldr	r3, [r7, #4]
200045f4:	f103 4378 	add.w	r3, r3, #4160749568	; 0xf8000000
200045f8:	091b      	lsrs	r3, r3, #4
200045fa:	613b      	str	r3, [r7, #16]
        MODIFY_REG(FLASH->PCROP1ER, FLASH_PCROP1ER_PCROP1_END, reg_value);
200045fc:	4b4c      	ldr	r3, [pc, #304]	; (20004730 <FLASH_OB_PCROPConfig+0x1f0>)
200045fe:	6a9b      	ldr	r3, [r3, #40]	; 0x28
20004600:	f423 43ff 	bic.w	r3, r3, #32640	; 0x7f80
20004604:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
20004608:	4949      	ldr	r1, [pc, #292]	; (20004730 <FLASH_OB_PCROPConfig+0x1f0>)
2000460a:	693a      	ldr	r2, [r7, #16]
2000460c:	4313      	orrs	r3, r2
2000460e:	628b      	str	r3, [r1, #40]	; 0x28
20004610:	e06a      	b.n	200046e8 <FLASH_OB_PCROPConfig+0x1a8>
      }
      else if ((PCROPConfig & FLASH_BANK_BOTH) == FLASH_BANK_2)
20004612:	68fb      	ldr	r3, [r7, #12]
20004614:	f003 0303 	and.w	r3, r3, #3
20004618:	2b02      	cmp	r3, #2
2000461a:	d165      	bne.n	200046e8 <FLASH_OB_PCROPConfig+0x1a8>
      {
        reg_value = ((PCROPStartAddr - FLASH_BASE) >> 4);
2000461c:	68bb      	ldr	r3, [r7, #8]
2000461e:	f103 4378 	add.w	r3, r3, #4160749568	; 0xf8000000
20004622:	091b      	lsrs	r3, r3, #4
20004624:	613b      	str	r3, [r7, #16]
        MODIFY_REG(FLASH->PCROP2SR, FLASH_PCROP2SR_PCROP2_STRT, reg_value);
20004626:	4b42      	ldr	r3, [pc, #264]	; (20004730 <FLASH_OB_PCROPConfig+0x1f0>)
20004628:	6c5b      	ldr	r3, [r3, #68]	; 0x44
2000462a:	f423 43ff 	bic.w	r3, r3, #32640	; 0x7f80
2000462e:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
20004632:	493f      	ldr	r1, [pc, #252]	; (20004730 <FLASH_OB_PCROPConfig+0x1f0>)
20004634:	693a      	ldr	r2, [r7, #16]
20004636:	4313      	orrs	r3, r2
20004638:	644b      	str	r3, [r1, #68]	; 0x44

        reg_value = ((PCROPEndAddr - FLASH_BASE) >> 4);
2000463a:	687b      	ldr	r3, [r7, #4]
2000463c:	f103 4378 	add.w	r3, r3, #4160749568	; 0xf8000000
20004640:	091b      	lsrs	r3, r3, #4
20004642:	613b      	str	r3, [r7, #16]
        MODIFY_REG(FLASH->PCROP2ER, FLASH_PCROP2ER_PCROP2_END, reg_value);
20004644:	4b3a      	ldr	r3, [pc, #232]	; (20004730 <FLASH_OB_PCROPConfig+0x1f0>)
20004646:	6c9b      	ldr	r3, [r3, #72]	; 0x48
20004648:	f423 43ff 	bic.w	r3, r3, #32640	; 0x7f80
2000464c:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
20004650:	4937      	ldr	r1, [pc, #220]	; (20004730 <FLASH_OB_PCROPConfig+0x1f0>)
20004652:	693a      	ldr	r2, [r7, #16]
20004654:	4313      	orrs	r3, r2
20004656:	648b      	str	r3, [r1, #72]	; 0x48
20004658:	e046      	b.n	200046e8 <FLASH_OB_PCROPConfig+0x1a8>
    }
    else
#endif
    {
      /* Configure the Proprietary code readout protection */
      if ((PCROPConfig & FLASH_BANK_BOTH) == FLASH_BANK_1)
2000465a:	68fb      	ldr	r3, [r7, #12]
2000465c:	f003 0303 	and.w	r3, r3, #3
20004660:	2b01      	cmp	r3, #1
20004662:	d11e      	bne.n	200046a2 <FLASH_OB_PCROPConfig+0x162>
      {
        reg_value = ((PCROPStartAddr - bank1_addr) >> 3);
20004664:	68ba      	ldr	r2, [r7, #8]
20004666:	69bb      	ldr	r3, [r7, #24]
20004668:	1ad3      	subs	r3, r2, r3
2000466a:	08db      	lsrs	r3, r3, #3
2000466c:	613b      	str	r3, [r7, #16]
        MODIFY_REG(FLASH->PCROP1SR, FLASH_PCROP1SR_PCROP1_STRT, reg_value);
2000466e:	4b30      	ldr	r3, [pc, #192]	; (20004730 <FLASH_OB_PCROPConfig+0x1f0>)
20004670:	6a5b      	ldr	r3, [r3, #36]	; 0x24
20004672:	f423 43ff 	bic.w	r3, r3, #32640	; 0x7f80
20004676:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
2000467a:	492d      	ldr	r1, [pc, #180]	; (20004730 <FLASH_OB_PCROPConfig+0x1f0>)
2000467c:	693a      	ldr	r2, [r7, #16]
2000467e:	4313      	orrs	r3, r2
20004680:	624b      	str	r3, [r1, #36]	; 0x24

        reg_value = ((PCROPEndAddr - bank1_addr) >> 3);
20004682:	687a      	ldr	r2, [r7, #4]
20004684:	69bb      	ldr	r3, [r7, #24]
20004686:	1ad3      	subs	r3, r2, r3
20004688:	08db      	lsrs	r3, r3, #3
2000468a:	613b      	str	r3, [r7, #16]
        MODIFY_REG(FLASH->PCROP1ER, FLASH_PCROP1ER_PCROP1_END, reg_value);
2000468c:	4b28      	ldr	r3, [pc, #160]	; (20004730 <FLASH_OB_PCROPConfig+0x1f0>)
2000468e:	6a9b      	ldr	r3, [r3, #40]	; 0x28
20004690:	f423 43ff 	bic.w	r3, r3, #32640	; 0x7f80
20004694:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
20004698:	4925      	ldr	r1, [pc, #148]	; (20004730 <FLASH_OB_PCROPConfig+0x1f0>)
2000469a:	693a      	ldr	r2, [r7, #16]
2000469c:	4313      	orrs	r3, r2
2000469e:	628b      	str	r3, [r1, #40]	; 0x28
200046a0:	e022      	b.n	200046e8 <FLASH_OB_PCROPConfig+0x1a8>
      }
#if defined (FLASH_OPTR_DBANK)
      else if ((PCROPConfig & FLASH_BANK_BOTH) == FLASH_BANK_2)
200046a2:	68fb      	ldr	r3, [r7, #12]
200046a4:	f003 0303 	and.w	r3, r3, #3
200046a8:	2b02      	cmp	r3, #2
200046aa:	d11d      	bne.n	200046e8 <FLASH_OB_PCROPConfig+0x1a8>
      {
        reg_value = ((PCROPStartAddr - bank2_addr) >> 3);
200046ac:	68ba      	ldr	r2, [r7, #8]
200046ae:	697b      	ldr	r3, [r7, #20]
200046b0:	1ad3      	subs	r3, r2, r3
200046b2:	08db      	lsrs	r3, r3, #3
200046b4:	613b      	str	r3, [r7, #16]
        MODIFY_REG(FLASH->PCROP2SR, FLASH_PCROP2SR_PCROP2_STRT, reg_value);
200046b6:	4b1e      	ldr	r3, [pc, #120]	; (20004730 <FLASH_OB_PCROPConfig+0x1f0>)
200046b8:	6c5b      	ldr	r3, [r3, #68]	; 0x44
200046ba:	f423 43ff 	bic.w	r3, r3, #32640	; 0x7f80
200046be:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
200046c2:	491b      	ldr	r1, [pc, #108]	; (20004730 <FLASH_OB_PCROPConfig+0x1f0>)
200046c4:	693a      	ldr	r2, [r7, #16]
200046c6:	4313      	orrs	r3, r2
200046c8:	644b      	str	r3, [r1, #68]	; 0x44

        reg_value = ((PCROPEndAddr - bank2_addr) >> 3);
200046ca:	687a      	ldr	r2, [r7, #4]
200046cc:	697b      	ldr	r3, [r7, #20]
200046ce:	1ad3      	subs	r3, r2, r3
200046d0:	08db      	lsrs	r3, r3, #3
200046d2:	613b      	str	r3, [r7, #16]
        MODIFY_REG(FLASH->PCROP2ER, FLASH_PCROP2ER_PCROP2_END, reg_value);
200046d4:	4b16      	ldr	r3, [pc, #88]	; (20004730 <FLASH_OB_PCROPConfig+0x1f0>)
200046d6:	6c9b      	ldr	r3, [r3, #72]	; 0x48
200046d8:	f423 43ff 	bic.w	r3, r3, #32640	; 0x7f80
200046dc:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
200046e0:	4913      	ldr	r1, [pc, #76]	; (20004730 <FLASH_OB_PCROPConfig+0x1f0>)
200046e2:	693a      	ldr	r2, [r7, #16]
200046e4:	4313      	orrs	r3, r2
200046e6:	648b      	str	r3, [r1, #72]	; 0x48
      {
        /* Nothing to do */
      }
    }

    MODIFY_REG(FLASH->PCROP1ER, FLASH_PCROP1ER_PCROP_RDP, (PCROPConfig & FLASH_PCROP1ER_PCROP_RDP));
200046e8:	4b11      	ldr	r3, [pc, #68]	; (20004730 <FLASH_OB_PCROPConfig+0x1f0>)
200046ea:	6a9b      	ldr	r3, [r3, #40]	; 0x28
200046ec:	f023 4200 	bic.w	r2, r3, #2147483648	; 0x80000000
200046f0:	68fb      	ldr	r3, [r7, #12]
200046f2:	f003 4300 	and.w	r3, r3, #2147483648	; 0x80000000
200046f6:	490e      	ldr	r1, [pc, #56]	; (20004730 <FLASH_OB_PCROPConfig+0x1f0>)
200046f8:	4313      	orrs	r3, r2
200046fa:	628b      	str	r3, [r1, #40]	; 0x28

    /* Set OPTSTRT Bit */
    SET_BIT(FLASH->CR, FLASH_CR_OPTSTRT);
200046fc:	4b0c      	ldr	r3, [pc, #48]	; (20004730 <FLASH_OB_PCROPConfig+0x1f0>)
200046fe:	695b      	ldr	r3, [r3, #20]
20004700:	4a0b      	ldr	r2, [pc, #44]	; (20004730 <FLASH_OB_PCROPConfig+0x1f0>)
20004702:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
20004706:	6153      	str	r3, [r2, #20]

    /* Wait for last operation to be completed */
    status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
20004708:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
2000470c:	f7ff f9ac 	bl	20003a68 <FLASH_WaitForLastOperation>
20004710:	4603      	mov	r3, r0
20004712:	77fb      	strb	r3, [r7, #31]
  }

  return status;
20004714:	7ffb      	ldrb	r3, [r7, #31]
}
20004716:	4618      	mov	r0, r3
20004718:	3720      	adds	r7, #32
2000471a:	46bd      	mov	sp, r7
2000471c:	bd80      	pop	{r7, pc}
2000471e:	bf00      	nop
20004720:	40010000 	.word	0x40010000
20004724:	1fff75e0 	.word	0x1fff75e0
20004728:	01fffe00 	.word	0x01fffe00
2000472c:	08040000 	.word	0x08040000
20004730:	40022000 	.word	0x40022000

20004734 <FLASH_OB_SecMemConfig>:
  *         starting from first page of the bank.
  *         This parameter can be page number between 0 and (max number of pages in the bank - 1)
  * @retval HAL Status
  */
static HAL_StatusTypeDef FLASH_OB_SecMemConfig(uint32_t SecBank, uint32_t SecSize)
{
20004734:	b580      	push	{r7, lr}
20004736:	b084      	sub	sp, #16
20004738:	af00      	add	r7, sp, #0
2000473a:	6078      	str	r0, [r7, #4]
2000473c:	6039      	str	r1, [r7, #0]
  /* Check the parameters */
  assert_param(IS_FLASH_BANK_EXCLUSIVE(SecBank));
  assert_param(IS_OB_SECMEM_SIZE(SecSize));

  /* Wait for last operation to be completed */
  status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
2000473e:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
20004742:	f7ff f991 	bl	20003a68 <FLASH_WaitForLastOperation>
20004746:	4603      	mov	r3, r0
20004748:	73fb      	strb	r3, [r7, #15]

  if (status == HAL_OK)
2000474a:	7bfb      	ldrb	r3, [r7, #15]
2000474c:	2b00      	cmp	r3, #0
2000474e:	d122      	bne.n	20004796 <FLASH_OB_SecMemConfig+0x62>
  {
    /* Configure the write protected area */
    if (SecBank == FLASH_BANK_1)
20004750:	687b      	ldr	r3, [r7, #4]
20004752:	2b01      	cmp	r3, #1
20004754:	d108      	bne.n	20004768 <FLASH_OB_SecMemConfig+0x34>
    {
      MODIFY_REG(FLASH->SEC1R, FLASH_SEC1R_SEC_SIZE1, SecSize);
20004756:	4b12      	ldr	r3, [pc, #72]	; (200047a0 <FLASH_OB_SecMemConfig+0x6c>)
20004758:	6f1b      	ldr	r3, [r3, #112]	; 0x70
2000475a:	f023 02ff 	bic.w	r2, r3, #255	; 0xff
2000475e:	4910      	ldr	r1, [pc, #64]	; (200047a0 <FLASH_OB_SecMemConfig+0x6c>)
20004760:	683b      	ldr	r3, [r7, #0]
20004762:	4313      	orrs	r3, r2
20004764:	670b      	str	r3, [r1, #112]	; 0x70
20004766:	e00a      	b.n	2000477e <FLASH_OB_SecMemConfig+0x4a>
    }
#if defined (FLASH_OPTR_DBANK)
    else if (SecBank == FLASH_BANK_2)
20004768:	687b      	ldr	r3, [r7, #4]
2000476a:	2b02      	cmp	r3, #2
2000476c:	d107      	bne.n	2000477e <FLASH_OB_SecMemConfig+0x4a>
    {
      MODIFY_REG(FLASH->SEC2R, FLASH_SEC2R_SEC_SIZE2, SecSize);
2000476e:	4b0c      	ldr	r3, [pc, #48]	; (200047a0 <FLASH_OB_SecMemConfig+0x6c>)
20004770:	6f5b      	ldr	r3, [r3, #116]	; 0x74
20004772:	f023 02ff 	bic.w	r2, r3, #255	; 0xff
20004776:	490a      	ldr	r1, [pc, #40]	; (200047a0 <FLASH_OB_SecMemConfig+0x6c>)
20004778:	683b      	ldr	r3, [r7, #0]
2000477a:	4313      	orrs	r3, r2
2000477c:	674b      	str	r3, [r1, #116]	; 0x74
      /* Nothing to do */
    }
#endif

    /* Set OPTSTRT Bit */
    SET_BIT(FLASH->CR, FLASH_CR_OPTSTRT);
2000477e:	4b08      	ldr	r3, [pc, #32]	; (200047a0 <FLASH_OB_SecMemConfig+0x6c>)
20004780:	695b      	ldr	r3, [r3, #20]
20004782:	4a07      	ldr	r2, [pc, #28]	; (200047a0 <FLASH_OB_SecMemConfig+0x6c>)
20004784:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
20004788:	6153      	str	r3, [r2, #20]

    /* Wait for last operation to be completed */
    status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
2000478a:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
2000478e:	f7ff f96b 	bl	20003a68 <FLASH_WaitForLastOperation>
20004792:	4603      	mov	r3, r0
20004794:	73fb      	strb	r3, [r7, #15]
  }

  return status;
20004796:	7bfb      	ldrb	r3, [r7, #15]
}
20004798:	4618      	mov	r0, r3
2000479a:	3710      	adds	r7, #16
2000479c:	46bd      	mov	sp, r7
2000479e:	bd80      	pop	{r7, pc}
200047a0:	40022000 	.word	0x40022000

200047a4 <FLASH_OB_BootLockConfig>:
  *            @arg OB_BOOT_LOCK_DISABLE: Disable Boot Lock
  *
  * @retval HAL_Status
  */
static HAL_StatusTypeDef FLASH_OB_BootLockConfig(uint32_t BootLockConfig)
{
200047a4:	b580      	push	{r7, lr}
200047a6:	b084      	sub	sp, #16
200047a8:	af00      	add	r7, sp, #0
200047aa:	6078      	str	r0, [r7, #4]

  /* Check the parameters */
  assert_param(IS_OB_BOOT_LOCK(BootLockConfig));

  /* Wait for last operation to be completed */
  status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
200047ac:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
200047b0:	f7ff f95a 	bl	20003a68 <FLASH_WaitForLastOperation>
200047b4:	4603      	mov	r3, r0
200047b6:	73fb      	strb	r3, [r7, #15]

  if (status == HAL_OK)
200047b8:	7bfb      	ldrb	r3, [r7, #15]
200047ba:	2b00      	cmp	r3, #0
200047bc:	d113      	bne.n	200047e6 <FLASH_OB_BootLockConfig+0x42>
  {
    MODIFY_REG(FLASH->SEC1R, FLASH_SEC1R_BOOT_LOCK, BootLockConfig);
200047be:	4b0c      	ldr	r3, [pc, #48]	; (200047f0 <FLASH_OB_BootLockConfig+0x4c>)
200047c0:	6f1b      	ldr	r3, [r3, #112]	; 0x70
200047c2:	f423 3280 	bic.w	r2, r3, #65536	; 0x10000
200047c6:	490a      	ldr	r1, [pc, #40]	; (200047f0 <FLASH_OB_BootLockConfig+0x4c>)
200047c8:	687b      	ldr	r3, [r7, #4]
200047ca:	4313      	orrs	r3, r2
200047cc:	670b      	str	r3, [r1, #112]	; 0x70

    /* Set OPTSTRT Bit */
    SET_BIT(FLASH->CR, FLASH_CR_OPTSTRT);
200047ce:	4b08      	ldr	r3, [pc, #32]	; (200047f0 <FLASH_OB_BootLockConfig+0x4c>)
200047d0:	695b      	ldr	r3, [r3, #20]
200047d2:	4a07      	ldr	r2, [pc, #28]	; (200047f0 <FLASH_OB_BootLockConfig+0x4c>)
200047d4:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
200047d8:	6153      	str	r3, [r2, #20]

    /* Wait for last operation to be completed */
    status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
200047da:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
200047de:	f7ff f943 	bl	20003a68 <FLASH_WaitForLastOperation>
200047e2:	4603      	mov	r3, r0
200047e4:	73fb      	strb	r3, [r7, #15]
  }

  return status;
200047e6:	7bfb      	ldrb	r3, [r7, #15]
}
200047e8:	4618      	mov	r0, r3
200047ea:	3710      	adds	r7, #16
200047ec:	46bd      	mov	sp, r7
200047ee:	bd80      	pop	{r7, pc}
200047f0:	40022000 	.word	0x40022000

200047f4 <FLASH_OB_GetSecMem>:
  * @param[out]  SecSize specifies the number of pages used in the securable
                 memory area of the bank.
  * @retval None
  */
static void FLASH_OB_GetSecMem(uint32_t SecBank, uint32_t *SecSize)
{
200047f4:	b480      	push	{r7}
200047f6:	b083      	sub	sp, #12
200047f8:	af00      	add	r7, sp, #0
200047fa:	6078      	str	r0, [r7, #4]
200047fc:	6039      	str	r1, [r7, #0]
  /* Get the configuration of the securable memory area */
  if (SecBank == FLASH_BANK_1)
200047fe:	687b      	ldr	r3, [r7, #4]
20004800:	2b01      	cmp	r3, #1
20004802:	d105      	bne.n	20004810 <FLASH_OB_GetSecMem+0x1c>
  {
    *SecSize = READ_BIT(FLASH->SEC1R, FLASH_SEC1R_SEC_SIZE1);
20004804:	4b09      	ldr	r3, [pc, #36]	; (2000482c <FLASH_OB_GetSecMem+0x38>)
20004806:	6f1b      	ldr	r3, [r3, #112]	; 0x70
20004808:	b2da      	uxtb	r2, r3
2000480a:	683b      	ldr	r3, [r7, #0]
2000480c:	601a      	str	r2, [r3, #0]
  else
  {
    /* Nothing to do */
  }
#endif
}
2000480e:	e007      	b.n	20004820 <FLASH_OB_GetSecMem+0x2c>
  else if (SecBank == FLASH_BANK_2)
20004810:	687b      	ldr	r3, [r7, #4]
20004812:	2b02      	cmp	r3, #2
20004814:	d104      	bne.n	20004820 <FLASH_OB_GetSecMem+0x2c>
    *SecSize = READ_BIT(FLASH->SEC2R, FLASH_SEC2R_SEC_SIZE2);
20004816:	4b05      	ldr	r3, [pc, #20]	; (2000482c <FLASH_OB_GetSecMem+0x38>)
20004818:	6f5b      	ldr	r3, [r3, #116]	; 0x74
2000481a:	b2da      	uxtb	r2, r3
2000481c:	683b      	ldr	r3, [r7, #0]
2000481e:	601a      	str	r2, [r3, #0]
}
20004820:	bf00      	nop
20004822:	370c      	adds	r7, #12
20004824:	46bd      	mov	sp, r7
20004826:	f85d 7b04 	ldr.w	r7, [sp], #4
2000482a:	4770      	bx	lr
2000482c:	40022000 	.word	0x40022000

20004830 <FLASH_OB_GetBootLock>:
  *         This return value can be one of the following values:
  *            @arg OB_BOOT_LOCK_ENABLE: Boot lock enabled
  *            @arg OB_BOOT_LOCK_DISABLE: Boot lock disabled
  */
static uint32_t FLASH_OB_GetBootLock(void)
{
20004830:	b480      	push	{r7}
20004832:	af00      	add	r7, sp, #0
  return (READ_REG(FLASH->SEC1R) & FLASH_SEC1R_BOOT_LOCK);
20004834:	4b04      	ldr	r3, [pc, #16]	; (20004848 <FLASH_OB_GetBootLock+0x18>)
20004836:	6f1b      	ldr	r3, [r3, #112]	; 0x70
20004838:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
}
2000483c:	4618      	mov	r0, r3
2000483e:	46bd      	mov	sp, r7
20004840:	f85d 7b04 	ldr.w	r7, [sp], #4
20004844:	4770      	bx	lr
20004846:	bf00      	nop
20004848:	40022000 	.word	0x40022000

2000484c <FLASH_OB_GetWRP>:
  * @param[out]  WRDPEndOffset specifies the address where to copied the end page of
  *              the write protected area.
  * @retval None
  */
static void FLASH_OB_GetWRP(uint32_t WRPArea, uint32_t *WRPStartOffset, uint32_t *WRDPEndOffset)
{
2000484c:	b480      	push	{r7}
2000484e:	b085      	sub	sp, #20
20004850:	af00      	add	r7, sp, #0
20004852:	60f8      	str	r0, [r7, #12]
20004854:	60b9      	str	r1, [r7, #8]
20004856:	607a      	str	r2, [r7, #4]
  /* Get the configuration of the write protected area */
  if (WRPArea == OB_WRPAREA_BANK1_AREAA)
20004858:	68fb      	ldr	r3, [r7, #12]
2000485a:	2b00      	cmp	r3, #0
2000485c:	d10d      	bne.n	2000487a <FLASH_OB_GetWRP+0x2e>
  {
    *WRPStartOffset = READ_BIT(FLASH->WRP1AR, FLASH_WRP1AR_WRP1A_STRT);
2000485e:	4b23      	ldr	r3, [pc, #140]	; (200048ec <FLASH_OB_GetWRP+0xa0>)
20004860:	6adb      	ldr	r3, [r3, #44]	; 0x2c
20004862:	f003 027f 	and.w	r2, r3, #127	; 0x7f
20004866:	68bb      	ldr	r3, [r7, #8]
20004868:	601a      	str	r2, [r3, #0]
    *WRDPEndOffset = (READ_BIT(FLASH->WRP1AR, FLASH_WRP1AR_WRP1A_END) >> FLASH_WRP1AR_WRP1A_END_Pos);
2000486a:	4b20      	ldr	r3, [pc, #128]	; (200048ec <FLASH_OB_GetWRP+0xa0>)
2000486c:	6adb      	ldr	r3, [r3, #44]	; 0x2c
2000486e:	0c1b      	lsrs	r3, r3, #16
20004870:	f003 027f 	and.w	r2, r3, #127	; 0x7f
20004874:	687b      	ldr	r3, [r7, #4]
20004876:	601a      	str	r2, [r3, #0]
#endif
  else
  {
    /* Nothing to do */
  }
}
20004878:	e031      	b.n	200048de <FLASH_OB_GetWRP+0x92>
  else if (WRPArea == OB_WRPAREA_BANK1_AREAB)
2000487a:	68fb      	ldr	r3, [r7, #12]
2000487c:	2b01      	cmp	r3, #1
2000487e:	d10d      	bne.n	2000489c <FLASH_OB_GetWRP+0x50>
    *WRPStartOffset = READ_BIT(FLASH->WRP1BR, FLASH_WRP1BR_WRP1B_STRT);
20004880:	4b1a      	ldr	r3, [pc, #104]	; (200048ec <FLASH_OB_GetWRP+0xa0>)
20004882:	6b1b      	ldr	r3, [r3, #48]	; 0x30
20004884:	f003 027f 	and.w	r2, r3, #127	; 0x7f
20004888:	68bb      	ldr	r3, [r7, #8]
2000488a:	601a      	str	r2, [r3, #0]
    *WRDPEndOffset = (READ_BIT(FLASH->WRP1BR, FLASH_WRP1BR_WRP1B_END) >> FLASH_WRP1BR_WRP1B_END_Pos);
2000488c:	4b17      	ldr	r3, [pc, #92]	; (200048ec <FLASH_OB_GetWRP+0xa0>)
2000488e:	6b1b      	ldr	r3, [r3, #48]	; 0x30
20004890:	0c1b      	lsrs	r3, r3, #16
20004892:	f003 027f 	and.w	r2, r3, #127	; 0x7f
20004896:	687b      	ldr	r3, [r7, #4]
20004898:	601a      	str	r2, [r3, #0]
}
2000489a:	e020      	b.n	200048de <FLASH_OB_GetWRP+0x92>
  else if (WRPArea == OB_WRPAREA_BANK2_AREAA)
2000489c:	68fb      	ldr	r3, [r7, #12]
2000489e:	2b02      	cmp	r3, #2
200048a0:	d10d      	bne.n	200048be <FLASH_OB_GetWRP+0x72>
    *WRPStartOffset = READ_BIT(FLASH->WRP2AR, FLASH_WRP2AR_WRP2A_STRT);
200048a2:	4b12      	ldr	r3, [pc, #72]	; (200048ec <FLASH_OB_GetWRP+0xa0>)
200048a4:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
200048a6:	f003 027f 	and.w	r2, r3, #127	; 0x7f
200048aa:	68bb      	ldr	r3, [r7, #8]
200048ac:	601a      	str	r2, [r3, #0]
    *WRDPEndOffset = (READ_BIT(FLASH->WRP2AR, FLASH_WRP2AR_WRP2A_END) >> FLASH_WRP2AR_WRP2A_END_Pos);
200048ae:	4b0f      	ldr	r3, [pc, #60]	; (200048ec <FLASH_OB_GetWRP+0xa0>)
200048b0:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
200048b2:	0c1b      	lsrs	r3, r3, #16
200048b4:	f003 027f 	and.w	r2, r3, #127	; 0x7f
200048b8:	687b      	ldr	r3, [r7, #4]
200048ba:	601a      	str	r2, [r3, #0]
}
200048bc:	e00f      	b.n	200048de <FLASH_OB_GetWRP+0x92>
  else if (WRPArea == OB_WRPAREA_BANK2_AREAB)
200048be:	68fb      	ldr	r3, [r7, #12]
200048c0:	2b04      	cmp	r3, #4
200048c2:	d10c      	bne.n	200048de <FLASH_OB_GetWRP+0x92>
    *WRPStartOffset = READ_BIT(FLASH->WRP2BR, FLASH_WRP2BR_WRP2B_STRT);
200048c4:	4b09      	ldr	r3, [pc, #36]	; (200048ec <FLASH_OB_GetWRP+0xa0>)
200048c6:	6d1b      	ldr	r3, [r3, #80]	; 0x50
200048c8:	f003 027f 	and.w	r2, r3, #127	; 0x7f
200048cc:	68bb      	ldr	r3, [r7, #8]
200048ce:	601a      	str	r2, [r3, #0]
    *WRDPEndOffset = (READ_BIT(FLASH->WRP2BR, FLASH_WRP2BR_WRP2B_END) >> FLASH_WRP2BR_WRP2B_END_Pos);
200048d0:	4b06      	ldr	r3, [pc, #24]	; (200048ec <FLASH_OB_GetWRP+0xa0>)
200048d2:	6d1b      	ldr	r3, [r3, #80]	; 0x50
200048d4:	0c1b      	lsrs	r3, r3, #16
200048d6:	f003 027f 	and.w	r2, r3, #127	; 0x7f
200048da:	687b      	ldr	r3, [r7, #4]
200048dc:	601a      	str	r2, [r3, #0]
}
200048de:	bf00      	nop
200048e0:	3714      	adds	r7, #20
200048e2:	46bd      	mov	sp, r7
200048e4:	f85d 7b04 	ldr.w	r7, [sp], #4
200048e8:	4770      	bx	lr
200048ea:	bf00      	nop
200048ec:	40022000 	.word	0x40022000

200048f0 <FLASH_OB_GetRDP>:
  *            @arg OB_RDP_LEVEL_0: No protection
  *            @arg OB_RDP_LEVEL_1: Read protection of the memory
  *            @arg OB_RDP_LEVEL_2: Full chip protection
  */
static uint32_t FLASH_OB_GetRDP(void)
{
200048f0:	b480      	push	{r7}
200048f2:	b083      	sub	sp, #12
200048f4:	af00      	add	r7, sp, #0
  uint32_t rdp_level = READ_BIT(FLASH->OPTR, FLASH_OPTR_RDP);
200048f6:	4b09      	ldr	r3, [pc, #36]	; (2000491c <FLASH_OB_GetRDP+0x2c>)
200048f8:	6a1b      	ldr	r3, [r3, #32]
200048fa:	b2db      	uxtb	r3, r3
200048fc:	607b      	str	r3, [r7, #4]

  if ((rdp_level != OB_RDP_LEVEL_0) && (rdp_level != OB_RDP_LEVEL_2))
200048fe:	687b      	ldr	r3, [r7, #4]
20004900:	2baa      	cmp	r3, #170	; 0xaa
20004902:	d004      	beq.n	2000490e <FLASH_OB_GetRDP+0x1e>
20004904:	687b      	ldr	r3, [r7, #4]
20004906:	2bcc      	cmp	r3, #204	; 0xcc
20004908:	d001      	beq.n	2000490e <FLASH_OB_GetRDP+0x1e>
  {
    return (OB_RDP_LEVEL_1);
2000490a:	23bb      	movs	r3, #187	; 0xbb
2000490c:	e000      	b.n	20004910 <FLASH_OB_GetRDP+0x20>
  }
  else
  {
    return rdp_level;
2000490e:	687b      	ldr	r3, [r7, #4]
  }
}
20004910:	4618      	mov	r0, r3
20004912:	370c      	adds	r7, #12
20004914:	46bd      	mov	sp, r7
20004916:	f85d 7b04 	ldr.w	r7, [sp], #4
2000491a:	4770      	bx	lr
2000491c:	40022000 	.word	0x40022000

20004920 <FLASH_OB_GetUser>:
  *         @ref FLASH_OB_USER_CCMSRAM_RST, @ref OB_USER_nSWBOOT0,@ref FLASH_OB_USER_nBOOT0,
  *         @ref FLASH_OB_USER_NRST_MODE, @ref FLASH_OB_USER_INTERNAL_RESET_HOLDER
  * @note  (*) availability depends on devices
  */
static uint32_t FLASH_OB_GetUser(void)
{
20004920:	b480      	push	{r7}
20004922:	b083      	sub	sp, #12
20004924:	af00      	add	r7, sp, #0
  uint32_t user_config = READ_REG(FLASH->OPTR);
20004926:	4b07      	ldr	r3, [pc, #28]	; (20004944 <FLASH_OB_GetUser+0x24>)
20004928:	6a1b      	ldr	r3, [r3, #32]
2000492a:	607b      	str	r3, [r7, #4]
  CLEAR_BIT(user_config, FLASH_OPTR_RDP);
2000492c:	687b      	ldr	r3, [r7, #4]
2000492e:	f023 03ff 	bic.w	r3, r3, #255	; 0xff
20004932:	607b      	str	r3, [r7, #4]

  return user_config;
20004934:	687b      	ldr	r3, [r7, #4]
}
20004936:	4618      	mov	r0, r3
20004938:	370c      	adds	r7, #12
2000493a:	46bd      	mov	sp, r7
2000493c:	f85d 7b04 	ldr.w	r7, [sp], #4
20004940:	4770      	bx	lr
20004942:	bf00      	nop
20004944:	40022000 	.word	0x40022000

20004948 <FLASH_OB_GetPCROP>:
  * @param[out] PCROPEndAddr specifies the address where to copied the end address of
  *        the Proprietary code readout protection.
  * @retval None
  */
static void FLASH_OB_GetPCROP(uint32_t *PCROPConfig, uint32_t *PCROPStartAddr, uint32_t *PCROPEndAddr)
{
20004948:	b480      	push	{r7}
2000494a:	b089      	sub	sp, #36	; 0x24
2000494c:	af00      	add	r7, sp, #0
2000494e:	60f8      	str	r0, [r7, #12]
20004950:	60b9      	str	r1, [r7, #8]
20004952:	607a      	str	r2, [r7, #4]
  uint32_t bank1_addr;
#if defined (FLASH_OPTR_DBANK)
  uint32_t bank2_addr;

  /* Get the information about the bank swapping */
  if (READ_BIT(SYSCFG->MEMRMP, SYSCFG_MEMRMP_FB_MODE) == 0U)
20004954:	4b5b      	ldr	r3, [pc, #364]	; (20004ac4 <FLASH_OB_GetPCROP+0x17c>)
20004956:	681b      	ldr	r3, [r3, #0]
20004958:	f403 7380 	and.w	r3, r3, #256	; 0x100
2000495c:	2b00      	cmp	r3, #0
2000495e:	d114      	bne.n	2000498a <FLASH_OB_GetPCROP+0x42>
  {
    bank1_addr = FLASH_BASE;
20004960:	f04f 6300 	mov.w	r3, #134217728	; 0x8000000
20004964:	61fb      	str	r3, [r7, #28]
    bank2_addr = FLASH_BASE + FLASH_BANK_SIZE;
20004966:	4b58      	ldr	r3, [pc, #352]	; (20004ac8 <FLASH_OB_GetPCROP+0x180>)
20004968:	881b      	ldrh	r3, [r3, #0]
2000496a:	f64f 72ff 	movw	r2, #65535	; 0xffff
2000496e:	4293      	cmp	r3, r2
20004970:	d008      	beq.n	20004984 <FLASH_OB_GetPCROP+0x3c>
20004972:	4b55      	ldr	r3, [pc, #340]	; (20004ac8 <FLASH_OB_GetPCROP+0x180>)
20004974:	681b      	ldr	r3, [r3, #0]
20004976:	029b      	lsls	r3, r3, #10
20004978:	085a      	lsrs	r2, r3, #1
2000497a:	4b54      	ldr	r3, [pc, #336]	; (20004acc <FLASH_OB_GetPCROP+0x184>)
2000497c:	4013      	ands	r3, r2
2000497e:	f103 6300 	add.w	r3, r3, #134217728	; 0x8000000
20004982:	e000      	b.n	20004986 <FLASH_OB_GetPCROP+0x3e>
20004984:	4b52      	ldr	r3, [pc, #328]	; (20004ad0 <FLASH_OB_GetPCROP+0x188>)
20004986:	61bb      	str	r3, [r7, #24]
20004988:	e013      	b.n	200049b2 <FLASH_OB_GetPCROP+0x6a>
  }
  else
  {
    bank1_addr = FLASH_BASE + FLASH_BANK_SIZE;
2000498a:	4b4f      	ldr	r3, [pc, #316]	; (20004ac8 <FLASH_OB_GetPCROP+0x180>)
2000498c:	881b      	ldrh	r3, [r3, #0]
2000498e:	f64f 72ff 	movw	r2, #65535	; 0xffff
20004992:	4293      	cmp	r3, r2
20004994:	d008      	beq.n	200049a8 <FLASH_OB_GetPCROP+0x60>
20004996:	4b4c      	ldr	r3, [pc, #304]	; (20004ac8 <FLASH_OB_GetPCROP+0x180>)
20004998:	681b      	ldr	r3, [r3, #0]
2000499a:	029b      	lsls	r3, r3, #10
2000499c:	085a      	lsrs	r2, r3, #1
2000499e:	4b4b      	ldr	r3, [pc, #300]	; (20004acc <FLASH_OB_GetPCROP+0x184>)
200049a0:	4013      	ands	r3, r2
200049a2:	f103 6300 	add.w	r3, r3, #134217728	; 0x8000000
200049a6:	e000      	b.n	200049aa <FLASH_OB_GetPCROP+0x62>
200049a8:	4b49      	ldr	r3, [pc, #292]	; (20004ad0 <FLASH_OB_GetPCROP+0x188>)
200049aa:	61fb      	str	r3, [r7, #28]
    bank2_addr = FLASH_BASE;
200049ac:	f04f 6300 	mov.w	r3, #134217728	; 0x8000000
200049b0:	61bb      	str	r3, [r7, #24]
#else
  bank1_addr = FLASH_BASE;
#endif

#if defined (FLASH_OPTR_DBANK)
  if (READ_BIT(FLASH->OPTR, FLASH_OPTR_DBANK) == 0U)
200049b2:	4b48      	ldr	r3, [pc, #288]	; (20004ad4 <FLASH_OB_GetPCROP+0x18c>)
200049b4:	6a1b      	ldr	r3, [r3, #32]
200049b6:	f403 0380 	and.w	r3, r3, #4194304	; 0x400000
200049ba:	2b00      	cmp	r3, #0
200049bc:	d139      	bne.n	20004a32 <FLASH_OB_GetPCROP+0xea>
  {
    if (((*PCROPConfig) & FLASH_BANK_BOTH) == FLASH_BANK_1)
200049be:	68fb      	ldr	r3, [r7, #12]
200049c0:	681b      	ldr	r3, [r3, #0]
200049c2:	f003 0303 	and.w	r3, r3, #3
200049c6:	2b01      	cmp	r3, #1
200049c8:	d116      	bne.n	200049f8 <FLASH_OB_GetPCROP+0xb0>
    {
      reg_value       = (READ_REG(FLASH->PCROP1SR) & FLASH_PCROP1SR_PCROP1_STRT);
200049ca:	4b42      	ldr	r3, [pc, #264]	; (20004ad4 <FLASH_OB_GetPCROP+0x18c>)
200049cc:	6a5b      	ldr	r3, [r3, #36]	; 0x24
200049ce:	f3c3 030e 	ubfx	r3, r3, #0, #15
200049d2:	617b      	str	r3, [r7, #20]
      *PCROPStartAddr = (reg_value << 4) + FLASH_BASE;
200049d4:	697b      	ldr	r3, [r7, #20]
200049d6:	011b      	lsls	r3, r3, #4
200049d8:	f103 6200 	add.w	r2, r3, #134217728	; 0x8000000
200049dc:	68bb      	ldr	r3, [r7, #8]
200049de:	601a      	str	r2, [r3, #0]

      reg_value     = (READ_REG(FLASH->PCROP1ER) & FLASH_PCROP1ER_PCROP1_END);
200049e0:	4b3c      	ldr	r3, [pc, #240]	; (20004ad4 <FLASH_OB_GetPCROP+0x18c>)
200049e2:	6a9b      	ldr	r3, [r3, #40]	; 0x28
200049e4:	f3c3 030e 	ubfx	r3, r3, #0, #15
200049e8:	617b      	str	r3, [r7, #20]
      *PCROPEndAddr = (reg_value << 4) + FLASH_BASE;
200049ea:	697b      	ldr	r3, [r7, #20]
200049ec:	011b      	lsls	r3, r3, #4
200049ee:	f103 6200 	add.w	r2, r3, #134217728	; 0x8000000
200049f2:	687b      	ldr	r3, [r7, #4]
200049f4:	601a      	str	r2, [r3, #0]
200049f6:	e055      	b.n	20004aa4 <FLASH_OB_GetPCROP+0x15c>
    }
    else if (((*PCROPConfig) & FLASH_BANK_BOTH) == FLASH_BANK_2)
200049f8:	68fb      	ldr	r3, [r7, #12]
200049fa:	681b      	ldr	r3, [r3, #0]
200049fc:	f003 0303 	and.w	r3, r3, #3
20004a00:	2b02      	cmp	r3, #2
20004a02:	d14f      	bne.n	20004aa4 <FLASH_OB_GetPCROP+0x15c>
    {
      reg_value       = (READ_REG(FLASH->PCROP2SR) & FLASH_PCROP2SR_PCROP2_STRT);
20004a04:	4b33      	ldr	r3, [pc, #204]	; (20004ad4 <FLASH_OB_GetPCROP+0x18c>)
20004a06:	6c5b      	ldr	r3, [r3, #68]	; 0x44
20004a08:	f3c3 030e 	ubfx	r3, r3, #0, #15
20004a0c:	617b      	str	r3, [r7, #20]
      *PCROPStartAddr = (reg_value << 4) + FLASH_BASE;
20004a0e:	697b      	ldr	r3, [r7, #20]
20004a10:	011b      	lsls	r3, r3, #4
20004a12:	f103 6200 	add.w	r2, r3, #134217728	; 0x8000000
20004a16:	68bb      	ldr	r3, [r7, #8]
20004a18:	601a      	str	r2, [r3, #0]

      reg_value     = (READ_REG(FLASH->PCROP2ER) & FLASH_PCROP2ER_PCROP2_END);
20004a1a:	4b2e      	ldr	r3, [pc, #184]	; (20004ad4 <FLASH_OB_GetPCROP+0x18c>)
20004a1c:	6c9b      	ldr	r3, [r3, #72]	; 0x48
20004a1e:	f3c3 030e 	ubfx	r3, r3, #0, #15
20004a22:	617b      	str	r3, [r7, #20]
      *PCROPEndAddr = (reg_value << 4) + FLASH_BASE;
20004a24:	697b      	ldr	r3, [r7, #20]
20004a26:	011b      	lsls	r3, r3, #4
20004a28:	f103 6200 	add.w	r2, r3, #134217728	; 0x8000000
20004a2c:	687b      	ldr	r3, [r7, #4]
20004a2e:	601a      	str	r2, [r3, #0]
20004a30:	e038      	b.n	20004aa4 <FLASH_OB_GetPCROP+0x15c>
    }
  }
  else
#endif
  {
    if (((*PCROPConfig) & FLASH_BANK_BOTH) == FLASH_BANK_1)
20004a32:	68fb      	ldr	r3, [r7, #12]
20004a34:	681b      	ldr	r3, [r3, #0]
20004a36:	f003 0303 	and.w	r3, r3, #3
20004a3a:	2b01      	cmp	r3, #1
20004a3c:	d116      	bne.n	20004a6c <FLASH_OB_GetPCROP+0x124>
    {
      reg_value       = (READ_REG(FLASH->PCROP1SR) & FLASH_PCROP1SR_PCROP1_STRT);
20004a3e:	4b25      	ldr	r3, [pc, #148]	; (20004ad4 <FLASH_OB_GetPCROP+0x18c>)
20004a40:	6a5b      	ldr	r3, [r3, #36]	; 0x24
20004a42:	f3c3 030e 	ubfx	r3, r3, #0, #15
20004a46:	617b      	str	r3, [r7, #20]
      *PCROPStartAddr = (reg_value << 3) + bank1_addr;
20004a48:	697b      	ldr	r3, [r7, #20]
20004a4a:	00da      	lsls	r2, r3, #3
20004a4c:	69fb      	ldr	r3, [r7, #28]
20004a4e:	441a      	add	r2, r3
20004a50:	68bb      	ldr	r3, [r7, #8]
20004a52:	601a      	str	r2, [r3, #0]

      reg_value     = (READ_REG(FLASH->PCROP1ER) & FLASH_PCROP1ER_PCROP1_END);
20004a54:	4b1f      	ldr	r3, [pc, #124]	; (20004ad4 <FLASH_OB_GetPCROP+0x18c>)
20004a56:	6a9b      	ldr	r3, [r3, #40]	; 0x28
20004a58:	f3c3 030e 	ubfx	r3, r3, #0, #15
20004a5c:	617b      	str	r3, [r7, #20]
      *PCROPEndAddr = (reg_value << 3) + bank1_addr;
20004a5e:	697b      	ldr	r3, [r7, #20]
20004a60:	00da      	lsls	r2, r3, #3
20004a62:	69fb      	ldr	r3, [r7, #28]
20004a64:	441a      	add	r2, r3
20004a66:	687b      	ldr	r3, [r7, #4]
20004a68:	601a      	str	r2, [r3, #0]
20004a6a:	e01b      	b.n	20004aa4 <FLASH_OB_GetPCROP+0x15c>
    }
#if defined (FLASH_OPTR_DBANK)
    else if (((*PCROPConfig) & FLASH_BANK_BOTH) == FLASH_BANK_2)
20004a6c:	68fb      	ldr	r3, [r7, #12]
20004a6e:	681b      	ldr	r3, [r3, #0]
20004a70:	f003 0303 	and.w	r3, r3, #3
20004a74:	2b02      	cmp	r3, #2
20004a76:	d115      	bne.n	20004aa4 <FLASH_OB_GetPCROP+0x15c>
    {
      reg_value       = (READ_REG(FLASH->PCROP2SR) & FLASH_PCROP2SR_PCROP2_STRT);
20004a78:	4b16      	ldr	r3, [pc, #88]	; (20004ad4 <FLASH_OB_GetPCROP+0x18c>)
20004a7a:	6c5b      	ldr	r3, [r3, #68]	; 0x44
20004a7c:	f3c3 030e 	ubfx	r3, r3, #0, #15
20004a80:	617b      	str	r3, [r7, #20]
      *PCROPStartAddr = (reg_value << 3) + bank2_addr;
20004a82:	697b      	ldr	r3, [r7, #20]
20004a84:	00da      	lsls	r2, r3, #3
20004a86:	69bb      	ldr	r3, [r7, #24]
20004a88:	441a      	add	r2, r3
20004a8a:	68bb      	ldr	r3, [r7, #8]
20004a8c:	601a      	str	r2, [r3, #0]

      reg_value     = (READ_REG(FLASH->PCROP2ER) & FLASH_PCROP2ER_PCROP2_END);
20004a8e:	4b11      	ldr	r3, [pc, #68]	; (20004ad4 <FLASH_OB_GetPCROP+0x18c>)
20004a90:	6c9b      	ldr	r3, [r3, #72]	; 0x48
20004a92:	f3c3 030e 	ubfx	r3, r3, #0, #15
20004a96:	617b      	str	r3, [r7, #20]
      *PCROPEndAddr = (reg_value << 3) + bank2_addr;
20004a98:	697b      	ldr	r3, [r7, #20]
20004a9a:	00da      	lsls	r2, r3, #3
20004a9c:	69bb      	ldr	r3, [r7, #24]
20004a9e:	441a      	add	r2, r3
20004aa0:	687b      	ldr	r3, [r7, #4]
20004aa2:	601a      	str	r2, [r3, #0]
    {
      /* Nothing to do */
    }
  }

  *PCROPConfig |= (READ_REG(FLASH->PCROP1ER) & FLASH_PCROP1ER_PCROP_RDP);
20004aa4:	4b0b      	ldr	r3, [pc, #44]	; (20004ad4 <FLASH_OB_GetPCROP+0x18c>)
20004aa6:	6a9b      	ldr	r3, [r3, #40]	; 0x28
20004aa8:	f003 4200 	and.w	r2, r3, #2147483648	; 0x80000000
20004aac:	68fb      	ldr	r3, [r7, #12]
20004aae:	681b      	ldr	r3, [r3, #0]
20004ab0:	431a      	orrs	r2, r3
20004ab2:	68fb      	ldr	r3, [r7, #12]
20004ab4:	601a      	str	r2, [r3, #0]
}
20004ab6:	bf00      	nop
20004ab8:	3724      	adds	r7, #36	; 0x24
20004aba:	46bd      	mov	sp, r7
20004abc:	f85d 7b04 	ldr.w	r7, [sp], #4
20004ac0:	4770      	bx	lr
20004ac2:	bf00      	nop
20004ac4:	40010000 	.word	0x40010000
20004ac8:	1fff75e0 	.word	0x1fff75e0
20004acc:	01fffe00 	.word	0x01fffe00
20004ad0:	08040000 	.word	0x08040000
20004ad4:	40022000 	.word	0x40022000

20004ad8 <HAL_GPIO_Init>:
  * @param  GPIO_Init pointer to a GPIO_InitTypeDef structure that contains
  *         the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, GPIO_InitTypeDef *GPIO_Init)
{
20004ad8:	b480      	push	{r7}
20004ada:	b087      	sub	sp, #28
20004adc:	af00      	add	r7, sp, #0
20004ade:	6078      	str	r0, [r7, #4]
20004ae0:	6039      	str	r1, [r7, #0]
  uint32_t position = 0x00U;
20004ae2:	2300      	movs	r3, #0
20004ae4:	617b      	str	r3, [r7, #20]
  assert_param(IS_GPIO_PIN(GPIO_Init->Pin));
  assert_param(IS_GPIO_MODE(GPIO_Init->Mode));
  assert_param(IS_GPIO_PULL(GPIO_Init->Pull));

  /* Configure the port pins */
  while (((GPIO_Init->Pin) >> position) != 0U)
20004ae6:	e15a      	b.n	20004d9e <HAL_GPIO_Init+0x2c6>
  {
    /* Get current io position */
    iocurrent = (GPIO_Init->Pin) & (1UL << position);
20004ae8:	683b      	ldr	r3, [r7, #0]
20004aea:	681a      	ldr	r2, [r3, #0]
20004aec:	2101      	movs	r1, #1
20004aee:	697b      	ldr	r3, [r7, #20]
20004af0:	fa01 f303 	lsl.w	r3, r1, r3
20004af4:	4013      	ands	r3, r2
20004af6:	60fb      	str	r3, [r7, #12]

    if (iocurrent != 0x00u)
20004af8:	68fb      	ldr	r3, [r7, #12]
20004afa:	2b00      	cmp	r3, #0
20004afc:	f000 814c 	beq.w	20004d98 <HAL_GPIO_Init+0x2c0>
    {
      /*--------------------- GPIO Mode Configuration ------------------------*/
      /* In case of Output or Alternate function mode selection */
      if ((GPIO_Init->Mode == GPIO_MODE_OUTPUT_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_PP) ||
20004b00:	683b      	ldr	r3, [r7, #0]
20004b02:	685b      	ldr	r3, [r3, #4]
20004b04:	2b01      	cmp	r3, #1
20004b06:	d00b      	beq.n	20004b20 <HAL_GPIO_Init+0x48>
20004b08:	683b      	ldr	r3, [r7, #0]
20004b0a:	685b      	ldr	r3, [r3, #4]
20004b0c:	2b02      	cmp	r3, #2
20004b0e:	d007      	beq.n	20004b20 <HAL_GPIO_Init+0x48>
          (GPIO_Init->Mode == GPIO_MODE_OUTPUT_OD) || (GPIO_Init->Mode == GPIO_MODE_AF_OD))
20004b10:	683b      	ldr	r3, [r7, #0]
20004b12:	685b      	ldr	r3, [r3, #4]
      if ((GPIO_Init->Mode == GPIO_MODE_OUTPUT_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_PP) ||
20004b14:	2b11      	cmp	r3, #17
20004b16:	d003      	beq.n	20004b20 <HAL_GPIO_Init+0x48>
          (GPIO_Init->Mode == GPIO_MODE_OUTPUT_OD) || (GPIO_Init->Mode == GPIO_MODE_AF_OD))
20004b18:	683b      	ldr	r3, [r7, #0]
20004b1a:	685b      	ldr	r3, [r3, #4]
20004b1c:	2b12      	cmp	r3, #18
20004b1e:	d130      	bne.n	20004b82 <HAL_GPIO_Init+0xaa>
      {
        /* Check the Speed parameter */
        assert_param(IS_GPIO_SPEED(GPIO_Init->Speed));
        /* Configure the IO Speed */
        temp = GPIOx->OSPEEDR;
20004b20:	687b      	ldr	r3, [r7, #4]
20004b22:	689b      	ldr	r3, [r3, #8]
20004b24:	613b      	str	r3, [r7, #16]
        temp &= ~(GPIO_OSPEEDR_OSPEED0 << (position * 2U));
20004b26:	697b      	ldr	r3, [r7, #20]
20004b28:	005b      	lsls	r3, r3, #1
20004b2a:	2203      	movs	r2, #3
20004b2c:	fa02 f303 	lsl.w	r3, r2, r3
20004b30:	43db      	mvns	r3, r3
20004b32:	693a      	ldr	r2, [r7, #16]
20004b34:	4013      	ands	r3, r2
20004b36:	613b      	str	r3, [r7, #16]
        temp |= (GPIO_Init->Speed << (position * 2U));
20004b38:	683b      	ldr	r3, [r7, #0]
20004b3a:	68da      	ldr	r2, [r3, #12]
20004b3c:	697b      	ldr	r3, [r7, #20]
20004b3e:	005b      	lsls	r3, r3, #1
20004b40:	fa02 f303 	lsl.w	r3, r2, r3
20004b44:	693a      	ldr	r2, [r7, #16]
20004b46:	4313      	orrs	r3, r2
20004b48:	613b      	str	r3, [r7, #16]
        GPIOx->OSPEEDR = temp;
20004b4a:	687b      	ldr	r3, [r7, #4]
20004b4c:	693a      	ldr	r2, [r7, #16]
20004b4e:	609a      	str	r2, [r3, #8]

        /* Configure the IO Output Type */
        temp = GPIOx->OTYPER;
20004b50:	687b      	ldr	r3, [r7, #4]
20004b52:	685b      	ldr	r3, [r3, #4]
20004b54:	613b      	str	r3, [r7, #16]
        temp &= ~(GPIO_OTYPER_OT0 << position) ;
20004b56:	2201      	movs	r2, #1
20004b58:	697b      	ldr	r3, [r7, #20]
20004b5a:	fa02 f303 	lsl.w	r3, r2, r3
20004b5e:	43db      	mvns	r3, r3
20004b60:	693a      	ldr	r2, [r7, #16]
20004b62:	4013      	ands	r3, r2
20004b64:	613b      	str	r3, [r7, #16]
        temp |= (((GPIO_Init->Mode & GPIO_OUTPUT_TYPE) >> 4U) << position);
20004b66:	683b      	ldr	r3, [r7, #0]
20004b68:	685b      	ldr	r3, [r3, #4]
20004b6a:	091b      	lsrs	r3, r3, #4
20004b6c:	f003 0201 	and.w	r2, r3, #1
20004b70:	697b      	ldr	r3, [r7, #20]
20004b72:	fa02 f303 	lsl.w	r3, r2, r3
20004b76:	693a      	ldr	r2, [r7, #16]
20004b78:	4313      	orrs	r3, r2
20004b7a:	613b      	str	r3, [r7, #16]
        GPIOx->OTYPER = temp;
20004b7c:	687b      	ldr	r3, [r7, #4]
20004b7e:	693a      	ldr	r2, [r7, #16]
20004b80:	605a      	str	r2, [r3, #4]
      }

      /* Activate the Pull-up or Pull down resistor for the current IO */
      temp = GPIOx->PUPDR;
20004b82:	687b      	ldr	r3, [r7, #4]
20004b84:	68db      	ldr	r3, [r3, #12]
20004b86:	613b      	str	r3, [r7, #16]
      temp &= ~(GPIO_PUPDR_PUPD0 << (position * 2U));
20004b88:	697b      	ldr	r3, [r7, #20]
20004b8a:	005b      	lsls	r3, r3, #1
20004b8c:	2203      	movs	r2, #3
20004b8e:	fa02 f303 	lsl.w	r3, r2, r3
20004b92:	43db      	mvns	r3, r3
20004b94:	693a      	ldr	r2, [r7, #16]
20004b96:	4013      	ands	r3, r2
20004b98:	613b      	str	r3, [r7, #16]
      temp |= ((GPIO_Init->Pull) << (position * 2U));
20004b9a:	683b      	ldr	r3, [r7, #0]
20004b9c:	689a      	ldr	r2, [r3, #8]
20004b9e:	697b      	ldr	r3, [r7, #20]
20004ba0:	005b      	lsls	r3, r3, #1
20004ba2:	fa02 f303 	lsl.w	r3, r2, r3
20004ba6:	693a      	ldr	r2, [r7, #16]
20004ba8:	4313      	orrs	r3, r2
20004baa:	613b      	str	r3, [r7, #16]
      GPIOx->PUPDR = temp;
20004bac:	687b      	ldr	r3, [r7, #4]
20004bae:	693a      	ldr	r2, [r7, #16]
20004bb0:	60da      	str	r2, [r3, #12]

      /* In case of Alternate function mode selection */
      if ((GPIO_Init->Mode == GPIO_MODE_AF_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_OD))
20004bb2:	683b      	ldr	r3, [r7, #0]
20004bb4:	685b      	ldr	r3, [r3, #4]
20004bb6:	2b02      	cmp	r3, #2
20004bb8:	d003      	beq.n	20004bc2 <HAL_GPIO_Init+0xea>
20004bba:	683b      	ldr	r3, [r7, #0]
20004bbc:	685b      	ldr	r3, [r3, #4]
20004bbe:	2b12      	cmp	r3, #18
20004bc0:	d123      	bne.n	20004c0a <HAL_GPIO_Init+0x132>
        /* Check the Alternate function parameters */
        assert_param(IS_GPIO_AF_INSTANCE(GPIOx));
        assert_param(IS_GPIO_AF(GPIO_Init->Alternate));

        /* Configure Alternate function mapped with the current IO */
        temp = GPIOx->AFR[position >> 3U];
20004bc2:	697b      	ldr	r3, [r7, #20]
20004bc4:	08da      	lsrs	r2, r3, #3
20004bc6:	687b      	ldr	r3, [r7, #4]
20004bc8:	3208      	adds	r2, #8
20004bca:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
20004bce:	613b      	str	r3, [r7, #16]
        temp &= ~(0xFU << ((position & 0x07U) * 4U));
20004bd0:	697b      	ldr	r3, [r7, #20]
20004bd2:	f003 0307 	and.w	r3, r3, #7
20004bd6:	009b      	lsls	r3, r3, #2
20004bd8:	220f      	movs	r2, #15
20004bda:	fa02 f303 	lsl.w	r3, r2, r3
20004bde:	43db      	mvns	r3, r3
20004be0:	693a      	ldr	r2, [r7, #16]
20004be2:	4013      	ands	r3, r2
20004be4:	613b      	str	r3, [r7, #16]
        temp |= ((GPIO_Init->Alternate) << ((position & 0x07U) * 4U));
20004be6:	683b      	ldr	r3, [r7, #0]
20004be8:	691a      	ldr	r2, [r3, #16]
20004bea:	697b      	ldr	r3, [r7, #20]
20004bec:	f003 0307 	and.w	r3, r3, #7
20004bf0:	009b      	lsls	r3, r3, #2
20004bf2:	fa02 f303 	lsl.w	r3, r2, r3
20004bf6:	693a      	ldr	r2, [r7, #16]
20004bf8:	4313      	orrs	r3, r2
20004bfa:	613b      	str	r3, [r7, #16]
        GPIOx->AFR[position >> 3U] = temp;
20004bfc:	697b      	ldr	r3, [r7, #20]
20004bfe:	08da      	lsrs	r2, r3, #3
20004c00:	687b      	ldr	r3, [r7, #4]
20004c02:	3208      	adds	r2, #8
20004c04:	6939      	ldr	r1, [r7, #16]
20004c06:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
      }

      /* Configure IO Direction mode (Input, Output, Alternate or Analog) */
      temp = GPIOx->MODER;
20004c0a:	687b      	ldr	r3, [r7, #4]
20004c0c:	681b      	ldr	r3, [r3, #0]
20004c0e:	613b      	str	r3, [r7, #16]
      temp &= ~(GPIO_MODER_MODE0 << (position * 2U));
20004c10:	697b      	ldr	r3, [r7, #20]
20004c12:	005b      	lsls	r3, r3, #1
20004c14:	2203      	movs	r2, #3
20004c16:	fa02 f303 	lsl.w	r3, r2, r3
20004c1a:	43db      	mvns	r3, r3
20004c1c:	693a      	ldr	r2, [r7, #16]
20004c1e:	4013      	ands	r3, r2
20004c20:	613b      	str	r3, [r7, #16]
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2U));
20004c22:	683b      	ldr	r3, [r7, #0]
20004c24:	685b      	ldr	r3, [r3, #4]
20004c26:	f003 0203 	and.w	r2, r3, #3
20004c2a:	697b      	ldr	r3, [r7, #20]
20004c2c:	005b      	lsls	r3, r3, #1
20004c2e:	fa02 f303 	lsl.w	r3, r2, r3
20004c32:	693a      	ldr	r2, [r7, #16]
20004c34:	4313      	orrs	r3, r2
20004c36:	613b      	str	r3, [r7, #16]
      GPIOx->MODER = temp;
20004c38:	687b      	ldr	r3, [r7, #4]
20004c3a:	693a      	ldr	r2, [r7, #16]
20004c3c:	601a      	str	r2, [r3, #0]

      /*--------------------- EXTI Mode Configuration ------------------------*/
      /* Configure the External Interrupt or event for the current IO */
      if ((GPIO_Init->Mode & EXTI_MODE) == EXTI_MODE)
20004c3e:	683b      	ldr	r3, [r7, #0]
20004c40:	685b      	ldr	r3, [r3, #4]
20004c42:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
20004c46:	2b00      	cmp	r3, #0
20004c48:	f000 80a6 	beq.w	20004d98 <HAL_GPIO_Init+0x2c0>
      {
        /* Enable SYSCFG Clock */
        __HAL_RCC_SYSCFG_CLK_ENABLE();
20004c4c:	4b5b      	ldr	r3, [pc, #364]	; (20004dbc <HAL_GPIO_Init+0x2e4>)
20004c4e:	6e1b      	ldr	r3, [r3, #96]	; 0x60
20004c50:	4a5a      	ldr	r2, [pc, #360]	; (20004dbc <HAL_GPIO_Init+0x2e4>)
20004c52:	f043 0301 	orr.w	r3, r3, #1
20004c56:	6613      	str	r3, [r2, #96]	; 0x60
20004c58:	4b58      	ldr	r3, [pc, #352]	; (20004dbc <HAL_GPIO_Init+0x2e4>)
20004c5a:	6e1b      	ldr	r3, [r3, #96]	; 0x60
20004c5c:	f003 0301 	and.w	r3, r3, #1
20004c60:	60bb      	str	r3, [r7, #8]
20004c62:	68bb      	ldr	r3, [r7, #8]

        temp = SYSCFG->EXTICR[position >> 2U];
20004c64:	4a56      	ldr	r2, [pc, #344]	; (20004dc0 <HAL_GPIO_Init+0x2e8>)
20004c66:	697b      	ldr	r3, [r7, #20]
20004c68:	089b      	lsrs	r3, r3, #2
20004c6a:	3302      	adds	r3, #2
20004c6c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
20004c70:	613b      	str	r3, [r7, #16]
        temp &= ~(0x0FUL << (4U * (position & 0x03U)));
20004c72:	697b      	ldr	r3, [r7, #20]
20004c74:	f003 0303 	and.w	r3, r3, #3
20004c78:	009b      	lsls	r3, r3, #2
20004c7a:	220f      	movs	r2, #15
20004c7c:	fa02 f303 	lsl.w	r3, r2, r3
20004c80:	43db      	mvns	r3, r3
20004c82:	693a      	ldr	r2, [r7, #16]
20004c84:	4013      	ands	r3, r2
20004c86:	613b      	str	r3, [r7, #16]
        temp |= (GPIO_GET_INDEX(GPIOx) << (4U * (position & 0x03U)));
20004c88:	687b      	ldr	r3, [r7, #4]
20004c8a:	f1b3 4f90 	cmp.w	r3, #1207959552	; 0x48000000
20004c8e:	d01f      	beq.n	20004cd0 <HAL_GPIO_Init+0x1f8>
20004c90:	687b      	ldr	r3, [r7, #4]
20004c92:	4a4c      	ldr	r2, [pc, #304]	; (20004dc4 <HAL_GPIO_Init+0x2ec>)
20004c94:	4293      	cmp	r3, r2
20004c96:	d019      	beq.n	20004ccc <HAL_GPIO_Init+0x1f4>
20004c98:	687b      	ldr	r3, [r7, #4]
20004c9a:	4a4b      	ldr	r2, [pc, #300]	; (20004dc8 <HAL_GPIO_Init+0x2f0>)
20004c9c:	4293      	cmp	r3, r2
20004c9e:	d013      	beq.n	20004cc8 <HAL_GPIO_Init+0x1f0>
20004ca0:	687b      	ldr	r3, [r7, #4]
20004ca2:	4a4a      	ldr	r2, [pc, #296]	; (20004dcc <HAL_GPIO_Init+0x2f4>)
20004ca4:	4293      	cmp	r3, r2
20004ca6:	d00d      	beq.n	20004cc4 <HAL_GPIO_Init+0x1ec>
20004ca8:	687b      	ldr	r3, [r7, #4]
20004caa:	4a49      	ldr	r2, [pc, #292]	; (20004dd0 <HAL_GPIO_Init+0x2f8>)
20004cac:	4293      	cmp	r3, r2
20004cae:	d007      	beq.n	20004cc0 <HAL_GPIO_Init+0x1e8>
20004cb0:	687b      	ldr	r3, [r7, #4]
20004cb2:	4a48      	ldr	r2, [pc, #288]	; (20004dd4 <HAL_GPIO_Init+0x2fc>)
20004cb4:	4293      	cmp	r3, r2
20004cb6:	d101      	bne.n	20004cbc <HAL_GPIO_Init+0x1e4>
20004cb8:	2305      	movs	r3, #5
20004cba:	e00a      	b.n	20004cd2 <HAL_GPIO_Init+0x1fa>
20004cbc:	2306      	movs	r3, #6
20004cbe:	e008      	b.n	20004cd2 <HAL_GPIO_Init+0x1fa>
20004cc0:	2304      	movs	r3, #4
20004cc2:	e006      	b.n	20004cd2 <HAL_GPIO_Init+0x1fa>
20004cc4:	2303      	movs	r3, #3
20004cc6:	e004      	b.n	20004cd2 <HAL_GPIO_Init+0x1fa>
20004cc8:	2302      	movs	r3, #2
20004cca:	e002      	b.n	20004cd2 <HAL_GPIO_Init+0x1fa>
20004ccc:	2301      	movs	r3, #1
20004cce:	e000      	b.n	20004cd2 <HAL_GPIO_Init+0x1fa>
20004cd0:	2300      	movs	r3, #0
20004cd2:	697a      	ldr	r2, [r7, #20]
20004cd4:	f002 0203 	and.w	r2, r2, #3
20004cd8:	0092      	lsls	r2, r2, #2
20004cda:	4093      	lsls	r3, r2
20004cdc:	693a      	ldr	r2, [r7, #16]
20004cde:	4313      	orrs	r3, r2
20004ce0:	613b      	str	r3, [r7, #16]
        SYSCFG->EXTICR[position >> 2U] = temp;
20004ce2:	4937      	ldr	r1, [pc, #220]	; (20004dc0 <HAL_GPIO_Init+0x2e8>)
20004ce4:	697b      	ldr	r3, [r7, #20]
20004ce6:	089b      	lsrs	r3, r3, #2
20004ce8:	3302      	adds	r3, #2
20004cea:	693a      	ldr	r2, [r7, #16]
20004cec:	f841 2023 	str.w	r2, [r1, r3, lsl #2]

        /* Clear EXTI line configuration */
        temp = EXTI->IMR1;
20004cf0:	4b39      	ldr	r3, [pc, #228]	; (20004dd8 <HAL_GPIO_Init+0x300>)
20004cf2:	681b      	ldr	r3, [r3, #0]
20004cf4:	613b      	str	r3, [r7, #16]
        temp &= ~(iocurrent);
20004cf6:	68fb      	ldr	r3, [r7, #12]
20004cf8:	43db      	mvns	r3, r3
20004cfa:	693a      	ldr	r2, [r7, #16]
20004cfc:	4013      	ands	r3, r2
20004cfe:	613b      	str	r3, [r7, #16]
        if ((GPIO_Init->Mode & GPIO_MODE_IT) == GPIO_MODE_IT)
20004d00:	683b      	ldr	r3, [r7, #0]
20004d02:	685b      	ldr	r3, [r3, #4]
20004d04:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
20004d08:	2b00      	cmp	r3, #0
20004d0a:	d003      	beq.n	20004d14 <HAL_GPIO_Init+0x23c>
        {
          temp |= iocurrent;
20004d0c:	693a      	ldr	r2, [r7, #16]
20004d0e:	68fb      	ldr	r3, [r7, #12]
20004d10:	4313      	orrs	r3, r2
20004d12:	613b      	str	r3, [r7, #16]
        }
        EXTI->IMR1 = temp;
20004d14:	4a30      	ldr	r2, [pc, #192]	; (20004dd8 <HAL_GPIO_Init+0x300>)
20004d16:	693b      	ldr	r3, [r7, #16]
20004d18:	6013      	str	r3, [r2, #0]

        temp = EXTI->EMR1;
20004d1a:	4b2f      	ldr	r3, [pc, #188]	; (20004dd8 <HAL_GPIO_Init+0x300>)
20004d1c:	685b      	ldr	r3, [r3, #4]
20004d1e:	613b      	str	r3, [r7, #16]
        temp &= ~(iocurrent);
20004d20:	68fb      	ldr	r3, [r7, #12]
20004d22:	43db      	mvns	r3, r3
20004d24:	693a      	ldr	r2, [r7, #16]
20004d26:	4013      	ands	r3, r2
20004d28:	613b      	str	r3, [r7, #16]
        if ((GPIO_Init->Mode & GPIO_MODE_EVT) == GPIO_MODE_EVT)
20004d2a:	683b      	ldr	r3, [r7, #0]
20004d2c:	685b      	ldr	r3, [r3, #4]
20004d2e:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
20004d32:	2b00      	cmp	r3, #0
20004d34:	d003      	beq.n	20004d3e <HAL_GPIO_Init+0x266>
        {
          temp |= iocurrent;
20004d36:	693a      	ldr	r2, [r7, #16]
20004d38:	68fb      	ldr	r3, [r7, #12]
20004d3a:	4313      	orrs	r3, r2
20004d3c:	613b      	str	r3, [r7, #16]
        }
        EXTI->EMR1 = temp;
20004d3e:	4a26      	ldr	r2, [pc, #152]	; (20004dd8 <HAL_GPIO_Init+0x300>)
20004d40:	693b      	ldr	r3, [r7, #16]
20004d42:	6053      	str	r3, [r2, #4]

        /* Clear Rising Falling edge configuration */
        temp = EXTI->RTSR1;
20004d44:	4b24      	ldr	r3, [pc, #144]	; (20004dd8 <HAL_GPIO_Init+0x300>)
20004d46:	689b      	ldr	r3, [r3, #8]
20004d48:	613b      	str	r3, [r7, #16]
        temp &= ~(iocurrent);
20004d4a:	68fb      	ldr	r3, [r7, #12]
20004d4c:	43db      	mvns	r3, r3
20004d4e:	693a      	ldr	r2, [r7, #16]
20004d50:	4013      	ands	r3, r2
20004d52:	613b      	str	r3, [r7, #16]
        if ((GPIO_Init->Mode & RISING_EDGE) == RISING_EDGE)
20004d54:	683b      	ldr	r3, [r7, #0]
20004d56:	685b      	ldr	r3, [r3, #4]
20004d58:	f403 1380 	and.w	r3, r3, #1048576	; 0x100000
20004d5c:	2b00      	cmp	r3, #0
20004d5e:	d003      	beq.n	20004d68 <HAL_GPIO_Init+0x290>
        {
          temp |= iocurrent;
20004d60:	693a      	ldr	r2, [r7, #16]
20004d62:	68fb      	ldr	r3, [r7, #12]
20004d64:	4313      	orrs	r3, r2
20004d66:	613b      	str	r3, [r7, #16]
        }
        EXTI->RTSR1 = temp;
20004d68:	4a1b      	ldr	r2, [pc, #108]	; (20004dd8 <HAL_GPIO_Init+0x300>)
20004d6a:	693b      	ldr	r3, [r7, #16]
20004d6c:	6093      	str	r3, [r2, #8]

        temp = EXTI->FTSR1;
20004d6e:	4b1a      	ldr	r3, [pc, #104]	; (20004dd8 <HAL_GPIO_Init+0x300>)
20004d70:	68db      	ldr	r3, [r3, #12]
20004d72:	613b      	str	r3, [r7, #16]
        temp &= ~(iocurrent);
20004d74:	68fb      	ldr	r3, [r7, #12]
20004d76:	43db      	mvns	r3, r3
20004d78:	693a      	ldr	r2, [r7, #16]
20004d7a:	4013      	ands	r3, r2
20004d7c:	613b      	str	r3, [r7, #16]
        if ((GPIO_Init->Mode & FALLING_EDGE) == FALLING_EDGE)
20004d7e:	683b      	ldr	r3, [r7, #0]
20004d80:	685b      	ldr	r3, [r3, #4]
20004d82:	f403 1300 	and.w	r3, r3, #2097152	; 0x200000
20004d86:	2b00      	cmp	r3, #0
20004d88:	d003      	beq.n	20004d92 <HAL_GPIO_Init+0x2ba>
        {
          temp |= iocurrent;
20004d8a:	693a      	ldr	r2, [r7, #16]
20004d8c:	68fb      	ldr	r3, [r7, #12]
20004d8e:	4313      	orrs	r3, r2
20004d90:	613b      	str	r3, [r7, #16]
        }
        EXTI->FTSR1 = temp;
20004d92:	4a11      	ldr	r2, [pc, #68]	; (20004dd8 <HAL_GPIO_Init+0x300>)
20004d94:	693b      	ldr	r3, [r7, #16]
20004d96:	60d3      	str	r3, [r2, #12]
      }
    }

    position++;
20004d98:	697b      	ldr	r3, [r7, #20]
20004d9a:	3301      	adds	r3, #1
20004d9c:	617b      	str	r3, [r7, #20]
  while (((GPIO_Init->Pin) >> position) != 0U)
20004d9e:	683b      	ldr	r3, [r7, #0]
20004da0:	681a      	ldr	r2, [r3, #0]
20004da2:	697b      	ldr	r3, [r7, #20]
20004da4:	fa22 f303 	lsr.w	r3, r2, r3
20004da8:	2b00      	cmp	r3, #0
20004daa:	f47f ae9d 	bne.w	20004ae8 <HAL_GPIO_Init+0x10>
  }
}
20004dae:	bf00      	nop
20004db0:	bf00      	nop
20004db2:	371c      	adds	r7, #28
20004db4:	46bd      	mov	sp, r7
20004db6:	f85d 7b04 	ldr.w	r7, [sp], #4
20004dba:	4770      	bx	lr
20004dbc:	40021000 	.word	0x40021000
20004dc0:	40010000 	.word	0x40010000
20004dc4:	48000400 	.word	0x48000400
20004dc8:	48000800 	.word	0x48000800
20004dcc:	48000c00 	.word	0x48000c00
20004dd0:	48001000 	.word	0x48001000
20004dd4:	48001400 	.word	0x48001400
20004dd8:	40010400 	.word	0x40010400

20004ddc <HAL_GPIO_DeInit>:
  * @param  GPIO_Pin specifies the port bit to be written.
  *         This parameter can be any combination of GPIO_PIN_x where x can be (0..15).
  * @retval None
  */
void HAL_GPIO_DeInit(GPIO_TypeDef  *GPIOx, uint32_t GPIO_Pin)
{
20004ddc:	b480      	push	{r7}
20004dde:	b087      	sub	sp, #28
20004de0:	af00      	add	r7, sp, #0
20004de2:	6078      	str	r0, [r7, #4]
20004de4:	6039      	str	r1, [r7, #0]
  uint32_t position = 0x00U;
20004de6:	2300      	movs	r3, #0
20004de8:	617b      	str	r3, [r7, #20]
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_INSTANCE(GPIOx));
  assert_param(IS_GPIO_PIN(GPIO_Pin));

  /* Configure the port pins */
  while ((GPIO_Pin >> position) != 0U)
20004dea:	e0bd      	b.n	20004f68 <HAL_GPIO_DeInit+0x18c>
  {
    /* Get current io position */
    iocurrent = (GPIO_Pin) & (1UL << position);
20004dec:	2201      	movs	r2, #1
20004dee:	697b      	ldr	r3, [r7, #20]
20004df0:	fa02 f303 	lsl.w	r3, r2, r3
20004df4:	683a      	ldr	r2, [r7, #0]
20004df6:	4013      	ands	r3, r2
20004df8:	613b      	str	r3, [r7, #16]

    if (iocurrent != 0x00u)
20004dfa:	693b      	ldr	r3, [r7, #16]
20004dfc:	2b00      	cmp	r3, #0
20004dfe:	f000 80b0 	beq.w	20004f62 <HAL_GPIO_DeInit+0x186>
    {
      /*------------------------- EXTI Mode Configuration --------------------*/
      /* Clear the External Interrupt or Event for the current IO */

      tmp = SYSCFG->EXTICR[position >> 2U];
20004e02:	4a60      	ldr	r2, [pc, #384]	; (20004f84 <HAL_GPIO_DeInit+0x1a8>)
20004e04:	697b      	ldr	r3, [r7, #20]
20004e06:	089b      	lsrs	r3, r3, #2
20004e08:	3302      	adds	r3, #2
20004e0a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
20004e0e:	60fb      	str	r3, [r7, #12]
      tmp &= (0x0FUL << (4U * (position & 0x03U)));
20004e10:	697b      	ldr	r3, [r7, #20]
20004e12:	f003 0303 	and.w	r3, r3, #3
20004e16:	009b      	lsls	r3, r3, #2
20004e18:	220f      	movs	r2, #15
20004e1a:	fa02 f303 	lsl.w	r3, r2, r3
20004e1e:	68fa      	ldr	r2, [r7, #12]
20004e20:	4013      	ands	r3, r2
20004e22:	60fb      	str	r3, [r7, #12]
      if (tmp == (GPIO_GET_INDEX(GPIOx) << (4U * (position & 0x03U))))
20004e24:	687b      	ldr	r3, [r7, #4]
20004e26:	f1b3 4f90 	cmp.w	r3, #1207959552	; 0x48000000
20004e2a:	d01f      	beq.n	20004e6c <HAL_GPIO_DeInit+0x90>
20004e2c:	687b      	ldr	r3, [r7, #4]
20004e2e:	4a56      	ldr	r2, [pc, #344]	; (20004f88 <HAL_GPIO_DeInit+0x1ac>)
20004e30:	4293      	cmp	r3, r2
20004e32:	d019      	beq.n	20004e68 <HAL_GPIO_DeInit+0x8c>
20004e34:	687b      	ldr	r3, [r7, #4]
20004e36:	4a55      	ldr	r2, [pc, #340]	; (20004f8c <HAL_GPIO_DeInit+0x1b0>)
20004e38:	4293      	cmp	r3, r2
20004e3a:	d013      	beq.n	20004e64 <HAL_GPIO_DeInit+0x88>
20004e3c:	687b      	ldr	r3, [r7, #4]
20004e3e:	4a54      	ldr	r2, [pc, #336]	; (20004f90 <HAL_GPIO_DeInit+0x1b4>)
20004e40:	4293      	cmp	r3, r2
20004e42:	d00d      	beq.n	20004e60 <HAL_GPIO_DeInit+0x84>
20004e44:	687b      	ldr	r3, [r7, #4]
20004e46:	4a53      	ldr	r2, [pc, #332]	; (20004f94 <HAL_GPIO_DeInit+0x1b8>)
20004e48:	4293      	cmp	r3, r2
20004e4a:	d007      	beq.n	20004e5c <HAL_GPIO_DeInit+0x80>
20004e4c:	687b      	ldr	r3, [r7, #4]
20004e4e:	4a52      	ldr	r2, [pc, #328]	; (20004f98 <HAL_GPIO_DeInit+0x1bc>)
20004e50:	4293      	cmp	r3, r2
20004e52:	d101      	bne.n	20004e58 <HAL_GPIO_DeInit+0x7c>
20004e54:	2305      	movs	r3, #5
20004e56:	e00a      	b.n	20004e6e <HAL_GPIO_DeInit+0x92>
20004e58:	2306      	movs	r3, #6
20004e5a:	e008      	b.n	20004e6e <HAL_GPIO_DeInit+0x92>
20004e5c:	2304      	movs	r3, #4
20004e5e:	e006      	b.n	20004e6e <HAL_GPIO_DeInit+0x92>
20004e60:	2303      	movs	r3, #3
20004e62:	e004      	b.n	20004e6e <HAL_GPIO_DeInit+0x92>
20004e64:	2302      	movs	r3, #2
20004e66:	e002      	b.n	20004e6e <HAL_GPIO_DeInit+0x92>
20004e68:	2301      	movs	r3, #1
20004e6a:	e000      	b.n	20004e6e <HAL_GPIO_DeInit+0x92>
20004e6c:	2300      	movs	r3, #0
20004e6e:	697a      	ldr	r2, [r7, #20]
20004e70:	f002 0203 	and.w	r2, r2, #3
20004e74:	0092      	lsls	r2, r2, #2
20004e76:	4093      	lsls	r3, r2
20004e78:	68fa      	ldr	r2, [r7, #12]
20004e7a:	429a      	cmp	r2, r3
20004e7c:	d132      	bne.n	20004ee4 <HAL_GPIO_DeInit+0x108>
      {
        /* Clear EXTI line configuration */
        EXTI->IMR1 &= ~(iocurrent);
20004e7e:	4b47      	ldr	r3, [pc, #284]	; (20004f9c <HAL_GPIO_DeInit+0x1c0>)
20004e80:	681a      	ldr	r2, [r3, #0]
20004e82:	693b      	ldr	r3, [r7, #16]
20004e84:	43db      	mvns	r3, r3
20004e86:	4945      	ldr	r1, [pc, #276]	; (20004f9c <HAL_GPIO_DeInit+0x1c0>)
20004e88:	4013      	ands	r3, r2
20004e8a:	600b      	str	r3, [r1, #0]
        EXTI->EMR1 &= ~(iocurrent);
20004e8c:	4b43      	ldr	r3, [pc, #268]	; (20004f9c <HAL_GPIO_DeInit+0x1c0>)
20004e8e:	685a      	ldr	r2, [r3, #4]
20004e90:	693b      	ldr	r3, [r7, #16]
20004e92:	43db      	mvns	r3, r3
20004e94:	4941      	ldr	r1, [pc, #260]	; (20004f9c <HAL_GPIO_DeInit+0x1c0>)
20004e96:	4013      	ands	r3, r2
20004e98:	604b      	str	r3, [r1, #4]

        /* Clear Rising Falling edge configuration */
        EXTI->RTSR1 &= ~(iocurrent);
20004e9a:	4b40      	ldr	r3, [pc, #256]	; (20004f9c <HAL_GPIO_DeInit+0x1c0>)
20004e9c:	689a      	ldr	r2, [r3, #8]
20004e9e:	693b      	ldr	r3, [r7, #16]
20004ea0:	43db      	mvns	r3, r3
20004ea2:	493e      	ldr	r1, [pc, #248]	; (20004f9c <HAL_GPIO_DeInit+0x1c0>)
20004ea4:	4013      	ands	r3, r2
20004ea6:	608b      	str	r3, [r1, #8]
        EXTI->FTSR1 &= ~(iocurrent);
20004ea8:	4b3c      	ldr	r3, [pc, #240]	; (20004f9c <HAL_GPIO_DeInit+0x1c0>)
20004eaa:	68da      	ldr	r2, [r3, #12]
20004eac:	693b      	ldr	r3, [r7, #16]
20004eae:	43db      	mvns	r3, r3
20004eb0:	493a      	ldr	r1, [pc, #232]	; (20004f9c <HAL_GPIO_DeInit+0x1c0>)
20004eb2:	4013      	ands	r3, r2
20004eb4:	60cb      	str	r3, [r1, #12]

        tmp = 0x0FUL << (4U * (position & 0x03U));
20004eb6:	697b      	ldr	r3, [r7, #20]
20004eb8:	f003 0303 	and.w	r3, r3, #3
20004ebc:	009b      	lsls	r3, r3, #2
20004ebe:	220f      	movs	r2, #15
20004ec0:	fa02 f303 	lsl.w	r3, r2, r3
20004ec4:	60fb      	str	r3, [r7, #12]
        SYSCFG->EXTICR[position >> 2U] &= ~tmp;
20004ec6:	4a2f      	ldr	r2, [pc, #188]	; (20004f84 <HAL_GPIO_DeInit+0x1a8>)
20004ec8:	697b      	ldr	r3, [r7, #20]
20004eca:	089b      	lsrs	r3, r3, #2
20004ecc:	3302      	adds	r3, #2
20004ece:	f852 1023 	ldr.w	r1, [r2, r3, lsl #2]
20004ed2:	68fb      	ldr	r3, [r7, #12]
20004ed4:	43da      	mvns	r2, r3
20004ed6:	482b      	ldr	r0, [pc, #172]	; (20004f84 <HAL_GPIO_DeInit+0x1a8>)
20004ed8:	697b      	ldr	r3, [r7, #20]
20004eda:	089b      	lsrs	r3, r3, #2
20004edc:	400a      	ands	r2, r1
20004ede:	3302      	adds	r3, #2
20004ee0:	f840 2023 	str.w	r2, [r0, r3, lsl #2]
      }

      /*------------------------- GPIO Mode Configuration --------------------*/
      /* Configure IO in Analog Mode */
      GPIOx->MODER |= (GPIO_MODER_MODE0 << (position * 2u));
20004ee4:	687b      	ldr	r3, [r7, #4]
20004ee6:	681a      	ldr	r2, [r3, #0]
20004ee8:	697b      	ldr	r3, [r7, #20]
20004eea:	005b      	lsls	r3, r3, #1
20004eec:	2103      	movs	r1, #3
20004eee:	fa01 f303 	lsl.w	r3, r1, r3
20004ef2:	431a      	orrs	r2, r3
20004ef4:	687b      	ldr	r3, [r7, #4]
20004ef6:	601a      	str	r2, [r3, #0]

      /* Configure the default Alternate Function in current IO */
      GPIOx->AFR[position >> 3u] &= ~(0xFu << ((position & 0x07u) * 4u));
20004ef8:	697b      	ldr	r3, [r7, #20]
20004efa:	08da      	lsrs	r2, r3, #3
20004efc:	687b      	ldr	r3, [r7, #4]
20004efe:	3208      	adds	r2, #8
20004f00:	f853 1022 	ldr.w	r1, [r3, r2, lsl #2]
20004f04:	697b      	ldr	r3, [r7, #20]
20004f06:	f003 0307 	and.w	r3, r3, #7
20004f0a:	009b      	lsls	r3, r3, #2
20004f0c:	220f      	movs	r2, #15
20004f0e:	fa02 f303 	lsl.w	r3, r2, r3
20004f12:	43db      	mvns	r3, r3
20004f14:	697a      	ldr	r2, [r7, #20]
20004f16:	08d2      	lsrs	r2, r2, #3
20004f18:	4019      	ands	r1, r3
20004f1a:	687b      	ldr	r3, [r7, #4]
20004f1c:	3208      	adds	r2, #8
20004f1e:	f843 1022 	str.w	r1, [r3, r2, lsl #2]

      /* Deactivate the Pull-up and Pull-down resistor for the current IO */
      GPIOx->PUPDR &= ~(GPIO_PUPDR_PUPD0 << (position * 2u));
20004f22:	687b      	ldr	r3, [r7, #4]
20004f24:	68da      	ldr	r2, [r3, #12]
20004f26:	697b      	ldr	r3, [r7, #20]
20004f28:	005b      	lsls	r3, r3, #1
20004f2a:	2103      	movs	r1, #3
20004f2c:	fa01 f303 	lsl.w	r3, r1, r3
20004f30:	43db      	mvns	r3, r3
20004f32:	401a      	ands	r2, r3
20004f34:	687b      	ldr	r3, [r7, #4]
20004f36:	60da      	str	r2, [r3, #12]

      /* Configure the default value IO Output Type */
      GPIOx->OTYPER  &= ~(GPIO_OTYPER_OT0 << position);
20004f38:	687b      	ldr	r3, [r7, #4]
20004f3a:	685a      	ldr	r2, [r3, #4]
20004f3c:	2101      	movs	r1, #1
20004f3e:	697b      	ldr	r3, [r7, #20]
20004f40:	fa01 f303 	lsl.w	r3, r1, r3
20004f44:	43db      	mvns	r3, r3
20004f46:	401a      	ands	r2, r3
20004f48:	687b      	ldr	r3, [r7, #4]
20004f4a:	605a      	str	r2, [r3, #4]

      /* Configure the default value for IO Speed */
      GPIOx->OSPEEDR &= ~(GPIO_OSPEEDR_OSPEED0 << (position * 2u));
20004f4c:	687b      	ldr	r3, [r7, #4]
20004f4e:	689a      	ldr	r2, [r3, #8]
20004f50:	697b      	ldr	r3, [r7, #20]
20004f52:	005b      	lsls	r3, r3, #1
20004f54:	2103      	movs	r1, #3
20004f56:	fa01 f303 	lsl.w	r3, r1, r3
20004f5a:	43db      	mvns	r3, r3
20004f5c:	401a      	ands	r2, r3
20004f5e:	687b      	ldr	r3, [r7, #4]
20004f60:	609a      	str	r2, [r3, #8]
    }

    position++;
20004f62:	697b      	ldr	r3, [r7, #20]
20004f64:	3301      	adds	r3, #1
20004f66:	617b      	str	r3, [r7, #20]
  while ((GPIO_Pin >> position) != 0U)
20004f68:	683a      	ldr	r2, [r7, #0]
20004f6a:	697b      	ldr	r3, [r7, #20]
20004f6c:	fa22 f303 	lsr.w	r3, r2, r3
20004f70:	2b00      	cmp	r3, #0
20004f72:	f47f af3b 	bne.w	20004dec <HAL_GPIO_DeInit+0x10>
  }
}
20004f76:	bf00      	nop
20004f78:	bf00      	nop
20004f7a:	371c      	adds	r7, #28
20004f7c:	46bd      	mov	sp, r7
20004f7e:	f85d 7b04 	ldr.w	r7, [sp], #4
20004f82:	4770      	bx	lr
20004f84:	40010000 	.word	0x40010000
20004f88:	48000400 	.word	0x48000400
20004f8c:	48000800 	.word	0x48000800
20004f90:	48000c00 	.word	0x48000c00
20004f94:	48001000 	.word	0x48001000
20004f98:	48001400 	.word	0x48001400
20004f9c:	40010400 	.word	0x40010400

20004fa0 <HAL_GPIO_ReadPin>:
  * @param  GPIO_Pin specifies the port bit to read.
  *         This parameter can be any combination of GPIO_PIN_x where x can be (0..15).
  * @retval The input port pin value.
  */
GPIO_PinState HAL_GPIO_ReadPin(GPIO_TypeDef *GPIOx, uint16_t GPIO_Pin)
{
20004fa0:	b480      	push	{r7}
20004fa2:	b085      	sub	sp, #20
20004fa4:	af00      	add	r7, sp, #0
20004fa6:	6078      	str	r0, [r7, #4]
20004fa8:	460b      	mov	r3, r1
20004faa:	807b      	strh	r3, [r7, #2]
  GPIO_PinState bitstatus;

  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));

  if ((GPIOx->IDR & GPIO_Pin) != 0x00U)
20004fac:	687b      	ldr	r3, [r7, #4]
20004fae:	691a      	ldr	r2, [r3, #16]
20004fb0:	887b      	ldrh	r3, [r7, #2]
20004fb2:	4013      	ands	r3, r2
20004fb4:	2b00      	cmp	r3, #0
20004fb6:	d002      	beq.n	20004fbe <HAL_GPIO_ReadPin+0x1e>
  {
    bitstatus = GPIO_PIN_SET;
20004fb8:	2301      	movs	r3, #1
20004fba:	73fb      	strb	r3, [r7, #15]
20004fbc:	e001      	b.n	20004fc2 <HAL_GPIO_ReadPin+0x22>
  }
  else
  {
    bitstatus = GPIO_PIN_RESET;
20004fbe:	2300      	movs	r3, #0
20004fc0:	73fb      	strb	r3, [r7, #15]
  }
  return bitstatus;
20004fc2:	7bfb      	ldrb	r3, [r7, #15]
}
20004fc4:	4618      	mov	r0, r3
20004fc6:	3714      	adds	r7, #20
20004fc8:	46bd      	mov	sp, r7
20004fca:	f85d 7b04 	ldr.w	r7, [sp], #4
20004fce:	4770      	bx	lr

20004fd0 <HAL_GPIO_WritePin>:
  *            @arg GPIO_PIN_RESET: to clear the port pin
  *            @arg GPIO_PIN_SET: to set the port pin
  * @retval None
  */
void HAL_GPIO_WritePin(GPIO_TypeDef *GPIOx, uint16_t GPIO_Pin, GPIO_PinState PinState)
{
20004fd0:	b480      	push	{r7}
20004fd2:	b083      	sub	sp, #12
20004fd4:	af00      	add	r7, sp, #0
20004fd6:	6078      	str	r0, [r7, #4]
20004fd8:	460b      	mov	r3, r1
20004fda:	807b      	strh	r3, [r7, #2]
20004fdc:	4613      	mov	r3, r2
20004fde:	707b      	strb	r3, [r7, #1]
  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));
  assert_param(IS_GPIO_PIN_ACTION(PinState));

  if (PinState != GPIO_PIN_RESET)
20004fe0:	787b      	ldrb	r3, [r7, #1]
20004fe2:	2b00      	cmp	r3, #0
20004fe4:	d003      	beq.n	20004fee <HAL_GPIO_WritePin+0x1e>
  {
    GPIOx->BSRR = (uint32_t)GPIO_Pin;
20004fe6:	887a      	ldrh	r2, [r7, #2]
20004fe8:	687b      	ldr	r3, [r7, #4]
20004fea:	619a      	str	r2, [r3, #24]
  }
  else
  {
    GPIOx->BRR = (uint32_t)GPIO_Pin;
  }
}
20004fec:	e002      	b.n	20004ff4 <HAL_GPIO_WritePin+0x24>
    GPIOx->BRR = (uint32_t)GPIO_Pin;
20004fee:	887a      	ldrh	r2, [r7, #2]
20004ff0:	687b      	ldr	r3, [r7, #4]
20004ff2:	629a      	str	r2, [r3, #40]	; 0x28
}
20004ff4:	bf00      	nop
20004ff6:	370c      	adds	r7, #12
20004ff8:	46bd      	mov	sp, r7
20004ffa:	f85d 7b04 	ldr.w	r7, [sp], #4
20004ffe:	4770      	bx	lr

20005000 <HAL_GPIO_TogglePin>:
  * @param  GPIO_Pin specifies the pin to be toggled.
  *         This parameter can be any combination of GPIO_PIN_x where x can be (0..15).
  * @retval None
  */
void HAL_GPIO_TogglePin(GPIO_TypeDef *GPIOx, uint16_t GPIO_Pin)
{
20005000:	b480      	push	{r7}
20005002:	b085      	sub	sp, #20
20005004:	af00      	add	r7, sp, #0
20005006:	6078      	str	r0, [r7, #4]
20005008:	460b      	mov	r3, r1
2000500a:	807b      	strh	r3, [r7, #2]

  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));

  /* get current Output Data Register value */
  odr = GPIOx->ODR;
2000500c:	687b      	ldr	r3, [r7, #4]
2000500e:	695b      	ldr	r3, [r3, #20]
20005010:	60fb      	str	r3, [r7, #12]

  /* Set selected pins that were at low level, and reset ones that were high */
  GPIOx->BSRR = ((odr & GPIO_Pin) << GPIO_NUMBER) | (~odr & GPIO_Pin);
20005012:	887a      	ldrh	r2, [r7, #2]
20005014:	68fb      	ldr	r3, [r7, #12]
20005016:	4013      	ands	r3, r2
20005018:	041a      	lsls	r2, r3, #16
2000501a:	68fb      	ldr	r3, [r7, #12]
2000501c:	43d9      	mvns	r1, r3
2000501e:	887b      	ldrh	r3, [r7, #2]
20005020:	400b      	ands	r3, r1
20005022:	431a      	orrs	r2, r3
20005024:	687b      	ldr	r3, [r7, #4]
20005026:	619a      	str	r2, [r3, #24]
}
20005028:	bf00      	nop
2000502a:	3714      	adds	r7, #20
2000502c:	46bd      	mov	sp, r7
2000502e:	f85d 7b04 	ldr.w	r7, [sp], #4
20005032:	4770      	bx	lr

20005034 <HAL_GPIO_LockPin>:
  * @param  GPIO_Pin specifies the port bits to be locked.
  *         This parameter can be any combination of GPIO_Pin_x where x can be (0..15).
  * @retval None
  */
HAL_StatusTypeDef HAL_GPIO_LockPin(GPIO_TypeDef *GPIOx, uint16_t GPIO_Pin)
{
20005034:	b480      	push	{r7}
20005036:	b085      	sub	sp, #20
20005038:	af00      	add	r7, sp, #0
2000503a:	6078      	str	r0, [r7, #4]
2000503c:	460b      	mov	r3, r1
2000503e:	807b      	strh	r3, [r7, #2]
  __IO uint32_t tmp = GPIO_LCKR_LCKK;
20005040:	f44f 3380 	mov.w	r3, #65536	; 0x10000
20005044:	60fb      	str	r3, [r7, #12]
  /* Check the parameters */
  assert_param(IS_GPIO_LOCK_INSTANCE(GPIOx));
  assert_param(IS_GPIO_PIN(GPIO_Pin));

  /* Apply lock key write sequence */
  tmp |= GPIO_Pin;
20005046:	887a      	ldrh	r2, [r7, #2]
20005048:	68fb      	ldr	r3, [r7, #12]
2000504a:	4313      	orrs	r3, r2
2000504c:	60fb      	str	r3, [r7, #12]
  /* Set LCKx bit(s): LCKK='1' + LCK[15-0] */
  GPIOx->LCKR = tmp;
2000504e:	68fa      	ldr	r2, [r7, #12]
20005050:	687b      	ldr	r3, [r7, #4]
20005052:	61da      	str	r2, [r3, #28]
  /* Reset LCKx bit(s): LCKK='0' + LCK[15-0] */
  GPIOx->LCKR = GPIO_Pin;
20005054:	887a      	ldrh	r2, [r7, #2]
20005056:	687b      	ldr	r3, [r7, #4]
20005058:	61da      	str	r2, [r3, #28]
  /* Set LCKx bit(s): LCKK='1' + LCK[15-0] */
  GPIOx->LCKR = tmp;
2000505a:	68fa      	ldr	r2, [r7, #12]
2000505c:	687b      	ldr	r3, [r7, #4]
2000505e:	61da      	str	r2, [r3, #28]
  /* Read LCKK register. This read is mandatory to complete key lock sequence */
  tmp = GPIOx->LCKR;
20005060:	687b      	ldr	r3, [r7, #4]
20005062:	69db      	ldr	r3, [r3, #28]
20005064:	60fb      	str	r3, [r7, #12]

  /* read again in order to confirm lock is active */
  if ((GPIOx->LCKR & GPIO_LCKR_LCKK) != 0x00u)
20005066:	687b      	ldr	r3, [r7, #4]
20005068:	69db      	ldr	r3, [r3, #28]
2000506a:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
2000506e:	2b00      	cmp	r3, #0
20005070:	d001      	beq.n	20005076 <HAL_GPIO_LockPin+0x42>
  {
    return HAL_OK;
20005072:	2300      	movs	r3, #0
20005074:	e000      	b.n	20005078 <HAL_GPIO_LockPin+0x44>
  }
  else
  {
    return HAL_ERROR;
20005076:	2301      	movs	r3, #1
  }
}
20005078:	4618      	mov	r0, r3
2000507a:	3714      	adds	r7, #20
2000507c:	46bd      	mov	sp, r7
2000507e:	f85d 7b04 	ldr.w	r7, [sp], #4
20005082:	4770      	bx	lr

20005084 <HAL_GPIO_EXTI_IRQHandler>:
  * @brief  Handle EXTI interrupt request.
  * @param  GPIO_Pin Specifies the port pin connected to corresponding EXTI line.
  * @retval None
  */
void HAL_GPIO_EXTI_IRQHandler(uint16_t GPIO_Pin)
{
20005084:	b580      	push	{r7, lr}
20005086:	b082      	sub	sp, #8
20005088:	af00      	add	r7, sp, #0
2000508a:	4603      	mov	r3, r0
2000508c:	80fb      	strh	r3, [r7, #6]
  /* EXTI line interrupt detected */
  if (__HAL_GPIO_EXTI_GET_IT(GPIO_Pin) != 0x00u)
2000508e:	4b08      	ldr	r3, [pc, #32]	; (200050b0 <HAL_GPIO_EXTI_IRQHandler+0x2c>)
20005090:	695a      	ldr	r2, [r3, #20]
20005092:	88fb      	ldrh	r3, [r7, #6]
20005094:	4013      	ands	r3, r2
20005096:	2b00      	cmp	r3, #0
20005098:	d006      	beq.n	200050a8 <HAL_GPIO_EXTI_IRQHandler+0x24>
  {
    __HAL_GPIO_EXTI_CLEAR_IT(GPIO_Pin);
2000509a:	4a05      	ldr	r2, [pc, #20]	; (200050b0 <HAL_GPIO_EXTI_IRQHandler+0x2c>)
2000509c:	88fb      	ldrh	r3, [r7, #6]
2000509e:	6153      	str	r3, [r2, #20]
    HAL_GPIO_EXTI_Callback(GPIO_Pin);
200050a0:	88fb      	ldrh	r3, [r7, #6]
200050a2:	4618      	mov	r0, r3
200050a4:	f000 f806 	bl	200050b4 <HAL_GPIO_EXTI_Callback>
  }
}
200050a8:	bf00      	nop
200050aa:	3708      	adds	r7, #8
200050ac:	46bd      	mov	sp, r7
200050ae:	bd80      	pop	{r7, pc}
200050b0:	40010400 	.word	0x40010400

200050b4 <HAL_GPIO_EXTI_Callback>:
  * @brief  EXTI line detection callback.
  * @param  GPIO_Pin: Specifies the port pin connected to corresponding EXTI line.
  * @retval None
  */
__weak void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin)
{
200050b4:	b480      	push	{r7}
200050b6:	b083      	sub	sp, #12
200050b8:	af00      	add	r7, sp, #0
200050ba:	4603      	mov	r3, r0
200050bc:	80fb      	strh	r3, [r7, #6]
  UNUSED(GPIO_Pin);

  /* NOTE: This function should not be modified, when the callback is needed,
           the HAL_GPIO_EXTI_Callback could be implemented in the user file
   */
}
200050be:	bf00      	nop
200050c0:	370c      	adds	r7, #12
200050c2:	46bd      	mov	sp, r7
200050c4:	f85d 7b04 	ldr.w	r7, [sp], #4
200050c8:	4770      	bx	lr
	...

200050cc <HAL_PWR_DeInit>:
/**
  * @brief Deinitialize the HAL PWR peripheral registers to their default reset values.
  * @retval None
  */
void HAL_PWR_DeInit(void)
{
200050cc:	b480      	push	{r7}
200050ce:	af00      	add	r7, sp, #0
  __HAL_RCC_PWR_FORCE_RESET();
200050d0:	4b08      	ldr	r3, [pc, #32]	; (200050f4 <HAL_PWR_DeInit+0x28>)
200050d2:	6b9b      	ldr	r3, [r3, #56]	; 0x38
200050d4:	4a07      	ldr	r2, [pc, #28]	; (200050f4 <HAL_PWR_DeInit+0x28>)
200050d6:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
200050da:	6393      	str	r3, [r2, #56]	; 0x38
  __HAL_RCC_PWR_RELEASE_RESET();
200050dc:	4b05      	ldr	r3, [pc, #20]	; (200050f4 <HAL_PWR_DeInit+0x28>)
200050de:	6b9b      	ldr	r3, [r3, #56]	; 0x38
200050e0:	4a04      	ldr	r2, [pc, #16]	; (200050f4 <HAL_PWR_DeInit+0x28>)
200050e2:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
200050e6:	6393      	str	r3, [r2, #56]	; 0x38
}
200050e8:	bf00      	nop
200050ea:	46bd      	mov	sp, r7
200050ec:	f85d 7b04 	ldr.w	r7, [sp], #4
200050f0:	4770      	bx	lr
200050f2:	bf00      	nop
200050f4:	40021000 	.word	0x40021000

200050f8 <HAL_PWR_EnableBkUpAccess>:
  * @note  LSEON bit that switches on and off the LSE crystal belongs as well to the
  *        back-up domain.
  * @retval None
  */
void HAL_PWR_EnableBkUpAccess(void)
{
200050f8:	b480      	push	{r7}
200050fa:	af00      	add	r7, sp, #0
  SET_BIT(PWR->CR1, PWR_CR1_DBP);
200050fc:	4b05      	ldr	r3, [pc, #20]	; (20005114 <HAL_PWR_EnableBkUpAccess+0x1c>)
200050fe:	681b      	ldr	r3, [r3, #0]
20005100:	4a04      	ldr	r2, [pc, #16]	; (20005114 <HAL_PWR_EnableBkUpAccess+0x1c>)
20005102:	f443 7380 	orr.w	r3, r3, #256	; 0x100
20005106:	6013      	str	r3, [r2, #0]
}
20005108:	bf00      	nop
2000510a:	46bd      	mov	sp, r7
2000510c:	f85d 7b04 	ldr.w	r7, [sp], #4
20005110:	4770      	bx	lr
20005112:	bf00      	nop
20005114:	40007000 	.word	0x40007000

20005118 <HAL_PWR_DisableBkUpAccess>:
  * @brief Disable access to the backup domain
  *        (RTC registers, RTC backup data registers).
  * @retval None
  */
void HAL_PWR_DisableBkUpAccess(void)
{
20005118:	b480      	push	{r7}
2000511a:	af00      	add	r7, sp, #0
  CLEAR_BIT(PWR->CR1, PWR_CR1_DBP);
2000511c:	4b05      	ldr	r3, [pc, #20]	; (20005134 <HAL_PWR_DisableBkUpAccess+0x1c>)
2000511e:	681b      	ldr	r3, [r3, #0]
20005120:	4a04      	ldr	r2, [pc, #16]	; (20005134 <HAL_PWR_DisableBkUpAccess+0x1c>)
20005122:	f423 7380 	bic.w	r3, r3, #256	; 0x100
20005126:	6013      	str	r3, [r2, #0]
}
20005128:	bf00      	nop
2000512a:	46bd      	mov	sp, r7
2000512c:	f85d 7b04 	ldr.w	r7, [sp], #4
20005130:	4770      	bx	lr
20005132:	bf00      	nop
20005134:	40007000 	.word	0x40007000

20005138 <HAL_PWR_ConfigPVD>:
  *         more details about the voltage thresholds corresponding to each
  *         detection level.
  * @retval None
  */
HAL_StatusTypeDef HAL_PWR_ConfigPVD(PWR_PVDTypeDef *sConfigPVD)
{
20005138:	b480      	push	{r7}
2000513a:	b083      	sub	sp, #12
2000513c:	af00      	add	r7, sp, #0
2000513e:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_PWR_PVD_LEVEL(sConfigPVD->PVDLevel));
  assert_param(IS_PWR_PVD_MODE(sConfigPVD->Mode));

  /* Set PLS bits according to PVDLevel value */
  MODIFY_REG(PWR->CR2, PWR_CR2_PLS, sConfigPVD->PVDLevel);
20005140:	4b2b      	ldr	r3, [pc, #172]	; (200051f0 <HAL_PWR_ConfigPVD+0xb8>)
20005142:	685b      	ldr	r3, [r3, #4]
20005144:	f023 020e 	bic.w	r2, r3, #14
20005148:	687b      	ldr	r3, [r7, #4]
2000514a:	681b      	ldr	r3, [r3, #0]
2000514c:	4928      	ldr	r1, [pc, #160]	; (200051f0 <HAL_PWR_ConfigPVD+0xb8>)
2000514e:	4313      	orrs	r3, r2
20005150:	604b      	str	r3, [r1, #4]

  /* Clear any previous config. Keep it clear if no event or IT mode is selected */
  __HAL_PWR_PVD_EXTI_DISABLE_EVENT();
20005152:	4b28      	ldr	r3, [pc, #160]	; (200051f4 <HAL_PWR_ConfigPVD+0xbc>)
20005154:	685b      	ldr	r3, [r3, #4]
20005156:	4a27      	ldr	r2, [pc, #156]	; (200051f4 <HAL_PWR_ConfigPVD+0xbc>)
20005158:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
2000515c:	6053      	str	r3, [r2, #4]
  __HAL_PWR_PVD_EXTI_DISABLE_IT();
2000515e:	4b25      	ldr	r3, [pc, #148]	; (200051f4 <HAL_PWR_ConfigPVD+0xbc>)
20005160:	681b      	ldr	r3, [r3, #0]
20005162:	4a24      	ldr	r2, [pc, #144]	; (200051f4 <HAL_PWR_ConfigPVD+0xbc>)
20005164:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
20005168:	6013      	str	r3, [r2, #0]
  __HAL_PWR_PVD_EXTI_DISABLE_FALLING_EDGE();
2000516a:	4b22      	ldr	r3, [pc, #136]	; (200051f4 <HAL_PWR_ConfigPVD+0xbc>)
2000516c:	68db      	ldr	r3, [r3, #12]
2000516e:	4a21      	ldr	r2, [pc, #132]	; (200051f4 <HAL_PWR_ConfigPVD+0xbc>)
20005170:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
20005174:	60d3      	str	r3, [r2, #12]
  __HAL_PWR_PVD_EXTI_DISABLE_RISING_EDGE();
20005176:	4b1f      	ldr	r3, [pc, #124]	; (200051f4 <HAL_PWR_ConfigPVD+0xbc>)
20005178:	689b      	ldr	r3, [r3, #8]
2000517a:	4a1e      	ldr	r2, [pc, #120]	; (200051f4 <HAL_PWR_ConfigPVD+0xbc>)
2000517c:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
20005180:	6093      	str	r3, [r2, #8]

  /* Configure interrupt mode */
  if((sConfigPVD->Mode & PVD_MODE_IT) == PVD_MODE_IT)
20005182:	687b      	ldr	r3, [r7, #4]
20005184:	685b      	ldr	r3, [r3, #4]
20005186:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
2000518a:	2b00      	cmp	r3, #0
2000518c:	d005      	beq.n	2000519a <HAL_PWR_ConfigPVD+0x62>
  {
    __HAL_PWR_PVD_EXTI_ENABLE_IT();
2000518e:	4b19      	ldr	r3, [pc, #100]	; (200051f4 <HAL_PWR_ConfigPVD+0xbc>)
20005190:	681b      	ldr	r3, [r3, #0]
20005192:	4a18      	ldr	r2, [pc, #96]	; (200051f4 <HAL_PWR_ConfigPVD+0xbc>)
20005194:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
20005198:	6013      	str	r3, [r2, #0]
  }

  /* Configure event mode */
  if((sConfigPVD->Mode & PVD_MODE_EVT) == PVD_MODE_EVT)
2000519a:	687b      	ldr	r3, [r7, #4]
2000519c:	685b      	ldr	r3, [r3, #4]
2000519e:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
200051a2:	2b00      	cmp	r3, #0
200051a4:	d005      	beq.n	200051b2 <HAL_PWR_ConfigPVD+0x7a>
  {
    __HAL_PWR_PVD_EXTI_ENABLE_EVENT();
200051a6:	4b13      	ldr	r3, [pc, #76]	; (200051f4 <HAL_PWR_ConfigPVD+0xbc>)
200051a8:	685b      	ldr	r3, [r3, #4]
200051aa:	4a12      	ldr	r2, [pc, #72]	; (200051f4 <HAL_PWR_ConfigPVD+0xbc>)
200051ac:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
200051b0:	6053      	str	r3, [r2, #4]
  }

  /* Configure the edge */
  if((sConfigPVD->Mode & PVD_RISING_EDGE) == PVD_RISING_EDGE)
200051b2:	687b      	ldr	r3, [r7, #4]
200051b4:	685b      	ldr	r3, [r3, #4]
200051b6:	f003 0301 	and.w	r3, r3, #1
200051ba:	2b00      	cmp	r3, #0
200051bc:	d005      	beq.n	200051ca <HAL_PWR_ConfigPVD+0x92>
  {
    __HAL_PWR_PVD_EXTI_ENABLE_RISING_EDGE();
200051be:	4b0d      	ldr	r3, [pc, #52]	; (200051f4 <HAL_PWR_ConfigPVD+0xbc>)
200051c0:	689b      	ldr	r3, [r3, #8]
200051c2:	4a0c      	ldr	r2, [pc, #48]	; (200051f4 <HAL_PWR_ConfigPVD+0xbc>)
200051c4:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
200051c8:	6093      	str	r3, [r2, #8]
  }

  if((sConfigPVD->Mode & PVD_FALLING_EDGE) == PVD_FALLING_EDGE)
200051ca:	687b      	ldr	r3, [r7, #4]
200051cc:	685b      	ldr	r3, [r3, #4]
200051ce:	f003 0302 	and.w	r3, r3, #2
200051d2:	2b00      	cmp	r3, #0
200051d4:	d005      	beq.n	200051e2 <HAL_PWR_ConfigPVD+0xaa>
  {
    __HAL_PWR_PVD_EXTI_ENABLE_FALLING_EDGE();
200051d6:	4b07      	ldr	r3, [pc, #28]	; (200051f4 <HAL_PWR_ConfigPVD+0xbc>)
200051d8:	68db      	ldr	r3, [r3, #12]
200051da:	4a06      	ldr	r2, [pc, #24]	; (200051f4 <HAL_PWR_ConfigPVD+0xbc>)
200051dc:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
200051e0:	60d3      	str	r3, [r2, #12]
  }

  return HAL_OK;
200051e2:	2300      	movs	r3, #0
}
200051e4:	4618      	mov	r0, r3
200051e6:	370c      	adds	r7, #12
200051e8:	46bd      	mov	sp, r7
200051ea:	f85d 7b04 	ldr.w	r7, [sp], #4
200051ee:	4770      	bx	lr
200051f0:	40007000 	.word	0x40007000
200051f4:	40010400 	.word	0x40010400

200051f8 <HAL_PWR_EnablePVD>:
/**
  * @brief Enable the Power Voltage Detector (PVD).
  * @retval None
  */
void HAL_PWR_EnablePVD(void)
{
200051f8:	b480      	push	{r7}
200051fa:	af00      	add	r7, sp, #0
  SET_BIT(PWR->CR2, PWR_CR2_PVDE);
200051fc:	4b05      	ldr	r3, [pc, #20]	; (20005214 <HAL_PWR_EnablePVD+0x1c>)
200051fe:	685b      	ldr	r3, [r3, #4]
20005200:	4a04      	ldr	r2, [pc, #16]	; (20005214 <HAL_PWR_EnablePVD+0x1c>)
20005202:	f043 0301 	orr.w	r3, r3, #1
20005206:	6053      	str	r3, [r2, #4]
}
20005208:	bf00      	nop
2000520a:	46bd      	mov	sp, r7
2000520c:	f85d 7b04 	ldr.w	r7, [sp], #4
20005210:	4770      	bx	lr
20005212:	bf00      	nop
20005214:	40007000 	.word	0x40007000

20005218 <HAL_PWR_DisablePVD>:
/**
  * @brief Disable the Power Voltage Detector (PVD).
  * @retval None
  */
void HAL_PWR_DisablePVD(void)
{
20005218:	b480      	push	{r7}
2000521a:	af00      	add	r7, sp, #0
  CLEAR_BIT(PWR->CR2, PWR_CR2_PVDE);
2000521c:	4b05      	ldr	r3, [pc, #20]	; (20005234 <HAL_PWR_DisablePVD+0x1c>)
2000521e:	685b      	ldr	r3, [r3, #4]
20005220:	4a04      	ldr	r2, [pc, #16]	; (20005234 <HAL_PWR_DisablePVD+0x1c>)
20005222:	f023 0301 	bic.w	r3, r3, #1
20005226:	6053      	str	r3, [r2, #4]
}
20005228:	bf00      	nop
2000522a:	46bd      	mov	sp, r7
2000522c:	f85d 7b04 	ldr.w	r7, [sp], #4
20005230:	4770      	bx	lr
20005232:	bf00      	nop
20005234:	40007000 	.word	0x40007000

20005238 <HAL_PWR_EnableWakeUpPin>:
  *           @arg @ref PWR_WAKEUP_PIN5_HIGH or PWR_WAKEUP_PIN5_LOW
  * @note  PWR_WAKEUP_PINx and PWR_WAKEUP_PINx_HIGH are equivalent.
  * @retval None
  */
void HAL_PWR_EnableWakeUpPin(uint32_t WakeUpPinPolarity)
{
20005238:	b480      	push	{r7}
2000523a:	b083      	sub	sp, #12
2000523c:	af00      	add	r7, sp, #0
2000523e:	6078      	str	r0, [r7, #4]
  assert_param(IS_PWR_WAKEUP_PIN(WakeUpPinPolarity));

  /* Specifies the Wake-Up pin polarity for the event detection
    (rising or falling edge) */
  MODIFY_REG(PWR->CR4, (PWR_CR3_EWUP & WakeUpPinPolarity), (WakeUpPinPolarity >> PWR_WUP_POLARITY_SHIFT));
20005240:	4b0c      	ldr	r3, [pc, #48]	; (20005274 <HAL_PWR_EnableWakeUpPin+0x3c>)
20005242:	68da      	ldr	r2, [r3, #12]
20005244:	687b      	ldr	r3, [r7, #4]
20005246:	f003 031f 	and.w	r3, r3, #31
2000524a:	43db      	mvns	r3, r3
2000524c:	401a      	ands	r2, r3
2000524e:	687b      	ldr	r3, [r7, #4]
20005250:	095b      	lsrs	r3, r3, #5
20005252:	4908      	ldr	r1, [pc, #32]	; (20005274 <HAL_PWR_EnableWakeUpPin+0x3c>)
20005254:	4313      	orrs	r3, r2
20005256:	60cb      	str	r3, [r1, #12]

  /* Enable wake-up pin */
  SET_BIT(PWR->CR3, (PWR_CR3_EWUP & WakeUpPinPolarity));
20005258:	4b06      	ldr	r3, [pc, #24]	; (20005274 <HAL_PWR_EnableWakeUpPin+0x3c>)
2000525a:	689a      	ldr	r2, [r3, #8]
2000525c:	687b      	ldr	r3, [r7, #4]
2000525e:	f003 031f 	and.w	r3, r3, #31
20005262:	4904      	ldr	r1, [pc, #16]	; (20005274 <HAL_PWR_EnableWakeUpPin+0x3c>)
20005264:	4313      	orrs	r3, r2
20005266:	608b      	str	r3, [r1, #8]


}
20005268:	bf00      	nop
2000526a:	370c      	adds	r7, #12
2000526c:	46bd      	mov	sp, r7
2000526e:	f85d 7b04 	ldr.w	r7, [sp], #4
20005272:	4770      	bx	lr
20005274:	40007000 	.word	0x40007000

20005278 <HAL_PWR_DisableWakeUpPin>:
  *         This parameter can be one of the following values:
  *           @arg @ref PWR_WAKEUP_PIN1, PWR_WAKEUP_PIN2, PWR_WAKEUP_PIN3, PWR_WAKEUP_PIN4, PWR_WAKEUP_PIN5
  * @retval None
  */
void HAL_PWR_DisableWakeUpPin(uint32_t WakeUpPinx)
{
20005278:	b480      	push	{r7}
2000527a:	b083      	sub	sp, #12
2000527c:	af00      	add	r7, sp, #0
2000527e:	6078      	str	r0, [r7, #4]
  assert_param(IS_PWR_WAKEUP_PIN(WakeUpPinx));

  CLEAR_BIT(PWR->CR3, (PWR_CR3_EWUP & WakeUpPinx));
20005280:	4b07      	ldr	r3, [pc, #28]	; (200052a0 <HAL_PWR_DisableWakeUpPin+0x28>)
20005282:	689a      	ldr	r2, [r3, #8]
20005284:	687b      	ldr	r3, [r7, #4]
20005286:	f003 031f 	and.w	r3, r3, #31
2000528a:	43db      	mvns	r3, r3
2000528c:	4904      	ldr	r1, [pc, #16]	; (200052a0 <HAL_PWR_DisableWakeUpPin+0x28>)
2000528e:	4013      	ands	r3, r2
20005290:	608b      	str	r3, [r1, #8]
}
20005292:	bf00      	nop
20005294:	370c      	adds	r7, #12
20005296:	46bd      	mov	sp, r7
20005298:	f85d 7b04 	ldr.w	r7, [sp], #4
2000529c:	4770      	bx	lr
2000529e:	bf00      	nop
200052a0:	40007000 	.word	0x40007000

200052a4 <HAL_PWR_EnterSLEEPMode>:
  * @note  When WFI entry is used, tick interrupt have to be disabled if not desired as
  *        the interrupt wake up source.
  * @retval None
  */
void HAL_PWR_EnterSLEEPMode(uint32_t Regulator, uint8_t SLEEPEntry)
{
200052a4:	b580      	push	{r7, lr}
200052a6:	b082      	sub	sp, #8
200052a8:	af00      	add	r7, sp, #0
200052aa:	6078      	str	r0, [r7, #4]
200052ac:	460b      	mov	r3, r1
200052ae:	70fb      	strb	r3, [r7, #3]
  /* Check the parameters */
  assert_param(IS_PWR_REGULATOR(Regulator));
  assert_param(IS_PWR_SLEEP_ENTRY(SLEEPEntry));

  /* Set Regulator parameter */
  if (Regulator == PWR_MAINREGULATOR_ON)
200052b0:	687b      	ldr	r3, [r7, #4]
200052b2:	2b00      	cmp	r3, #0
200052b4:	d109      	bne.n	200052ca <HAL_PWR_EnterSLEEPMode+0x26>
  {
    /* If in low-power run mode at this point, exit it */
    if (HAL_IS_BIT_SET(PWR->SR2, PWR_SR2_REGLPF))
200052b6:	4b12      	ldr	r3, [pc, #72]	; (20005300 <HAL_PWR_EnterSLEEPMode+0x5c>)
200052b8:	695b      	ldr	r3, [r3, #20]
200052ba:	f403 7300 	and.w	r3, r3, #512	; 0x200
200052be:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
200052c2:	d10b      	bne.n	200052dc <HAL_PWR_EnterSLEEPMode+0x38>
    {
      (void)HAL_PWREx_DisableLowPowerRunMode();
200052c4:	f000 fdc4 	bl	20005e50 <HAL_PWREx_DisableLowPowerRunMode>
200052c8:	e008      	b.n	200052dc <HAL_PWR_EnterSLEEPMode+0x38>
  }
  else
  {
    /* If in run mode, first move to low-power run mode.
       The system clock frequency must be below 2 MHz at this point. */
    if (HAL_IS_BIT_SET(PWR->SR2, PWR_SR2_REGLPF) == 0U)
200052ca:	4b0d      	ldr	r3, [pc, #52]	; (20005300 <HAL_PWR_EnterSLEEPMode+0x5c>)
200052cc:	695b      	ldr	r3, [r3, #20]
200052ce:	f403 7300 	and.w	r3, r3, #512	; 0x200
200052d2:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
200052d6:	d001      	beq.n	200052dc <HAL_PWR_EnterSLEEPMode+0x38>
    {
      HAL_PWREx_EnableLowPowerRunMode();
200052d8:	f000 fdaa 	bl	20005e30 <HAL_PWREx_EnableLowPowerRunMode>
    }
  }

  /* Clear SLEEPDEEP bit of Cortex System Control Register */
  CLEAR_BIT(SCB->SCR, ((uint32_t)SCB_SCR_SLEEPDEEP_Msk));
200052dc:	4b09      	ldr	r3, [pc, #36]	; (20005304 <HAL_PWR_EnterSLEEPMode+0x60>)
200052de:	691b      	ldr	r3, [r3, #16]
200052e0:	4a08      	ldr	r2, [pc, #32]	; (20005304 <HAL_PWR_EnterSLEEPMode+0x60>)
200052e2:	f023 0304 	bic.w	r3, r3, #4
200052e6:	6113      	str	r3, [r2, #16]

  /* Select SLEEP mode entry -------------------------------------------------*/
  if(SLEEPEntry == PWR_SLEEPENTRY_WFI)
200052e8:	78fb      	ldrb	r3, [r7, #3]
200052ea:	2b01      	cmp	r3, #1
200052ec:	d101      	bne.n	200052f2 <HAL_PWR_EnterSLEEPMode+0x4e>
  {
    /* Request Wait For Interrupt */
    __WFI();
200052ee:	bf30      	wfi
    __SEV();
    __WFE();
    __WFE();
  }

}
200052f0:	e002      	b.n	200052f8 <HAL_PWR_EnterSLEEPMode+0x54>
    __SEV();
200052f2:	bf40      	sev
    __WFE();
200052f4:	bf20      	wfe
    __WFE();
200052f6:	bf20      	wfe
}
200052f8:	bf00      	nop
200052fa:	3708      	adds	r7, #8
200052fc:	46bd      	mov	sp, r7
200052fe:	bd80      	pop	{r7, pc}
20005300:	40007000 	.word	0x40007000
20005304:	e000ed00 	.word	0xe000ed00

20005308 <HAL_PWR_EnterSTOPMode>:
  *            @arg @ref PWR_STOPENTRY_WFI  Enter Stop 0 or Stop 1 mode with WFI instruction.
  *            @arg @ref PWR_STOPENTRY_WFE  Enter Stop 0 or Stop 1 mode with WFE instruction.
  * @retval None
  */
void HAL_PWR_EnterSTOPMode(uint32_t Regulator, uint8_t STOPEntry)
{
20005308:	b580      	push	{r7, lr}
2000530a:	b082      	sub	sp, #8
2000530c:	af00      	add	r7, sp, #0
2000530e:	6078      	str	r0, [r7, #4]
20005310:	460b      	mov	r3, r1
20005312:	70fb      	strb	r3, [r7, #3]
  /* Check the parameters */
  assert_param(IS_PWR_REGULATOR(Regulator));

  if(Regulator == PWR_LOWPOWERREGULATOR_ON)
20005314:	687b      	ldr	r3, [r7, #4]
20005316:	f5b3 4f80 	cmp.w	r3, #16384	; 0x4000
2000531a:	d104      	bne.n	20005326 <HAL_PWR_EnterSTOPMode+0x1e>
  {
    HAL_PWREx_EnterSTOP1Mode(STOPEntry);
2000531c:	78fb      	ldrb	r3, [r7, #3]
2000531e:	4618      	mov	r0, r3
20005320:	f000 fdf8 	bl	20005f14 <HAL_PWREx_EnterSTOP1Mode>
  }
  else
  {
    HAL_PWREx_EnterSTOP0Mode(STOPEntry);
  }
}
20005324:	e003      	b.n	2000532e <HAL_PWR_EnterSTOPMode+0x26>
    HAL_PWREx_EnterSTOP0Mode(STOPEntry);
20005326:	78fb      	ldrb	r3, [r7, #3]
20005328:	4618      	mov	r0, r3
2000532a:	f000 fdc9 	bl	20005ec0 <HAL_PWREx_EnterSTOP0Mode>
}
2000532e:	bf00      	nop
20005330:	3708      	adds	r7, #8
20005332:	46bd      	mov	sp, r7
20005334:	bd80      	pop	{r7, pc}
	...

20005338 <HAL_PWR_EnterSTANDBYMode>:
  *        These states are effective in Standby mode only if APC bit is set through
  *        HAL_PWREx_EnablePullUpPullDownConfig() API.
  * @retval None
  */
void HAL_PWR_EnterSTANDBYMode(void)
{
20005338:	b480      	push	{r7}
2000533a:	af00      	add	r7, sp, #0
  /* Set Stand-by mode */
  MODIFY_REG(PWR->CR1, PWR_CR1_LPMS, PWR_CR1_LPMS_STANDBY);
2000533c:	4b09      	ldr	r3, [pc, #36]	; (20005364 <HAL_PWR_EnterSTANDBYMode+0x2c>)
2000533e:	681b      	ldr	r3, [r3, #0]
20005340:	f023 0307 	bic.w	r3, r3, #7
20005344:	4a07      	ldr	r2, [pc, #28]	; (20005364 <HAL_PWR_EnterSTANDBYMode+0x2c>)
20005346:	f043 0303 	orr.w	r3, r3, #3
2000534a:	6013      	str	r3, [r2, #0]

  /* Set SLEEPDEEP bit of Cortex System Control Register */
  SET_BIT(SCB->SCR, ((uint32_t)SCB_SCR_SLEEPDEEP_Msk));
2000534c:	4b06      	ldr	r3, [pc, #24]	; (20005368 <HAL_PWR_EnterSTANDBYMode+0x30>)
2000534e:	691b      	ldr	r3, [r3, #16]
20005350:	4a05      	ldr	r2, [pc, #20]	; (20005368 <HAL_PWR_EnterSTANDBYMode+0x30>)
20005352:	f043 0304 	orr.w	r3, r3, #4
20005356:	6113      	str	r3, [r2, #16]
/* This option is used to ensure that store operations are completed */
#if defined ( __CC_ARM)
  __force_stores();
#endif
  /* Request Wait For Interrupt */
  __WFI();
20005358:	bf30      	wfi
}
2000535a:	bf00      	nop
2000535c:	46bd      	mov	sp, r7
2000535e:	f85d 7b04 	ldr.w	r7, [sp], #4
20005362:	4770      	bx	lr
20005364:	40007000 	.word	0x40007000
20005368:	e000ed00 	.word	0xe000ed00

2000536c <HAL_PWR_EnableSleepOnExit>:
  *       Setting this bit is useful when the processor is expected to run only on
  *       interruptions handling.
  * @retval None
  */
void HAL_PWR_EnableSleepOnExit(void)
{
2000536c:	b480      	push	{r7}
2000536e:	af00      	add	r7, sp, #0
  /* Set SLEEPONEXIT bit of Cortex System Control Register */
  SET_BIT(SCB->SCR, ((uint32_t)SCB_SCR_SLEEPONEXIT_Msk));
20005370:	4b05      	ldr	r3, [pc, #20]	; (20005388 <HAL_PWR_EnableSleepOnExit+0x1c>)
20005372:	691b      	ldr	r3, [r3, #16]
20005374:	4a04      	ldr	r2, [pc, #16]	; (20005388 <HAL_PWR_EnableSleepOnExit+0x1c>)
20005376:	f043 0302 	orr.w	r3, r3, #2
2000537a:	6113      	str	r3, [r2, #16]
}
2000537c:	bf00      	nop
2000537e:	46bd      	mov	sp, r7
20005380:	f85d 7b04 	ldr.w	r7, [sp], #4
20005384:	4770      	bx	lr
20005386:	bf00      	nop
20005388:	e000ed00 	.word	0xe000ed00

2000538c <HAL_PWR_DisableSleepOnExit>:
  * @note Clear SLEEPONEXIT bit of SCR register. When this bit is set, the processor
  *       re-enters SLEEP mode when an interruption handling is over.
  * @retval None
  */
void HAL_PWR_DisableSleepOnExit(void)
{
2000538c:	b480      	push	{r7}
2000538e:	af00      	add	r7, sp, #0
  /* Clear SLEEPONEXIT bit of Cortex System Control Register */
  CLEAR_BIT(SCB->SCR, ((uint32_t)SCB_SCR_SLEEPONEXIT_Msk));
20005390:	4b05      	ldr	r3, [pc, #20]	; (200053a8 <HAL_PWR_DisableSleepOnExit+0x1c>)
20005392:	691b      	ldr	r3, [r3, #16]
20005394:	4a04      	ldr	r2, [pc, #16]	; (200053a8 <HAL_PWR_DisableSleepOnExit+0x1c>)
20005396:	f023 0302 	bic.w	r3, r3, #2
2000539a:	6113      	str	r3, [r2, #16]
}
2000539c:	bf00      	nop
2000539e:	46bd      	mov	sp, r7
200053a0:	f85d 7b04 	ldr.w	r7, [sp], #4
200053a4:	4770      	bx	lr
200053a6:	bf00      	nop
200053a8:	e000ed00 	.word	0xe000ed00

200053ac <HAL_PWR_EnableSEVOnPend>:
  * @note Set SEVONPEND bit of SCR register. When this bit is set, this causes
  *       WFE to wake up when an interrupt moves from inactive to pended.
  * @retval None
  */
void HAL_PWR_EnableSEVOnPend(void)
{
200053ac:	b480      	push	{r7}
200053ae:	af00      	add	r7, sp, #0
  /* Set SEVONPEND bit of Cortex System Control Register */
  SET_BIT(SCB->SCR, ((uint32_t)SCB_SCR_SEVONPEND_Msk));
200053b0:	4b05      	ldr	r3, [pc, #20]	; (200053c8 <HAL_PWR_EnableSEVOnPend+0x1c>)
200053b2:	691b      	ldr	r3, [r3, #16]
200053b4:	4a04      	ldr	r2, [pc, #16]	; (200053c8 <HAL_PWR_EnableSEVOnPend+0x1c>)
200053b6:	f043 0310 	orr.w	r3, r3, #16
200053ba:	6113      	str	r3, [r2, #16]
}
200053bc:	bf00      	nop
200053be:	46bd      	mov	sp, r7
200053c0:	f85d 7b04 	ldr.w	r7, [sp], #4
200053c4:	4770      	bx	lr
200053c6:	bf00      	nop
200053c8:	e000ed00 	.word	0xe000ed00

200053cc <HAL_PWR_DisableSEVOnPend>:
  * @note Clear SEVONPEND bit of SCR register. When this bit is set, this causes
  *       WFE to wake up when an interrupt moves from inactive to pended.
  * @retval None
  */
void HAL_PWR_DisableSEVOnPend(void)
{
200053cc:	b480      	push	{r7}
200053ce:	af00      	add	r7, sp, #0
  /* Clear SEVONPEND bit of Cortex System Control Register */
  CLEAR_BIT(SCB->SCR, ((uint32_t)SCB_SCR_SEVONPEND_Msk));
200053d0:	4b05      	ldr	r3, [pc, #20]	; (200053e8 <HAL_PWR_DisableSEVOnPend+0x1c>)
200053d2:	691b      	ldr	r3, [r3, #16]
200053d4:	4a04      	ldr	r2, [pc, #16]	; (200053e8 <HAL_PWR_DisableSEVOnPend+0x1c>)
200053d6:	f023 0310 	bic.w	r3, r3, #16
200053da:	6113      	str	r3, [r2, #16]
}
200053dc:	bf00      	nop
200053de:	46bd      	mov	sp, r7
200053e0:	f85d 7b04 	ldr.w	r7, [sp], #4
200053e4:	4770      	bx	lr
200053e6:	bf00      	nop
200053e8:	e000ed00 	.word	0xe000ed00

200053ec <HAL_PWR_PVDCallback>:
/**
  * @brief PWR PVD interrupt callback
  * @retval None
  */
__weak void HAL_PWR_PVDCallback(void)
{
200053ec:	b480      	push	{r7}
200053ee:	af00      	add	r7, sp, #0
  /* NOTE : This function should not be modified; when the callback is needed,
            the HAL_PWR_PVDCallback can be implemented in the user file
   */
}
200053f0:	bf00      	nop
200053f2:	46bd      	mov	sp, r7
200053f4:	f85d 7b04 	ldr.w	r7, [sp], #4
200053f8:	4770      	bx	lr
	...

200053fc <HAL_PWREx_GetVoltageRange>:
  * @brief Return Voltage Scaling Range.
  * @retval VOS bit field (PWR_REGULATOR_VOLTAGE_SCALE1 or PWR_REGULATOR_VOLTAGE_SCALE2
  *         or PWR_REGULATOR_VOLTAGE_SCALE1_BOOST when applicable)
  */
uint32_t HAL_PWREx_GetVoltageRange(void)
{
200053fc:	b480      	push	{r7}
200053fe:	af00      	add	r7, sp, #0
  if (READ_BIT(PWR->CR1, PWR_CR1_VOS) == PWR_REGULATOR_VOLTAGE_SCALE2)
20005400:	4b0d      	ldr	r3, [pc, #52]	; (20005438 <HAL_PWREx_GetVoltageRange+0x3c>)
20005402:	681b      	ldr	r3, [r3, #0]
20005404:	f403 63c0 	and.w	r3, r3, #1536	; 0x600
20005408:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
2000540c:	d102      	bne.n	20005414 <HAL_PWREx_GetVoltageRange+0x18>
  {
    return PWR_REGULATOR_VOLTAGE_SCALE2;
2000540e:	f44f 6380 	mov.w	r3, #1024	; 0x400
20005412:	e00b      	b.n	2000542c <HAL_PWREx_GetVoltageRange+0x30>
  }
  else if (READ_BIT(PWR->CR5, PWR_CR5_R1MODE) == PWR_CR5_R1MODE)
20005414:	4b08      	ldr	r3, [pc, #32]	; (20005438 <HAL_PWREx_GetVoltageRange+0x3c>)
20005416:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
2000541a:	f403 7380 	and.w	r3, r3, #256	; 0x100
2000541e:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
20005422:	d102      	bne.n	2000542a <HAL_PWREx_GetVoltageRange+0x2e>
  {
    /* PWR_CR5_R1MODE bit set means that Range 1 Boost is disabled */
    return PWR_REGULATOR_VOLTAGE_SCALE1;
20005424:	f44f 7300 	mov.w	r3, #512	; 0x200
20005428:	e000      	b.n	2000542c <HAL_PWREx_GetVoltageRange+0x30>
  }
  else
  {
    return PWR_REGULATOR_VOLTAGE_SCALE1_BOOST;
2000542a:	2300      	movs	r3, #0
  }
}
2000542c:	4618      	mov	r0, r3
2000542e:	46bd      	mov	sp, r7
20005430:	f85d 7b04 	ldr.w	r7, [sp], #4
20005434:	4770      	bx	lr
20005436:	bf00      	nop
20005438:	40007000 	.word	0x40007000

2000543c <HAL_PWREx_ControlVoltageScaling>:
  *        cleared before returning the status. If the flag is not cleared within
  *        50 microseconds, HAL_TIMEOUT status is reported.
  * @retval HAL Status
  */
HAL_StatusTypeDef HAL_PWREx_ControlVoltageScaling(uint32_t VoltageScaling)
{
2000543c:	b480      	push	{r7}
2000543e:	b085      	sub	sp, #20
20005440:	af00      	add	r7, sp, #0
20005442:	6078      	str	r0, [r7, #4]
  uint32_t wait_loop_index;

  assert_param(IS_PWR_VOLTAGE_SCALING_RANGE(VoltageScaling));

  if (VoltageScaling == PWR_REGULATOR_VOLTAGE_SCALE1_BOOST)
20005444:	687b      	ldr	r3, [r7, #4]
20005446:	2b00      	cmp	r3, #0
20005448:	d141      	bne.n	200054ce <HAL_PWREx_ControlVoltageScaling+0x92>
  {
    /* If current range is range 2 */
    if (READ_BIT(PWR->CR1, PWR_CR1_VOS) == PWR_REGULATOR_VOLTAGE_SCALE2)
2000544a:	4b4b      	ldr	r3, [pc, #300]	; (20005578 <HAL_PWREx_ControlVoltageScaling+0x13c>)
2000544c:	681b      	ldr	r3, [r3, #0]
2000544e:	f403 63c0 	and.w	r3, r3, #1536	; 0x600
20005452:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
20005456:	d131      	bne.n	200054bc <HAL_PWREx_ControlVoltageScaling+0x80>
    {
      /* Make sure Range 1 Boost is enabled */
      CLEAR_BIT(PWR->CR5, PWR_CR5_R1MODE);
20005458:	4b47      	ldr	r3, [pc, #284]	; (20005578 <HAL_PWREx_ControlVoltageScaling+0x13c>)
2000545a:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
2000545e:	4a46      	ldr	r2, [pc, #280]	; (20005578 <HAL_PWREx_ControlVoltageScaling+0x13c>)
20005460:	f423 7380 	bic.w	r3, r3, #256	; 0x100
20005464:	f8c2 3080 	str.w	r3, [r2, #128]	; 0x80

      /* Set Range 1 */
      MODIFY_REG(PWR->CR1, PWR_CR1_VOS, PWR_REGULATOR_VOLTAGE_SCALE1);
20005468:	4b43      	ldr	r3, [pc, #268]	; (20005578 <HAL_PWREx_ControlVoltageScaling+0x13c>)
2000546a:	681b      	ldr	r3, [r3, #0]
2000546c:	f423 63c0 	bic.w	r3, r3, #1536	; 0x600
20005470:	4a41      	ldr	r2, [pc, #260]	; (20005578 <HAL_PWREx_ControlVoltageScaling+0x13c>)
20005472:	f443 7300 	orr.w	r3, r3, #512	; 0x200
20005476:	6013      	str	r3, [r2, #0]

      /* Wait until VOSF is cleared */
      wait_loop_index = ((PWR_FLAG_SETTING_DELAY_US * SystemCoreClock) / 1000000U) + 1U;
20005478:	4b40      	ldr	r3, [pc, #256]	; (2000557c <HAL_PWREx_ControlVoltageScaling+0x140>)
2000547a:	681b      	ldr	r3, [r3, #0]
2000547c:	2232      	movs	r2, #50	; 0x32
2000547e:	fb02 f303 	mul.w	r3, r2, r3
20005482:	4a3f      	ldr	r2, [pc, #252]	; (20005580 <HAL_PWREx_ControlVoltageScaling+0x144>)
20005484:	fba2 2303 	umull	r2, r3, r2, r3
20005488:	0c9b      	lsrs	r3, r3, #18
2000548a:	3301      	adds	r3, #1
2000548c:	60fb      	str	r3, [r7, #12]
      while ((HAL_IS_BIT_SET(PWR->SR2, PWR_SR2_VOSF)) && (wait_loop_index != 0U))
2000548e:	e002      	b.n	20005496 <HAL_PWREx_ControlVoltageScaling+0x5a>
      {
        wait_loop_index--;
20005490:	68fb      	ldr	r3, [r7, #12]
20005492:	3b01      	subs	r3, #1
20005494:	60fb      	str	r3, [r7, #12]
      while ((HAL_IS_BIT_SET(PWR->SR2, PWR_SR2_VOSF)) && (wait_loop_index != 0U))
20005496:	4b38      	ldr	r3, [pc, #224]	; (20005578 <HAL_PWREx_ControlVoltageScaling+0x13c>)
20005498:	695b      	ldr	r3, [r3, #20]
2000549a:	f403 6380 	and.w	r3, r3, #1024	; 0x400
2000549e:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
200054a2:	d102      	bne.n	200054aa <HAL_PWREx_ControlVoltageScaling+0x6e>
200054a4:	68fb      	ldr	r3, [r7, #12]
200054a6:	2b00      	cmp	r3, #0
200054a8:	d1f2      	bne.n	20005490 <HAL_PWREx_ControlVoltageScaling+0x54>
      }
      if (HAL_IS_BIT_SET(PWR->SR2, PWR_SR2_VOSF))
200054aa:	4b33      	ldr	r3, [pc, #204]	; (20005578 <HAL_PWREx_ControlVoltageScaling+0x13c>)
200054ac:	695b      	ldr	r3, [r3, #20]
200054ae:	f403 6380 	and.w	r3, r3, #1024	; 0x400
200054b2:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
200054b6:	d158      	bne.n	2000556a <HAL_PWREx_ControlVoltageScaling+0x12e>
      {
        return HAL_TIMEOUT;
200054b8:	2303      	movs	r3, #3
200054ba:	e057      	b.n	2000556c <HAL_PWREx_ControlVoltageScaling+0x130>
    }
    /* If current range is range 1 normal or boost mode */
    else
    {
      /* Enable Range 1 Boost (no issue if bit already reset) */
      CLEAR_BIT(PWR->CR5, PWR_CR5_R1MODE);
200054bc:	4b2e      	ldr	r3, [pc, #184]	; (20005578 <HAL_PWREx_ControlVoltageScaling+0x13c>)
200054be:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
200054c2:	4a2d      	ldr	r2, [pc, #180]	; (20005578 <HAL_PWREx_ControlVoltageScaling+0x13c>)
200054c4:	f423 7380 	bic.w	r3, r3, #256	; 0x100
200054c8:	f8c2 3080 	str.w	r3, [r2, #128]	; 0x80
200054cc:	e04d      	b.n	2000556a <HAL_PWREx_ControlVoltageScaling+0x12e>
    }
  }
  else if (VoltageScaling == PWR_REGULATOR_VOLTAGE_SCALE1)
200054ce:	687b      	ldr	r3, [r7, #4]
200054d0:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
200054d4:	d141      	bne.n	2000555a <HAL_PWREx_ControlVoltageScaling+0x11e>
  {
    /* If current range is range 2 */
    if (READ_BIT(PWR->CR1, PWR_CR1_VOS) == PWR_REGULATOR_VOLTAGE_SCALE2)
200054d6:	4b28      	ldr	r3, [pc, #160]	; (20005578 <HAL_PWREx_ControlVoltageScaling+0x13c>)
200054d8:	681b      	ldr	r3, [r3, #0]
200054da:	f403 63c0 	and.w	r3, r3, #1536	; 0x600
200054de:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
200054e2:	d131      	bne.n	20005548 <HAL_PWREx_ControlVoltageScaling+0x10c>
    {
      /* Make sure Range 1 Boost is disabled */
      SET_BIT(PWR->CR5, PWR_CR5_R1MODE);
200054e4:	4b24      	ldr	r3, [pc, #144]	; (20005578 <HAL_PWREx_ControlVoltageScaling+0x13c>)
200054e6:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
200054ea:	4a23      	ldr	r2, [pc, #140]	; (20005578 <HAL_PWREx_ControlVoltageScaling+0x13c>)
200054ec:	f443 7380 	orr.w	r3, r3, #256	; 0x100
200054f0:	f8c2 3080 	str.w	r3, [r2, #128]	; 0x80

      /* Set Range 1 */
      MODIFY_REG(PWR->CR1, PWR_CR1_VOS, PWR_REGULATOR_VOLTAGE_SCALE1);
200054f4:	4b20      	ldr	r3, [pc, #128]	; (20005578 <HAL_PWREx_ControlVoltageScaling+0x13c>)
200054f6:	681b      	ldr	r3, [r3, #0]
200054f8:	f423 63c0 	bic.w	r3, r3, #1536	; 0x600
200054fc:	4a1e      	ldr	r2, [pc, #120]	; (20005578 <HAL_PWREx_ControlVoltageScaling+0x13c>)
200054fe:	f443 7300 	orr.w	r3, r3, #512	; 0x200
20005502:	6013      	str	r3, [r2, #0]

      /* Wait until VOSF is cleared */
      wait_loop_index = ((PWR_FLAG_SETTING_DELAY_US * SystemCoreClock) / 1000000U) + 1U;
20005504:	4b1d      	ldr	r3, [pc, #116]	; (2000557c <HAL_PWREx_ControlVoltageScaling+0x140>)
20005506:	681b      	ldr	r3, [r3, #0]
20005508:	2232      	movs	r2, #50	; 0x32
2000550a:	fb02 f303 	mul.w	r3, r2, r3
2000550e:	4a1c      	ldr	r2, [pc, #112]	; (20005580 <HAL_PWREx_ControlVoltageScaling+0x144>)
20005510:	fba2 2303 	umull	r2, r3, r2, r3
20005514:	0c9b      	lsrs	r3, r3, #18
20005516:	3301      	adds	r3, #1
20005518:	60fb      	str	r3, [r7, #12]
      while ((HAL_IS_BIT_SET(PWR->SR2, PWR_SR2_VOSF)) && (wait_loop_index != 0U))
2000551a:	e002      	b.n	20005522 <HAL_PWREx_ControlVoltageScaling+0xe6>
      {
        wait_loop_index--;
2000551c:	68fb      	ldr	r3, [r7, #12]
2000551e:	3b01      	subs	r3, #1
20005520:	60fb      	str	r3, [r7, #12]
      while ((HAL_IS_BIT_SET(PWR->SR2, PWR_SR2_VOSF)) && (wait_loop_index != 0U))
20005522:	4b15      	ldr	r3, [pc, #84]	; (20005578 <HAL_PWREx_ControlVoltageScaling+0x13c>)
20005524:	695b      	ldr	r3, [r3, #20]
20005526:	f403 6380 	and.w	r3, r3, #1024	; 0x400
2000552a:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
2000552e:	d102      	bne.n	20005536 <HAL_PWREx_ControlVoltageScaling+0xfa>
20005530:	68fb      	ldr	r3, [r7, #12]
20005532:	2b00      	cmp	r3, #0
20005534:	d1f2      	bne.n	2000551c <HAL_PWREx_ControlVoltageScaling+0xe0>
      }
      if (HAL_IS_BIT_SET(PWR->SR2, PWR_SR2_VOSF))
20005536:	4b10      	ldr	r3, [pc, #64]	; (20005578 <HAL_PWREx_ControlVoltageScaling+0x13c>)
20005538:	695b      	ldr	r3, [r3, #20]
2000553a:	f403 6380 	and.w	r3, r3, #1024	; 0x400
2000553e:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
20005542:	d112      	bne.n	2000556a <HAL_PWREx_ControlVoltageScaling+0x12e>
      {
        return HAL_TIMEOUT;
20005544:	2303      	movs	r3, #3
20005546:	e011      	b.n	2000556c <HAL_PWREx_ControlVoltageScaling+0x130>
    }
     /* If current range is range 1 normal or boost mode */
    else
    {
      /* Disable Range 1 Boost (no issue if bit already set) */
      SET_BIT(PWR->CR5, PWR_CR5_R1MODE);
20005548:	4b0b      	ldr	r3, [pc, #44]	; (20005578 <HAL_PWREx_ControlVoltageScaling+0x13c>)
2000554a:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
2000554e:	4a0a      	ldr	r2, [pc, #40]	; (20005578 <HAL_PWREx_ControlVoltageScaling+0x13c>)
20005550:	f443 7380 	orr.w	r3, r3, #256	; 0x100
20005554:	f8c2 3080 	str.w	r3, [r2, #128]	; 0x80
20005558:	e007      	b.n	2000556a <HAL_PWREx_ControlVoltageScaling+0x12e>
    }
  }
  else
  {
    /* Set Range 2 */
    MODIFY_REG(PWR->CR1, PWR_CR1_VOS, PWR_REGULATOR_VOLTAGE_SCALE2);
2000555a:	4b07      	ldr	r3, [pc, #28]	; (20005578 <HAL_PWREx_ControlVoltageScaling+0x13c>)
2000555c:	681b      	ldr	r3, [r3, #0]
2000555e:	f423 63c0 	bic.w	r3, r3, #1536	; 0x600
20005562:	4a05      	ldr	r2, [pc, #20]	; (20005578 <HAL_PWREx_ControlVoltageScaling+0x13c>)
20005564:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
20005568:	6013      	str	r3, [r2, #0]
    /* No need to wait for VOSF to be cleared for this transition */
    /* PWR_CR5_R1MODE bit setting has no effect in Range 2        */
  }

  return HAL_OK;
2000556a:	2300      	movs	r3, #0
}
2000556c:	4618      	mov	r0, r3
2000556e:	3714      	adds	r7, #20
20005570:	46bd      	mov	sp, r7
20005572:	f85d 7b04 	ldr.w	r7, [sp], #4
20005576:	4770      	bx	lr
20005578:	40007000 	.word	0x40007000
2000557c:	200003f0 	.word	0x200003f0
20005580:	431bde83 	.word	0x431bde83

20005584 <HAL_PWREx_EnableBatteryCharging>:
  *            @arg @ref PWR_BATTERY_CHARGING_RESISTOR_5     5 kOhms resistor
  *            @arg @ref PWR_BATTERY_CHARGING_RESISTOR_1_5 1.5 kOhms resistor
  * @retval None
  */
void HAL_PWREx_EnableBatteryCharging(uint32_t ResistorSelection)
{
20005584:	b480      	push	{r7}
20005586:	b083      	sub	sp, #12
20005588:	af00      	add	r7, sp, #0
2000558a:	6078      	str	r0, [r7, #4]
  assert_param(IS_PWR_BATTERY_RESISTOR_SELECT(ResistorSelection));

  /* Specify resistor selection */
  MODIFY_REG(PWR->CR4, PWR_CR4_VBRS, ResistorSelection);
2000558c:	4b09      	ldr	r3, [pc, #36]	; (200055b4 <HAL_PWREx_EnableBatteryCharging+0x30>)
2000558e:	68db      	ldr	r3, [r3, #12]
20005590:	f423 7200 	bic.w	r2, r3, #512	; 0x200
20005594:	4907      	ldr	r1, [pc, #28]	; (200055b4 <HAL_PWREx_EnableBatteryCharging+0x30>)
20005596:	687b      	ldr	r3, [r7, #4]
20005598:	4313      	orrs	r3, r2
2000559a:	60cb      	str	r3, [r1, #12]

  /* Enable battery charging */
  SET_BIT(PWR->CR4, PWR_CR4_VBE);
2000559c:	4b05      	ldr	r3, [pc, #20]	; (200055b4 <HAL_PWREx_EnableBatteryCharging+0x30>)
2000559e:	68db      	ldr	r3, [r3, #12]
200055a0:	4a04      	ldr	r2, [pc, #16]	; (200055b4 <HAL_PWREx_EnableBatteryCharging+0x30>)
200055a2:	f443 7380 	orr.w	r3, r3, #256	; 0x100
200055a6:	60d3      	str	r3, [r2, #12]
}
200055a8:	bf00      	nop
200055aa:	370c      	adds	r7, #12
200055ac:	46bd      	mov	sp, r7
200055ae:	f85d 7b04 	ldr.w	r7, [sp], #4
200055b2:	4770      	bx	lr
200055b4:	40007000 	.word	0x40007000

200055b8 <HAL_PWREx_DisableBatteryCharging>:
/**
  * @brief Disable battery charging.
  * @retval None
  */
void HAL_PWREx_DisableBatteryCharging(void)
{
200055b8:	b480      	push	{r7}
200055ba:	af00      	add	r7, sp, #0
  CLEAR_BIT(PWR->CR4, PWR_CR4_VBE);
200055bc:	4b05      	ldr	r3, [pc, #20]	; (200055d4 <HAL_PWREx_DisableBatteryCharging+0x1c>)
200055be:	68db      	ldr	r3, [r3, #12]
200055c0:	4a04      	ldr	r2, [pc, #16]	; (200055d4 <HAL_PWREx_DisableBatteryCharging+0x1c>)
200055c2:	f423 7380 	bic.w	r3, r3, #256	; 0x100
200055c6:	60d3      	str	r3, [r2, #12]
}
200055c8:	bf00      	nop
200055ca:	46bd      	mov	sp, r7
200055cc:	f85d 7b04 	ldr.w	r7, [sp], #4
200055d0:	4770      	bx	lr
200055d2:	bf00      	nop
200055d4:	40007000 	.word	0x40007000

200055d8 <HAL_PWREx_EnableInternalWakeUpLine>:
/**
  * @brief Enable Internal Wake-up Line.
  * @retval None
  */
void HAL_PWREx_EnableInternalWakeUpLine(void)
{
200055d8:	b480      	push	{r7}
200055da:	af00      	add	r7, sp, #0
  SET_BIT(PWR->CR3, PWR_CR3_EIWF);
200055dc:	4b05      	ldr	r3, [pc, #20]	; (200055f4 <HAL_PWREx_EnableInternalWakeUpLine+0x1c>)
200055de:	689b      	ldr	r3, [r3, #8]
200055e0:	4a04      	ldr	r2, [pc, #16]	; (200055f4 <HAL_PWREx_EnableInternalWakeUpLine+0x1c>)
200055e2:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
200055e6:	6093      	str	r3, [r2, #8]
}
200055e8:	bf00      	nop
200055ea:	46bd      	mov	sp, r7
200055ec:	f85d 7b04 	ldr.w	r7, [sp], #4
200055f0:	4770      	bx	lr
200055f2:	bf00      	nop
200055f4:	40007000 	.word	0x40007000

200055f8 <HAL_PWREx_DisableInternalWakeUpLine>:
/**
  * @brief Disable Internal Wake-up Line.
  * @retval None
  */
void HAL_PWREx_DisableInternalWakeUpLine(void)
{
200055f8:	b480      	push	{r7}
200055fa:	af00      	add	r7, sp, #0
  CLEAR_BIT(PWR->CR3, PWR_CR3_EIWF);
200055fc:	4b05      	ldr	r3, [pc, #20]	; (20005614 <HAL_PWREx_DisableInternalWakeUpLine+0x1c>)
200055fe:	689b      	ldr	r3, [r3, #8]
20005600:	4a04      	ldr	r2, [pc, #16]	; (20005614 <HAL_PWREx_DisableInternalWakeUpLine+0x1c>)
20005602:	f423 4300 	bic.w	r3, r3, #32768	; 0x8000
20005606:	6093      	str	r3, [r2, #8]
}
20005608:	bf00      	nop
2000560a:	46bd      	mov	sp, r7
2000560c:	f85d 7b04 	ldr.w	r7, [sp], #4
20005610:	4770      	bx	lr
20005612:	bf00      	nop
20005614:	40007000 	.word	0x40007000

20005618 <HAL_PWREx_EnableGPIOPullUp>:
  *         I/O pins are available) or the logical OR of several of them to set
  *         several bits for a given port in a single API call.
  * @retval HAL Status
  */
HAL_StatusTypeDef HAL_PWREx_EnableGPIOPullUp(uint32_t GPIO, uint32_t GPIONumber)
{
20005618:	b480      	push	{r7}
2000561a:	b085      	sub	sp, #20
2000561c:	af00      	add	r7, sp, #0
2000561e:	6078      	str	r0, [r7, #4]
20005620:	6039      	str	r1, [r7, #0]
  HAL_StatusTypeDef status = HAL_OK;
20005622:	2300      	movs	r3, #0
20005624:	73fb      	strb	r3, [r7, #15]
20005626:	687b      	ldr	r3, [r7, #4]
20005628:	2b06      	cmp	r3, #6
2000562a:	d87f      	bhi.n	2000572c <HAL_PWREx_EnableGPIOPullUp+0x114>
2000562c:	a201      	add	r2, pc, #4	; (adr r2, 20005634 <HAL_PWREx_EnableGPIOPullUp+0x1c>)
2000562e:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
20005632:	bf00      	nop
20005634:	20005651 	.word	0x20005651
20005638:	20005675 	.word	0x20005675
2000563c:	20005695 	.word	0x20005695
20005640:	200056b1 	.word	0x200056b1
20005644:	200056cd 	.word	0x200056cd
20005648:	200056e9 	.word	0x200056e9
2000564c:	20005709 	.word	0x20005709
  assert_param(IS_PWR_GPIO_BIT_NUMBER(GPIONumber));

  switch (GPIO)
  {
    case PWR_GPIO_A:
       SET_BIT(PWR->PUCRA, (GPIONumber & (~(PWR_GPIO_BIT_14))));
20005650:	4b3b      	ldr	r3, [pc, #236]	; (20005740 <HAL_PWREx_EnableGPIOPullUp+0x128>)
20005652:	6a1a      	ldr	r2, [r3, #32]
20005654:	683b      	ldr	r3, [r7, #0]
20005656:	f423 4380 	bic.w	r3, r3, #16384	; 0x4000
2000565a:	4939      	ldr	r1, [pc, #228]	; (20005740 <HAL_PWREx_EnableGPIOPullUp+0x128>)
2000565c:	4313      	orrs	r3, r2
2000565e:	620b      	str	r3, [r1, #32]
       CLEAR_BIT(PWR->PDCRA, (GPIONumber & (~(PWR_GPIO_BIT_13|PWR_GPIO_BIT_15))));
20005660:	4b37      	ldr	r3, [pc, #220]	; (20005740 <HAL_PWREx_EnableGPIOPullUp+0x128>)
20005662:	6a5a      	ldr	r2, [r3, #36]	; 0x24
20005664:	683b      	ldr	r3, [r7, #0]
20005666:	f423 4320 	bic.w	r3, r3, #40960	; 0xa000
2000566a:	43db      	mvns	r3, r3
2000566c:	4934      	ldr	r1, [pc, #208]	; (20005740 <HAL_PWREx_EnableGPIOPullUp+0x128>)
2000566e:	4013      	ands	r3, r2
20005670:	624b      	str	r3, [r1, #36]	; 0x24
       break;
20005672:	e05e      	b.n	20005732 <HAL_PWREx_EnableGPIOPullUp+0x11a>
    case PWR_GPIO_B:
       SET_BIT(PWR->PUCRB, GPIONumber);
20005674:	4b32      	ldr	r3, [pc, #200]	; (20005740 <HAL_PWREx_EnableGPIOPullUp+0x128>)
20005676:	6a9a      	ldr	r2, [r3, #40]	; 0x28
20005678:	4931      	ldr	r1, [pc, #196]	; (20005740 <HAL_PWREx_EnableGPIOPullUp+0x128>)
2000567a:	683b      	ldr	r3, [r7, #0]
2000567c:	4313      	orrs	r3, r2
2000567e:	628b      	str	r3, [r1, #40]	; 0x28
       CLEAR_BIT(PWR->PDCRB, (GPIONumber & (~(PWR_GPIO_BIT_4))));
20005680:	4b2f      	ldr	r3, [pc, #188]	; (20005740 <HAL_PWREx_EnableGPIOPullUp+0x128>)
20005682:	6ada      	ldr	r2, [r3, #44]	; 0x2c
20005684:	683b      	ldr	r3, [r7, #0]
20005686:	f023 0310 	bic.w	r3, r3, #16
2000568a:	43db      	mvns	r3, r3
2000568c:	492c      	ldr	r1, [pc, #176]	; (20005740 <HAL_PWREx_EnableGPIOPullUp+0x128>)
2000568e:	4013      	ands	r3, r2
20005690:	62cb      	str	r3, [r1, #44]	; 0x2c
       break;
20005692:	e04e      	b.n	20005732 <HAL_PWREx_EnableGPIOPullUp+0x11a>
    case PWR_GPIO_C:
       SET_BIT(PWR->PUCRC, GPIONumber);
20005694:	4b2a      	ldr	r3, [pc, #168]	; (20005740 <HAL_PWREx_EnableGPIOPullUp+0x128>)
20005696:	6b1a      	ldr	r2, [r3, #48]	; 0x30
20005698:	4929      	ldr	r1, [pc, #164]	; (20005740 <HAL_PWREx_EnableGPIOPullUp+0x128>)
2000569a:	683b      	ldr	r3, [r7, #0]
2000569c:	4313      	orrs	r3, r2
2000569e:	630b      	str	r3, [r1, #48]	; 0x30
       CLEAR_BIT(PWR->PDCRC, GPIONumber);
200056a0:	4b27      	ldr	r3, [pc, #156]	; (20005740 <HAL_PWREx_EnableGPIOPullUp+0x128>)
200056a2:	6b5a      	ldr	r2, [r3, #52]	; 0x34
200056a4:	683b      	ldr	r3, [r7, #0]
200056a6:	43db      	mvns	r3, r3
200056a8:	4925      	ldr	r1, [pc, #148]	; (20005740 <HAL_PWREx_EnableGPIOPullUp+0x128>)
200056aa:	4013      	ands	r3, r2
200056ac:	634b      	str	r3, [r1, #52]	; 0x34
       break;
200056ae:	e040      	b.n	20005732 <HAL_PWREx_EnableGPIOPullUp+0x11a>
    case PWR_GPIO_D:
       SET_BIT(PWR->PUCRD, GPIONumber);
200056b0:	4b23      	ldr	r3, [pc, #140]	; (20005740 <HAL_PWREx_EnableGPIOPullUp+0x128>)
200056b2:	6b9a      	ldr	r2, [r3, #56]	; 0x38
200056b4:	4922      	ldr	r1, [pc, #136]	; (20005740 <HAL_PWREx_EnableGPIOPullUp+0x128>)
200056b6:	683b      	ldr	r3, [r7, #0]
200056b8:	4313      	orrs	r3, r2
200056ba:	638b      	str	r3, [r1, #56]	; 0x38
       CLEAR_BIT(PWR->PDCRD, GPIONumber);
200056bc:	4b20      	ldr	r3, [pc, #128]	; (20005740 <HAL_PWREx_EnableGPIOPullUp+0x128>)
200056be:	6bda      	ldr	r2, [r3, #60]	; 0x3c
200056c0:	683b      	ldr	r3, [r7, #0]
200056c2:	43db      	mvns	r3, r3
200056c4:	491e      	ldr	r1, [pc, #120]	; (20005740 <HAL_PWREx_EnableGPIOPullUp+0x128>)
200056c6:	4013      	ands	r3, r2
200056c8:	63cb      	str	r3, [r1, #60]	; 0x3c
       break;
200056ca:	e032      	b.n	20005732 <HAL_PWREx_EnableGPIOPullUp+0x11a>
    case PWR_GPIO_E:
       SET_BIT(PWR->PUCRE, GPIONumber);
200056cc:	4b1c      	ldr	r3, [pc, #112]	; (20005740 <HAL_PWREx_EnableGPIOPullUp+0x128>)
200056ce:	6c1a      	ldr	r2, [r3, #64]	; 0x40
200056d0:	491b      	ldr	r1, [pc, #108]	; (20005740 <HAL_PWREx_EnableGPIOPullUp+0x128>)
200056d2:	683b      	ldr	r3, [r7, #0]
200056d4:	4313      	orrs	r3, r2
200056d6:	640b      	str	r3, [r1, #64]	; 0x40
       CLEAR_BIT(PWR->PDCRE, GPIONumber);
200056d8:	4b19      	ldr	r3, [pc, #100]	; (20005740 <HAL_PWREx_EnableGPIOPullUp+0x128>)
200056da:	6c5a      	ldr	r2, [r3, #68]	; 0x44
200056dc:	683b      	ldr	r3, [r7, #0]
200056de:	43db      	mvns	r3, r3
200056e0:	4917      	ldr	r1, [pc, #92]	; (20005740 <HAL_PWREx_EnableGPIOPullUp+0x128>)
200056e2:	4013      	ands	r3, r2
200056e4:	644b      	str	r3, [r1, #68]	; 0x44
       break;
200056e6:	e024      	b.n	20005732 <HAL_PWREx_EnableGPIOPullUp+0x11a>
    case PWR_GPIO_F:
       SET_BIT(PWR->PUCRF, (GPIONumber & PWR_PORTF_AVAILABLE_PINS));
200056e8:	4b15      	ldr	r3, [pc, #84]	; (20005740 <HAL_PWREx_EnableGPIOPullUp+0x128>)
200056ea:	6c9a      	ldr	r2, [r3, #72]	; 0x48
200056ec:	683b      	ldr	r3, [r7, #0]
200056ee:	b29b      	uxth	r3, r3
200056f0:	4913      	ldr	r1, [pc, #76]	; (20005740 <HAL_PWREx_EnableGPIOPullUp+0x128>)
200056f2:	4313      	orrs	r3, r2
200056f4:	648b      	str	r3, [r1, #72]	; 0x48
       CLEAR_BIT(PWR->PDCRF, (GPIONumber & PWR_PORTF_AVAILABLE_PINS));
200056f6:	4b12      	ldr	r3, [pc, #72]	; (20005740 <HAL_PWREx_EnableGPIOPullUp+0x128>)
200056f8:	6cda      	ldr	r2, [r3, #76]	; 0x4c
200056fa:	683b      	ldr	r3, [r7, #0]
200056fc:	b29b      	uxth	r3, r3
200056fe:	43db      	mvns	r3, r3
20005700:	490f      	ldr	r1, [pc, #60]	; (20005740 <HAL_PWREx_EnableGPIOPullUp+0x128>)
20005702:	4013      	ands	r3, r2
20005704:	64cb      	str	r3, [r1, #76]	; 0x4c
       break;
20005706:	e014      	b.n	20005732 <HAL_PWREx_EnableGPIOPullUp+0x11a>
    case PWR_GPIO_G:
       SET_BIT(PWR->PUCRG, (GPIONumber & PWR_PORTG_AVAILABLE_PINS));
20005708:	4b0d      	ldr	r3, [pc, #52]	; (20005740 <HAL_PWREx_EnableGPIOPullUp+0x128>)
2000570a:	6d1a      	ldr	r2, [r3, #80]	; 0x50
2000570c:	683b      	ldr	r3, [r7, #0]
2000570e:	f3c3 030a 	ubfx	r3, r3, #0, #11
20005712:	490b      	ldr	r1, [pc, #44]	; (20005740 <HAL_PWREx_EnableGPIOPullUp+0x128>)
20005714:	4313      	orrs	r3, r2
20005716:	650b      	str	r3, [r1, #80]	; 0x50
       CLEAR_BIT(PWR->PDCRG, ((GPIONumber & PWR_PORTG_AVAILABLE_PINS) & (~(PWR_GPIO_BIT_10))));
20005718:	4b09      	ldr	r3, [pc, #36]	; (20005740 <HAL_PWREx_EnableGPIOPullUp+0x128>)
2000571a:	6d5a      	ldr	r2, [r3, #84]	; 0x54
2000571c:	683b      	ldr	r3, [r7, #0]
2000571e:	f3c3 0309 	ubfx	r3, r3, #0, #10
20005722:	43db      	mvns	r3, r3
20005724:	4906      	ldr	r1, [pc, #24]	; (20005740 <HAL_PWREx_EnableGPIOPullUp+0x128>)
20005726:	4013      	ands	r3, r2
20005728:	654b      	str	r3, [r1, #84]	; 0x54
       break;
2000572a:	e002      	b.n	20005732 <HAL_PWREx_EnableGPIOPullUp+0x11a>
    default:
      status = HAL_ERROR;
2000572c:	2301      	movs	r3, #1
2000572e:	73fb      	strb	r3, [r7, #15]
      break;
20005730:	bf00      	nop
  }

  return status;
20005732:	7bfb      	ldrb	r3, [r7, #15]
}
20005734:	4618      	mov	r0, r3
20005736:	3714      	adds	r7, #20
20005738:	46bd      	mov	sp, r7
2000573a:	f85d 7b04 	ldr.w	r7, [sp], #4
2000573e:	4770      	bx	lr
20005740:	40007000 	.word	0x40007000

20005744 <HAL_PWREx_DisableGPIOPullUp>:
  *         I/O pins are available) or the logical OR of several of them to reset
  *         several bits for a given port in a single API call.
  * @retval HAL Status
  */
HAL_StatusTypeDef HAL_PWREx_DisableGPIOPullUp(uint32_t GPIO, uint32_t GPIONumber)
{
20005744:	b480      	push	{r7}
20005746:	b085      	sub	sp, #20
20005748:	af00      	add	r7, sp, #0
2000574a:	6078      	str	r0, [r7, #4]
2000574c:	6039      	str	r1, [r7, #0]
  HAL_StatusTypeDef status = HAL_OK;
2000574e:	2300      	movs	r3, #0
20005750:	73fb      	strb	r3, [r7, #15]
20005752:	687b      	ldr	r3, [r7, #4]
20005754:	2b06      	cmp	r3, #6
20005756:	d84e      	bhi.n	200057f6 <HAL_PWREx_DisableGPIOPullUp+0xb2>
20005758:	a201      	add	r2, pc, #4	; (adr r2, 20005760 <HAL_PWREx_DisableGPIOPullUp+0x1c>)
2000575a:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
2000575e:	bf00      	nop
20005760:	2000577d 	.word	0x2000577d
20005764:	20005791 	.word	0x20005791
20005768:	200057a1 	.word	0x200057a1
2000576c:	200057b1 	.word	0x200057b1
20005770:	200057c1 	.word	0x200057c1
20005774:	200057d1 	.word	0x200057d1
20005778:	200057e3 	.word	0x200057e3
  assert_param(IS_PWR_GPIO_BIT_NUMBER(GPIONumber));

  switch (GPIO)
  {
    case PWR_GPIO_A:
       CLEAR_BIT(PWR->PUCRA, (GPIONumber & (~(PWR_GPIO_BIT_14))));
2000577c:	4b23      	ldr	r3, [pc, #140]	; (2000580c <HAL_PWREx_DisableGPIOPullUp+0xc8>)
2000577e:	6a1a      	ldr	r2, [r3, #32]
20005780:	683b      	ldr	r3, [r7, #0]
20005782:	f423 4380 	bic.w	r3, r3, #16384	; 0x4000
20005786:	43db      	mvns	r3, r3
20005788:	4920      	ldr	r1, [pc, #128]	; (2000580c <HAL_PWREx_DisableGPIOPullUp+0xc8>)
2000578a:	4013      	ands	r3, r2
2000578c:	620b      	str	r3, [r1, #32]
       break;
2000578e:	e035      	b.n	200057fc <HAL_PWREx_DisableGPIOPullUp+0xb8>
    case PWR_GPIO_B:
       CLEAR_BIT(PWR->PUCRB, GPIONumber);
20005790:	4b1e      	ldr	r3, [pc, #120]	; (2000580c <HAL_PWREx_DisableGPIOPullUp+0xc8>)
20005792:	6a9a      	ldr	r2, [r3, #40]	; 0x28
20005794:	683b      	ldr	r3, [r7, #0]
20005796:	43db      	mvns	r3, r3
20005798:	491c      	ldr	r1, [pc, #112]	; (2000580c <HAL_PWREx_DisableGPIOPullUp+0xc8>)
2000579a:	4013      	ands	r3, r2
2000579c:	628b      	str	r3, [r1, #40]	; 0x28
       break;
2000579e:	e02d      	b.n	200057fc <HAL_PWREx_DisableGPIOPullUp+0xb8>
    case PWR_GPIO_C:
       CLEAR_BIT(PWR->PUCRC, GPIONumber);
200057a0:	4b1a      	ldr	r3, [pc, #104]	; (2000580c <HAL_PWREx_DisableGPIOPullUp+0xc8>)
200057a2:	6b1a      	ldr	r2, [r3, #48]	; 0x30
200057a4:	683b      	ldr	r3, [r7, #0]
200057a6:	43db      	mvns	r3, r3
200057a8:	4918      	ldr	r1, [pc, #96]	; (2000580c <HAL_PWREx_DisableGPIOPullUp+0xc8>)
200057aa:	4013      	ands	r3, r2
200057ac:	630b      	str	r3, [r1, #48]	; 0x30
       break;
200057ae:	e025      	b.n	200057fc <HAL_PWREx_DisableGPIOPullUp+0xb8>
    case PWR_GPIO_D:
       CLEAR_BIT(PWR->PUCRD, GPIONumber);
200057b0:	4b16      	ldr	r3, [pc, #88]	; (2000580c <HAL_PWREx_DisableGPIOPullUp+0xc8>)
200057b2:	6b9a      	ldr	r2, [r3, #56]	; 0x38
200057b4:	683b      	ldr	r3, [r7, #0]
200057b6:	43db      	mvns	r3, r3
200057b8:	4914      	ldr	r1, [pc, #80]	; (2000580c <HAL_PWREx_DisableGPIOPullUp+0xc8>)
200057ba:	4013      	ands	r3, r2
200057bc:	638b      	str	r3, [r1, #56]	; 0x38
       break;
200057be:	e01d      	b.n	200057fc <HAL_PWREx_DisableGPIOPullUp+0xb8>
    case PWR_GPIO_E:
       CLEAR_BIT(PWR->PUCRE, GPIONumber);
200057c0:	4b12      	ldr	r3, [pc, #72]	; (2000580c <HAL_PWREx_DisableGPIOPullUp+0xc8>)
200057c2:	6c1a      	ldr	r2, [r3, #64]	; 0x40
200057c4:	683b      	ldr	r3, [r7, #0]
200057c6:	43db      	mvns	r3, r3
200057c8:	4910      	ldr	r1, [pc, #64]	; (2000580c <HAL_PWREx_DisableGPIOPullUp+0xc8>)
200057ca:	4013      	ands	r3, r2
200057cc:	640b      	str	r3, [r1, #64]	; 0x40
       break;
200057ce:	e015      	b.n	200057fc <HAL_PWREx_DisableGPIOPullUp+0xb8>
    case PWR_GPIO_F:
       CLEAR_BIT(PWR->PUCRF, (GPIONumber & PWR_PORTF_AVAILABLE_PINS));
200057d0:	4b0e      	ldr	r3, [pc, #56]	; (2000580c <HAL_PWREx_DisableGPIOPullUp+0xc8>)
200057d2:	6c9a      	ldr	r2, [r3, #72]	; 0x48
200057d4:	683b      	ldr	r3, [r7, #0]
200057d6:	b29b      	uxth	r3, r3
200057d8:	43db      	mvns	r3, r3
200057da:	490c      	ldr	r1, [pc, #48]	; (2000580c <HAL_PWREx_DisableGPIOPullUp+0xc8>)
200057dc:	4013      	ands	r3, r2
200057de:	648b      	str	r3, [r1, #72]	; 0x48
       break;
200057e0:	e00c      	b.n	200057fc <HAL_PWREx_DisableGPIOPullUp+0xb8>
    case PWR_GPIO_G:
       CLEAR_BIT(PWR->PUCRG, (GPIONumber & PWR_PORTG_AVAILABLE_PINS));
200057e2:	4b0a      	ldr	r3, [pc, #40]	; (2000580c <HAL_PWREx_DisableGPIOPullUp+0xc8>)
200057e4:	6d1a      	ldr	r2, [r3, #80]	; 0x50
200057e6:	683b      	ldr	r3, [r7, #0]
200057e8:	f3c3 030a 	ubfx	r3, r3, #0, #11
200057ec:	43db      	mvns	r3, r3
200057ee:	4907      	ldr	r1, [pc, #28]	; (2000580c <HAL_PWREx_DisableGPIOPullUp+0xc8>)
200057f0:	4013      	ands	r3, r2
200057f2:	650b      	str	r3, [r1, #80]	; 0x50
       break;
200057f4:	e002      	b.n	200057fc <HAL_PWREx_DisableGPIOPullUp+0xb8>
    default:
       status = HAL_ERROR;
200057f6:	2301      	movs	r3, #1
200057f8:	73fb      	strb	r3, [r7, #15]
       break;
200057fa:	bf00      	nop
  }

  return status;
200057fc:	7bfb      	ldrb	r3, [r7, #15]
}
200057fe:	4618      	mov	r0, r3
20005800:	3714      	adds	r7, #20
20005802:	46bd      	mov	sp, r7
20005804:	f85d 7b04 	ldr.w	r7, [sp], #4
20005808:	4770      	bx	lr
2000580a:	bf00      	nop
2000580c:	40007000 	.word	0x40007000

20005810 <HAL_PWREx_EnableGPIOPullDown>:
  *         I/O pins are available) or the logical OR of several of them to set
  *         several bits for a given port in a single API call.
  * @retval HAL Status
  */
HAL_StatusTypeDef HAL_PWREx_EnableGPIOPullDown(uint32_t GPIO, uint32_t GPIONumber)
{
20005810:	b480      	push	{r7}
20005812:	b085      	sub	sp, #20
20005814:	af00      	add	r7, sp, #0
20005816:	6078      	str	r0, [r7, #4]
20005818:	6039      	str	r1, [r7, #0]
  HAL_StatusTypeDef status = HAL_OK;
2000581a:	2300      	movs	r3, #0
2000581c:	73fb      	strb	r3, [r7, #15]
2000581e:	687b      	ldr	r3, [r7, #4]
20005820:	2b06      	cmp	r3, #6
20005822:	d87f      	bhi.n	20005924 <HAL_PWREx_EnableGPIOPullDown+0x114>
20005824:	a201      	add	r2, pc, #4	; (adr r2, 2000582c <HAL_PWREx_EnableGPIOPullDown+0x1c>)
20005826:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
2000582a:	bf00      	nop
2000582c:	20005849 	.word	0x20005849
20005830:	2000586d 	.word	0x2000586d
20005834:	2000588d 	.word	0x2000588d
20005838:	200058a9 	.word	0x200058a9
2000583c:	200058c5 	.word	0x200058c5
20005840:	200058e1 	.word	0x200058e1
20005844:	20005901 	.word	0x20005901
  assert_param(IS_PWR_GPIO_BIT_NUMBER(GPIONumber));

  switch (GPIO)
  {
    case PWR_GPIO_A:
       SET_BIT(PWR->PDCRA, (GPIONumber & (~(PWR_GPIO_BIT_13|PWR_GPIO_BIT_15))));
20005848:	4b3b      	ldr	r3, [pc, #236]	; (20005938 <HAL_PWREx_EnableGPIOPullDown+0x128>)
2000584a:	6a5a      	ldr	r2, [r3, #36]	; 0x24
2000584c:	683b      	ldr	r3, [r7, #0]
2000584e:	f423 4320 	bic.w	r3, r3, #40960	; 0xa000
20005852:	4939      	ldr	r1, [pc, #228]	; (20005938 <HAL_PWREx_EnableGPIOPullDown+0x128>)
20005854:	4313      	orrs	r3, r2
20005856:	624b      	str	r3, [r1, #36]	; 0x24
       CLEAR_BIT(PWR->PUCRA, (GPIONumber & (~(PWR_GPIO_BIT_14))));
20005858:	4b37      	ldr	r3, [pc, #220]	; (20005938 <HAL_PWREx_EnableGPIOPullDown+0x128>)
2000585a:	6a1a      	ldr	r2, [r3, #32]
2000585c:	683b      	ldr	r3, [r7, #0]
2000585e:	f423 4380 	bic.w	r3, r3, #16384	; 0x4000
20005862:	43db      	mvns	r3, r3
20005864:	4934      	ldr	r1, [pc, #208]	; (20005938 <HAL_PWREx_EnableGPIOPullDown+0x128>)
20005866:	4013      	ands	r3, r2
20005868:	620b      	str	r3, [r1, #32]
       break;
2000586a:	e05e      	b.n	2000592a <HAL_PWREx_EnableGPIOPullDown+0x11a>
    case PWR_GPIO_B:
       SET_BIT(PWR->PDCRB, (GPIONumber & (~(PWR_GPIO_BIT_4))));
2000586c:	4b32      	ldr	r3, [pc, #200]	; (20005938 <HAL_PWREx_EnableGPIOPullDown+0x128>)
2000586e:	6ada      	ldr	r2, [r3, #44]	; 0x2c
20005870:	683b      	ldr	r3, [r7, #0]
20005872:	f023 0310 	bic.w	r3, r3, #16
20005876:	4930      	ldr	r1, [pc, #192]	; (20005938 <HAL_PWREx_EnableGPIOPullDown+0x128>)
20005878:	4313      	orrs	r3, r2
2000587a:	62cb      	str	r3, [r1, #44]	; 0x2c
       CLEAR_BIT(PWR->PUCRB, GPIONumber);
2000587c:	4b2e      	ldr	r3, [pc, #184]	; (20005938 <HAL_PWREx_EnableGPIOPullDown+0x128>)
2000587e:	6a9a      	ldr	r2, [r3, #40]	; 0x28
20005880:	683b      	ldr	r3, [r7, #0]
20005882:	43db      	mvns	r3, r3
20005884:	492c      	ldr	r1, [pc, #176]	; (20005938 <HAL_PWREx_EnableGPIOPullDown+0x128>)
20005886:	4013      	ands	r3, r2
20005888:	628b      	str	r3, [r1, #40]	; 0x28
       break;
2000588a:	e04e      	b.n	2000592a <HAL_PWREx_EnableGPIOPullDown+0x11a>
    case PWR_GPIO_C:
       SET_BIT(PWR->PDCRC, GPIONumber);
2000588c:	4b2a      	ldr	r3, [pc, #168]	; (20005938 <HAL_PWREx_EnableGPIOPullDown+0x128>)
2000588e:	6b5a      	ldr	r2, [r3, #52]	; 0x34
20005890:	4929      	ldr	r1, [pc, #164]	; (20005938 <HAL_PWREx_EnableGPIOPullDown+0x128>)
20005892:	683b      	ldr	r3, [r7, #0]
20005894:	4313      	orrs	r3, r2
20005896:	634b      	str	r3, [r1, #52]	; 0x34
       CLEAR_BIT(PWR->PUCRC, GPIONumber);
20005898:	4b27      	ldr	r3, [pc, #156]	; (20005938 <HAL_PWREx_EnableGPIOPullDown+0x128>)
2000589a:	6b1a      	ldr	r2, [r3, #48]	; 0x30
2000589c:	683b      	ldr	r3, [r7, #0]
2000589e:	43db      	mvns	r3, r3
200058a0:	4925      	ldr	r1, [pc, #148]	; (20005938 <HAL_PWREx_EnableGPIOPullDown+0x128>)
200058a2:	4013      	ands	r3, r2
200058a4:	630b      	str	r3, [r1, #48]	; 0x30
       break;
200058a6:	e040      	b.n	2000592a <HAL_PWREx_EnableGPIOPullDown+0x11a>
    case PWR_GPIO_D:
       SET_BIT(PWR->PDCRD, GPIONumber);
200058a8:	4b23      	ldr	r3, [pc, #140]	; (20005938 <HAL_PWREx_EnableGPIOPullDown+0x128>)
200058aa:	6bda      	ldr	r2, [r3, #60]	; 0x3c
200058ac:	4922      	ldr	r1, [pc, #136]	; (20005938 <HAL_PWREx_EnableGPIOPullDown+0x128>)
200058ae:	683b      	ldr	r3, [r7, #0]
200058b0:	4313      	orrs	r3, r2
200058b2:	63cb      	str	r3, [r1, #60]	; 0x3c
       CLEAR_BIT(PWR->PUCRD, GPIONumber);
200058b4:	4b20      	ldr	r3, [pc, #128]	; (20005938 <HAL_PWREx_EnableGPIOPullDown+0x128>)
200058b6:	6b9a      	ldr	r2, [r3, #56]	; 0x38
200058b8:	683b      	ldr	r3, [r7, #0]
200058ba:	43db      	mvns	r3, r3
200058bc:	491e      	ldr	r1, [pc, #120]	; (20005938 <HAL_PWREx_EnableGPIOPullDown+0x128>)
200058be:	4013      	ands	r3, r2
200058c0:	638b      	str	r3, [r1, #56]	; 0x38
       break;
200058c2:	e032      	b.n	2000592a <HAL_PWREx_EnableGPIOPullDown+0x11a>
    case PWR_GPIO_E:
       SET_BIT(PWR->PDCRE, GPIONumber);
200058c4:	4b1c      	ldr	r3, [pc, #112]	; (20005938 <HAL_PWREx_EnableGPIOPullDown+0x128>)
200058c6:	6c5a      	ldr	r2, [r3, #68]	; 0x44
200058c8:	491b      	ldr	r1, [pc, #108]	; (20005938 <HAL_PWREx_EnableGPIOPullDown+0x128>)
200058ca:	683b      	ldr	r3, [r7, #0]
200058cc:	4313      	orrs	r3, r2
200058ce:	644b      	str	r3, [r1, #68]	; 0x44
       CLEAR_BIT(PWR->PUCRE, GPIONumber);
200058d0:	4b19      	ldr	r3, [pc, #100]	; (20005938 <HAL_PWREx_EnableGPIOPullDown+0x128>)
200058d2:	6c1a      	ldr	r2, [r3, #64]	; 0x40
200058d4:	683b      	ldr	r3, [r7, #0]
200058d6:	43db      	mvns	r3, r3
200058d8:	4917      	ldr	r1, [pc, #92]	; (20005938 <HAL_PWREx_EnableGPIOPullDown+0x128>)
200058da:	4013      	ands	r3, r2
200058dc:	640b      	str	r3, [r1, #64]	; 0x40
       break;
200058de:	e024      	b.n	2000592a <HAL_PWREx_EnableGPIOPullDown+0x11a>
    case PWR_GPIO_F:
       SET_BIT(PWR->PDCRF, (GPIONumber & PWR_PORTF_AVAILABLE_PINS));
200058e0:	4b15      	ldr	r3, [pc, #84]	; (20005938 <HAL_PWREx_EnableGPIOPullDown+0x128>)
200058e2:	6cda      	ldr	r2, [r3, #76]	; 0x4c
200058e4:	683b      	ldr	r3, [r7, #0]
200058e6:	b29b      	uxth	r3, r3
200058e8:	4913      	ldr	r1, [pc, #76]	; (20005938 <HAL_PWREx_EnableGPIOPullDown+0x128>)
200058ea:	4313      	orrs	r3, r2
200058ec:	64cb      	str	r3, [r1, #76]	; 0x4c
       CLEAR_BIT(PWR->PUCRF, (GPIONumber & PWR_PORTF_AVAILABLE_PINS));
200058ee:	4b12      	ldr	r3, [pc, #72]	; (20005938 <HAL_PWREx_EnableGPIOPullDown+0x128>)
200058f0:	6c9a      	ldr	r2, [r3, #72]	; 0x48
200058f2:	683b      	ldr	r3, [r7, #0]
200058f4:	b29b      	uxth	r3, r3
200058f6:	43db      	mvns	r3, r3
200058f8:	490f      	ldr	r1, [pc, #60]	; (20005938 <HAL_PWREx_EnableGPIOPullDown+0x128>)
200058fa:	4013      	ands	r3, r2
200058fc:	648b      	str	r3, [r1, #72]	; 0x48
       break;
200058fe:	e014      	b.n	2000592a <HAL_PWREx_EnableGPIOPullDown+0x11a>
    case PWR_GPIO_G:
       SET_BIT(PWR->PDCRG, ((GPIONumber & PWR_PORTG_AVAILABLE_PINS) & (~(PWR_GPIO_BIT_10))));
20005900:	4b0d      	ldr	r3, [pc, #52]	; (20005938 <HAL_PWREx_EnableGPIOPullDown+0x128>)
20005902:	6d5a      	ldr	r2, [r3, #84]	; 0x54
20005904:	683b      	ldr	r3, [r7, #0]
20005906:	f3c3 0309 	ubfx	r3, r3, #0, #10
2000590a:	490b      	ldr	r1, [pc, #44]	; (20005938 <HAL_PWREx_EnableGPIOPullDown+0x128>)
2000590c:	4313      	orrs	r3, r2
2000590e:	654b      	str	r3, [r1, #84]	; 0x54
       CLEAR_BIT(PWR->PUCRG, (GPIONumber & PWR_PORTG_AVAILABLE_PINS));
20005910:	4b09      	ldr	r3, [pc, #36]	; (20005938 <HAL_PWREx_EnableGPIOPullDown+0x128>)
20005912:	6d1a      	ldr	r2, [r3, #80]	; 0x50
20005914:	683b      	ldr	r3, [r7, #0]
20005916:	f3c3 030a 	ubfx	r3, r3, #0, #11
2000591a:	43db      	mvns	r3, r3
2000591c:	4906      	ldr	r1, [pc, #24]	; (20005938 <HAL_PWREx_EnableGPIOPullDown+0x128>)
2000591e:	4013      	ands	r3, r2
20005920:	650b      	str	r3, [r1, #80]	; 0x50
       break;
20005922:	e002      	b.n	2000592a <HAL_PWREx_EnableGPIOPullDown+0x11a>
    default:
      status = HAL_ERROR;
20005924:	2301      	movs	r3, #1
20005926:	73fb      	strb	r3, [r7, #15]
      break;
20005928:	bf00      	nop
  }

  return status;
2000592a:	7bfb      	ldrb	r3, [r7, #15]
}
2000592c:	4618      	mov	r0, r3
2000592e:	3714      	adds	r7, #20
20005930:	46bd      	mov	sp, r7
20005932:	f85d 7b04 	ldr.w	r7, [sp], #4
20005936:	4770      	bx	lr
20005938:	40007000 	.word	0x40007000

2000593c <HAL_PWREx_DisableGPIOPullDown>:
  *         I/O pins are available) or the logical OR of several of them to reset
  *         several bits for a given port in a single API call.
  * @retval HAL Status
  */
HAL_StatusTypeDef HAL_PWREx_DisableGPIOPullDown(uint32_t GPIO, uint32_t GPIONumber)
{
2000593c:	b480      	push	{r7}
2000593e:	b085      	sub	sp, #20
20005940:	af00      	add	r7, sp, #0
20005942:	6078      	str	r0, [r7, #4]
20005944:	6039      	str	r1, [r7, #0]
  HAL_StatusTypeDef status = HAL_OK;
20005946:	2300      	movs	r3, #0
20005948:	73fb      	strb	r3, [r7, #15]
2000594a:	687b      	ldr	r3, [r7, #4]
2000594c:	2b06      	cmp	r3, #6
2000594e:	d850      	bhi.n	200059f2 <HAL_PWREx_DisableGPIOPullDown+0xb6>
20005950:	a201      	add	r2, pc, #4	; (adr r2, 20005958 <HAL_PWREx_DisableGPIOPullDown+0x1c>)
20005952:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
20005956:	bf00      	nop
20005958:	20005975 	.word	0x20005975
2000595c:	20005989 	.word	0x20005989
20005960:	2000599d 	.word	0x2000599d
20005964:	200059ad 	.word	0x200059ad
20005968:	200059bd 	.word	0x200059bd
2000596c:	200059cd 	.word	0x200059cd
20005970:	200059df 	.word	0x200059df
  assert_param(IS_PWR_GPIO_BIT_NUMBER(GPIONumber));

  switch (GPIO)
  {
    case PWR_GPIO_A:
       CLEAR_BIT(PWR->PDCRA, (GPIONumber & (~(PWR_GPIO_BIT_13|PWR_GPIO_BIT_15))));
20005974:	4b24      	ldr	r3, [pc, #144]	; (20005a08 <HAL_PWREx_DisableGPIOPullDown+0xcc>)
20005976:	6a5a      	ldr	r2, [r3, #36]	; 0x24
20005978:	683b      	ldr	r3, [r7, #0]
2000597a:	f423 4320 	bic.w	r3, r3, #40960	; 0xa000
2000597e:	43db      	mvns	r3, r3
20005980:	4921      	ldr	r1, [pc, #132]	; (20005a08 <HAL_PWREx_DisableGPIOPullDown+0xcc>)
20005982:	4013      	ands	r3, r2
20005984:	624b      	str	r3, [r1, #36]	; 0x24
       break;
20005986:	e037      	b.n	200059f8 <HAL_PWREx_DisableGPIOPullDown+0xbc>
    case PWR_GPIO_B:
       CLEAR_BIT(PWR->PDCRB, (GPIONumber & (~(PWR_GPIO_BIT_4))));
20005988:	4b1f      	ldr	r3, [pc, #124]	; (20005a08 <HAL_PWREx_DisableGPIOPullDown+0xcc>)
2000598a:	6ada      	ldr	r2, [r3, #44]	; 0x2c
2000598c:	683b      	ldr	r3, [r7, #0]
2000598e:	f023 0310 	bic.w	r3, r3, #16
20005992:	43db      	mvns	r3, r3
20005994:	491c      	ldr	r1, [pc, #112]	; (20005a08 <HAL_PWREx_DisableGPIOPullDown+0xcc>)
20005996:	4013      	ands	r3, r2
20005998:	62cb      	str	r3, [r1, #44]	; 0x2c
       break;
2000599a:	e02d      	b.n	200059f8 <HAL_PWREx_DisableGPIOPullDown+0xbc>
    case PWR_GPIO_C:
       CLEAR_BIT(PWR->PDCRC, GPIONumber);
2000599c:	4b1a      	ldr	r3, [pc, #104]	; (20005a08 <HAL_PWREx_DisableGPIOPullDown+0xcc>)
2000599e:	6b5a      	ldr	r2, [r3, #52]	; 0x34
200059a0:	683b      	ldr	r3, [r7, #0]
200059a2:	43db      	mvns	r3, r3
200059a4:	4918      	ldr	r1, [pc, #96]	; (20005a08 <HAL_PWREx_DisableGPIOPullDown+0xcc>)
200059a6:	4013      	ands	r3, r2
200059a8:	634b      	str	r3, [r1, #52]	; 0x34
       break;
200059aa:	e025      	b.n	200059f8 <HAL_PWREx_DisableGPIOPullDown+0xbc>
    case PWR_GPIO_D:
       CLEAR_BIT(PWR->PDCRD, GPIONumber);
200059ac:	4b16      	ldr	r3, [pc, #88]	; (20005a08 <HAL_PWREx_DisableGPIOPullDown+0xcc>)
200059ae:	6bda      	ldr	r2, [r3, #60]	; 0x3c
200059b0:	683b      	ldr	r3, [r7, #0]
200059b2:	43db      	mvns	r3, r3
200059b4:	4914      	ldr	r1, [pc, #80]	; (20005a08 <HAL_PWREx_DisableGPIOPullDown+0xcc>)
200059b6:	4013      	ands	r3, r2
200059b8:	63cb      	str	r3, [r1, #60]	; 0x3c
       break;
200059ba:	e01d      	b.n	200059f8 <HAL_PWREx_DisableGPIOPullDown+0xbc>
    case PWR_GPIO_E:
       CLEAR_BIT(PWR->PDCRE, GPIONumber);
200059bc:	4b12      	ldr	r3, [pc, #72]	; (20005a08 <HAL_PWREx_DisableGPIOPullDown+0xcc>)
200059be:	6c5a      	ldr	r2, [r3, #68]	; 0x44
200059c0:	683b      	ldr	r3, [r7, #0]
200059c2:	43db      	mvns	r3, r3
200059c4:	4910      	ldr	r1, [pc, #64]	; (20005a08 <HAL_PWREx_DisableGPIOPullDown+0xcc>)
200059c6:	4013      	ands	r3, r2
200059c8:	644b      	str	r3, [r1, #68]	; 0x44
       break;
200059ca:	e015      	b.n	200059f8 <HAL_PWREx_DisableGPIOPullDown+0xbc>
    case PWR_GPIO_F:
       CLEAR_BIT(PWR->PDCRF, (GPIONumber & PWR_PORTF_AVAILABLE_PINS));
200059cc:	4b0e      	ldr	r3, [pc, #56]	; (20005a08 <HAL_PWREx_DisableGPIOPullDown+0xcc>)
200059ce:	6cda      	ldr	r2, [r3, #76]	; 0x4c
200059d0:	683b      	ldr	r3, [r7, #0]
200059d2:	b29b      	uxth	r3, r3
200059d4:	43db      	mvns	r3, r3
200059d6:	490c      	ldr	r1, [pc, #48]	; (20005a08 <HAL_PWREx_DisableGPIOPullDown+0xcc>)
200059d8:	4013      	ands	r3, r2
200059da:	64cb      	str	r3, [r1, #76]	; 0x4c
       break;
200059dc:	e00c      	b.n	200059f8 <HAL_PWREx_DisableGPIOPullDown+0xbc>
    case PWR_GPIO_G:
       CLEAR_BIT(PWR->PDCRG, ((GPIONumber & PWR_PORTG_AVAILABLE_PINS) & (~(PWR_GPIO_BIT_10))));
200059de:	4b0a      	ldr	r3, [pc, #40]	; (20005a08 <HAL_PWREx_DisableGPIOPullDown+0xcc>)
200059e0:	6d5a      	ldr	r2, [r3, #84]	; 0x54
200059e2:	683b      	ldr	r3, [r7, #0]
200059e4:	f3c3 0309 	ubfx	r3, r3, #0, #10
200059e8:	43db      	mvns	r3, r3
200059ea:	4907      	ldr	r1, [pc, #28]	; (20005a08 <HAL_PWREx_DisableGPIOPullDown+0xcc>)
200059ec:	4013      	ands	r3, r2
200059ee:	654b      	str	r3, [r1, #84]	; 0x54
       break;
200059f0:	e002      	b.n	200059f8 <HAL_PWREx_DisableGPIOPullDown+0xbc>
    default:
      status = HAL_ERROR;
200059f2:	2301      	movs	r3, #1
200059f4:	73fb      	strb	r3, [r7, #15]
      break;
200059f6:	bf00      	nop
  }

  return status;
200059f8:	7bfb      	ldrb	r3, [r7, #15]
}
200059fa:	4618      	mov	r0, r3
200059fc:	3714      	adds	r7, #20
200059fe:	46bd      	mov	sp, r7
20005a00:	f85d 7b04 	ldr.w	r7, [sp], #4
20005a04:	4770      	bx	lr
20005a06:	bf00      	nop
20005a08:	40007000 	.word	0x40007000

20005a0c <HAL_PWREx_EnablePullUpPullDownConfig>:
  *        HAL_PWREx_EnableGPIOPullUp() and HAL_PWREx_EnableGPIOPullDown() API's ensure there
  *        is no conflict when setting PUy or PDy bit.
  * @retval None
  */
void HAL_PWREx_EnablePullUpPullDownConfig(void)
{
20005a0c:	b480      	push	{r7}
20005a0e:	af00      	add	r7, sp, #0
  SET_BIT(PWR->CR3, PWR_CR3_APC);
20005a10:	4b05      	ldr	r3, [pc, #20]	; (20005a28 <HAL_PWREx_EnablePullUpPullDownConfig+0x1c>)
20005a12:	689b      	ldr	r3, [r3, #8]
20005a14:	4a04      	ldr	r2, [pc, #16]	; (20005a28 <HAL_PWREx_EnablePullUpPullDownConfig+0x1c>)
20005a16:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
20005a1a:	6093      	str	r3, [r2, #8]
}
20005a1c:	bf00      	nop
20005a1e:	46bd      	mov	sp, r7
20005a20:	f85d 7b04 	ldr.w	r7, [sp], #4
20005a24:	4770      	bx	lr
20005a26:	bf00      	nop
20005a28:	40007000 	.word	0x40007000

20005a2c <HAL_PWREx_DisablePullUpPullDownConfig>:
  * @note  When APC bit is cleared, the I/O pull-up and pull-down configurations defined in
  *        PWR_PUCRx and PWR_PDCRx registers are not applied in Standby and Shutdown modes.
  * @retval None
  */
void HAL_PWREx_DisablePullUpPullDownConfig(void)
{
20005a2c:	b480      	push	{r7}
20005a2e:	af00      	add	r7, sp, #0
  CLEAR_BIT(PWR->CR3, PWR_CR3_APC);
20005a30:	4b05      	ldr	r3, [pc, #20]	; (20005a48 <HAL_PWREx_DisablePullUpPullDownConfig+0x1c>)
20005a32:	689b      	ldr	r3, [r3, #8]
20005a34:	4a04      	ldr	r2, [pc, #16]	; (20005a48 <HAL_PWREx_DisablePullUpPullDownConfig+0x1c>)
20005a36:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
20005a3a:	6093      	str	r3, [r2, #8]
}
20005a3c:	bf00      	nop
20005a3e:	46bd      	mov	sp, r7
20005a40:	f85d 7b04 	ldr.w	r7, [sp], #4
20005a44:	4770      	bx	lr
20005a46:	bf00      	nop
20005a48:	40007000 	.word	0x40007000

20005a4c <HAL_PWREx_EnableSRAM2ContentRetention>:
  * @note  When RRS bit is set, SRAM2 is powered by the low-power regulator in
  *         Standby mode and its content is kept.
  * @retval None
  */
void HAL_PWREx_EnableSRAM2ContentRetention(void)
{
20005a4c:	b480      	push	{r7}
20005a4e:	af00      	add	r7, sp, #0
  SET_BIT(PWR->CR3, PWR_CR3_RRS);
20005a50:	4b05      	ldr	r3, [pc, #20]	; (20005a68 <HAL_PWREx_EnableSRAM2ContentRetention+0x1c>)
20005a52:	689b      	ldr	r3, [r3, #8]
20005a54:	4a04      	ldr	r2, [pc, #16]	; (20005a68 <HAL_PWREx_EnableSRAM2ContentRetention+0x1c>)
20005a56:	f443 7380 	orr.w	r3, r3, #256	; 0x100
20005a5a:	6093      	str	r3, [r2, #8]
}
20005a5c:	bf00      	nop
20005a5e:	46bd      	mov	sp, r7
20005a60:	f85d 7b04 	ldr.w	r7, [sp], #4
20005a64:	4770      	bx	lr
20005a66:	bf00      	nop
20005a68:	40007000 	.word	0x40007000

20005a6c <HAL_PWREx_DisableSRAM2ContentRetention>:
  * @note  When RRS bit is reset, SRAM2 is powered off in Standby mode
  *        and its content is lost.
  * @retval None
  */
void HAL_PWREx_DisableSRAM2ContentRetention(void)
{
20005a6c:	b480      	push	{r7}
20005a6e:	af00      	add	r7, sp, #0
  CLEAR_BIT(PWR->CR3, PWR_CR3_RRS);
20005a70:	4b05      	ldr	r3, [pc, #20]	; (20005a88 <HAL_PWREx_DisableSRAM2ContentRetention+0x1c>)
20005a72:	689b      	ldr	r3, [r3, #8]
20005a74:	4a04      	ldr	r2, [pc, #16]	; (20005a88 <HAL_PWREx_DisableSRAM2ContentRetention+0x1c>)
20005a76:	f423 7380 	bic.w	r3, r3, #256	; 0x100
20005a7a:	6093      	str	r3, [r2, #8]
}
20005a7c:	bf00      	nop
20005a7e:	46bd      	mov	sp, r7
20005a80:	f85d 7b04 	ldr.w	r7, [sp], #4
20005a84:	4770      	bx	lr
20005a86:	bf00      	nop
20005a88:	40007000 	.word	0x40007000

20005a8c <HAL_PWREx_EnablePVM1>:
/**
  * @brief Enable the Power Voltage Monitoring 1: VDDA versus FASTCOMP minimum voltage.
  * @retval None
  */
void HAL_PWREx_EnablePVM1(void)
{
20005a8c:	b480      	push	{r7}
20005a8e:	af00      	add	r7, sp, #0
  SET_BIT(PWR->CR2, PWR_PVM_1);
20005a90:	4b05      	ldr	r3, [pc, #20]	; (20005aa8 <HAL_PWREx_EnablePVM1+0x1c>)
20005a92:	685b      	ldr	r3, [r3, #4]
20005a94:	4a04      	ldr	r2, [pc, #16]	; (20005aa8 <HAL_PWREx_EnablePVM1+0x1c>)
20005a96:	f043 0310 	orr.w	r3, r3, #16
20005a9a:	6053      	str	r3, [r2, #4]
}
20005a9c:	bf00      	nop
20005a9e:	46bd      	mov	sp, r7
20005aa0:	f85d 7b04 	ldr.w	r7, [sp], #4
20005aa4:	4770      	bx	lr
20005aa6:	bf00      	nop
20005aa8:	40007000 	.word	0x40007000

20005aac <HAL_PWREx_DisablePVM1>:
/**
  * @brief Disable the Power Voltage Monitoring 1: VDDA versus FASTCOMP minimum voltage.
  * @retval None
  */
void HAL_PWREx_DisablePVM1(void)
{
20005aac:	b480      	push	{r7}
20005aae:	af00      	add	r7, sp, #0
  CLEAR_BIT(PWR->CR2, PWR_PVM_1);
20005ab0:	4b05      	ldr	r3, [pc, #20]	; (20005ac8 <HAL_PWREx_DisablePVM1+0x1c>)
20005ab2:	685b      	ldr	r3, [r3, #4]
20005ab4:	4a04      	ldr	r2, [pc, #16]	; (20005ac8 <HAL_PWREx_DisablePVM1+0x1c>)
20005ab6:	f023 0310 	bic.w	r3, r3, #16
20005aba:	6053      	str	r3, [r2, #4]
}
20005abc:	bf00      	nop
20005abe:	46bd      	mov	sp, r7
20005ac0:	f85d 7b04 	ldr.w	r7, [sp], #4
20005ac4:	4770      	bx	lr
20005ac6:	bf00      	nop
20005ac8:	40007000 	.word	0x40007000

20005acc <HAL_PWREx_EnablePVM2>:
/**
  * @brief Enable the Power Voltage Monitoring 2: VDDA versus FASTDAC minimum voltage.
  * @retval None
  */
void HAL_PWREx_EnablePVM2(void)
{
20005acc:	b480      	push	{r7}
20005ace:	af00      	add	r7, sp, #0
  SET_BIT(PWR->CR2, PWR_PVM_2);
20005ad0:	4b05      	ldr	r3, [pc, #20]	; (20005ae8 <HAL_PWREx_EnablePVM2+0x1c>)
20005ad2:	685b      	ldr	r3, [r3, #4]
20005ad4:	4a04      	ldr	r2, [pc, #16]	; (20005ae8 <HAL_PWREx_EnablePVM2+0x1c>)
20005ad6:	f043 0320 	orr.w	r3, r3, #32
20005ada:	6053      	str	r3, [r2, #4]
}
20005adc:	bf00      	nop
20005ade:	46bd      	mov	sp, r7
20005ae0:	f85d 7b04 	ldr.w	r7, [sp], #4
20005ae4:	4770      	bx	lr
20005ae6:	bf00      	nop
20005ae8:	40007000 	.word	0x40007000

20005aec <HAL_PWREx_DisablePVM2>:
/**
  * @brief Disable the Power Voltage Monitoring 2: VDDA versus FASTDAC minimum voltage.
  * @retval None
  */
void HAL_PWREx_DisablePVM2(void)
{
20005aec:	b480      	push	{r7}
20005aee:	af00      	add	r7, sp, #0
  CLEAR_BIT(PWR->CR2, PWR_PVM_2);
20005af0:	4b05      	ldr	r3, [pc, #20]	; (20005b08 <HAL_PWREx_DisablePVM2+0x1c>)
20005af2:	685b      	ldr	r3, [r3, #4]
20005af4:	4a04      	ldr	r2, [pc, #16]	; (20005b08 <HAL_PWREx_DisablePVM2+0x1c>)
20005af6:	f023 0320 	bic.w	r3, r3, #32
20005afa:	6053      	str	r3, [r2, #4]
}
20005afc:	bf00      	nop
20005afe:	46bd      	mov	sp, r7
20005b00:	f85d 7b04 	ldr.w	r7, [sp], #4
20005b04:	4770      	bx	lr
20005b06:	bf00      	nop
20005b08:	40007000 	.word	0x40007000

20005b0c <HAL_PWREx_EnablePVM3>:
/**
  * @brief Enable the Power Voltage Monitoring 3: VDDA versus ADC minimum voltage 1.62V.
  * @retval None
  */
void HAL_PWREx_EnablePVM3(void)
{
20005b0c:	b480      	push	{r7}
20005b0e:	af00      	add	r7, sp, #0
  SET_BIT(PWR->CR2, PWR_PVM_3);
20005b10:	4b05      	ldr	r3, [pc, #20]	; (20005b28 <HAL_PWREx_EnablePVM3+0x1c>)
20005b12:	685b      	ldr	r3, [r3, #4]
20005b14:	4a04      	ldr	r2, [pc, #16]	; (20005b28 <HAL_PWREx_EnablePVM3+0x1c>)
20005b16:	f043 0340 	orr.w	r3, r3, #64	; 0x40
20005b1a:	6053      	str	r3, [r2, #4]
}
20005b1c:	bf00      	nop
20005b1e:	46bd      	mov	sp, r7
20005b20:	f85d 7b04 	ldr.w	r7, [sp], #4
20005b24:	4770      	bx	lr
20005b26:	bf00      	nop
20005b28:	40007000 	.word	0x40007000

20005b2c <HAL_PWREx_DisablePVM3>:
/**
  * @brief Disable the Power Voltage Monitoring 3: VDDA versus ADC minimum voltage 1.62V.
  * @retval None
  */
void HAL_PWREx_DisablePVM3(void)
{
20005b2c:	b480      	push	{r7}
20005b2e:	af00      	add	r7, sp, #0
  CLEAR_BIT(PWR->CR2, PWR_PVM_3);
20005b30:	4b05      	ldr	r3, [pc, #20]	; (20005b48 <HAL_PWREx_DisablePVM3+0x1c>)
20005b32:	685b      	ldr	r3, [r3, #4]
20005b34:	4a04      	ldr	r2, [pc, #16]	; (20005b48 <HAL_PWREx_DisablePVM3+0x1c>)
20005b36:	f023 0340 	bic.w	r3, r3, #64	; 0x40
20005b3a:	6053      	str	r3, [r2, #4]
}
20005b3c:	bf00      	nop
20005b3e:	46bd      	mov	sp, r7
20005b40:	f85d 7b04 	ldr.w	r7, [sp], #4
20005b44:	4770      	bx	lr
20005b46:	bf00      	nop
20005b48:	40007000 	.word	0x40007000

20005b4c <HAL_PWREx_EnablePVM4>:
/**
  * @brief Enable the Power Voltage Monitoring 4: VDDA versus OPAMP/DAC minimum voltage 1.8V.
  * @retval None
  */
void HAL_PWREx_EnablePVM4(void)
{
20005b4c:	b480      	push	{r7}
20005b4e:	af00      	add	r7, sp, #0
  SET_BIT(PWR->CR2, PWR_PVM_4);
20005b50:	4b05      	ldr	r3, [pc, #20]	; (20005b68 <HAL_PWREx_EnablePVM4+0x1c>)
20005b52:	685b      	ldr	r3, [r3, #4]
20005b54:	4a04      	ldr	r2, [pc, #16]	; (20005b68 <HAL_PWREx_EnablePVM4+0x1c>)
20005b56:	f043 0380 	orr.w	r3, r3, #128	; 0x80
20005b5a:	6053      	str	r3, [r2, #4]
}
20005b5c:	bf00      	nop
20005b5e:	46bd      	mov	sp, r7
20005b60:	f85d 7b04 	ldr.w	r7, [sp], #4
20005b64:	4770      	bx	lr
20005b66:	bf00      	nop
20005b68:	40007000 	.word	0x40007000

20005b6c <HAL_PWREx_DisablePVM4>:
/**
  * @brief Disable the Power Voltage Monitoring 4: VDDA versus OPAMP/DAC minimum voltage 1.8V.
  * @retval None
  */
void HAL_PWREx_DisablePVM4(void)
{
20005b6c:	b480      	push	{r7}
20005b6e:	af00      	add	r7, sp, #0
  CLEAR_BIT(PWR->CR2, PWR_PVM_4);
20005b70:	4b05      	ldr	r3, [pc, #20]	; (20005b88 <HAL_PWREx_DisablePVM4+0x1c>)
20005b72:	685b      	ldr	r3, [r3, #4]
20005b74:	4a04      	ldr	r2, [pc, #16]	; (20005b88 <HAL_PWREx_DisablePVM4+0x1c>)
20005b76:	f023 0380 	bic.w	r3, r3, #128	; 0x80
20005b7a:	6053      	str	r3, [r2, #4]
}
20005b7c:	bf00      	nop
20005b7e:	46bd      	mov	sp, r7
20005b80:	f85d 7b04 	ldr.w	r7, [sp], #4
20005b84:	4770      	bx	lr
20005b86:	bf00      	nop
20005b88:	40007000 	.word	0x40007000

20005b8c <HAL_PWREx_ConfigPVM>:
  *         more details about the voltage thresholds corresponding to each
  *         detection level and to each monitored supply.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PWREx_ConfigPVM(PWR_PVMTypeDef *sConfigPVM)
{
20005b8c:	b480      	push	{r7}
20005b8e:	b085      	sub	sp, #20
20005b90:	af00      	add	r7, sp, #0
20005b92:	6078      	str	r0, [r7, #4]
  HAL_StatusTypeDef status = HAL_OK;
20005b94:	2300      	movs	r3, #0
20005b96:	73fb      	strb	r3, [r7, #15]


  /* Configure EXTI 35 to 38 interrupts if so required:
     scan through PVMType to detect which PVMx is set and
     configure the corresponding EXTI line accordingly. */
  switch (sConfigPVM->PVMType)
20005b98:	687b      	ldr	r3, [r7, #4]
20005b9a:	681b      	ldr	r3, [r3, #0]
20005b9c:	2b80      	cmp	r3, #128	; 0x80
20005b9e:	f000 80eb 	beq.w	20005d78 <HAL_PWREx_ConfigPVM+0x1ec>
20005ba2:	2b80      	cmp	r3, #128	; 0x80
20005ba4:	f200 8131 	bhi.w	20005e0a <HAL_PWREx_ConfigPVM+0x27e>
20005ba8:	2b40      	cmp	r3, #64	; 0x40
20005baa:	f000 809c 	beq.w	20005ce6 <HAL_PWREx_ConfigPVM+0x15a>
20005bae:	2b40      	cmp	r3, #64	; 0x40
20005bb0:	f200 812b 	bhi.w	20005e0a <HAL_PWREx_ConfigPVM+0x27e>
20005bb4:	2b10      	cmp	r3, #16
20005bb6:	d002      	beq.n	20005bbe <HAL_PWREx_ConfigPVM+0x32>
20005bb8:	2b20      	cmp	r3, #32
20005bba:	d04a      	beq.n	20005c52 <HAL_PWREx_ConfigPVM+0xc6>
20005bbc:	e125      	b.n	20005e0a <HAL_PWREx_ConfigPVM+0x27e>
  {
#if defined(PWR_CR2_PVME1)
    case PWR_PVM_1:
      /* Clear any previous config. Keep it clear if no event or IT mode is selected */
      __HAL_PWR_PVM1_EXTI_DISABLE_EVENT();
20005bbe:	4b9b      	ldr	r3, [pc, #620]	; (20005e2c <HAL_PWREx_ConfigPVM+0x2a0>)
20005bc0:	6a5b      	ldr	r3, [r3, #36]	; 0x24
20005bc2:	4a9a      	ldr	r2, [pc, #616]	; (20005e2c <HAL_PWREx_ConfigPVM+0x2a0>)
20005bc4:	f023 0308 	bic.w	r3, r3, #8
20005bc8:	6253      	str	r3, [r2, #36]	; 0x24
      __HAL_PWR_PVM1_EXTI_DISABLE_IT();
20005bca:	4b98      	ldr	r3, [pc, #608]	; (20005e2c <HAL_PWREx_ConfigPVM+0x2a0>)
20005bcc:	6a1b      	ldr	r3, [r3, #32]
20005bce:	4a97      	ldr	r2, [pc, #604]	; (20005e2c <HAL_PWREx_ConfigPVM+0x2a0>)
20005bd0:	f023 0308 	bic.w	r3, r3, #8
20005bd4:	6213      	str	r3, [r2, #32]
      __HAL_PWR_PVM1_EXTI_DISABLE_FALLING_EDGE();
20005bd6:	4b95      	ldr	r3, [pc, #596]	; (20005e2c <HAL_PWREx_ConfigPVM+0x2a0>)
20005bd8:	6adb      	ldr	r3, [r3, #44]	; 0x2c
20005bda:	4a94      	ldr	r2, [pc, #592]	; (20005e2c <HAL_PWREx_ConfigPVM+0x2a0>)
20005bdc:	f023 0308 	bic.w	r3, r3, #8
20005be0:	62d3      	str	r3, [r2, #44]	; 0x2c
      __HAL_PWR_PVM1_EXTI_DISABLE_RISING_EDGE();
20005be2:	4b92      	ldr	r3, [pc, #584]	; (20005e2c <HAL_PWREx_ConfigPVM+0x2a0>)
20005be4:	6a9b      	ldr	r3, [r3, #40]	; 0x28
20005be6:	4a91      	ldr	r2, [pc, #580]	; (20005e2c <HAL_PWREx_ConfigPVM+0x2a0>)
20005be8:	f023 0308 	bic.w	r3, r3, #8
20005bec:	6293      	str	r3, [r2, #40]	; 0x28

      /* Configure interrupt mode */
      if((sConfigPVM->Mode & PVM_MODE_IT) == PVM_MODE_IT)
20005bee:	687b      	ldr	r3, [r7, #4]
20005bf0:	685b      	ldr	r3, [r3, #4]
20005bf2:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
20005bf6:	2b00      	cmp	r3, #0
20005bf8:	d005      	beq.n	20005c06 <HAL_PWREx_ConfigPVM+0x7a>
      {
        __HAL_PWR_PVM1_EXTI_ENABLE_IT();
20005bfa:	4b8c      	ldr	r3, [pc, #560]	; (20005e2c <HAL_PWREx_ConfigPVM+0x2a0>)
20005bfc:	6a1b      	ldr	r3, [r3, #32]
20005bfe:	4a8b      	ldr	r2, [pc, #556]	; (20005e2c <HAL_PWREx_ConfigPVM+0x2a0>)
20005c00:	f043 0308 	orr.w	r3, r3, #8
20005c04:	6213      	str	r3, [r2, #32]
      }

      /* Configure event mode */
      if((sConfigPVM->Mode & PVM_MODE_EVT) == PVM_MODE_EVT)
20005c06:	687b      	ldr	r3, [r7, #4]
20005c08:	685b      	ldr	r3, [r3, #4]
20005c0a:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
20005c0e:	2b00      	cmp	r3, #0
20005c10:	d005      	beq.n	20005c1e <HAL_PWREx_ConfigPVM+0x92>
      {
        __HAL_PWR_PVM1_EXTI_ENABLE_EVENT();
20005c12:	4b86      	ldr	r3, [pc, #536]	; (20005e2c <HAL_PWREx_ConfigPVM+0x2a0>)
20005c14:	6a5b      	ldr	r3, [r3, #36]	; 0x24
20005c16:	4a85      	ldr	r2, [pc, #532]	; (20005e2c <HAL_PWREx_ConfigPVM+0x2a0>)
20005c18:	f043 0308 	orr.w	r3, r3, #8
20005c1c:	6253      	str	r3, [r2, #36]	; 0x24
      }

      /* Configure the edge */
      if((sConfigPVM->Mode & PVM_RISING_EDGE) == PVM_RISING_EDGE)
20005c1e:	687b      	ldr	r3, [r7, #4]
20005c20:	685b      	ldr	r3, [r3, #4]
20005c22:	f003 0301 	and.w	r3, r3, #1
20005c26:	2b00      	cmp	r3, #0
20005c28:	d005      	beq.n	20005c36 <HAL_PWREx_ConfigPVM+0xaa>
      {
        __HAL_PWR_PVM1_EXTI_ENABLE_RISING_EDGE();
20005c2a:	4b80      	ldr	r3, [pc, #512]	; (20005e2c <HAL_PWREx_ConfigPVM+0x2a0>)
20005c2c:	6a9b      	ldr	r3, [r3, #40]	; 0x28
20005c2e:	4a7f      	ldr	r2, [pc, #508]	; (20005e2c <HAL_PWREx_ConfigPVM+0x2a0>)
20005c30:	f043 0308 	orr.w	r3, r3, #8
20005c34:	6293      	str	r3, [r2, #40]	; 0x28
      }

      if((sConfigPVM->Mode & PVM_FALLING_EDGE) == PVM_FALLING_EDGE)
20005c36:	687b      	ldr	r3, [r7, #4]
20005c38:	685b      	ldr	r3, [r3, #4]
20005c3a:	f003 0302 	and.w	r3, r3, #2
20005c3e:	2b00      	cmp	r3, #0
20005c40:	f000 80e6 	beq.w	20005e10 <HAL_PWREx_ConfigPVM+0x284>
      {
        __HAL_PWR_PVM1_EXTI_ENABLE_FALLING_EDGE();
20005c44:	4b79      	ldr	r3, [pc, #484]	; (20005e2c <HAL_PWREx_ConfigPVM+0x2a0>)
20005c46:	6adb      	ldr	r3, [r3, #44]	; 0x2c
20005c48:	4a78      	ldr	r2, [pc, #480]	; (20005e2c <HAL_PWREx_ConfigPVM+0x2a0>)
20005c4a:	f043 0308 	orr.w	r3, r3, #8
20005c4e:	62d3      	str	r3, [r2, #44]	; 0x2c
      }
      break;
20005c50:	e0de      	b.n	20005e10 <HAL_PWREx_ConfigPVM+0x284>
#endif /* PWR_CR2_PVME1 */

#if defined(PWR_CR2_PVME2)
    case PWR_PVM_2:
      /* Clear any previous config. Keep it clear if no event or IT mode is selected */
      __HAL_PWR_PVM2_EXTI_DISABLE_EVENT();
20005c52:	4b76      	ldr	r3, [pc, #472]	; (20005e2c <HAL_PWREx_ConfigPVM+0x2a0>)
20005c54:	6a5b      	ldr	r3, [r3, #36]	; 0x24
20005c56:	4a75      	ldr	r2, [pc, #468]	; (20005e2c <HAL_PWREx_ConfigPVM+0x2a0>)
20005c58:	f023 0310 	bic.w	r3, r3, #16
20005c5c:	6253      	str	r3, [r2, #36]	; 0x24
      __HAL_PWR_PVM2_EXTI_DISABLE_IT();
20005c5e:	4b73      	ldr	r3, [pc, #460]	; (20005e2c <HAL_PWREx_ConfigPVM+0x2a0>)
20005c60:	6a1b      	ldr	r3, [r3, #32]
20005c62:	4a72      	ldr	r2, [pc, #456]	; (20005e2c <HAL_PWREx_ConfigPVM+0x2a0>)
20005c64:	f023 0310 	bic.w	r3, r3, #16
20005c68:	6213      	str	r3, [r2, #32]
      __HAL_PWR_PVM2_EXTI_DISABLE_FALLING_EDGE();
20005c6a:	4b70      	ldr	r3, [pc, #448]	; (20005e2c <HAL_PWREx_ConfigPVM+0x2a0>)
20005c6c:	6adb      	ldr	r3, [r3, #44]	; 0x2c
20005c6e:	4a6f      	ldr	r2, [pc, #444]	; (20005e2c <HAL_PWREx_ConfigPVM+0x2a0>)
20005c70:	f023 0310 	bic.w	r3, r3, #16
20005c74:	62d3      	str	r3, [r2, #44]	; 0x2c
      __HAL_PWR_PVM2_EXTI_DISABLE_RISING_EDGE();
20005c76:	4b6d      	ldr	r3, [pc, #436]	; (20005e2c <HAL_PWREx_ConfigPVM+0x2a0>)
20005c78:	6a9b      	ldr	r3, [r3, #40]	; 0x28
20005c7a:	4a6c      	ldr	r2, [pc, #432]	; (20005e2c <HAL_PWREx_ConfigPVM+0x2a0>)
20005c7c:	f023 0310 	bic.w	r3, r3, #16
20005c80:	6293      	str	r3, [r2, #40]	; 0x28

      /* Configure interrupt mode */
      if((sConfigPVM->Mode & PVM_MODE_IT) == PVM_MODE_IT)
20005c82:	687b      	ldr	r3, [r7, #4]
20005c84:	685b      	ldr	r3, [r3, #4]
20005c86:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
20005c8a:	2b00      	cmp	r3, #0
20005c8c:	d005      	beq.n	20005c9a <HAL_PWREx_ConfigPVM+0x10e>
      {
        __HAL_PWR_PVM2_EXTI_ENABLE_IT();
20005c8e:	4b67      	ldr	r3, [pc, #412]	; (20005e2c <HAL_PWREx_ConfigPVM+0x2a0>)
20005c90:	6a1b      	ldr	r3, [r3, #32]
20005c92:	4a66      	ldr	r2, [pc, #408]	; (20005e2c <HAL_PWREx_ConfigPVM+0x2a0>)
20005c94:	f043 0310 	orr.w	r3, r3, #16
20005c98:	6213      	str	r3, [r2, #32]
      }

      /* Configure event mode */
      if((sConfigPVM->Mode & PVM_MODE_EVT) == PVM_MODE_EVT)
20005c9a:	687b      	ldr	r3, [r7, #4]
20005c9c:	685b      	ldr	r3, [r3, #4]
20005c9e:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
20005ca2:	2b00      	cmp	r3, #0
20005ca4:	d005      	beq.n	20005cb2 <HAL_PWREx_ConfigPVM+0x126>
      {
        __HAL_PWR_PVM2_EXTI_ENABLE_EVENT();
20005ca6:	4b61      	ldr	r3, [pc, #388]	; (20005e2c <HAL_PWREx_ConfigPVM+0x2a0>)
20005ca8:	6a5b      	ldr	r3, [r3, #36]	; 0x24
20005caa:	4a60      	ldr	r2, [pc, #384]	; (20005e2c <HAL_PWREx_ConfigPVM+0x2a0>)
20005cac:	f043 0310 	orr.w	r3, r3, #16
20005cb0:	6253      	str	r3, [r2, #36]	; 0x24
      }

      /* Configure the edge */
      if((sConfigPVM->Mode & PVM_RISING_EDGE) == PVM_RISING_EDGE)
20005cb2:	687b      	ldr	r3, [r7, #4]
20005cb4:	685b      	ldr	r3, [r3, #4]
20005cb6:	f003 0301 	and.w	r3, r3, #1
20005cba:	2b00      	cmp	r3, #0
20005cbc:	d005      	beq.n	20005cca <HAL_PWREx_ConfigPVM+0x13e>
      {
        __HAL_PWR_PVM2_EXTI_ENABLE_RISING_EDGE();
20005cbe:	4b5b      	ldr	r3, [pc, #364]	; (20005e2c <HAL_PWREx_ConfigPVM+0x2a0>)
20005cc0:	6a9b      	ldr	r3, [r3, #40]	; 0x28
20005cc2:	4a5a      	ldr	r2, [pc, #360]	; (20005e2c <HAL_PWREx_ConfigPVM+0x2a0>)
20005cc4:	f043 0310 	orr.w	r3, r3, #16
20005cc8:	6293      	str	r3, [r2, #40]	; 0x28
      }

      if((sConfigPVM->Mode & PVM_FALLING_EDGE) == PVM_FALLING_EDGE)
20005cca:	687b      	ldr	r3, [r7, #4]
20005ccc:	685b      	ldr	r3, [r3, #4]
20005cce:	f003 0302 	and.w	r3, r3, #2
20005cd2:	2b00      	cmp	r3, #0
20005cd4:	f000 809e 	beq.w	20005e14 <HAL_PWREx_ConfigPVM+0x288>
      {
        __HAL_PWR_PVM2_EXTI_ENABLE_FALLING_EDGE();
20005cd8:	4b54      	ldr	r3, [pc, #336]	; (20005e2c <HAL_PWREx_ConfigPVM+0x2a0>)
20005cda:	6adb      	ldr	r3, [r3, #44]	; 0x2c
20005cdc:	4a53      	ldr	r2, [pc, #332]	; (20005e2c <HAL_PWREx_ConfigPVM+0x2a0>)
20005cde:	f043 0310 	orr.w	r3, r3, #16
20005ce2:	62d3      	str	r3, [r2, #44]	; 0x2c
      }
      break;
20005ce4:	e096      	b.n	20005e14 <HAL_PWREx_ConfigPVM+0x288>
#endif /* PWR_CR2_PVME2 */

    case PWR_PVM_3:
      /* Clear any previous config. Keep it clear if no event or IT mode is selected */
      __HAL_PWR_PVM3_EXTI_DISABLE_EVENT();
20005ce6:	4b51      	ldr	r3, [pc, #324]	; (20005e2c <HAL_PWREx_ConfigPVM+0x2a0>)
20005ce8:	6a5b      	ldr	r3, [r3, #36]	; 0x24
20005cea:	4a50      	ldr	r2, [pc, #320]	; (20005e2c <HAL_PWREx_ConfigPVM+0x2a0>)
20005cec:	f023 0320 	bic.w	r3, r3, #32
20005cf0:	6253      	str	r3, [r2, #36]	; 0x24
      __HAL_PWR_PVM3_EXTI_DISABLE_IT();
20005cf2:	4b4e      	ldr	r3, [pc, #312]	; (20005e2c <HAL_PWREx_ConfigPVM+0x2a0>)
20005cf4:	6a1b      	ldr	r3, [r3, #32]
20005cf6:	4a4d      	ldr	r2, [pc, #308]	; (20005e2c <HAL_PWREx_ConfigPVM+0x2a0>)
20005cf8:	f023 0320 	bic.w	r3, r3, #32
20005cfc:	6213      	str	r3, [r2, #32]
      __HAL_PWR_PVM3_EXTI_DISABLE_FALLING_EDGE();
20005cfe:	4b4b      	ldr	r3, [pc, #300]	; (20005e2c <HAL_PWREx_ConfigPVM+0x2a0>)
20005d00:	6adb      	ldr	r3, [r3, #44]	; 0x2c
20005d02:	4a4a      	ldr	r2, [pc, #296]	; (20005e2c <HAL_PWREx_ConfigPVM+0x2a0>)
20005d04:	f023 0320 	bic.w	r3, r3, #32
20005d08:	62d3      	str	r3, [r2, #44]	; 0x2c
      __HAL_PWR_PVM3_EXTI_DISABLE_RISING_EDGE();
20005d0a:	4b48      	ldr	r3, [pc, #288]	; (20005e2c <HAL_PWREx_ConfigPVM+0x2a0>)
20005d0c:	6a9b      	ldr	r3, [r3, #40]	; 0x28
20005d0e:	4a47      	ldr	r2, [pc, #284]	; (20005e2c <HAL_PWREx_ConfigPVM+0x2a0>)
20005d10:	f023 0320 	bic.w	r3, r3, #32
20005d14:	6293      	str	r3, [r2, #40]	; 0x28

      /* Configure interrupt mode */
      if((sConfigPVM->Mode & PVM_MODE_IT) == PVM_MODE_IT)
20005d16:	687b      	ldr	r3, [r7, #4]
20005d18:	685b      	ldr	r3, [r3, #4]
20005d1a:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
20005d1e:	2b00      	cmp	r3, #0
20005d20:	d005      	beq.n	20005d2e <HAL_PWREx_ConfigPVM+0x1a2>
      {
        __HAL_PWR_PVM3_EXTI_ENABLE_IT();
20005d22:	4b42      	ldr	r3, [pc, #264]	; (20005e2c <HAL_PWREx_ConfigPVM+0x2a0>)
20005d24:	6a1b      	ldr	r3, [r3, #32]
20005d26:	4a41      	ldr	r2, [pc, #260]	; (20005e2c <HAL_PWREx_ConfigPVM+0x2a0>)
20005d28:	f043 0320 	orr.w	r3, r3, #32
20005d2c:	6213      	str	r3, [r2, #32]
      }

      /* Configure event mode */
      if((sConfigPVM->Mode & PVM_MODE_EVT) == PVM_MODE_EVT)
20005d2e:	687b      	ldr	r3, [r7, #4]
20005d30:	685b      	ldr	r3, [r3, #4]
20005d32:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
20005d36:	2b00      	cmp	r3, #0
20005d38:	d005      	beq.n	20005d46 <HAL_PWREx_ConfigPVM+0x1ba>
      {
        __HAL_PWR_PVM3_EXTI_ENABLE_EVENT();
20005d3a:	4b3c      	ldr	r3, [pc, #240]	; (20005e2c <HAL_PWREx_ConfigPVM+0x2a0>)
20005d3c:	6a5b      	ldr	r3, [r3, #36]	; 0x24
20005d3e:	4a3b      	ldr	r2, [pc, #236]	; (20005e2c <HAL_PWREx_ConfigPVM+0x2a0>)
20005d40:	f043 0320 	orr.w	r3, r3, #32
20005d44:	6253      	str	r3, [r2, #36]	; 0x24
      }

      /* Configure the edge */
      if((sConfigPVM->Mode & PVM_RISING_EDGE) == PVM_RISING_EDGE)
20005d46:	687b      	ldr	r3, [r7, #4]
20005d48:	685b      	ldr	r3, [r3, #4]
20005d4a:	f003 0301 	and.w	r3, r3, #1
20005d4e:	2b00      	cmp	r3, #0
20005d50:	d005      	beq.n	20005d5e <HAL_PWREx_ConfigPVM+0x1d2>
      {
        __HAL_PWR_PVM3_EXTI_ENABLE_RISING_EDGE();
20005d52:	4b36      	ldr	r3, [pc, #216]	; (20005e2c <HAL_PWREx_ConfigPVM+0x2a0>)
20005d54:	6a9b      	ldr	r3, [r3, #40]	; 0x28
20005d56:	4a35      	ldr	r2, [pc, #212]	; (20005e2c <HAL_PWREx_ConfigPVM+0x2a0>)
20005d58:	f043 0320 	orr.w	r3, r3, #32
20005d5c:	6293      	str	r3, [r2, #40]	; 0x28
      }

      if((sConfigPVM->Mode & PVM_FALLING_EDGE) == PVM_FALLING_EDGE)
20005d5e:	687b      	ldr	r3, [r7, #4]
20005d60:	685b      	ldr	r3, [r3, #4]
20005d62:	f003 0302 	and.w	r3, r3, #2
20005d66:	2b00      	cmp	r3, #0
20005d68:	d056      	beq.n	20005e18 <HAL_PWREx_ConfigPVM+0x28c>
      {
        __HAL_PWR_PVM3_EXTI_ENABLE_FALLING_EDGE();
20005d6a:	4b30      	ldr	r3, [pc, #192]	; (20005e2c <HAL_PWREx_ConfigPVM+0x2a0>)
20005d6c:	6adb      	ldr	r3, [r3, #44]	; 0x2c
20005d6e:	4a2f      	ldr	r2, [pc, #188]	; (20005e2c <HAL_PWREx_ConfigPVM+0x2a0>)
20005d70:	f043 0320 	orr.w	r3, r3, #32
20005d74:	62d3      	str	r3, [r2, #44]	; 0x2c
      }
      break;
20005d76:	e04f      	b.n	20005e18 <HAL_PWREx_ConfigPVM+0x28c>

    case PWR_PVM_4:
      /* Clear any previous config. Keep it clear if no event or IT mode is selected */
      __HAL_PWR_PVM4_EXTI_DISABLE_EVENT();
20005d78:	4b2c      	ldr	r3, [pc, #176]	; (20005e2c <HAL_PWREx_ConfigPVM+0x2a0>)
20005d7a:	6a5b      	ldr	r3, [r3, #36]	; 0x24
20005d7c:	4a2b      	ldr	r2, [pc, #172]	; (20005e2c <HAL_PWREx_ConfigPVM+0x2a0>)
20005d7e:	f023 0340 	bic.w	r3, r3, #64	; 0x40
20005d82:	6253      	str	r3, [r2, #36]	; 0x24
      __HAL_PWR_PVM4_EXTI_DISABLE_IT();
20005d84:	4b29      	ldr	r3, [pc, #164]	; (20005e2c <HAL_PWREx_ConfigPVM+0x2a0>)
20005d86:	6a1b      	ldr	r3, [r3, #32]
20005d88:	4a28      	ldr	r2, [pc, #160]	; (20005e2c <HAL_PWREx_ConfigPVM+0x2a0>)
20005d8a:	f023 0340 	bic.w	r3, r3, #64	; 0x40
20005d8e:	6213      	str	r3, [r2, #32]
      __HAL_PWR_PVM4_EXTI_DISABLE_FALLING_EDGE();
20005d90:	4b26      	ldr	r3, [pc, #152]	; (20005e2c <HAL_PWREx_ConfigPVM+0x2a0>)
20005d92:	6adb      	ldr	r3, [r3, #44]	; 0x2c
20005d94:	4a25      	ldr	r2, [pc, #148]	; (20005e2c <HAL_PWREx_ConfigPVM+0x2a0>)
20005d96:	f023 0340 	bic.w	r3, r3, #64	; 0x40
20005d9a:	62d3      	str	r3, [r2, #44]	; 0x2c
      __HAL_PWR_PVM4_EXTI_DISABLE_RISING_EDGE();
20005d9c:	4b23      	ldr	r3, [pc, #140]	; (20005e2c <HAL_PWREx_ConfigPVM+0x2a0>)
20005d9e:	6a9b      	ldr	r3, [r3, #40]	; 0x28
20005da0:	4a22      	ldr	r2, [pc, #136]	; (20005e2c <HAL_PWREx_ConfigPVM+0x2a0>)
20005da2:	f023 0340 	bic.w	r3, r3, #64	; 0x40
20005da6:	6293      	str	r3, [r2, #40]	; 0x28

      /* Configure interrupt mode */
      if((sConfigPVM->Mode & PVM_MODE_IT) == PVM_MODE_IT)
20005da8:	687b      	ldr	r3, [r7, #4]
20005daa:	685b      	ldr	r3, [r3, #4]
20005dac:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
20005db0:	2b00      	cmp	r3, #0
20005db2:	d005      	beq.n	20005dc0 <HAL_PWREx_ConfigPVM+0x234>
      {
        __HAL_PWR_PVM4_EXTI_ENABLE_IT();
20005db4:	4b1d      	ldr	r3, [pc, #116]	; (20005e2c <HAL_PWREx_ConfigPVM+0x2a0>)
20005db6:	6a1b      	ldr	r3, [r3, #32]
20005db8:	4a1c      	ldr	r2, [pc, #112]	; (20005e2c <HAL_PWREx_ConfigPVM+0x2a0>)
20005dba:	f043 0340 	orr.w	r3, r3, #64	; 0x40
20005dbe:	6213      	str	r3, [r2, #32]
      }

      /* Configure event mode */
      if((sConfigPVM->Mode & PVM_MODE_EVT) == PVM_MODE_EVT)
20005dc0:	687b      	ldr	r3, [r7, #4]
20005dc2:	685b      	ldr	r3, [r3, #4]
20005dc4:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
20005dc8:	2b00      	cmp	r3, #0
20005dca:	d005      	beq.n	20005dd8 <HAL_PWREx_ConfigPVM+0x24c>
      {
        __HAL_PWR_PVM4_EXTI_ENABLE_EVENT();
20005dcc:	4b17      	ldr	r3, [pc, #92]	; (20005e2c <HAL_PWREx_ConfigPVM+0x2a0>)
20005dce:	6a5b      	ldr	r3, [r3, #36]	; 0x24
20005dd0:	4a16      	ldr	r2, [pc, #88]	; (20005e2c <HAL_PWREx_ConfigPVM+0x2a0>)
20005dd2:	f043 0340 	orr.w	r3, r3, #64	; 0x40
20005dd6:	6253      	str	r3, [r2, #36]	; 0x24
      }

      /* Configure the edge */
      if((sConfigPVM->Mode & PVM_RISING_EDGE) == PVM_RISING_EDGE)
20005dd8:	687b      	ldr	r3, [r7, #4]
20005dda:	685b      	ldr	r3, [r3, #4]
20005ddc:	f003 0301 	and.w	r3, r3, #1
20005de0:	2b00      	cmp	r3, #0
20005de2:	d005      	beq.n	20005df0 <HAL_PWREx_ConfigPVM+0x264>
      {
        __HAL_PWR_PVM4_EXTI_ENABLE_RISING_EDGE();
20005de4:	4b11      	ldr	r3, [pc, #68]	; (20005e2c <HAL_PWREx_ConfigPVM+0x2a0>)
20005de6:	6a9b      	ldr	r3, [r3, #40]	; 0x28
20005de8:	4a10      	ldr	r2, [pc, #64]	; (20005e2c <HAL_PWREx_ConfigPVM+0x2a0>)
20005dea:	f043 0340 	orr.w	r3, r3, #64	; 0x40
20005dee:	6293      	str	r3, [r2, #40]	; 0x28
      }

      if((sConfigPVM->Mode & PVM_FALLING_EDGE) == PVM_FALLING_EDGE)
20005df0:	687b      	ldr	r3, [r7, #4]
20005df2:	685b      	ldr	r3, [r3, #4]
20005df4:	f003 0302 	and.w	r3, r3, #2
20005df8:	2b00      	cmp	r3, #0
20005dfa:	d00f      	beq.n	20005e1c <HAL_PWREx_ConfigPVM+0x290>
      {
        __HAL_PWR_PVM4_EXTI_ENABLE_FALLING_EDGE();
20005dfc:	4b0b      	ldr	r3, [pc, #44]	; (20005e2c <HAL_PWREx_ConfigPVM+0x2a0>)
20005dfe:	6adb      	ldr	r3, [r3, #44]	; 0x2c
20005e00:	4a0a      	ldr	r2, [pc, #40]	; (20005e2c <HAL_PWREx_ConfigPVM+0x2a0>)
20005e02:	f043 0340 	orr.w	r3, r3, #64	; 0x40
20005e06:	62d3      	str	r3, [r2, #44]	; 0x2c
      }
      break;
20005e08:	e008      	b.n	20005e1c <HAL_PWREx_ConfigPVM+0x290>

    default:
      status = HAL_ERROR;
20005e0a:	2301      	movs	r3, #1
20005e0c:	73fb      	strb	r3, [r7, #15]
      break;
20005e0e:	e006      	b.n	20005e1e <HAL_PWREx_ConfigPVM+0x292>
      break;
20005e10:	bf00      	nop
20005e12:	e004      	b.n	20005e1e <HAL_PWREx_ConfigPVM+0x292>
      break;
20005e14:	bf00      	nop
20005e16:	e002      	b.n	20005e1e <HAL_PWREx_ConfigPVM+0x292>
      break;
20005e18:	bf00      	nop
20005e1a:	e000      	b.n	20005e1e <HAL_PWREx_ConfigPVM+0x292>
      break;
20005e1c:	bf00      	nop
  }

  return status;
20005e1e:	7bfb      	ldrb	r3, [r7, #15]
}
20005e20:	4618      	mov	r0, r3
20005e22:	3714      	adds	r7, #20
20005e24:	46bd      	mov	sp, r7
20005e26:	f85d 7b04 	ldr.w	r7, [sp], #4
20005e2a:	4770      	bx	lr
20005e2c:	40010400 	.word	0x40010400

20005e30 <HAL_PWREx_EnableLowPowerRunMode>:
  *        Setting RUN_PD in FLASH_ACR then appropriately reducing the clock frequency must
  *        be done before calling HAL_PWREx_EnableLowPowerRunMode() API.
  * @retval None
  */
void HAL_PWREx_EnableLowPowerRunMode(void)
{
20005e30:	b480      	push	{r7}
20005e32:	af00      	add	r7, sp, #0
  /* Set Regulator parameter */
  SET_BIT(PWR->CR1, PWR_CR1_LPR);
20005e34:	4b05      	ldr	r3, [pc, #20]	; (20005e4c <HAL_PWREx_EnableLowPowerRunMode+0x1c>)
20005e36:	681b      	ldr	r3, [r3, #0]
20005e38:	4a04      	ldr	r2, [pc, #16]	; (20005e4c <HAL_PWREx_EnableLowPowerRunMode+0x1c>)
20005e3a:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
20005e3e:	6013      	str	r3, [r2, #0]
}
20005e40:	bf00      	nop
20005e42:	46bd      	mov	sp, r7
20005e44:	f85d 7b04 	ldr.w	r7, [sp], #4
20005e48:	4770      	bx	lr
20005e4a:	bf00      	nop
20005e4c:	40007000 	.word	0x40007000

20005e50 <HAL_PWREx_DisableLowPowerRunMode>:
  *        returns HAL_TIMEOUT status). The system clock frequency can then be
  *        increased above 2 MHz.
  * @retval HAL Status
  */
HAL_StatusTypeDef HAL_PWREx_DisableLowPowerRunMode(void)
{
20005e50:	b480      	push	{r7}
20005e52:	b083      	sub	sp, #12
20005e54:	af00      	add	r7, sp, #0
  uint32_t wait_loop_index;

  /* Clear LPR bit */
  CLEAR_BIT(PWR->CR1, PWR_CR1_LPR);
20005e56:	4b17      	ldr	r3, [pc, #92]	; (20005eb4 <HAL_PWREx_DisableLowPowerRunMode+0x64>)
20005e58:	681b      	ldr	r3, [r3, #0]
20005e5a:	4a16      	ldr	r2, [pc, #88]	; (20005eb4 <HAL_PWREx_DisableLowPowerRunMode+0x64>)
20005e5c:	f423 4380 	bic.w	r3, r3, #16384	; 0x4000
20005e60:	6013      	str	r3, [r2, #0]

  /* Wait until REGLPF is reset */
  wait_loop_index = (PWR_FLAG_SETTING_DELAY_US * (SystemCoreClock / 1000000U));
20005e62:	4b15      	ldr	r3, [pc, #84]	; (20005eb8 <HAL_PWREx_DisableLowPowerRunMode+0x68>)
20005e64:	681b      	ldr	r3, [r3, #0]
20005e66:	4a15      	ldr	r2, [pc, #84]	; (20005ebc <HAL_PWREx_DisableLowPowerRunMode+0x6c>)
20005e68:	fba2 2303 	umull	r2, r3, r2, r3
20005e6c:	0c9b      	lsrs	r3, r3, #18
20005e6e:	2232      	movs	r2, #50	; 0x32
20005e70:	fb02 f303 	mul.w	r3, r2, r3
20005e74:	607b      	str	r3, [r7, #4]
  while ((HAL_IS_BIT_SET(PWR->SR2, PWR_SR2_REGLPF)) && (wait_loop_index != 0U))
20005e76:	e002      	b.n	20005e7e <HAL_PWREx_DisableLowPowerRunMode+0x2e>
  {
    wait_loop_index--;
20005e78:	687b      	ldr	r3, [r7, #4]
20005e7a:	3b01      	subs	r3, #1
20005e7c:	607b      	str	r3, [r7, #4]
  while ((HAL_IS_BIT_SET(PWR->SR2, PWR_SR2_REGLPF)) && (wait_loop_index != 0U))
20005e7e:	4b0d      	ldr	r3, [pc, #52]	; (20005eb4 <HAL_PWREx_DisableLowPowerRunMode+0x64>)
20005e80:	695b      	ldr	r3, [r3, #20]
20005e82:	f403 7300 	and.w	r3, r3, #512	; 0x200
20005e86:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
20005e8a:	d102      	bne.n	20005e92 <HAL_PWREx_DisableLowPowerRunMode+0x42>
20005e8c:	687b      	ldr	r3, [r7, #4]
20005e8e:	2b00      	cmp	r3, #0
20005e90:	d1f2      	bne.n	20005e78 <HAL_PWREx_DisableLowPowerRunMode+0x28>
  }
  if (HAL_IS_BIT_SET(PWR->SR2, PWR_SR2_REGLPF))
20005e92:	4b08      	ldr	r3, [pc, #32]	; (20005eb4 <HAL_PWREx_DisableLowPowerRunMode+0x64>)
20005e94:	695b      	ldr	r3, [r3, #20]
20005e96:	f403 7300 	and.w	r3, r3, #512	; 0x200
20005e9a:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
20005e9e:	d101      	bne.n	20005ea4 <HAL_PWREx_DisableLowPowerRunMode+0x54>
  {
    return HAL_TIMEOUT;
20005ea0:	2303      	movs	r3, #3
20005ea2:	e000      	b.n	20005ea6 <HAL_PWREx_DisableLowPowerRunMode+0x56>
  }

  return HAL_OK;
20005ea4:	2300      	movs	r3, #0
}
20005ea6:	4618      	mov	r0, r3
20005ea8:	370c      	adds	r7, #12
20005eaa:	46bd      	mov	sp, r7
20005eac:	f85d 7b04 	ldr.w	r7, [sp], #4
20005eb0:	4770      	bx	lr
20005eb2:	bf00      	nop
20005eb4:	40007000 	.word	0x40007000
20005eb8:	200003f0 	.word	0x200003f0
20005ebc:	431bde83 	.word	0x431bde83

20005ec0 <HAL_PWREx_EnterSTOP0Mode>:
  *            @arg @ref PWR_STOPENTRY_WFI  Enter Stop mode with WFI instruction
  *            @arg @ref PWR_STOPENTRY_WFE  Enter Stop mode with WFE instruction
  * @retval None
  */
void HAL_PWREx_EnterSTOP0Mode(uint8_t STOPEntry)
{
20005ec0:	b480      	push	{r7}
20005ec2:	b083      	sub	sp, #12
20005ec4:	af00      	add	r7, sp, #0
20005ec6:	4603      	mov	r3, r0
20005ec8:	71fb      	strb	r3, [r7, #7]
  /* Check the parameters */
  assert_param(IS_PWR_STOP_ENTRY(STOPEntry));

  /* Stop 0 mode with Main Regulator */
  MODIFY_REG(PWR->CR1, PWR_CR1_LPMS, PWR_CR1_LPMS_STOP0);
20005eca:	4b10      	ldr	r3, [pc, #64]	; (20005f0c <HAL_PWREx_EnterSTOP0Mode+0x4c>)
20005ecc:	681b      	ldr	r3, [r3, #0]
20005ece:	4a0f      	ldr	r2, [pc, #60]	; (20005f0c <HAL_PWREx_EnterSTOP0Mode+0x4c>)
20005ed0:	f023 0307 	bic.w	r3, r3, #7
20005ed4:	6013      	str	r3, [r2, #0]

  /* Set SLEEPDEEP bit of Cortex System Control Register */
  SET_BIT(SCB->SCR, ((uint32_t)SCB_SCR_SLEEPDEEP_Msk));
20005ed6:	4b0e      	ldr	r3, [pc, #56]	; (20005f10 <HAL_PWREx_EnterSTOP0Mode+0x50>)
20005ed8:	691b      	ldr	r3, [r3, #16]
20005eda:	4a0d      	ldr	r2, [pc, #52]	; (20005f10 <HAL_PWREx_EnterSTOP0Mode+0x50>)
20005edc:	f043 0304 	orr.w	r3, r3, #4
20005ee0:	6113      	str	r3, [r2, #16]

  /* Select Stop mode entry --------------------------------------------------*/
  if(STOPEntry == PWR_STOPENTRY_WFI)
20005ee2:	79fb      	ldrb	r3, [r7, #7]
20005ee4:	2b01      	cmp	r3, #1
20005ee6:	d101      	bne.n	20005eec <HAL_PWREx_EnterSTOP0Mode+0x2c>
  {
    /* Request Wait For Interrupt */
    __WFI();
20005ee8:	bf30      	wfi
20005eea:	e002      	b.n	20005ef2 <HAL_PWREx_EnterSTOP0Mode+0x32>
  }
  else
  {
    /* Request Wait For Event */
    __SEV();
20005eec:	bf40      	sev
    __WFE();
20005eee:	bf20      	wfe
    __WFE();
20005ef0:	bf20      	wfe
  }

  /* Reset SLEEPDEEP bit of Cortex System Control Register */
  CLEAR_BIT(SCB->SCR, ((uint32_t)SCB_SCR_SLEEPDEEP_Msk));
20005ef2:	4b07      	ldr	r3, [pc, #28]	; (20005f10 <HAL_PWREx_EnterSTOP0Mode+0x50>)
20005ef4:	691b      	ldr	r3, [r3, #16]
20005ef6:	4a06      	ldr	r2, [pc, #24]	; (20005f10 <HAL_PWREx_EnterSTOP0Mode+0x50>)
20005ef8:	f023 0304 	bic.w	r3, r3, #4
20005efc:	6113      	str	r3, [r2, #16]
}
20005efe:	bf00      	nop
20005f00:	370c      	adds	r7, #12
20005f02:	46bd      	mov	sp, r7
20005f04:	f85d 7b04 	ldr.w	r7, [sp], #4
20005f08:	4770      	bx	lr
20005f0a:	bf00      	nop
20005f0c:	40007000 	.word	0x40007000
20005f10:	e000ed00 	.word	0xe000ed00

20005f14 <HAL_PWREx_EnterSTOP1Mode>:
  *            @arg @ref PWR_STOPENTRY_WFI  Enter Stop mode with WFI instruction
  *            @arg @ref PWR_STOPENTRY_WFE  Enter Stop mode with WFE instruction
  * @retval None
  */
void HAL_PWREx_EnterSTOP1Mode(uint8_t STOPEntry)
{
20005f14:	b480      	push	{r7}
20005f16:	b083      	sub	sp, #12
20005f18:	af00      	add	r7, sp, #0
20005f1a:	4603      	mov	r3, r0
20005f1c:	71fb      	strb	r3, [r7, #7]
  /* Check the parameters */
  assert_param(IS_PWR_STOP_ENTRY(STOPEntry));

  /* Stop 1 mode with Low-Power Regulator */
  MODIFY_REG(PWR->CR1, PWR_CR1_LPMS, PWR_CR1_LPMS_STOP1);
20005f1e:	4b11      	ldr	r3, [pc, #68]	; (20005f64 <HAL_PWREx_EnterSTOP1Mode+0x50>)
20005f20:	681b      	ldr	r3, [r3, #0]
20005f22:	f023 0307 	bic.w	r3, r3, #7
20005f26:	4a0f      	ldr	r2, [pc, #60]	; (20005f64 <HAL_PWREx_EnterSTOP1Mode+0x50>)
20005f28:	f043 0301 	orr.w	r3, r3, #1
20005f2c:	6013      	str	r3, [r2, #0]

  /* Set SLEEPDEEP bit of Cortex System Control Register */
  SET_BIT(SCB->SCR, ((uint32_t)SCB_SCR_SLEEPDEEP_Msk));
20005f2e:	4b0e      	ldr	r3, [pc, #56]	; (20005f68 <HAL_PWREx_EnterSTOP1Mode+0x54>)
20005f30:	691b      	ldr	r3, [r3, #16]
20005f32:	4a0d      	ldr	r2, [pc, #52]	; (20005f68 <HAL_PWREx_EnterSTOP1Mode+0x54>)
20005f34:	f043 0304 	orr.w	r3, r3, #4
20005f38:	6113      	str	r3, [r2, #16]

  /* Select Stop mode entry --------------------------------------------------*/
  if(STOPEntry == PWR_STOPENTRY_WFI)
20005f3a:	79fb      	ldrb	r3, [r7, #7]
20005f3c:	2b01      	cmp	r3, #1
20005f3e:	d101      	bne.n	20005f44 <HAL_PWREx_EnterSTOP1Mode+0x30>
  {
    /* Request Wait For Interrupt */
    __WFI();
20005f40:	bf30      	wfi
20005f42:	e002      	b.n	20005f4a <HAL_PWREx_EnterSTOP1Mode+0x36>
  }
  else
  {
    /* Request Wait For Event */
    __SEV();
20005f44:	bf40      	sev
    __WFE();
20005f46:	bf20      	wfe
    __WFE();
20005f48:	bf20      	wfe
  }

  /* Reset SLEEPDEEP bit of Cortex System Control Register */
  CLEAR_BIT(SCB->SCR, ((uint32_t)SCB_SCR_SLEEPDEEP_Msk));
20005f4a:	4b07      	ldr	r3, [pc, #28]	; (20005f68 <HAL_PWREx_EnterSTOP1Mode+0x54>)
20005f4c:	691b      	ldr	r3, [r3, #16]
20005f4e:	4a06      	ldr	r2, [pc, #24]	; (20005f68 <HAL_PWREx_EnterSTOP1Mode+0x54>)
20005f50:	f023 0304 	bic.w	r3, r3, #4
20005f54:	6113      	str	r3, [r2, #16]
}
20005f56:	bf00      	nop
20005f58:	370c      	adds	r7, #12
20005f5a:	46bd      	mov	sp, r7
20005f5c:	f85d 7b04 	ldr.w	r7, [sp], #4
20005f60:	4770      	bx	lr
20005f62:	bf00      	nop
20005f64:	40007000 	.word	0x40007000
20005f68:	e000ed00 	.word	0xe000ed00

20005f6c <HAL_PWREx_EnterSHUTDOWNMode>:
  *        The BOR is not available.
  * @note  The I/Os can be configured either with a pull-up or pull-down or can be kept in analog state.
  * @retval None
  */
void HAL_PWREx_EnterSHUTDOWNMode(void)
{
20005f6c:	b480      	push	{r7}
20005f6e:	af00      	add	r7, sp, #0

  /* Set Shutdown mode */
  MODIFY_REG(PWR->CR1, PWR_CR1_LPMS, PWR_CR1_LPMS_SHUTDOWN);
20005f70:	4b09      	ldr	r3, [pc, #36]	; (20005f98 <HAL_PWREx_EnterSHUTDOWNMode+0x2c>)
20005f72:	681b      	ldr	r3, [r3, #0]
20005f74:	f023 0307 	bic.w	r3, r3, #7
20005f78:	4a07      	ldr	r2, [pc, #28]	; (20005f98 <HAL_PWREx_EnterSHUTDOWNMode+0x2c>)
20005f7a:	f043 0304 	orr.w	r3, r3, #4
20005f7e:	6013      	str	r3, [r2, #0]

  /* Set SLEEPDEEP bit of Cortex System Control Register */
  SET_BIT(SCB->SCR, ((uint32_t)SCB_SCR_SLEEPDEEP_Msk));
20005f80:	4b06      	ldr	r3, [pc, #24]	; (20005f9c <HAL_PWREx_EnterSHUTDOWNMode+0x30>)
20005f82:	691b      	ldr	r3, [r3, #16]
20005f84:	4a05      	ldr	r2, [pc, #20]	; (20005f9c <HAL_PWREx_EnterSHUTDOWNMode+0x30>)
20005f86:	f043 0304 	orr.w	r3, r3, #4
20005f8a:	6113      	str	r3, [r2, #16]
/* This option is used to ensure that store operations are completed */
#if defined ( __CC_ARM)
  __force_stores();
#endif
  /* Request Wait For Interrupt */
  __WFI();
20005f8c:	bf30      	wfi
}
20005f8e:	bf00      	nop
20005f90:	46bd      	mov	sp, r7
20005f92:	f85d 7b04 	ldr.w	r7, [sp], #4
20005f96:	4770      	bx	lr
20005f98:	40007000 	.word	0x40007000
20005f9c:	e000ed00 	.word	0xe000ed00

20005fa0 <HAL_PWREx_PVD_PVM_IRQHandler>:
  * @brief This function handles the PWR PVD/PVMx interrupt request.
  * @note This API should be called under the PVD_PVM_IRQHandler().
  * @retval None
  */
void HAL_PWREx_PVD_PVM_IRQHandler(void)
{
20005fa0:	b580      	push	{r7, lr}
20005fa2:	af00      	add	r7, sp, #0
  /* Check PWR exti flag */
  if(__HAL_PWR_PVD_EXTI_GET_FLAG() != 0U)
20005fa4:	4b1c      	ldr	r3, [pc, #112]	; (20006018 <HAL_PWREx_PVD_PVM_IRQHandler+0x78>)
20005fa6:	695b      	ldr	r3, [r3, #20]
20005fa8:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
20005fac:	2b00      	cmp	r3, #0
20005fae:	d005      	beq.n	20005fbc <HAL_PWREx_PVD_PVM_IRQHandler+0x1c>
  {
    /* PWR PVD interrupt user callback */
    HAL_PWR_PVDCallback();
20005fb0:	f7ff fa1c 	bl	200053ec <HAL_PWR_PVDCallback>

    /* Clear PVD exti pending bit */
    __HAL_PWR_PVD_EXTI_CLEAR_FLAG();
20005fb4:	4b18      	ldr	r3, [pc, #96]	; (20006018 <HAL_PWREx_PVD_PVM_IRQHandler+0x78>)
20005fb6:	f44f 3280 	mov.w	r2, #65536	; 0x10000
20005fba:	615a      	str	r2, [r3, #20]
  }
  /* Next, successively check PVMx exti flags */
#if defined(PWR_CR2_PVME1)
  if(__HAL_PWR_PVM1_EXTI_GET_FLAG() != 0U)
20005fbc:	4b16      	ldr	r3, [pc, #88]	; (20006018 <HAL_PWREx_PVD_PVM_IRQHandler+0x78>)
20005fbe:	6b5b      	ldr	r3, [r3, #52]	; 0x34
20005fc0:	f003 0308 	and.w	r3, r3, #8
20005fc4:	2b00      	cmp	r3, #0
20005fc6:	d004      	beq.n	20005fd2 <HAL_PWREx_PVD_PVM_IRQHandler+0x32>
  {
    /* PWR PVM1 interrupt user callback */
    HAL_PWREx_PVM1Callback();
20005fc8:	f000 f828 	bl	2000601c <HAL_PWREx_PVM1Callback>

    /* Clear PVM1 exti pending bit */
    __HAL_PWR_PVM1_EXTI_CLEAR_FLAG();
20005fcc:	4b12      	ldr	r3, [pc, #72]	; (20006018 <HAL_PWREx_PVD_PVM_IRQHandler+0x78>)
20005fce:	2208      	movs	r2, #8
20005fd0:	635a      	str	r2, [r3, #52]	; 0x34
  }
#endif /* PWR_CR2_PVME1 */
#if defined(PWR_CR2_PVME2)
  if(__HAL_PWR_PVM2_EXTI_GET_FLAG() != 0U)
20005fd2:	4b11      	ldr	r3, [pc, #68]	; (20006018 <HAL_PWREx_PVD_PVM_IRQHandler+0x78>)
20005fd4:	6b5b      	ldr	r3, [r3, #52]	; 0x34
20005fd6:	f003 0310 	and.w	r3, r3, #16
20005fda:	2b00      	cmp	r3, #0
20005fdc:	d004      	beq.n	20005fe8 <HAL_PWREx_PVD_PVM_IRQHandler+0x48>
  {
    /* PWR PVM2 interrupt user callback */
    HAL_PWREx_PVM2Callback();
20005fde:	f000 f824 	bl	2000602a <HAL_PWREx_PVM2Callback>

    /* Clear PVM2 exti pending bit */
    __HAL_PWR_PVM2_EXTI_CLEAR_FLAG();
20005fe2:	4b0d      	ldr	r3, [pc, #52]	; (20006018 <HAL_PWREx_PVD_PVM_IRQHandler+0x78>)
20005fe4:	2210      	movs	r2, #16
20005fe6:	635a      	str	r2, [r3, #52]	; 0x34
  }
#endif /* PWR_CR2_PVME2 */
  if(__HAL_PWR_PVM3_EXTI_GET_FLAG() != 0U)
20005fe8:	4b0b      	ldr	r3, [pc, #44]	; (20006018 <HAL_PWREx_PVD_PVM_IRQHandler+0x78>)
20005fea:	6b5b      	ldr	r3, [r3, #52]	; 0x34
20005fec:	f003 0320 	and.w	r3, r3, #32
20005ff0:	2b00      	cmp	r3, #0
20005ff2:	d004      	beq.n	20005ffe <HAL_PWREx_PVD_PVM_IRQHandler+0x5e>
  {
    /* PWR PVM3 interrupt user callback */
    HAL_PWREx_PVM3Callback();
20005ff4:	f000 f820 	bl	20006038 <HAL_PWREx_PVM3Callback>

    /* Clear PVM3 exti pending bit */
    __HAL_PWR_PVM3_EXTI_CLEAR_FLAG();
20005ff8:	4b07      	ldr	r3, [pc, #28]	; (20006018 <HAL_PWREx_PVD_PVM_IRQHandler+0x78>)
20005ffa:	2220      	movs	r2, #32
20005ffc:	635a      	str	r2, [r3, #52]	; 0x34
  }
  if(__HAL_PWR_PVM4_EXTI_GET_FLAG() != 0U)
20005ffe:	4b06      	ldr	r3, [pc, #24]	; (20006018 <HAL_PWREx_PVD_PVM_IRQHandler+0x78>)
20006000:	6b5b      	ldr	r3, [r3, #52]	; 0x34
20006002:	f003 0340 	and.w	r3, r3, #64	; 0x40
20006006:	2b00      	cmp	r3, #0
20006008:	d004      	beq.n	20006014 <HAL_PWREx_PVD_PVM_IRQHandler+0x74>
  {
    /* PWR PVM4 interrupt user callback */
    HAL_PWREx_PVM4Callback();
2000600a:	f000 f81c 	bl	20006046 <HAL_PWREx_PVM4Callback>

    /* Clear PVM4 exti pending bit */
    __HAL_PWR_PVM4_EXTI_CLEAR_FLAG();
2000600e:	4b02      	ldr	r3, [pc, #8]	; (20006018 <HAL_PWREx_PVD_PVM_IRQHandler+0x78>)
20006010:	2240      	movs	r2, #64	; 0x40
20006012:	635a      	str	r2, [r3, #52]	; 0x34
  }
}
20006014:	bf00      	nop
20006016:	bd80      	pop	{r7, pc}
20006018:	40010400 	.word	0x40010400

2000601c <HAL_PWREx_PVM1Callback>:
/**
  * @brief PWR PVM1 interrupt callback
  * @retval None
  */
__weak void HAL_PWREx_PVM1Callback(void)
{
2000601c:	b480      	push	{r7}
2000601e:	af00      	add	r7, sp, #0
  /* NOTE : This function should not be modified; when the callback is needed,
            HAL_PWREx_PVM1Callback() API can be implemented in the user file
   */
}
20006020:	bf00      	nop
20006022:	46bd      	mov	sp, r7
20006024:	f85d 7b04 	ldr.w	r7, [sp], #4
20006028:	4770      	bx	lr

2000602a <HAL_PWREx_PVM2Callback>:
/**
  * @brief PWR PVM2 interrupt callback
  * @retval None
  */
__weak void HAL_PWREx_PVM2Callback(void)
{
2000602a:	b480      	push	{r7}
2000602c:	af00      	add	r7, sp, #0
  /* NOTE : This function should not be modified; when the callback is needed,
            HAL_PWREx_PVM2Callback() API can be implemented in the user file
   */
}
2000602e:	bf00      	nop
20006030:	46bd      	mov	sp, r7
20006032:	f85d 7b04 	ldr.w	r7, [sp], #4
20006036:	4770      	bx	lr

20006038 <HAL_PWREx_PVM3Callback>:
/**
  * @brief PWR PVM3 interrupt callback
  * @retval None
  */
__weak void HAL_PWREx_PVM3Callback(void)
{
20006038:	b480      	push	{r7}
2000603a:	af00      	add	r7, sp, #0
  /* NOTE : This function should not be modified; when the callback is needed,
            HAL_PWREx_PVM3Callback() API can be implemented in the user file
   */
}
2000603c:	bf00      	nop
2000603e:	46bd      	mov	sp, r7
20006040:	f85d 7b04 	ldr.w	r7, [sp], #4
20006044:	4770      	bx	lr

20006046 <HAL_PWREx_PVM4Callback>:
/**
  * @brief PWR PVM4 interrupt callback
  * @retval None
  */
__weak void HAL_PWREx_PVM4Callback(void)
{
20006046:	b480      	push	{r7}
20006048:	af00      	add	r7, sp, #0
  /* NOTE : This function should not be modified; when the callback is needed,
            HAL_PWREx_PVM4Callback() API can be implemented in the user file
   */
}
2000604a:	bf00      	nop
2000604c:	46bd      	mov	sp, r7
2000604e:	f85d 7b04 	ldr.w	r7, [sp], #4
20006052:	4770      	bx	lr

20006054 <HAL_PWREx_EnableUCPDStandbyMode>:
/**
  * @brief Enable UCPD configuration memorization in Standby.
  * @retval None
  */
void HAL_PWREx_EnableUCPDStandbyMode(void)
{
20006054:	b480      	push	{r7}
20006056:	af00      	add	r7, sp, #0
  /* Memorize UCPD configuration when entering standby mode */
  SET_BIT(PWR->CR3, PWR_CR3_UCPD_STDBY);
20006058:	4b05      	ldr	r3, [pc, #20]	; (20006070 <HAL_PWREx_EnableUCPDStandbyMode+0x1c>)
2000605a:	689b      	ldr	r3, [r3, #8]
2000605c:	4a04      	ldr	r2, [pc, #16]	; (20006070 <HAL_PWREx_EnableUCPDStandbyMode+0x1c>)
2000605e:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
20006062:	6093      	str	r3, [r2, #8]
}
20006064:	bf00      	nop
20006066:	46bd      	mov	sp, r7
20006068:	f85d 7b04 	ldr.w	r7, [sp], #4
2000606c:	4770      	bx	lr
2000606e:	bf00      	nop
20006070:	40007000 	.word	0x40007000

20006074 <HAL_PWREx_DisableUCPDStandbyMode>:
  * @note  This function must be called on exiting the Standby mode and before any UCPD
  *        configuration update.
  * @retval None
  */
void HAL_PWREx_DisableUCPDStandbyMode(void)
{
20006074:	b480      	push	{r7}
20006076:	af00      	add	r7, sp, #0
  /* Write 0 immediately after Standby exit when using UCPD,
     and before writing any UCPD registers */
  CLEAR_BIT(PWR->CR3, PWR_CR3_UCPD_STDBY);
20006078:	4b05      	ldr	r3, [pc, #20]	; (20006090 <HAL_PWREx_DisableUCPDStandbyMode+0x1c>)
2000607a:	689b      	ldr	r3, [r3, #8]
2000607c:	4a04      	ldr	r2, [pc, #16]	; (20006090 <HAL_PWREx_DisableUCPDStandbyMode+0x1c>)
2000607e:	f423 5300 	bic.w	r3, r3, #8192	; 0x2000
20006082:	6093      	str	r3, [r2, #8]
}
20006084:	bf00      	nop
20006086:	46bd      	mov	sp, r7
20006088:	f85d 7b04 	ldr.w	r7, [sp], #4
2000608c:	4770      	bx	lr
2000608e:	bf00      	nop
20006090:	40007000 	.word	0x40007000

20006094 <HAL_PWREx_EnableUCPDDeadBattery>:
  * @brief Enable the USB Type-C dead battery pull-down behavior
  *        on UCPDx_CC1 and UCPDx_CC2 pins
  * @retval None
  */
void HAL_PWREx_EnableUCPDDeadBattery(void)
{
20006094:	b480      	push	{r7}
20006096:	af00      	add	r7, sp, #0
  /* Write 0 to enable the USB Type-C dead battery pull-down behavior */
  CLEAR_BIT(PWR->CR3, PWR_CR3_UCPD_DBDIS);
20006098:	4b05      	ldr	r3, [pc, #20]	; (200060b0 <HAL_PWREx_EnableUCPDDeadBattery+0x1c>)
2000609a:	689b      	ldr	r3, [r3, #8]
2000609c:	4a04      	ldr	r2, [pc, #16]	; (200060b0 <HAL_PWREx_EnableUCPDDeadBattery+0x1c>)
2000609e:	f423 4380 	bic.w	r3, r3, #16384	; 0x4000
200060a2:	6093      	str	r3, [r2, #8]
}
200060a4:	bf00      	nop
200060a6:	46bd      	mov	sp, r7
200060a8:	f85d 7b04 	ldr.w	r7, [sp], #4
200060ac:	4770      	bx	lr
200060ae:	bf00      	nop
200060b0:	40007000 	.word	0x40007000

200060b4 <HAL_PWREx_DisableUCPDDeadBattery>:
  *       or to hand over control to the UCPD (which should therefore be
  *       initialized before doing the disable).
  * @retval None
  */
void HAL_PWREx_DisableUCPDDeadBattery(void)
{
200060b4:	b480      	push	{r7}
200060b6:	af00      	add	r7, sp, #0
  /* Write 1 to disable the USB Type-C dead battery pull-down behavior */
  SET_BIT(PWR->CR3, PWR_CR3_UCPD_DBDIS);
200060b8:	4b05      	ldr	r3, [pc, #20]	; (200060d0 <HAL_PWREx_DisableUCPDDeadBattery+0x1c>)
200060ba:	689b      	ldr	r3, [r3, #8]
200060bc:	4a04      	ldr	r2, [pc, #16]	; (200060d0 <HAL_PWREx_DisableUCPDDeadBattery+0x1c>)
200060be:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
200060c2:	6093      	str	r3, [r2, #8]
}
200060c4:	bf00      	nop
200060c6:	46bd      	mov	sp, r7
200060c8:	f85d 7b04 	ldr.w	r7, [sp], #4
200060cc:	4770      	bx	lr
200060ce:	bf00      	nop
200060d0:	40007000 	.word	0x40007000

200060d4 <HAL_QSPI_Init>:
  *        in the QSPI_InitTypeDef and initialize the associated handle.
  * @param hqspi : QSPI handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_QSPI_Init(QSPI_HandleTypeDef *hqspi)
{
200060d4:	b580      	push	{r7, lr}
200060d6:	b086      	sub	sp, #24
200060d8:	af02      	add	r7, sp, #8
200060da:	6078      	str	r0, [r7, #4]
  HAL_StatusTypeDef status;
  uint32_t tickstart = HAL_GetTick();
200060dc:	f7fb fbde 	bl	2000189c <HAL_GetTick>
200060e0:	60f8      	str	r0, [r7, #12]

  /* Check the QSPI handle allocation */
  if(hqspi == NULL)
200060e2:	687b      	ldr	r3, [r7, #4]
200060e4:	2b00      	cmp	r3, #0
200060e6:	d101      	bne.n	200060ec <HAL_QSPI_Init+0x18>
  {
    return HAL_ERROR;
200060e8:	2301      	movs	r3, #1
200060ea:	e075      	b.n	200061d8 <HAL_QSPI_Init+0x104>
  {
    assert_param(IS_QSPI_FLASH_ID(hqspi->Init.FlashID));
  }

  /* Process locked */
  __HAL_LOCK(hqspi);
200060ec:	687b      	ldr	r3, [r7, #4]
200060ee:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
200060f2:	b2db      	uxtb	r3, r3
200060f4:	2b01      	cmp	r3, #1
200060f6:	d101      	bne.n	200060fc <HAL_QSPI_Init+0x28>
200060f8:	2302      	movs	r3, #2
200060fa:	e06d      	b.n	200061d8 <HAL_QSPI_Init+0x104>
200060fc:	687b      	ldr	r3, [r7, #4]
200060fe:	2201      	movs	r2, #1
20006100:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

  if(hqspi->State == HAL_QSPI_STATE_RESET)
20006104:	687b      	ldr	r3, [r7, #4]
20006106:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2000610a:	b2db      	uxtb	r3, r3
2000610c:	2b00      	cmp	r3, #0
2000610e:	d10b      	bne.n	20006128 <HAL_QSPI_Init+0x54>
  {
    /* Allocate lock resource and initialize it */
    hqspi->Lock = HAL_UNLOCKED;
20006110:	687b      	ldr	r3, [r7, #4]
20006112:	2200      	movs	r2, #0
20006114:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    /* Init the low level hardware */
    hqspi->MspInitCallback(hqspi);
#else
    /* Init the low level hardware : GPIO, CLOCK */
    HAL_QSPI_MspInit(hqspi);
20006118:	6878      	ldr	r0, [r7, #4]
2000611a:	f7fa fd5b 	bl	20000bd4 <HAL_QSPI_MspInit>
#endif

    /* Configure the default timeout for the QSPI memory access */
    HAL_QSPI_SetTimeout(hqspi, HAL_QSPI_TIMEOUT_DEFAULT_VALUE);
2000611e:	f241 3188 	movw	r1, #5000	; 0x1388
20006122:	6878      	ldr	r0, [r7, #4]
20006124:	f001 f9cc 	bl	200074c0 <HAL_QSPI_SetTimeout>
  }

  /* Configure QSPI FIFO Threshold */
  MODIFY_REG(hqspi->Instance->CR, QUADSPI_CR_FTHRES,
20006128:	687b      	ldr	r3, [r7, #4]
2000612a:	681b      	ldr	r3, [r3, #0]
2000612c:	681b      	ldr	r3, [r3, #0]
2000612e:	f423 6170 	bic.w	r1, r3, #3840	; 0xf00
20006132:	687b      	ldr	r3, [r7, #4]
20006134:	689b      	ldr	r3, [r3, #8]
20006136:	3b01      	subs	r3, #1
20006138:	021a      	lsls	r2, r3, #8
2000613a:	687b      	ldr	r3, [r7, #4]
2000613c:	681b      	ldr	r3, [r3, #0]
2000613e:	430a      	orrs	r2, r1
20006140:	601a      	str	r2, [r3, #0]
             ((hqspi->Init.FifoThreshold - 1U) << QUADSPI_CR_FTHRES_Pos));

  /* Wait till BUSY flag reset */
  status = QSPI_WaitFlagStateUntilTimeout(hqspi, QSPI_FLAG_BUSY, RESET, tickstart, hqspi->Timeout);
20006142:	687b      	ldr	r3, [r7, #4]
20006144:	6c9b      	ldr	r3, [r3, #72]	; 0x48
20006146:	9300      	str	r3, [sp, #0]
20006148:	68fb      	ldr	r3, [r7, #12]
2000614a:	2200      	movs	r2, #0
2000614c:	2120      	movs	r1, #32
2000614e:	6878      	ldr	r0, [r7, #4]
20006150:	f001 fae1 	bl	20007716 <QSPI_WaitFlagStateUntilTimeout>
20006154:	4603      	mov	r3, r0
20006156:	72fb      	strb	r3, [r7, #11]

  if(status == HAL_OK)
20006158:	7afb      	ldrb	r3, [r7, #11]
2000615a:	2b00      	cmp	r3, #0
2000615c:	d137      	bne.n	200061ce <HAL_QSPI_Init+0xfa>
  {
    /* Configure QSPI Clock Prescaler and Sample Shift */
    MODIFY_REG(hqspi->Instance->CR, (QUADSPI_CR_PRESCALER | QUADSPI_CR_SSHIFT | QUADSPI_CR_FSEL | QUADSPI_CR_DFM),
2000615e:	687b      	ldr	r3, [r7, #4]
20006160:	681b      	ldr	r3, [r3, #0]
20006162:	681b      	ldr	r3, [r3, #0]
20006164:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
20006168:	f023 03d0 	bic.w	r3, r3, #208	; 0xd0
2000616c:	687a      	ldr	r2, [r7, #4]
2000616e:	6852      	ldr	r2, [r2, #4]
20006170:	0611      	lsls	r1, r2, #24
20006172:	687a      	ldr	r2, [r7, #4]
20006174:	68d2      	ldr	r2, [r2, #12]
20006176:	4311      	orrs	r1, r2
20006178:	687a      	ldr	r2, [r7, #4]
2000617a:	69d2      	ldr	r2, [r2, #28]
2000617c:	4311      	orrs	r1, r2
2000617e:	687a      	ldr	r2, [r7, #4]
20006180:	6a12      	ldr	r2, [r2, #32]
20006182:	4311      	orrs	r1, r2
20006184:	687a      	ldr	r2, [r7, #4]
20006186:	6812      	ldr	r2, [r2, #0]
20006188:	430b      	orrs	r3, r1
2000618a:	6013      	str	r3, [r2, #0]
               ((hqspi->Init.ClockPrescaler << QUADSPI_CR_PRESCALER_Pos) |
                hqspi->Init.SampleShifting  | hqspi->Init.FlashID | hqspi->Init.DualFlash));

    /* Configure QSPI Flash Size, CS High Time and Clock Mode */
    MODIFY_REG(hqspi->Instance->DCR, (QUADSPI_DCR_FSIZE | QUADSPI_DCR_CSHT | QUADSPI_DCR_CKMODE),
2000618c:	687b      	ldr	r3, [r7, #4]
2000618e:	681b      	ldr	r3, [r3, #0]
20006190:	685a      	ldr	r2, [r3, #4]
20006192:	4b13      	ldr	r3, [pc, #76]	; (200061e0 <HAL_QSPI_Init+0x10c>)
20006194:	4013      	ands	r3, r2
20006196:	687a      	ldr	r2, [r7, #4]
20006198:	6912      	ldr	r2, [r2, #16]
2000619a:	0411      	lsls	r1, r2, #16
2000619c:	687a      	ldr	r2, [r7, #4]
2000619e:	6952      	ldr	r2, [r2, #20]
200061a0:	4311      	orrs	r1, r2
200061a2:	687a      	ldr	r2, [r7, #4]
200061a4:	6992      	ldr	r2, [r2, #24]
200061a6:	4311      	orrs	r1, r2
200061a8:	687a      	ldr	r2, [r7, #4]
200061aa:	6812      	ldr	r2, [r2, #0]
200061ac:	430b      	orrs	r3, r1
200061ae:	6053      	str	r3, [r2, #4]
               ((hqspi->Init.FlashSize << QUADSPI_DCR_FSIZE_Pos) |
                hqspi->Init.ChipSelectHighTime | hqspi->Init.ClockMode));

    /* Enable the QSPI peripheral */
    __HAL_QSPI_ENABLE(hqspi);
200061b0:	687b      	ldr	r3, [r7, #4]
200061b2:	681b      	ldr	r3, [r3, #0]
200061b4:	681a      	ldr	r2, [r3, #0]
200061b6:	687b      	ldr	r3, [r7, #4]
200061b8:	681b      	ldr	r3, [r3, #0]
200061ba:	f042 0201 	orr.w	r2, r2, #1
200061be:	601a      	str	r2, [r3, #0]

    /* Set QSPI error code to none */
    hqspi->ErrorCode = HAL_QSPI_ERROR_NONE;
200061c0:	687b      	ldr	r3, [r7, #4]
200061c2:	2200      	movs	r2, #0
200061c4:	645a      	str	r2, [r3, #68]	; 0x44

    /* Initialize the QSPI state */
    hqspi->State = HAL_QSPI_STATE_READY;
200061c6:	687b      	ldr	r3, [r7, #4]
200061c8:	2201      	movs	r2, #1
200061ca:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
  }

  /* Release Lock */
  __HAL_UNLOCK(hqspi);
200061ce:	687b      	ldr	r3, [r7, #4]
200061d0:	2200      	movs	r2, #0
200061d2:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

  /* Return function status */
  return status;
200061d6:	7afb      	ldrb	r3, [r7, #11]
}
200061d8:	4618      	mov	r0, r3
200061da:	3710      	adds	r7, #16
200061dc:	46bd      	mov	sp, r7
200061de:	bd80      	pop	{r7, pc}
200061e0:	ffe0f8fe 	.word	0xffe0f8fe

200061e4 <HAL_QSPI_DeInit>:
  * @brief De-Initialize the QSPI peripheral.
  * @param hqspi : QSPI handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_QSPI_DeInit(QSPI_HandleTypeDef *hqspi)
{
200061e4:	b580      	push	{r7, lr}
200061e6:	b082      	sub	sp, #8
200061e8:	af00      	add	r7, sp, #0
200061ea:	6078      	str	r0, [r7, #4]
  /* Check the QSPI handle allocation */
  if(hqspi == NULL)
200061ec:	687b      	ldr	r3, [r7, #4]
200061ee:	2b00      	cmp	r3, #0
200061f0:	d101      	bne.n	200061f6 <HAL_QSPI_DeInit+0x12>
  {
    return HAL_ERROR;
200061f2:	2301      	movs	r3, #1
200061f4:	e022      	b.n	2000623c <HAL_QSPI_DeInit+0x58>
  }

  /* Process locked */
  __HAL_LOCK(hqspi);
200061f6:	687b      	ldr	r3, [r7, #4]
200061f8:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
200061fc:	b2db      	uxtb	r3, r3
200061fe:	2b01      	cmp	r3, #1
20006200:	d101      	bne.n	20006206 <HAL_QSPI_DeInit+0x22>
20006202:	2302      	movs	r3, #2
20006204:	e01a      	b.n	2000623c <HAL_QSPI_DeInit+0x58>
20006206:	687b      	ldr	r3, [r7, #4]
20006208:	2201      	movs	r2, #1
2000620a:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

  /* Disable the QSPI Peripheral Clock */
  __HAL_QSPI_DISABLE(hqspi);
2000620e:	687b      	ldr	r3, [r7, #4]
20006210:	681b      	ldr	r3, [r3, #0]
20006212:	681a      	ldr	r2, [r3, #0]
20006214:	687b      	ldr	r3, [r7, #4]
20006216:	681b      	ldr	r3, [r3, #0]
20006218:	f022 0201 	bic.w	r2, r2, #1
2000621c:	601a      	str	r2, [r3, #0]

  /* DeInit the low level hardware */
  hqspi->MspDeInitCallback(hqspi);
#else
  /* DeInit the low level hardware: GPIO, CLOCK, NVIC... */
  HAL_QSPI_MspDeInit(hqspi);
2000621e:	6878      	ldr	r0, [r7, #4]
20006220:	f7fa fd38 	bl	20000c94 <HAL_QSPI_MspDeInit>
#endif

  /* Set QSPI error code to none */
  hqspi->ErrorCode = HAL_QSPI_ERROR_NONE;
20006224:	687b      	ldr	r3, [r7, #4]
20006226:	2200      	movs	r2, #0
20006228:	645a      	str	r2, [r3, #68]	; 0x44

  /* Initialize the QSPI state */
  hqspi->State = HAL_QSPI_STATE_RESET;
2000622a:	687b      	ldr	r3, [r7, #4]
2000622c:	2200      	movs	r2, #0
2000622e:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41

  /* Release Lock */
  __HAL_UNLOCK(hqspi);
20006232:	687b      	ldr	r3, [r7, #4]
20006234:	2200      	movs	r2, #0
20006236:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

  return HAL_OK;
2000623a:	2300      	movs	r3, #0
}
2000623c:	4618      	mov	r0, r3
2000623e:	3708      	adds	r7, #8
20006240:	46bd      	mov	sp, r7
20006242:	bd80      	pop	{r7, pc}
  * @brief Initialize the QSPI MSP.
  * @param hqspi : QSPI handle
  * @retval None
  */
__weak void HAL_QSPI_MspInit(QSPI_HandleTypeDef *hqspi)
{
20006244:	b480      	push	{r7}
20006246:	b083      	sub	sp, #12
20006248:	af00      	add	r7, sp, #0
2000624a:	6078      	str	r0, [r7, #4]
  UNUSED(hqspi);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_QSPI_MspInit can be implemented in the user file
   */
}
2000624c:	bf00      	nop
2000624e:	370c      	adds	r7, #12
20006250:	46bd      	mov	sp, r7
20006252:	f85d 7b04 	ldr.w	r7, [sp], #4
20006256:	4770      	bx	lr
  * @brief DeInitialize the QSPI MSP.
  * @param hqspi : QSPI handle
  * @retval None
  */
__weak void HAL_QSPI_MspDeInit(QSPI_HandleTypeDef *hqspi)
{
20006258:	b480      	push	{r7}
2000625a:	b083      	sub	sp, #12
2000625c:	af00      	add	r7, sp, #0
2000625e:	6078      	str	r0, [r7, #4]
  UNUSED(hqspi);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_QSPI_MspDeInit can be implemented in the user file
   */
}
20006260:	bf00      	nop
20006262:	370c      	adds	r7, #12
20006264:	46bd      	mov	sp, r7
20006266:	f85d 7b04 	ldr.w	r7, [sp], #4
2000626a:	4770      	bx	lr

2000626c <HAL_QSPI_IRQHandler>:
  * @brief Handle QSPI interrupt request.
  * @param hqspi : QSPI handle
  * @retval None
  */
void HAL_QSPI_IRQHandler(QSPI_HandleTypeDef *hqspi)
{
2000626c:	b580      	push	{r7, lr}
2000626e:	b086      	sub	sp, #24
20006270:	af00      	add	r7, sp, #0
20006272:	6078      	str	r0, [r7, #4]
  __IO uint32_t *data_reg;
  uint32_t flag = READ_REG(hqspi->Instance->SR);
20006274:	687b      	ldr	r3, [r7, #4]
20006276:	681b      	ldr	r3, [r3, #0]
20006278:	689b      	ldr	r3, [r3, #8]
2000627a:	617b      	str	r3, [r7, #20]
  uint32_t itsource = READ_REG(hqspi->Instance->CR);
2000627c:	687b      	ldr	r3, [r7, #4]
2000627e:	681b      	ldr	r3, [r3, #0]
20006280:	681b      	ldr	r3, [r3, #0]
20006282:	613b      	str	r3, [r7, #16]

  /* QSPI Fifo Threshold interrupt occurred ----------------------------------*/
  if(((flag & QSPI_FLAG_FT) != 0U) && ((itsource & QSPI_IT_FT) != 0U))
20006284:	697b      	ldr	r3, [r7, #20]
20006286:	f003 0304 	and.w	r3, r3, #4
2000628a:	2b00      	cmp	r3, #0
2000628c:	d064      	beq.n	20006358 <HAL_QSPI_IRQHandler+0xec>
2000628e:	693b      	ldr	r3, [r7, #16]
20006290:	f403 2380 	and.w	r3, r3, #262144	; 0x40000
20006294:	2b00      	cmp	r3, #0
20006296:	d05f      	beq.n	20006358 <HAL_QSPI_IRQHandler+0xec>
  {
    data_reg = &hqspi->Instance->DR;
20006298:	687b      	ldr	r3, [r7, #4]
2000629a:	681b      	ldr	r3, [r3, #0]
2000629c:	3320      	adds	r3, #32
2000629e:	60fb      	str	r3, [r7, #12]

    if(hqspi->State == HAL_QSPI_STATE_BUSY_INDIRECT_TX)
200062a0:	687b      	ldr	r3, [r7, #4]
200062a2:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
200062a6:	b2db      	uxtb	r3, r3
200062a8:	2b12      	cmp	r3, #18
200062aa:	d125      	bne.n	200062f8 <HAL_QSPI_IRQHandler+0x8c>
    {
      /* Transmission process */
      while(__HAL_QSPI_GET_FLAG(hqspi, QSPI_FLAG_FT) != RESET)
200062ac:	e01c      	b.n	200062e8 <HAL_QSPI_IRQHandler+0x7c>
      {
        if (hqspi->TxXferCount > 0U)
200062ae:	687b      	ldr	r3, [r7, #4]
200062b0:	6adb      	ldr	r3, [r3, #44]	; 0x2c
200062b2:	2b00      	cmp	r3, #0
200062b4:	d00f      	beq.n	200062d6 <HAL_QSPI_IRQHandler+0x6a>
        {
          /* Fill the FIFO until the threshold is reached */
          *((__IO uint8_t *)data_reg) = *hqspi->pTxBuffPtr;
200062b6:	687b      	ldr	r3, [r7, #4]
200062b8:	6a5b      	ldr	r3, [r3, #36]	; 0x24
200062ba:	781a      	ldrb	r2, [r3, #0]
200062bc:	68fb      	ldr	r3, [r7, #12]
200062be:	701a      	strb	r2, [r3, #0]
          hqspi->pTxBuffPtr++;
200062c0:	687b      	ldr	r3, [r7, #4]
200062c2:	6a5b      	ldr	r3, [r3, #36]	; 0x24
200062c4:	1c5a      	adds	r2, r3, #1
200062c6:	687b      	ldr	r3, [r7, #4]
200062c8:	625a      	str	r2, [r3, #36]	; 0x24
          hqspi->TxXferCount--;
200062ca:	687b      	ldr	r3, [r7, #4]
200062cc:	6adb      	ldr	r3, [r3, #44]	; 0x2c
200062ce:	1e5a      	subs	r2, r3, #1
200062d0:	687b      	ldr	r3, [r7, #4]
200062d2:	62da      	str	r2, [r3, #44]	; 0x2c
200062d4:	e008      	b.n	200062e8 <HAL_QSPI_IRQHandler+0x7c>
        }
        else
        {
          /* No more data available for the transfer */
          /* Disable the QSPI FIFO Threshold Interrupt */
          __HAL_QSPI_DISABLE_IT(hqspi, QSPI_IT_FT);
200062d6:	687b      	ldr	r3, [r7, #4]
200062d8:	681b      	ldr	r3, [r3, #0]
200062da:	681a      	ldr	r2, [r3, #0]
200062dc:	687b      	ldr	r3, [r7, #4]
200062de:	681b      	ldr	r3, [r3, #0]
200062e0:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
200062e4:	601a      	str	r2, [r3, #0]
          break;
200062e6:	e033      	b.n	20006350 <HAL_QSPI_IRQHandler+0xe4>
      while(__HAL_QSPI_GET_FLAG(hqspi, QSPI_FLAG_FT) != RESET)
200062e8:	687b      	ldr	r3, [r7, #4]
200062ea:	681b      	ldr	r3, [r3, #0]
200062ec:	689b      	ldr	r3, [r3, #8]
200062ee:	f003 0304 	and.w	r3, r3, #4
200062f2:	2b00      	cmp	r3, #0
200062f4:	d1db      	bne.n	200062ae <HAL_QSPI_IRQHandler+0x42>
200062f6:	e02b      	b.n	20006350 <HAL_QSPI_IRQHandler+0xe4>
        }
      }
    }
    else if(hqspi->State == HAL_QSPI_STATE_BUSY_INDIRECT_RX)
200062f8:	687b      	ldr	r3, [r7, #4]
200062fa:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
200062fe:	b2db      	uxtb	r3, r3
20006300:	2b22      	cmp	r3, #34	; 0x22
20006302:	d125      	bne.n	20006350 <HAL_QSPI_IRQHandler+0xe4>
    {
      /* Receiving Process */
      while(__HAL_QSPI_GET_FLAG(hqspi, QSPI_FLAG_FT) != RESET)
20006304:	e01d      	b.n	20006342 <HAL_QSPI_IRQHandler+0xd6>
      {
        if (hqspi->RxXferCount > 0U)
20006306:	687b      	ldr	r3, [r7, #4]
20006308:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2000630a:	2b00      	cmp	r3, #0
2000630c:	d010      	beq.n	20006330 <HAL_QSPI_IRQHandler+0xc4>
        {
          /* Read the FIFO until the threshold is reached */
          *hqspi->pRxBuffPtr = *((__IO uint8_t *)data_reg);
2000630e:	687b      	ldr	r3, [r7, #4]
20006310:	6b1b      	ldr	r3, [r3, #48]	; 0x30
20006312:	68fa      	ldr	r2, [r7, #12]
20006314:	7812      	ldrb	r2, [r2, #0]
20006316:	b2d2      	uxtb	r2, r2
20006318:	701a      	strb	r2, [r3, #0]
          hqspi->pRxBuffPtr++;
2000631a:	687b      	ldr	r3, [r7, #4]
2000631c:	6b1b      	ldr	r3, [r3, #48]	; 0x30
2000631e:	1c5a      	adds	r2, r3, #1
20006320:	687b      	ldr	r3, [r7, #4]
20006322:	631a      	str	r2, [r3, #48]	; 0x30
          hqspi->RxXferCount--;
20006324:	687b      	ldr	r3, [r7, #4]
20006326:	6b9b      	ldr	r3, [r3, #56]	; 0x38
20006328:	1e5a      	subs	r2, r3, #1
2000632a:	687b      	ldr	r3, [r7, #4]
2000632c:	639a      	str	r2, [r3, #56]	; 0x38
2000632e:	e008      	b.n	20006342 <HAL_QSPI_IRQHandler+0xd6>
        }
        else
        {
          /* All data have been received for the transfer */
          /* Disable the QSPI FIFO Threshold Interrupt */
          __HAL_QSPI_DISABLE_IT(hqspi, QSPI_IT_FT);
20006330:	687b      	ldr	r3, [r7, #4]
20006332:	681b      	ldr	r3, [r3, #0]
20006334:	681a      	ldr	r2, [r3, #0]
20006336:	687b      	ldr	r3, [r7, #4]
20006338:	681b      	ldr	r3, [r3, #0]
2000633a:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
2000633e:	601a      	str	r2, [r3, #0]
          break;
20006340:	e006      	b.n	20006350 <HAL_QSPI_IRQHandler+0xe4>
      while(__HAL_QSPI_GET_FLAG(hqspi, QSPI_FLAG_FT) != RESET)
20006342:	687b      	ldr	r3, [r7, #4]
20006344:	681b      	ldr	r3, [r3, #0]
20006346:	689b      	ldr	r3, [r3, #8]
20006348:	f003 0304 	and.w	r3, r3, #4
2000634c:	2b00      	cmp	r3, #0
2000634e:	d1da      	bne.n	20006306 <HAL_QSPI_IRQHandler+0x9a>

    /* FIFO Threshold callback */
#if (USE_HAL_QSPI_REGISTER_CALLBACKS == 1)
    hqspi->FifoThresholdCallback(hqspi);
#else
    HAL_QSPI_FifoThresholdCallback(hqspi);
20006350:	6878      	ldr	r0, [r7, #4]
20006352:	f000 ffb4 	bl	200072be <HAL_QSPI_FifoThresholdCallback>
20006356:	e13c      	b.n	200065d2 <HAL_QSPI_IRQHandler+0x366>
#endif
  }

  /* QSPI Transfer Complete interrupt occurred -------------------------------*/
  else if(((flag & QSPI_FLAG_TC) != 0U) && ((itsource & QSPI_IT_TC) != 0U))
20006358:	697b      	ldr	r3, [r7, #20]
2000635a:	f003 0302 	and.w	r3, r3, #2
2000635e:	2b00      	cmp	r3, #0
20006360:	f000 80b0 	beq.w	200064c4 <HAL_QSPI_IRQHandler+0x258>
20006364:	693b      	ldr	r3, [r7, #16]
20006366:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
2000636a:	2b00      	cmp	r3, #0
2000636c:	f000 80aa 	beq.w	200064c4 <HAL_QSPI_IRQHandler+0x258>
  {
    /* Clear interrupt */
    WRITE_REG(hqspi->Instance->FCR, QSPI_FLAG_TC);
20006370:	687b      	ldr	r3, [r7, #4]
20006372:	681b      	ldr	r3, [r3, #0]
20006374:	2202      	movs	r2, #2
20006376:	60da      	str	r2, [r3, #12]

    /* Disable the QSPI FIFO Threshold, Transfer Error and Transfer complete Interrupts */
    __HAL_QSPI_DISABLE_IT(hqspi, QSPI_IT_TC | QSPI_IT_TE | QSPI_IT_FT);
20006378:	687b      	ldr	r3, [r7, #4]
2000637a:	681b      	ldr	r3, [r3, #0]
2000637c:	681a      	ldr	r2, [r3, #0]
2000637e:	687b      	ldr	r3, [r7, #4]
20006380:	681b      	ldr	r3, [r3, #0]
20006382:	f422 22e0 	bic.w	r2, r2, #458752	; 0x70000
20006386:	601a      	str	r2, [r3, #0]

    /* Transfer complete callback */
    if(hqspi->State == HAL_QSPI_STATE_BUSY_INDIRECT_TX)
20006388:	687b      	ldr	r3, [r7, #4]
2000638a:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2000638e:	b2db      	uxtb	r3, r3
20006390:	2b12      	cmp	r3, #18
20006392:	d120      	bne.n	200063d6 <HAL_QSPI_IRQHandler+0x16a>
    {
      if ((hqspi->Instance->CR & QUADSPI_CR_DMAEN) != 0U)
20006394:	687b      	ldr	r3, [r7, #4]
20006396:	681b      	ldr	r3, [r3, #0]
20006398:	681b      	ldr	r3, [r3, #0]
2000639a:	f003 0304 	and.w	r3, r3, #4
2000639e:	2b00      	cmp	r3, #0
200063a0:	d011      	beq.n	200063c6 <HAL_QSPI_IRQHandler+0x15a>
      {
        /* Disable the DMA transfer by clearing the DMAEN bit in the QSPI CR register */
        CLEAR_BIT(hqspi->Instance->CR, QUADSPI_CR_DMAEN);
200063a2:	687b      	ldr	r3, [r7, #4]
200063a4:	681b      	ldr	r3, [r3, #0]
200063a6:	681a      	ldr	r2, [r3, #0]
200063a8:	687b      	ldr	r3, [r7, #4]
200063aa:	681b      	ldr	r3, [r3, #0]
200063ac:	f022 0204 	bic.w	r2, r2, #4
200063b0:	601a      	str	r2, [r3, #0]

        /* Disable the DMA channel */
        __HAL_DMA_DISABLE(hqspi->hdma);
200063b2:	687b      	ldr	r3, [r7, #4]
200063b4:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
200063b6:	681b      	ldr	r3, [r3, #0]
200063b8:	681a      	ldr	r2, [r3, #0]
200063ba:	687b      	ldr	r3, [r7, #4]
200063bc:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
200063be:	681b      	ldr	r3, [r3, #0]
200063c0:	f022 0201 	bic.w	r2, r2, #1
200063c4:	601a      	str	r2, [r3, #0]
      }


      /* Change state of QSPI */
      hqspi->State = HAL_QSPI_STATE_READY;
200063c6:	687b      	ldr	r3, [r7, #4]
200063c8:	2201      	movs	r2, #1
200063ca:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41

      /* TX Complete callback */
#if (USE_HAL_QSPI_REGISTER_CALLBACKS == 1)
      hqspi->TxCpltCallback(hqspi);
#else
      HAL_QSPI_TxCpltCallback(hqspi);
200063ce:	6878      	ldr	r0, [r7, #4]
200063d0:	f000 ff57 	bl	20007282 <HAL_QSPI_TxCpltCallback>
    if(hqspi->State == HAL_QSPI_STATE_BUSY_INDIRECT_TX)
200063d4:	e0fa      	b.n	200065cc <HAL_QSPI_IRQHandler+0x360>
#endif
    }
    else if(hqspi->State == HAL_QSPI_STATE_BUSY_INDIRECT_RX)
200063d6:	687b      	ldr	r3, [r7, #4]
200063d8:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
200063dc:	b2db      	uxtb	r3, r3
200063de:	2b22      	cmp	r3, #34	; 0x22
200063e0:	d143      	bne.n	2000646a <HAL_QSPI_IRQHandler+0x1fe>
    {
      if ((hqspi->Instance->CR & QUADSPI_CR_DMAEN) != 0U)
200063e2:	687b      	ldr	r3, [r7, #4]
200063e4:	681b      	ldr	r3, [r3, #0]
200063e6:	681b      	ldr	r3, [r3, #0]
200063e8:	f003 0304 	and.w	r3, r3, #4
200063ec:	2b00      	cmp	r3, #0
200063ee:	d012      	beq.n	20006416 <HAL_QSPI_IRQHandler+0x1aa>
      {
        /* Disable the DMA transfer by clearing the DMAEN bit in the QSPI CR register */
        CLEAR_BIT(hqspi->Instance->CR, QUADSPI_CR_DMAEN);
200063f0:	687b      	ldr	r3, [r7, #4]
200063f2:	681b      	ldr	r3, [r3, #0]
200063f4:	681a      	ldr	r2, [r3, #0]
200063f6:	687b      	ldr	r3, [r7, #4]
200063f8:	681b      	ldr	r3, [r3, #0]
200063fa:	f022 0204 	bic.w	r2, r2, #4
200063fe:	601a      	str	r2, [r3, #0]

        /* Disable the DMA channel */
        __HAL_DMA_DISABLE(hqspi->hdma);
20006400:	687b      	ldr	r3, [r7, #4]
20006402:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
20006404:	681b      	ldr	r3, [r3, #0]
20006406:	681a      	ldr	r2, [r3, #0]
20006408:	687b      	ldr	r3, [r7, #4]
2000640a:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2000640c:	681b      	ldr	r3, [r3, #0]
2000640e:	f022 0201 	bic.w	r2, r2, #1
20006412:	601a      	str	r2, [r3, #0]
20006414:	e021      	b.n	2000645a <HAL_QSPI_IRQHandler+0x1ee>
      }
      else
      {
        data_reg = &hqspi->Instance->DR;
20006416:	687b      	ldr	r3, [r7, #4]
20006418:	681b      	ldr	r3, [r3, #0]
2000641a:	3320      	adds	r3, #32
2000641c:	60fb      	str	r3, [r7, #12]
        while(READ_BIT(hqspi->Instance->SR, QUADSPI_SR_FLEVEL) != 0U)
2000641e:	e013      	b.n	20006448 <HAL_QSPI_IRQHandler+0x1dc>
        {
          if (hqspi->RxXferCount > 0U)
20006420:	687b      	ldr	r3, [r7, #4]
20006422:	6b9b      	ldr	r3, [r3, #56]	; 0x38
20006424:	2b00      	cmp	r3, #0
20006426:	d017      	beq.n	20006458 <HAL_QSPI_IRQHandler+0x1ec>
          {
            /* Read the last data received in the FIFO until it is empty */
            *hqspi->pRxBuffPtr = *((__IO uint8_t *)data_reg);
20006428:	687b      	ldr	r3, [r7, #4]
2000642a:	6b1b      	ldr	r3, [r3, #48]	; 0x30
2000642c:	68fa      	ldr	r2, [r7, #12]
2000642e:	7812      	ldrb	r2, [r2, #0]
20006430:	b2d2      	uxtb	r2, r2
20006432:	701a      	strb	r2, [r3, #0]
            hqspi->pRxBuffPtr++;
20006434:	687b      	ldr	r3, [r7, #4]
20006436:	6b1b      	ldr	r3, [r3, #48]	; 0x30
20006438:	1c5a      	adds	r2, r3, #1
2000643a:	687b      	ldr	r3, [r7, #4]
2000643c:	631a      	str	r2, [r3, #48]	; 0x30
            hqspi->RxXferCount--;
2000643e:	687b      	ldr	r3, [r7, #4]
20006440:	6b9b      	ldr	r3, [r3, #56]	; 0x38
20006442:	1e5a      	subs	r2, r3, #1
20006444:	687b      	ldr	r3, [r7, #4]
20006446:	639a      	str	r2, [r3, #56]	; 0x38
        while(READ_BIT(hqspi->Instance->SR, QUADSPI_SR_FLEVEL) != 0U)
20006448:	687b      	ldr	r3, [r7, #4]
2000644a:	681b      	ldr	r3, [r3, #0]
2000644c:	689b      	ldr	r3, [r3, #8]
2000644e:	f403 53f8 	and.w	r3, r3, #7936	; 0x1f00
20006452:	2b00      	cmp	r3, #0
20006454:	d1e4      	bne.n	20006420 <HAL_QSPI_IRQHandler+0x1b4>
20006456:	e000      	b.n	2000645a <HAL_QSPI_IRQHandler+0x1ee>
          }
          else
          {
            /* All data have been received for the transfer */
            break;
20006458:	bf00      	nop
        }
      }


      /* Change state of QSPI */
      hqspi->State = HAL_QSPI_STATE_READY;
2000645a:	687b      	ldr	r3, [r7, #4]
2000645c:	2201      	movs	r2, #1
2000645e:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41

      /* RX Complete callback */
#if (USE_HAL_QSPI_REGISTER_CALLBACKS == 1)
      hqspi->RxCpltCallback(hqspi);
#else
      HAL_QSPI_RxCpltCallback(hqspi);
20006462:	6878      	ldr	r0, [r7, #4]
20006464:	f000 ff03 	bl	2000726e <HAL_QSPI_RxCpltCallback>
    if(hqspi->State == HAL_QSPI_STATE_BUSY_INDIRECT_TX)
20006468:	e0b0      	b.n	200065cc <HAL_QSPI_IRQHandler+0x360>
#endif
    }
    else if(hqspi->State == HAL_QSPI_STATE_BUSY)
2000646a:	687b      	ldr	r3, [r7, #4]
2000646c:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
20006470:	b2db      	uxtb	r3, r3
20006472:	2b02      	cmp	r3, #2
20006474:	d107      	bne.n	20006486 <HAL_QSPI_IRQHandler+0x21a>
    {
      /* Change state of QSPI */
      hqspi->State = HAL_QSPI_STATE_READY;
20006476:	687b      	ldr	r3, [r7, #4]
20006478:	2201      	movs	r2, #1
2000647a:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41

      /* Command Complete callback */
#if (USE_HAL_QSPI_REGISTER_CALLBACKS == 1)
      hqspi->CmdCpltCallback(hqspi);
#else
      HAL_QSPI_CmdCpltCallback(hqspi);
2000647e:	6878      	ldr	r0, [r7, #4]
20006480:	f000 feeb 	bl	2000725a <HAL_QSPI_CmdCpltCallback>
    if(hqspi->State == HAL_QSPI_STATE_BUSY_INDIRECT_TX)
20006484:	e0a2      	b.n	200065cc <HAL_QSPI_IRQHandler+0x360>
#endif
    }
    else if(hqspi->State == HAL_QSPI_STATE_ABORT)
20006486:	687b      	ldr	r3, [r7, #4]
20006488:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2000648c:	b2db      	uxtb	r3, r3
2000648e:	2b08      	cmp	r3, #8
20006490:	f040 809c 	bne.w	200065cc <HAL_QSPI_IRQHandler+0x360>
    {
      /* Reset functional mode configuration to indirect write mode by default */
      CLEAR_BIT(hqspi->Instance->CCR, QUADSPI_CCR_FMODE);
20006494:	687b      	ldr	r3, [r7, #4]
20006496:	681b      	ldr	r3, [r3, #0]
20006498:	695a      	ldr	r2, [r3, #20]
2000649a:	687b      	ldr	r3, [r7, #4]
2000649c:	681b      	ldr	r3, [r3, #0]
2000649e:	f022 6240 	bic.w	r2, r2, #201326592	; 0xc000000
200064a2:	615a      	str	r2, [r3, #20]

      /* Change state of QSPI */
      hqspi->State = HAL_QSPI_STATE_READY;
200064a4:	687b      	ldr	r3, [r7, #4]
200064a6:	2201      	movs	r2, #1
200064a8:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41

      if (hqspi->ErrorCode == HAL_QSPI_ERROR_NONE)
200064ac:	687b      	ldr	r3, [r7, #4]
200064ae:	6c5b      	ldr	r3, [r3, #68]	; 0x44
200064b0:	2b00      	cmp	r3, #0
200064b2:	d103      	bne.n	200064bc <HAL_QSPI_IRQHandler+0x250>

        /* Abort Complete callback */
#if (USE_HAL_QSPI_REGISTER_CALLBACKS == 1)
        hqspi->AbortCpltCallback(hqspi);
#else
        HAL_QSPI_AbortCpltCallback(hqspi);
200064b4:	6878      	ldr	r0, [r7, #4]
200064b6:	f000 fec6 	bl	20007246 <HAL_QSPI_AbortCpltCallback>
    if(hqspi->State == HAL_QSPI_STATE_BUSY_INDIRECT_TX)
200064ba:	e087      	b.n	200065cc <HAL_QSPI_IRQHandler+0x360>

        /* Error callback */
#if (USE_HAL_QSPI_REGISTER_CALLBACKS == 1)
        hqspi->ErrorCallback(hqspi);
#else
        HAL_QSPI_ErrorCallback(hqspi);
200064bc:	6878      	ldr	r0, [r7, #4]
200064be:	f000 feb8 	bl	20007232 <HAL_QSPI_ErrorCallback>
    if(hqspi->State == HAL_QSPI_STATE_BUSY_INDIRECT_TX)
200064c2:	e083      	b.n	200065cc <HAL_QSPI_IRQHandler+0x360>
     /* Nothing to do */
    }
  }

  /* QSPI Status Match interrupt occurred ------------------------------------*/
  else if(((flag & QSPI_FLAG_SM) != 0U) && ((itsource & QSPI_IT_SM) != 0U))
200064c4:	697b      	ldr	r3, [r7, #20]
200064c6:	f003 0308 	and.w	r3, r3, #8
200064ca:	2b00      	cmp	r3, #0
200064cc:	d01f      	beq.n	2000650e <HAL_QSPI_IRQHandler+0x2a2>
200064ce:	693b      	ldr	r3, [r7, #16]
200064d0:	f403 2300 	and.w	r3, r3, #524288	; 0x80000
200064d4:	2b00      	cmp	r3, #0
200064d6:	d01a      	beq.n	2000650e <HAL_QSPI_IRQHandler+0x2a2>
  {
    /* Clear interrupt */
    WRITE_REG(hqspi->Instance->FCR, QSPI_FLAG_SM);
200064d8:	687b      	ldr	r3, [r7, #4]
200064da:	681b      	ldr	r3, [r3, #0]
200064dc:	2208      	movs	r2, #8
200064de:	60da      	str	r2, [r3, #12]

    /* Check if the automatic poll mode stop is activated */
    if(READ_BIT(hqspi->Instance->CR, QUADSPI_CR_APMS) != 0U)
200064e0:	687b      	ldr	r3, [r7, #4]
200064e2:	681b      	ldr	r3, [r3, #0]
200064e4:	681b      	ldr	r3, [r3, #0]
200064e6:	f403 0380 	and.w	r3, r3, #4194304	; 0x400000
200064ea:	2b00      	cmp	r3, #0
200064ec:	d00b      	beq.n	20006506 <HAL_QSPI_IRQHandler+0x29a>
    {
      /* Disable the QSPI Transfer Error and Status Match Interrupts */
      __HAL_QSPI_DISABLE_IT(hqspi, (QSPI_IT_SM | QSPI_IT_TE));
200064ee:	687b      	ldr	r3, [r7, #4]
200064f0:	681b      	ldr	r3, [r3, #0]
200064f2:	681a      	ldr	r2, [r3, #0]
200064f4:	687b      	ldr	r3, [r7, #4]
200064f6:	681b      	ldr	r3, [r3, #0]
200064f8:	f422 2210 	bic.w	r2, r2, #589824	; 0x90000
200064fc:	601a      	str	r2, [r3, #0]

      /* Change state of QSPI */
      hqspi->State = HAL_QSPI_STATE_READY;
200064fe:	687b      	ldr	r3, [r7, #4]
20006500:	2201      	movs	r2, #1
20006502:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41

    /* Status match callback */
#if (USE_HAL_QSPI_REGISTER_CALLBACKS == 1)
    hqspi->StatusMatchCallback(hqspi);
#else
    HAL_QSPI_StatusMatchCallback(hqspi);
20006506:	6878      	ldr	r0, [r7, #4]
20006508:	f000 fee3 	bl	200072d2 <HAL_QSPI_StatusMatchCallback>
2000650c:	e061      	b.n	200065d2 <HAL_QSPI_IRQHandler+0x366>
#endif
  }

  /* QSPI Transfer Error interrupt occurred ----------------------------------*/
  else if(((flag & QSPI_FLAG_TE) != 0U) && ((itsource & QSPI_IT_TE) != 0U))
2000650e:	697b      	ldr	r3, [r7, #20]
20006510:	f003 0301 	and.w	r3, r3, #1
20006514:	2b00      	cmp	r3, #0
20006516:	d047      	beq.n	200065a8 <HAL_QSPI_IRQHandler+0x33c>
20006518:	693b      	ldr	r3, [r7, #16]
2000651a:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
2000651e:	2b00      	cmp	r3, #0
20006520:	d042      	beq.n	200065a8 <HAL_QSPI_IRQHandler+0x33c>
  {
    /* Clear interrupt */
    WRITE_REG(hqspi->Instance->FCR, QSPI_FLAG_TE);
20006522:	687b      	ldr	r3, [r7, #4]
20006524:	681b      	ldr	r3, [r3, #0]
20006526:	2201      	movs	r2, #1
20006528:	60da      	str	r2, [r3, #12]

    /* Disable all the QSPI Interrupts */
    __HAL_QSPI_DISABLE_IT(hqspi, QSPI_IT_SM | QSPI_IT_TC | QSPI_IT_TE | QSPI_IT_FT);
2000652a:	687b      	ldr	r3, [r7, #4]
2000652c:	681b      	ldr	r3, [r3, #0]
2000652e:	681a      	ldr	r2, [r3, #0]
20006530:	687b      	ldr	r3, [r7, #4]
20006532:	681b      	ldr	r3, [r3, #0]
20006534:	f422 2270 	bic.w	r2, r2, #983040	; 0xf0000
20006538:	601a      	str	r2, [r3, #0]

    /* Set error code */
    hqspi->ErrorCode |= HAL_QSPI_ERROR_TRANSFER;
2000653a:	687b      	ldr	r3, [r7, #4]
2000653c:	6c5b      	ldr	r3, [r3, #68]	; 0x44
2000653e:	f043 0202 	orr.w	r2, r3, #2
20006542:	687b      	ldr	r3, [r7, #4]
20006544:	645a      	str	r2, [r3, #68]	; 0x44

    if ((hqspi->Instance->CR & QUADSPI_CR_DMAEN) != 0U)
20006546:	687b      	ldr	r3, [r7, #4]
20006548:	681b      	ldr	r3, [r3, #0]
2000654a:	681b      	ldr	r3, [r3, #0]
2000654c:	f003 0304 	and.w	r3, r3, #4
20006550:	2b00      	cmp	r3, #0
20006552:	d021      	beq.n	20006598 <HAL_QSPI_IRQHandler+0x32c>
    {
      /* Disable the DMA transfer by clearing the DMAEN bit in the QSPI CR register */
      CLEAR_BIT(hqspi->Instance->CR, QUADSPI_CR_DMAEN);
20006554:	687b      	ldr	r3, [r7, #4]
20006556:	681b      	ldr	r3, [r3, #0]
20006558:	681a      	ldr	r2, [r3, #0]
2000655a:	687b      	ldr	r3, [r7, #4]
2000655c:	681b      	ldr	r3, [r3, #0]
2000655e:	f022 0204 	bic.w	r2, r2, #4
20006562:	601a      	str	r2, [r3, #0]

      /* Disable the DMA channel */
      hqspi->hdma->XferAbortCallback = QSPI_DMAAbortCplt;
20006564:	687b      	ldr	r3, [r7, #4]
20006566:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
20006568:	4a1c      	ldr	r2, [pc, #112]	; (200065dc <HAL_QSPI_IRQHandler+0x370>)
2000656a:	639a      	str	r2, [r3, #56]	; 0x38
      if (HAL_DMA_Abort_IT(hqspi->hdma) != HAL_OK)
2000656c:	687b      	ldr	r3, [r7, #4]
2000656e:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
20006570:	4618      	mov	r0, r3
20006572:	f7fc f91a 	bl	200027aa <HAL_DMA_Abort_IT>
20006576:	4603      	mov	r3, r0
20006578:	2b00      	cmp	r3, #0
2000657a:	d029      	beq.n	200065d0 <HAL_QSPI_IRQHandler+0x364>
      {
        /* Set error code to DMA */
        hqspi->ErrorCode |= HAL_QSPI_ERROR_DMA;
2000657c:	687b      	ldr	r3, [r7, #4]
2000657e:	6c5b      	ldr	r3, [r3, #68]	; 0x44
20006580:	f043 0204 	orr.w	r2, r3, #4
20006584:	687b      	ldr	r3, [r7, #4]
20006586:	645a      	str	r2, [r3, #68]	; 0x44

        /* Change state of QSPI */
        hqspi->State = HAL_QSPI_STATE_READY;
20006588:	687b      	ldr	r3, [r7, #4]
2000658a:	2201      	movs	r2, #1
2000658c:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
        
        /* Error callback */
#if (USE_HAL_QSPI_REGISTER_CALLBACKS == 1)
        hqspi->ErrorCallback(hqspi);
#else
        HAL_QSPI_ErrorCallback(hqspi);
20006590:	6878      	ldr	r0, [r7, #4]
20006592:	f000 fe4e 	bl	20007232 <HAL_QSPI_ErrorCallback>
    if ((hqspi->Instance->CR & QUADSPI_CR_DMAEN) != 0U)
20006596:	e01b      	b.n	200065d0 <HAL_QSPI_IRQHandler+0x364>
      }
    }
    else
    {
      /* Change state of QSPI */
      hqspi->State = HAL_QSPI_STATE_READY;
20006598:	687b      	ldr	r3, [r7, #4]
2000659a:	2201      	movs	r2, #1
2000659c:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41

      /* Error callback */
#if (USE_HAL_QSPI_REGISTER_CALLBACKS == 1)
      hqspi->ErrorCallback(hqspi);
#else
      HAL_QSPI_ErrorCallback(hqspi);
200065a0:	6878      	ldr	r0, [r7, #4]
200065a2:	f000 fe46 	bl	20007232 <HAL_QSPI_ErrorCallback>
    if ((hqspi->Instance->CR & QUADSPI_CR_DMAEN) != 0U)
200065a6:	e013      	b.n	200065d0 <HAL_QSPI_IRQHandler+0x364>
#endif
    }
  }

  /* QSPI Timeout interrupt occurred -----------------------------------------*/
  else if(((flag & QSPI_FLAG_TO) != 0U) && ((itsource & QSPI_IT_TO) != 0U))
200065a8:	697b      	ldr	r3, [r7, #20]
200065aa:	f003 0310 	and.w	r3, r3, #16
200065ae:	2b00      	cmp	r3, #0
200065b0:	d00f      	beq.n	200065d2 <HAL_QSPI_IRQHandler+0x366>
200065b2:	693b      	ldr	r3, [r7, #16]
200065b4:	f403 1380 	and.w	r3, r3, #1048576	; 0x100000
200065b8:	2b00      	cmp	r3, #0
200065ba:	d00a      	beq.n	200065d2 <HAL_QSPI_IRQHandler+0x366>
  {
    /* Clear interrupt */
    WRITE_REG(hqspi->Instance->FCR, QSPI_FLAG_TO);
200065bc:	687b      	ldr	r3, [r7, #4]
200065be:	681b      	ldr	r3, [r3, #0]
200065c0:	2210      	movs	r2, #16
200065c2:	60da      	str	r2, [r3, #12]

    /* Timeout callback */
#if (USE_HAL_QSPI_REGISTER_CALLBACKS == 1)
    hqspi->TimeOutCallback(hqspi);
#else
    HAL_QSPI_TimeOutCallback(hqspi);
200065c4:	6878      	ldr	r0, [r7, #4]
200065c6:	f000 fe8e 	bl	200072e6 <HAL_QSPI_TimeOutCallback>

   else
  {
   /* Nothing to do */
  }
}
200065ca:	e002      	b.n	200065d2 <HAL_QSPI_IRQHandler+0x366>
    if(hqspi->State == HAL_QSPI_STATE_BUSY_INDIRECT_TX)
200065cc:	bf00      	nop
200065ce:	e000      	b.n	200065d2 <HAL_QSPI_IRQHandler+0x366>
    if ((hqspi->Instance->CR & QUADSPI_CR_DMAEN) != 0U)
200065d0:	bf00      	nop
}
200065d2:	bf00      	nop
200065d4:	3718      	adds	r7, #24
200065d6:	46bd      	mov	sp, r7
200065d8:	bd80      	pop	{r7, pc}
200065da:	bf00      	nop
200065dc:	200076b1 	.word	0x200076b1

200065e0 <HAL_QSPI_Command>:
  * @param Timeout : Timeout duration
  * @note   This function is used only in Indirect Read or Write Modes
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_QSPI_Command(QSPI_HandleTypeDef *hqspi, QSPI_CommandTypeDef *cmd, uint32_t Timeout)
{
200065e0:	b580      	push	{r7, lr}
200065e2:	b088      	sub	sp, #32
200065e4:	af02      	add	r7, sp, #8
200065e6:	60f8      	str	r0, [r7, #12]
200065e8:	60b9      	str	r1, [r7, #8]
200065ea:	607a      	str	r2, [r7, #4]
  HAL_StatusTypeDef status;
  uint32_t tickstart = HAL_GetTick();
200065ec:	f7fb f956 	bl	2000189c <HAL_GetTick>
200065f0:	6138      	str	r0, [r7, #16]
  assert_param(IS_QSPI_DDR_MODE(cmd->DdrMode));
  assert_param(IS_QSPI_DDR_HHC(cmd->DdrHoldHalfCycle));
  assert_param(IS_QSPI_SIOO_MODE(cmd->SIOOMode));

  /* Process locked */
  __HAL_LOCK(hqspi);
200065f2:	68fb      	ldr	r3, [r7, #12]
200065f4:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
200065f8:	b2db      	uxtb	r3, r3
200065fa:	2b01      	cmp	r3, #1
200065fc:	d101      	bne.n	20006602 <HAL_QSPI_Command+0x22>
200065fe:	2302      	movs	r3, #2
20006600:	e048      	b.n	20006694 <HAL_QSPI_Command+0xb4>
20006602:	68fb      	ldr	r3, [r7, #12]
20006604:	2201      	movs	r2, #1
20006606:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

  if(hqspi->State == HAL_QSPI_STATE_READY)
2000660a:	68fb      	ldr	r3, [r7, #12]
2000660c:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
20006610:	b2db      	uxtb	r3, r3
20006612:	2b01      	cmp	r3, #1
20006614:	d137      	bne.n	20006686 <HAL_QSPI_Command+0xa6>
  {
    hqspi->ErrorCode = HAL_QSPI_ERROR_NONE;
20006616:	68fb      	ldr	r3, [r7, #12]
20006618:	2200      	movs	r2, #0
2000661a:	645a      	str	r2, [r3, #68]	; 0x44

    /* Update QSPI state */
    hqspi->State = HAL_QSPI_STATE_BUSY;
2000661c:	68fb      	ldr	r3, [r7, #12]
2000661e:	2202      	movs	r2, #2
20006620:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41

    /* Wait till BUSY flag reset */
    status = QSPI_WaitFlagStateUntilTimeout(hqspi, QSPI_FLAG_BUSY, RESET, tickstart, Timeout);
20006624:	687b      	ldr	r3, [r7, #4]
20006626:	9300      	str	r3, [sp, #0]
20006628:	693b      	ldr	r3, [r7, #16]
2000662a:	2200      	movs	r2, #0
2000662c:	2120      	movs	r1, #32
2000662e:	68f8      	ldr	r0, [r7, #12]
20006630:	f001 f871 	bl	20007716 <QSPI_WaitFlagStateUntilTimeout>
20006634:	4603      	mov	r3, r0
20006636:	75fb      	strb	r3, [r7, #23]

    if (status == HAL_OK)
20006638:	7dfb      	ldrb	r3, [r7, #23]
2000663a:	2b00      	cmp	r3, #0
2000663c:	d125      	bne.n	2000668a <HAL_QSPI_Command+0xaa>
    {
      /* Call the configuration function */
      QSPI_Config(hqspi, cmd, QSPI_FUNCTIONAL_MODE_INDIRECT_WRITE);
2000663e:	2200      	movs	r2, #0
20006640:	68b9      	ldr	r1, [r7, #8]
20006642:	68f8      	ldr	r0, [r7, #12]
20006644:	f001 f89e 	bl	20007784 <QSPI_Config>

      if (cmd->DataMode == QSPI_DATA_NONE)
20006648:	68bb      	ldr	r3, [r7, #8]
2000664a:	6a5b      	ldr	r3, [r3, #36]	; 0x24
2000664c:	2b00      	cmp	r3, #0
2000664e:	d115      	bne.n	2000667c <HAL_QSPI_Command+0x9c>
      {
        /* When there is no data phase, the transfer start as soon as the configuration is done
        so wait until TC flag is set to go back in idle state */
        status = QSPI_WaitFlagStateUntilTimeout(hqspi, QSPI_FLAG_TC, SET, tickstart, Timeout);
20006650:	687b      	ldr	r3, [r7, #4]
20006652:	9300      	str	r3, [sp, #0]
20006654:	693b      	ldr	r3, [r7, #16]
20006656:	2201      	movs	r2, #1
20006658:	2102      	movs	r1, #2
2000665a:	68f8      	ldr	r0, [r7, #12]
2000665c:	f001 f85b 	bl	20007716 <QSPI_WaitFlagStateUntilTimeout>
20006660:	4603      	mov	r3, r0
20006662:	75fb      	strb	r3, [r7, #23]

        if (status == HAL_OK)
20006664:	7dfb      	ldrb	r3, [r7, #23]
20006666:	2b00      	cmp	r3, #0
20006668:	d10f      	bne.n	2000668a <HAL_QSPI_Command+0xaa>
        {
          __HAL_QSPI_CLEAR_FLAG(hqspi, QSPI_FLAG_TC);
2000666a:	68fb      	ldr	r3, [r7, #12]
2000666c:	681b      	ldr	r3, [r3, #0]
2000666e:	2202      	movs	r2, #2
20006670:	60da      	str	r2, [r3, #12]

          /* Update QSPI state */
          hqspi->State = HAL_QSPI_STATE_READY;
20006672:	68fb      	ldr	r3, [r7, #12]
20006674:	2201      	movs	r2, #1
20006676:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
2000667a:	e006      	b.n	2000668a <HAL_QSPI_Command+0xaa>
        }
      }
      else
      {
        /* Update QSPI state */
        hqspi->State = HAL_QSPI_STATE_READY;
2000667c:	68fb      	ldr	r3, [r7, #12]
2000667e:	2201      	movs	r2, #1
20006680:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
20006684:	e001      	b.n	2000668a <HAL_QSPI_Command+0xaa>
      }
    }
  }
  else
  {
    status = HAL_BUSY;
20006686:	2302      	movs	r3, #2
20006688:	75fb      	strb	r3, [r7, #23]
  }

  /* Process unlocked */
  __HAL_UNLOCK(hqspi);
2000668a:	68fb      	ldr	r3, [r7, #12]
2000668c:	2200      	movs	r2, #0
2000668e:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

  /* Return function status */
  return status;
20006692:	7dfb      	ldrb	r3, [r7, #23]
}
20006694:	4618      	mov	r0, r3
20006696:	3718      	adds	r7, #24
20006698:	46bd      	mov	sp, r7
2000669a:	bd80      	pop	{r7, pc}

2000669c <HAL_QSPI_Command_IT>:
  * @param cmd : structure that contains the command configuration information
  * @note   This function is used only in Indirect Read or Write Modes
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_QSPI_Command_IT(QSPI_HandleTypeDef *hqspi, QSPI_CommandTypeDef *cmd)
{
2000669c:	b580      	push	{r7, lr}
2000669e:	b086      	sub	sp, #24
200066a0:	af02      	add	r7, sp, #8
200066a2:	6078      	str	r0, [r7, #4]
200066a4:	6039      	str	r1, [r7, #0]
  HAL_StatusTypeDef status;
  uint32_t tickstart = HAL_GetTick();
200066a6:	f7fb f8f9 	bl	2000189c <HAL_GetTick>
200066aa:	60b8      	str	r0, [r7, #8]
  assert_param(IS_QSPI_DDR_MODE(cmd->DdrMode));
  assert_param(IS_QSPI_DDR_HHC(cmd->DdrHoldHalfCycle));
  assert_param(IS_QSPI_SIOO_MODE(cmd->SIOOMode));

  /* Process locked */
  __HAL_LOCK(hqspi);
200066ac:	687b      	ldr	r3, [r7, #4]
200066ae:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
200066b2:	b2db      	uxtb	r3, r3
200066b4:	2b01      	cmp	r3, #1
200066b6:	d101      	bne.n	200066bc <HAL_QSPI_Command_IT+0x20>
200066b8:	2302      	movs	r3, #2
200066ba:	e051      	b.n	20006760 <HAL_QSPI_Command_IT+0xc4>
200066bc:	687b      	ldr	r3, [r7, #4]
200066be:	2201      	movs	r2, #1
200066c0:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

  if(hqspi->State == HAL_QSPI_STATE_READY)
200066c4:	687b      	ldr	r3, [r7, #4]
200066c6:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
200066ca:	b2db      	uxtb	r3, r3
200066cc:	2b01      	cmp	r3, #1
200066ce:	d140      	bne.n	20006752 <HAL_QSPI_Command_IT+0xb6>
  {
    hqspi->ErrorCode = HAL_QSPI_ERROR_NONE;
200066d0:	687b      	ldr	r3, [r7, #4]
200066d2:	2200      	movs	r2, #0
200066d4:	645a      	str	r2, [r3, #68]	; 0x44

    /* Update QSPI state */
    hqspi->State = HAL_QSPI_STATE_BUSY;
200066d6:	687b      	ldr	r3, [r7, #4]
200066d8:	2202      	movs	r2, #2
200066da:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41

    /* Wait till BUSY flag reset */
    status = QSPI_WaitFlagStateUntilTimeout(hqspi, QSPI_FLAG_BUSY, RESET, tickstart, hqspi->Timeout);
200066de:	687b      	ldr	r3, [r7, #4]
200066e0:	6c9b      	ldr	r3, [r3, #72]	; 0x48
200066e2:	9300      	str	r3, [sp, #0]
200066e4:	68bb      	ldr	r3, [r7, #8]
200066e6:	2200      	movs	r2, #0
200066e8:	2120      	movs	r1, #32
200066ea:	6878      	ldr	r0, [r7, #4]
200066ec:	f001 f813 	bl	20007716 <QSPI_WaitFlagStateUntilTimeout>
200066f0:	4603      	mov	r3, r0
200066f2:	73fb      	strb	r3, [r7, #15]

    if (status == HAL_OK)
200066f4:	7bfb      	ldrb	r3, [r7, #15]
200066f6:	2b00      	cmp	r3, #0
200066f8:	d126      	bne.n	20006748 <HAL_QSPI_Command_IT+0xac>
    {
      if (cmd->DataMode == QSPI_DATA_NONE)
200066fa:	683b      	ldr	r3, [r7, #0]
200066fc:	6a5b      	ldr	r3, [r3, #36]	; 0x24
200066fe:	2b00      	cmp	r3, #0
20006700:	d103      	bne.n	2000670a <HAL_QSPI_Command_IT+0x6e>
      {
        /* Clear interrupt */
        __HAL_QSPI_CLEAR_FLAG(hqspi, QSPI_FLAG_TE | QSPI_FLAG_TC);
20006702:	687b      	ldr	r3, [r7, #4]
20006704:	681b      	ldr	r3, [r3, #0]
20006706:	2203      	movs	r2, #3
20006708:	60da      	str	r2, [r3, #12]
      }

      /* Call the configuration function */
      QSPI_Config(hqspi, cmd, QSPI_FUNCTIONAL_MODE_INDIRECT_WRITE);
2000670a:	2200      	movs	r2, #0
2000670c:	6839      	ldr	r1, [r7, #0]
2000670e:	6878      	ldr	r0, [r7, #4]
20006710:	f001 f838 	bl	20007784 <QSPI_Config>

      if (cmd->DataMode == QSPI_DATA_NONE)
20006714:	683b      	ldr	r3, [r7, #0]
20006716:	6a5b      	ldr	r3, [r3, #36]	; 0x24
20006718:	2b00      	cmp	r3, #0
2000671a:	d10c      	bne.n	20006736 <HAL_QSPI_Command_IT+0x9a>
      {
        /* When there is no data phase, the transfer start as soon as the configuration is done
        so activate TC and TE interrupts */
        /* Process unlocked */
        __HAL_UNLOCK(hqspi);
2000671c:	687b      	ldr	r3, [r7, #4]
2000671e:	2200      	movs	r2, #0
20006720:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

        /* Enable the QSPI Transfer Error Interrupt */
        __HAL_QSPI_ENABLE_IT(hqspi, QSPI_IT_TE | QSPI_IT_TC);
20006724:	687b      	ldr	r3, [r7, #4]
20006726:	681b      	ldr	r3, [r3, #0]
20006728:	681a      	ldr	r2, [r3, #0]
2000672a:	687b      	ldr	r3, [r7, #4]
2000672c:	681b      	ldr	r3, [r3, #0]
2000672e:	f442 3240 	orr.w	r2, r2, #196608	; 0x30000
20006732:	601a      	str	r2, [r3, #0]
20006734:	e013      	b.n	2000675e <HAL_QSPI_Command_IT+0xc2>
      }
      else
      {
        /* Update QSPI state */
        hqspi->State = HAL_QSPI_STATE_READY;
20006736:	687b      	ldr	r3, [r7, #4]
20006738:	2201      	movs	r2, #1
2000673a:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41

        /* Process unlocked */
        __HAL_UNLOCK(hqspi);
2000673e:	687b      	ldr	r3, [r7, #4]
20006740:	2200      	movs	r2, #0
20006742:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
20006746:	e00a      	b.n	2000675e <HAL_QSPI_Command_IT+0xc2>
      }
    }
    else
    {
      /* Process unlocked */
      __HAL_UNLOCK(hqspi);
20006748:	687b      	ldr	r3, [r7, #4]
2000674a:	2200      	movs	r2, #0
2000674c:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
20006750:	e005      	b.n	2000675e <HAL_QSPI_Command_IT+0xc2>
    }
  }
  else
  {
    status = HAL_BUSY;
20006752:	2302      	movs	r3, #2
20006754:	73fb      	strb	r3, [r7, #15]

    /* Process unlocked */
    __HAL_UNLOCK(hqspi);
20006756:	687b      	ldr	r3, [r7, #4]
20006758:	2200      	movs	r2, #0
2000675a:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
  }

  /* Return function status */
  return status;
2000675e:	7bfb      	ldrb	r3, [r7, #15]
}
20006760:	4618      	mov	r0, r3
20006762:	3710      	adds	r7, #16
20006764:	46bd      	mov	sp, r7
20006766:	bd80      	pop	{r7, pc}

20006768 <HAL_QSPI_Transmit>:
  * @param Timeout : Timeout duration
  * @note   This function is used only in Indirect Write Mode
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_QSPI_Transmit(QSPI_HandleTypeDef *hqspi, uint8_t *pData, uint32_t Timeout)
{
20006768:	b580      	push	{r7, lr}
2000676a:	b08a      	sub	sp, #40	; 0x28
2000676c:	af02      	add	r7, sp, #8
2000676e:	60f8      	str	r0, [r7, #12]
20006770:	60b9      	str	r1, [r7, #8]
20006772:	607a      	str	r2, [r7, #4]
  HAL_StatusTypeDef status = HAL_OK;
20006774:	2300      	movs	r3, #0
20006776:	77fb      	strb	r3, [r7, #31]
  uint32_t tickstart = HAL_GetTick();
20006778:	f7fb f890 	bl	2000189c <HAL_GetTick>
2000677c:	61b8      	str	r0, [r7, #24]
  __IO uint32_t *data_reg = &hqspi->Instance->DR;
2000677e:	68fb      	ldr	r3, [r7, #12]
20006780:	681b      	ldr	r3, [r3, #0]
20006782:	3320      	adds	r3, #32
20006784:	617b      	str	r3, [r7, #20]

  /* Process locked */
  __HAL_LOCK(hqspi);
20006786:	68fb      	ldr	r3, [r7, #12]
20006788:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
2000678c:	b2db      	uxtb	r3, r3
2000678e:	2b01      	cmp	r3, #1
20006790:	d101      	bne.n	20006796 <HAL_QSPI_Transmit+0x2e>
20006792:	2302      	movs	r3, #2
20006794:	e076      	b.n	20006884 <HAL_QSPI_Transmit+0x11c>
20006796:	68fb      	ldr	r3, [r7, #12]
20006798:	2201      	movs	r2, #1
2000679a:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

  if(hqspi->State == HAL_QSPI_STATE_READY)
2000679e:	68fb      	ldr	r3, [r7, #12]
200067a0:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
200067a4:	b2db      	uxtb	r3, r3
200067a6:	2b01      	cmp	r3, #1
200067a8:	d165      	bne.n	20006876 <HAL_QSPI_Transmit+0x10e>
  {
    hqspi->ErrorCode = HAL_QSPI_ERROR_NONE;
200067aa:	68fb      	ldr	r3, [r7, #12]
200067ac:	2200      	movs	r2, #0
200067ae:	645a      	str	r2, [r3, #68]	; 0x44

    if(pData != NULL )
200067b0:	68bb      	ldr	r3, [r7, #8]
200067b2:	2b00      	cmp	r3, #0
200067b4:	d056      	beq.n	20006864 <HAL_QSPI_Transmit+0xfc>
    {
      /* Update state */
      hqspi->State = HAL_QSPI_STATE_BUSY_INDIRECT_TX;
200067b6:	68fb      	ldr	r3, [r7, #12]
200067b8:	2212      	movs	r2, #18
200067ba:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41

      /* Configure counters and size of the handle */
      hqspi->TxXferCount = READ_REG(hqspi->Instance->DLR) + 1U;
200067be:	68fb      	ldr	r3, [r7, #12]
200067c0:	681b      	ldr	r3, [r3, #0]
200067c2:	691b      	ldr	r3, [r3, #16]
200067c4:	1c5a      	adds	r2, r3, #1
200067c6:	68fb      	ldr	r3, [r7, #12]
200067c8:	62da      	str	r2, [r3, #44]	; 0x2c
      hqspi->TxXferSize = READ_REG(hqspi->Instance->DLR) + 1U;
200067ca:	68fb      	ldr	r3, [r7, #12]
200067cc:	681b      	ldr	r3, [r3, #0]
200067ce:	691b      	ldr	r3, [r3, #16]
200067d0:	1c5a      	adds	r2, r3, #1
200067d2:	68fb      	ldr	r3, [r7, #12]
200067d4:	629a      	str	r2, [r3, #40]	; 0x28
      hqspi->pTxBuffPtr = pData;
200067d6:	68fb      	ldr	r3, [r7, #12]
200067d8:	68ba      	ldr	r2, [r7, #8]
200067da:	625a      	str	r2, [r3, #36]	; 0x24

      /* Configure QSPI: CCR register with functional as indirect write */
      MODIFY_REG(hqspi->Instance->CCR, QUADSPI_CCR_FMODE, QSPI_FUNCTIONAL_MODE_INDIRECT_WRITE);
200067dc:	68fb      	ldr	r3, [r7, #12]
200067de:	681b      	ldr	r3, [r3, #0]
200067e0:	695a      	ldr	r2, [r3, #20]
200067e2:	68fb      	ldr	r3, [r7, #12]
200067e4:	681b      	ldr	r3, [r3, #0]
200067e6:	f022 6240 	bic.w	r2, r2, #201326592	; 0xc000000
200067ea:	615a      	str	r2, [r3, #20]

      while(hqspi->TxXferCount > 0U)
200067ec:	e01b      	b.n	20006826 <HAL_QSPI_Transmit+0xbe>
      {
        /* Wait until FT flag is set to send data */
        status = QSPI_WaitFlagStateUntilTimeout(hqspi, QSPI_FLAG_FT, SET, tickstart, Timeout);
200067ee:	687b      	ldr	r3, [r7, #4]
200067f0:	9300      	str	r3, [sp, #0]
200067f2:	69bb      	ldr	r3, [r7, #24]
200067f4:	2201      	movs	r2, #1
200067f6:	2104      	movs	r1, #4
200067f8:	68f8      	ldr	r0, [r7, #12]
200067fa:	f000 ff8c 	bl	20007716 <QSPI_WaitFlagStateUntilTimeout>
200067fe:	4603      	mov	r3, r0
20006800:	77fb      	strb	r3, [r7, #31]

        if (status != HAL_OK)
20006802:	7ffb      	ldrb	r3, [r7, #31]
20006804:	2b00      	cmp	r3, #0
20006806:	d113      	bne.n	20006830 <HAL_QSPI_Transmit+0xc8>
        {
          break;
        }

        *((__IO uint8_t *)data_reg) = *hqspi->pTxBuffPtr;
20006808:	68fb      	ldr	r3, [r7, #12]
2000680a:	6a5b      	ldr	r3, [r3, #36]	; 0x24
2000680c:	781a      	ldrb	r2, [r3, #0]
2000680e:	697b      	ldr	r3, [r7, #20]
20006810:	701a      	strb	r2, [r3, #0]
        hqspi->pTxBuffPtr++;
20006812:	68fb      	ldr	r3, [r7, #12]
20006814:	6a5b      	ldr	r3, [r3, #36]	; 0x24
20006816:	1c5a      	adds	r2, r3, #1
20006818:	68fb      	ldr	r3, [r7, #12]
2000681a:	625a      	str	r2, [r3, #36]	; 0x24
        hqspi->TxXferCount--;
2000681c:	68fb      	ldr	r3, [r7, #12]
2000681e:	6adb      	ldr	r3, [r3, #44]	; 0x2c
20006820:	1e5a      	subs	r2, r3, #1
20006822:	68fb      	ldr	r3, [r7, #12]
20006824:	62da      	str	r2, [r3, #44]	; 0x2c
      while(hqspi->TxXferCount > 0U)
20006826:	68fb      	ldr	r3, [r7, #12]
20006828:	6adb      	ldr	r3, [r3, #44]	; 0x2c
2000682a:	2b00      	cmp	r3, #0
2000682c:	d1df      	bne.n	200067ee <HAL_QSPI_Transmit+0x86>
2000682e:	e000      	b.n	20006832 <HAL_QSPI_Transmit+0xca>
          break;
20006830:	bf00      	nop
      }

      if (status == HAL_OK)
20006832:	7ffb      	ldrb	r3, [r7, #31]
20006834:	2b00      	cmp	r3, #0
20006836:	d110      	bne.n	2000685a <HAL_QSPI_Transmit+0xf2>
      {
        /* Wait until TC flag is set to go back in idle state */
        status = QSPI_WaitFlagStateUntilTimeout(hqspi, QSPI_FLAG_TC, SET, tickstart, Timeout);
20006838:	687b      	ldr	r3, [r7, #4]
2000683a:	9300      	str	r3, [sp, #0]
2000683c:	69bb      	ldr	r3, [r7, #24]
2000683e:	2201      	movs	r2, #1
20006840:	2102      	movs	r1, #2
20006842:	68f8      	ldr	r0, [r7, #12]
20006844:	f000 ff67 	bl	20007716 <QSPI_WaitFlagStateUntilTimeout>
20006848:	4603      	mov	r3, r0
2000684a:	77fb      	strb	r3, [r7, #31]

        if (status == HAL_OK)
2000684c:	7ffb      	ldrb	r3, [r7, #31]
2000684e:	2b00      	cmp	r3, #0
20006850:	d103      	bne.n	2000685a <HAL_QSPI_Transmit+0xf2>
        {
          /* Clear Transfer Complete bit */
          __HAL_QSPI_CLEAR_FLAG(hqspi, QSPI_FLAG_TC);
20006852:	68fb      	ldr	r3, [r7, #12]
20006854:	681b      	ldr	r3, [r3, #0]
20006856:	2202      	movs	r2, #2
20006858:	60da      	str	r2, [r3, #12]

        }
      }

      /* Update QSPI state */
      hqspi->State = HAL_QSPI_STATE_READY;
2000685a:	68fb      	ldr	r3, [r7, #12]
2000685c:	2201      	movs	r2, #1
2000685e:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
20006862:	e00a      	b.n	2000687a <HAL_QSPI_Transmit+0x112>
    }
    else
    {
      hqspi->ErrorCode |= HAL_QSPI_ERROR_INVALID_PARAM;
20006864:	68fb      	ldr	r3, [r7, #12]
20006866:	6c5b      	ldr	r3, [r3, #68]	; 0x44
20006868:	f043 0208 	orr.w	r2, r3, #8
2000686c:	68fb      	ldr	r3, [r7, #12]
2000686e:	645a      	str	r2, [r3, #68]	; 0x44
      status = HAL_ERROR;
20006870:	2301      	movs	r3, #1
20006872:	77fb      	strb	r3, [r7, #31]
20006874:	e001      	b.n	2000687a <HAL_QSPI_Transmit+0x112>
    }
  }
  else
  {
    status = HAL_BUSY;
20006876:	2302      	movs	r3, #2
20006878:	77fb      	strb	r3, [r7, #31]
  }

  /* Process unlocked */
  __HAL_UNLOCK(hqspi);
2000687a:	68fb      	ldr	r3, [r7, #12]
2000687c:	2200      	movs	r2, #0
2000687e:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

  return status;
20006882:	7ffb      	ldrb	r3, [r7, #31]
}
20006884:	4618      	mov	r0, r3
20006886:	3720      	adds	r7, #32
20006888:	46bd      	mov	sp, r7
2000688a:	bd80      	pop	{r7, pc}

2000688c <HAL_QSPI_Receive>:
  * @param Timeout : Timeout duration
  * @note   This function is used only in Indirect Read Mode
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_QSPI_Receive(QSPI_HandleTypeDef *hqspi, uint8_t *pData, uint32_t Timeout)
{
2000688c:	b580      	push	{r7, lr}
2000688e:	b08a      	sub	sp, #40	; 0x28
20006890:	af02      	add	r7, sp, #8
20006892:	60f8      	str	r0, [r7, #12]
20006894:	60b9      	str	r1, [r7, #8]
20006896:	607a      	str	r2, [r7, #4]
  HAL_StatusTypeDef status = HAL_OK;
20006898:	2300      	movs	r3, #0
2000689a:	77fb      	strb	r3, [r7, #31]
  uint32_t tickstart = HAL_GetTick();
2000689c:	f7fa fffe 	bl	2000189c <HAL_GetTick>
200068a0:	61b8      	str	r0, [r7, #24]
  uint32_t addr_reg = READ_REG(hqspi->Instance->AR);
200068a2:	68fb      	ldr	r3, [r7, #12]
200068a4:	681b      	ldr	r3, [r3, #0]
200068a6:	699b      	ldr	r3, [r3, #24]
200068a8:	617b      	str	r3, [r7, #20]
  __IO uint32_t *data_reg = &hqspi->Instance->DR;
200068aa:	68fb      	ldr	r3, [r7, #12]
200068ac:	681b      	ldr	r3, [r3, #0]
200068ae:	3320      	adds	r3, #32
200068b0:	613b      	str	r3, [r7, #16]

  /* Process locked */
  __HAL_LOCK(hqspi);
200068b2:	68fb      	ldr	r3, [r7, #12]
200068b4:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
200068b8:	b2db      	uxtb	r3, r3
200068ba:	2b01      	cmp	r3, #1
200068bc:	d101      	bne.n	200068c2 <HAL_QSPI_Receive+0x36>
200068be:	2302      	movs	r3, #2
200068c0:	e07d      	b.n	200069be <HAL_QSPI_Receive+0x132>
200068c2:	68fb      	ldr	r3, [r7, #12]
200068c4:	2201      	movs	r2, #1
200068c6:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

  if(hqspi->State == HAL_QSPI_STATE_READY)
200068ca:	68fb      	ldr	r3, [r7, #12]
200068cc:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
200068d0:	b2db      	uxtb	r3, r3
200068d2:	2b01      	cmp	r3, #1
200068d4:	d16c      	bne.n	200069b0 <HAL_QSPI_Receive+0x124>
  {
    hqspi->ErrorCode = HAL_QSPI_ERROR_NONE;
200068d6:	68fb      	ldr	r3, [r7, #12]
200068d8:	2200      	movs	r2, #0
200068da:	645a      	str	r2, [r3, #68]	; 0x44

    if(pData != NULL )
200068dc:	68bb      	ldr	r3, [r7, #8]
200068de:	2b00      	cmp	r3, #0
200068e0:	d05d      	beq.n	2000699e <HAL_QSPI_Receive+0x112>
    {
      /* Update state */
      hqspi->State = HAL_QSPI_STATE_BUSY_INDIRECT_RX;
200068e2:	68fb      	ldr	r3, [r7, #12]
200068e4:	2222      	movs	r2, #34	; 0x22
200068e6:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41

      /* Configure counters and size of the handle */
      hqspi->RxXferCount = READ_REG(hqspi->Instance->DLR) + 1U;
200068ea:	68fb      	ldr	r3, [r7, #12]
200068ec:	681b      	ldr	r3, [r3, #0]
200068ee:	691b      	ldr	r3, [r3, #16]
200068f0:	1c5a      	adds	r2, r3, #1
200068f2:	68fb      	ldr	r3, [r7, #12]
200068f4:	639a      	str	r2, [r3, #56]	; 0x38
      hqspi->RxXferSize = READ_REG(hqspi->Instance->DLR) + 1U;
200068f6:	68fb      	ldr	r3, [r7, #12]
200068f8:	681b      	ldr	r3, [r3, #0]
200068fa:	691b      	ldr	r3, [r3, #16]
200068fc:	1c5a      	adds	r2, r3, #1
200068fe:	68fb      	ldr	r3, [r7, #12]
20006900:	635a      	str	r2, [r3, #52]	; 0x34
      hqspi->pRxBuffPtr = pData;
20006902:	68fb      	ldr	r3, [r7, #12]
20006904:	68ba      	ldr	r2, [r7, #8]
20006906:	631a      	str	r2, [r3, #48]	; 0x30

      /* Configure QSPI: CCR register with functional as indirect read */
      MODIFY_REG(hqspi->Instance->CCR, QUADSPI_CCR_FMODE, QSPI_FUNCTIONAL_MODE_INDIRECT_READ);
20006908:	68fb      	ldr	r3, [r7, #12]
2000690a:	681b      	ldr	r3, [r3, #0]
2000690c:	695b      	ldr	r3, [r3, #20]
2000690e:	f023 6240 	bic.w	r2, r3, #201326592	; 0xc000000
20006912:	68fb      	ldr	r3, [r7, #12]
20006914:	681b      	ldr	r3, [r3, #0]
20006916:	f042 6280 	orr.w	r2, r2, #67108864	; 0x4000000
2000691a:	615a      	str	r2, [r3, #20]

      /* Start the transfer by re-writing the address in AR register */
      WRITE_REG(hqspi->Instance->AR, addr_reg);
2000691c:	68fb      	ldr	r3, [r7, #12]
2000691e:	681b      	ldr	r3, [r3, #0]
20006920:	697a      	ldr	r2, [r7, #20]
20006922:	619a      	str	r2, [r3, #24]

      while(hqspi->RxXferCount > 0U)
20006924:	e01c      	b.n	20006960 <HAL_QSPI_Receive+0xd4>
      {
        /* Wait until FT or TC flag is set to read received data */
        status = QSPI_WaitFlagStateUntilTimeout(hqspi, (QSPI_FLAG_FT | QSPI_FLAG_TC), SET, tickstart, Timeout);
20006926:	687b      	ldr	r3, [r7, #4]
20006928:	9300      	str	r3, [sp, #0]
2000692a:	69bb      	ldr	r3, [r7, #24]
2000692c:	2201      	movs	r2, #1
2000692e:	2106      	movs	r1, #6
20006930:	68f8      	ldr	r0, [r7, #12]
20006932:	f000 fef0 	bl	20007716 <QSPI_WaitFlagStateUntilTimeout>
20006936:	4603      	mov	r3, r0
20006938:	77fb      	strb	r3, [r7, #31]

        if  (status != HAL_OK)
2000693a:	7ffb      	ldrb	r3, [r7, #31]
2000693c:	2b00      	cmp	r3, #0
2000693e:	d114      	bne.n	2000696a <HAL_QSPI_Receive+0xde>
        {
          break;
        }

        *hqspi->pRxBuffPtr = *((__IO uint8_t *)data_reg);
20006940:	68fb      	ldr	r3, [r7, #12]
20006942:	6b1b      	ldr	r3, [r3, #48]	; 0x30
20006944:	693a      	ldr	r2, [r7, #16]
20006946:	7812      	ldrb	r2, [r2, #0]
20006948:	b2d2      	uxtb	r2, r2
2000694a:	701a      	strb	r2, [r3, #0]
        hqspi->pRxBuffPtr++;
2000694c:	68fb      	ldr	r3, [r7, #12]
2000694e:	6b1b      	ldr	r3, [r3, #48]	; 0x30
20006950:	1c5a      	adds	r2, r3, #1
20006952:	68fb      	ldr	r3, [r7, #12]
20006954:	631a      	str	r2, [r3, #48]	; 0x30
        hqspi->RxXferCount--;
20006956:	68fb      	ldr	r3, [r7, #12]
20006958:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2000695a:	1e5a      	subs	r2, r3, #1
2000695c:	68fb      	ldr	r3, [r7, #12]
2000695e:	639a      	str	r2, [r3, #56]	; 0x38
      while(hqspi->RxXferCount > 0U)
20006960:	68fb      	ldr	r3, [r7, #12]
20006962:	6b9b      	ldr	r3, [r3, #56]	; 0x38
20006964:	2b00      	cmp	r3, #0
20006966:	d1de      	bne.n	20006926 <HAL_QSPI_Receive+0x9a>
20006968:	e000      	b.n	2000696c <HAL_QSPI_Receive+0xe0>
          break;
2000696a:	bf00      	nop
      }

      if (status == HAL_OK)
2000696c:	7ffb      	ldrb	r3, [r7, #31]
2000696e:	2b00      	cmp	r3, #0
20006970:	d110      	bne.n	20006994 <HAL_QSPI_Receive+0x108>
      {
        /* Wait until TC flag is set to go back in idle state */
        status = QSPI_WaitFlagStateUntilTimeout(hqspi, QSPI_FLAG_TC, SET, tickstart, Timeout);
20006972:	687b      	ldr	r3, [r7, #4]
20006974:	9300      	str	r3, [sp, #0]
20006976:	69bb      	ldr	r3, [r7, #24]
20006978:	2201      	movs	r2, #1
2000697a:	2102      	movs	r1, #2
2000697c:	68f8      	ldr	r0, [r7, #12]
2000697e:	f000 feca 	bl	20007716 <QSPI_WaitFlagStateUntilTimeout>
20006982:	4603      	mov	r3, r0
20006984:	77fb      	strb	r3, [r7, #31]

        if  (status == HAL_OK)
20006986:	7ffb      	ldrb	r3, [r7, #31]
20006988:	2b00      	cmp	r3, #0
2000698a:	d103      	bne.n	20006994 <HAL_QSPI_Receive+0x108>
        {
          /* Clear Transfer Complete bit */
          __HAL_QSPI_CLEAR_FLAG(hqspi, QSPI_FLAG_TC);
2000698c:	68fb      	ldr	r3, [r7, #12]
2000698e:	681b      	ldr	r3, [r3, #0]
20006990:	2202      	movs	r2, #2
20006992:	60da      	str	r2, [r3, #12]

        }
      }

      /* Update QSPI state */
      hqspi->State = HAL_QSPI_STATE_READY;
20006994:	68fb      	ldr	r3, [r7, #12]
20006996:	2201      	movs	r2, #1
20006998:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
2000699c:	e00a      	b.n	200069b4 <HAL_QSPI_Receive+0x128>
    }
    else
    {
      hqspi->ErrorCode |= HAL_QSPI_ERROR_INVALID_PARAM;
2000699e:	68fb      	ldr	r3, [r7, #12]
200069a0:	6c5b      	ldr	r3, [r3, #68]	; 0x44
200069a2:	f043 0208 	orr.w	r2, r3, #8
200069a6:	68fb      	ldr	r3, [r7, #12]
200069a8:	645a      	str	r2, [r3, #68]	; 0x44
      status = HAL_ERROR;
200069aa:	2301      	movs	r3, #1
200069ac:	77fb      	strb	r3, [r7, #31]
200069ae:	e001      	b.n	200069b4 <HAL_QSPI_Receive+0x128>
    }
  }
  else
  {
    status = HAL_BUSY;
200069b0:	2302      	movs	r3, #2
200069b2:	77fb      	strb	r3, [r7, #31]
  }

  /* Process unlocked */
  __HAL_UNLOCK(hqspi);
200069b4:	68fb      	ldr	r3, [r7, #12]
200069b6:	2200      	movs	r2, #0
200069b8:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

  return status;
200069bc:	7ffb      	ldrb	r3, [r7, #31]
}
200069be:	4618      	mov	r0, r3
200069c0:	3720      	adds	r7, #32
200069c2:	46bd      	mov	sp, r7
200069c4:	bd80      	pop	{r7, pc}

200069c6 <HAL_QSPI_Transmit_IT>:
  * @param  pData : pointer to data buffer
  * @note   This function is used only in Indirect Write Mode
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_QSPI_Transmit_IT(QSPI_HandleTypeDef *hqspi, uint8_t *pData)
{
200069c6:	b480      	push	{r7}
200069c8:	b085      	sub	sp, #20
200069ca:	af00      	add	r7, sp, #0
200069cc:	6078      	str	r0, [r7, #4]
200069ce:	6039      	str	r1, [r7, #0]
  HAL_StatusTypeDef status = HAL_OK;
200069d0:	2300      	movs	r3, #0
200069d2:	73fb      	strb	r3, [r7, #15]

  /* Process locked */
  __HAL_LOCK(hqspi);
200069d4:	687b      	ldr	r3, [r7, #4]
200069d6:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
200069da:	b2db      	uxtb	r3, r3
200069dc:	2b01      	cmp	r3, #1
200069de:	d101      	bne.n	200069e4 <HAL_QSPI_Transmit_IT+0x1e>
200069e0:	2302      	movs	r3, #2
200069e2:	e04f      	b.n	20006a84 <HAL_QSPI_Transmit_IT+0xbe>
200069e4:	687b      	ldr	r3, [r7, #4]
200069e6:	2201      	movs	r2, #1
200069e8:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

  if(hqspi->State == HAL_QSPI_STATE_READY)
200069ec:	687b      	ldr	r3, [r7, #4]
200069ee:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
200069f2:	b2db      	uxtb	r3, r3
200069f4:	2b01      	cmp	r3, #1
200069f6:	d13e      	bne.n	20006a76 <HAL_QSPI_Transmit_IT+0xb0>
  {
    hqspi->ErrorCode = HAL_QSPI_ERROR_NONE;
200069f8:	687b      	ldr	r3, [r7, #4]
200069fa:	2200      	movs	r2, #0
200069fc:	645a      	str	r2, [r3, #68]	; 0x44

    if(pData != NULL )
200069fe:	683b      	ldr	r3, [r7, #0]
20006a00:	2b00      	cmp	r3, #0
20006a02:	d02b      	beq.n	20006a5c <HAL_QSPI_Transmit_IT+0x96>
    {
      /* Update state */
      hqspi->State = HAL_QSPI_STATE_BUSY_INDIRECT_TX;
20006a04:	687b      	ldr	r3, [r7, #4]
20006a06:	2212      	movs	r2, #18
20006a08:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41

      /* Configure counters and size of the handle */
      hqspi->TxXferCount = READ_REG(hqspi->Instance->DLR) + 1U;
20006a0c:	687b      	ldr	r3, [r7, #4]
20006a0e:	681b      	ldr	r3, [r3, #0]
20006a10:	691b      	ldr	r3, [r3, #16]
20006a12:	1c5a      	adds	r2, r3, #1
20006a14:	687b      	ldr	r3, [r7, #4]
20006a16:	62da      	str	r2, [r3, #44]	; 0x2c
      hqspi->TxXferSize = READ_REG(hqspi->Instance->DLR) + 1U;
20006a18:	687b      	ldr	r3, [r7, #4]
20006a1a:	681b      	ldr	r3, [r3, #0]
20006a1c:	691b      	ldr	r3, [r3, #16]
20006a1e:	1c5a      	adds	r2, r3, #1
20006a20:	687b      	ldr	r3, [r7, #4]
20006a22:	629a      	str	r2, [r3, #40]	; 0x28
      hqspi->pTxBuffPtr = pData;
20006a24:	687b      	ldr	r3, [r7, #4]
20006a26:	683a      	ldr	r2, [r7, #0]
20006a28:	625a      	str	r2, [r3, #36]	; 0x24

      /* Clear interrupt */
      __HAL_QSPI_CLEAR_FLAG(hqspi, QSPI_FLAG_TE | QSPI_FLAG_TC);
20006a2a:	687b      	ldr	r3, [r7, #4]
20006a2c:	681b      	ldr	r3, [r3, #0]
20006a2e:	2203      	movs	r2, #3
20006a30:	60da      	str	r2, [r3, #12]

      /* Configure QSPI: CCR register with functional as indirect write */
      MODIFY_REG(hqspi->Instance->CCR, QUADSPI_CCR_FMODE, QSPI_FUNCTIONAL_MODE_INDIRECT_WRITE);
20006a32:	687b      	ldr	r3, [r7, #4]
20006a34:	681b      	ldr	r3, [r3, #0]
20006a36:	695a      	ldr	r2, [r3, #20]
20006a38:	687b      	ldr	r3, [r7, #4]
20006a3a:	681b      	ldr	r3, [r3, #0]
20006a3c:	f022 6240 	bic.w	r2, r2, #201326592	; 0xc000000
20006a40:	615a      	str	r2, [r3, #20]

      /* Process unlocked */
      __HAL_UNLOCK(hqspi);
20006a42:	687b      	ldr	r3, [r7, #4]
20006a44:	2200      	movs	r2, #0
20006a46:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

      /* Enable the QSPI transfer error, FIFO threshold and transfer complete Interrupts */
      __HAL_QSPI_ENABLE_IT(hqspi, QSPI_IT_TE | QSPI_IT_FT | QSPI_IT_TC);
20006a4a:	687b      	ldr	r3, [r7, #4]
20006a4c:	681b      	ldr	r3, [r3, #0]
20006a4e:	681a      	ldr	r2, [r3, #0]
20006a50:	687b      	ldr	r3, [r7, #4]
20006a52:	681b      	ldr	r3, [r3, #0]
20006a54:	f442 22e0 	orr.w	r2, r2, #458752	; 0x70000
20006a58:	601a      	str	r2, [r3, #0]
20006a5a:	e012      	b.n	20006a82 <HAL_QSPI_Transmit_IT+0xbc>
    }
    else
    {
      hqspi->ErrorCode |= HAL_QSPI_ERROR_INVALID_PARAM;
20006a5c:	687b      	ldr	r3, [r7, #4]
20006a5e:	6c5b      	ldr	r3, [r3, #68]	; 0x44
20006a60:	f043 0208 	orr.w	r2, r3, #8
20006a64:	687b      	ldr	r3, [r7, #4]
20006a66:	645a      	str	r2, [r3, #68]	; 0x44
      status = HAL_ERROR;
20006a68:	2301      	movs	r3, #1
20006a6a:	73fb      	strb	r3, [r7, #15]

      /* Process unlocked */
      __HAL_UNLOCK(hqspi);
20006a6c:	687b      	ldr	r3, [r7, #4]
20006a6e:	2200      	movs	r2, #0
20006a70:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
20006a74:	e005      	b.n	20006a82 <HAL_QSPI_Transmit_IT+0xbc>
    }
  }
  else
  {
    status = HAL_BUSY;
20006a76:	2302      	movs	r3, #2
20006a78:	73fb      	strb	r3, [r7, #15]

    /* Process unlocked */
    __HAL_UNLOCK(hqspi);
20006a7a:	687b      	ldr	r3, [r7, #4]
20006a7c:	2200      	movs	r2, #0
20006a7e:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
  }

  return status;
20006a82:	7bfb      	ldrb	r3, [r7, #15]
}
20006a84:	4618      	mov	r0, r3
20006a86:	3714      	adds	r7, #20
20006a88:	46bd      	mov	sp, r7
20006a8a:	f85d 7b04 	ldr.w	r7, [sp], #4
20006a8e:	4770      	bx	lr

20006a90 <HAL_QSPI_Receive_IT>:
  * @param  pData : pointer to data buffer
  * @note   This function is used only in Indirect Read Mode
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_QSPI_Receive_IT(QSPI_HandleTypeDef *hqspi, uint8_t *pData)
{
20006a90:	b480      	push	{r7}
20006a92:	b085      	sub	sp, #20
20006a94:	af00      	add	r7, sp, #0
20006a96:	6078      	str	r0, [r7, #4]
20006a98:	6039      	str	r1, [r7, #0]
  HAL_StatusTypeDef status = HAL_OK;
20006a9a:	2300      	movs	r3, #0
20006a9c:	73fb      	strb	r3, [r7, #15]
  uint32_t addr_reg = READ_REG(hqspi->Instance->AR);
20006a9e:	687b      	ldr	r3, [r7, #4]
20006aa0:	681b      	ldr	r3, [r3, #0]
20006aa2:	699b      	ldr	r3, [r3, #24]
20006aa4:	60bb      	str	r3, [r7, #8]

  /* Process locked */
  __HAL_LOCK(hqspi);
20006aa6:	687b      	ldr	r3, [r7, #4]
20006aa8:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
20006aac:	b2db      	uxtb	r3, r3
20006aae:	2b01      	cmp	r3, #1
20006ab0:	d101      	bne.n	20006ab6 <HAL_QSPI_Receive_IT+0x26>
20006ab2:	2302      	movs	r3, #2
20006ab4:	e055      	b.n	20006b62 <HAL_QSPI_Receive_IT+0xd2>
20006ab6:	687b      	ldr	r3, [r7, #4]
20006ab8:	2201      	movs	r2, #1
20006aba:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

  if(hqspi->State == HAL_QSPI_STATE_READY)
20006abe:	687b      	ldr	r3, [r7, #4]
20006ac0:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
20006ac4:	b2db      	uxtb	r3, r3
20006ac6:	2b01      	cmp	r3, #1
20006ac8:	d144      	bne.n	20006b54 <HAL_QSPI_Receive_IT+0xc4>
  {
    hqspi->ErrorCode = HAL_QSPI_ERROR_NONE;
20006aca:	687b      	ldr	r3, [r7, #4]
20006acc:	2200      	movs	r2, #0
20006ace:	645a      	str	r2, [r3, #68]	; 0x44

    if(pData != NULL )
20006ad0:	683b      	ldr	r3, [r7, #0]
20006ad2:	2b00      	cmp	r3, #0
20006ad4:	d031      	beq.n	20006b3a <HAL_QSPI_Receive_IT+0xaa>
    {
      /* Update state */
      hqspi->State = HAL_QSPI_STATE_BUSY_INDIRECT_RX;
20006ad6:	687b      	ldr	r3, [r7, #4]
20006ad8:	2222      	movs	r2, #34	; 0x22
20006ada:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41

      /* Configure counters and size of the handle */
      hqspi->RxXferCount = READ_REG(hqspi->Instance->DLR) + 1U;
20006ade:	687b      	ldr	r3, [r7, #4]
20006ae0:	681b      	ldr	r3, [r3, #0]
20006ae2:	691b      	ldr	r3, [r3, #16]
20006ae4:	1c5a      	adds	r2, r3, #1
20006ae6:	687b      	ldr	r3, [r7, #4]
20006ae8:	639a      	str	r2, [r3, #56]	; 0x38
      hqspi->RxXferSize = READ_REG(hqspi->Instance->DLR) + 1U;
20006aea:	687b      	ldr	r3, [r7, #4]
20006aec:	681b      	ldr	r3, [r3, #0]
20006aee:	691b      	ldr	r3, [r3, #16]
20006af0:	1c5a      	adds	r2, r3, #1
20006af2:	687b      	ldr	r3, [r7, #4]
20006af4:	635a      	str	r2, [r3, #52]	; 0x34
      hqspi->pRxBuffPtr = pData;
20006af6:	687b      	ldr	r3, [r7, #4]
20006af8:	683a      	ldr	r2, [r7, #0]
20006afa:	631a      	str	r2, [r3, #48]	; 0x30

      /* Clear interrupt */
      __HAL_QSPI_CLEAR_FLAG(hqspi, QSPI_FLAG_TE | QSPI_FLAG_TC);
20006afc:	687b      	ldr	r3, [r7, #4]
20006afe:	681b      	ldr	r3, [r3, #0]
20006b00:	2203      	movs	r2, #3
20006b02:	60da      	str	r2, [r3, #12]

      /* Configure QSPI: CCR register with functional as indirect read */
      MODIFY_REG(hqspi->Instance->CCR, QUADSPI_CCR_FMODE, QSPI_FUNCTIONAL_MODE_INDIRECT_READ);
20006b04:	687b      	ldr	r3, [r7, #4]
20006b06:	681b      	ldr	r3, [r3, #0]
20006b08:	695b      	ldr	r3, [r3, #20]
20006b0a:	f023 6240 	bic.w	r2, r3, #201326592	; 0xc000000
20006b0e:	687b      	ldr	r3, [r7, #4]
20006b10:	681b      	ldr	r3, [r3, #0]
20006b12:	f042 6280 	orr.w	r2, r2, #67108864	; 0x4000000
20006b16:	615a      	str	r2, [r3, #20]

      /* Start the transfer by re-writing the address in AR register */
      WRITE_REG(hqspi->Instance->AR, addr_reg);
20006b18:	687b      	ldr	r3, [r7, #4]
20006b1a:	681b      	ldr	r3, [r3, #0]
20006b1c:	68ba      	ldr	r2, [r7, #8]
20006b1e:	619a      	str	r2, [r3, #24]

      /* Process unlocked */
      __HAL_UNLOCK(hqspi);
20006b20:	687b      	ldr	r3, [r7, #4]
20006b22:	2200      	movs	r2, #0
20006b24:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

      /* Enable the QSPI transfer error, FIFO threshold and transfer complete Interrupts */
      __HAL_QSPI_ENABLE_IT(hqspi, QSPI_IT_TE | QSPI_IT_FT | QSPI_IT_TC);
20006b28:	687b      	ldr	r3, [r7, #4]
20006b2a:	681b      	ldr	r3, [r3, #0]
20006b2c:	681a      	ldr	r2, [r3, #0]
20006b2e:	687b      	ldr	r3, [r7, #4]
20006b30:	681b      	ldr	r3, [r3, #0]
20006b32:	f442 22e0 	orr.w	r2, r2, #458752	; 0x70000
20006b36:	601a      	str	r2, [r3, #0]
20006b38:	e012      	b.n	20006b60 <HAL_QSPI_Receive_IT+0xd0>
    }
    else
    {
      hqspi->ErrorCode |= HAL_QSPI_ERROR_INVALID_PARAM;
20006b3a:	687b      	ldr	r3, [r7, #4]
20006b3c:	6c5b      	ldr	r3, [r3, #68]	; 0x44
20006b3e:	f043 0208 	orr.w	r2, r3, #8
20006b42:	687b      	ldr	r3, [r7, #4]
20006b44:	645a      	str	r2, [r3, #68]	; 0x44
      status = HAL_ERROR;
20006b46:	2301      	movs	r3, #1
20006b48:	73fb      	strb	r3, [r7, #15]

      /* Process unlocked */
      __HAL_UNLOCK(hqspi);
20006b4a:	687b      	ldr	r3, [r7, #4]
20006b4c:	2200      	movs	r2, #0
20006b4e:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
20006b52:	e005      	b.n	20006b60 <HAL_QSPI_Receive_IT+0xd0>
    }
  }
  else
  {
    status = HAL_BUSY;
20006b54:	2302      	movs	r3, #2
20006b56:	73fb      	strb	r3, [r7, #15]

    /* Process unlocked */
    __HAL_UNLOCK(hqspi);
20006b58:	687b      	ldr	r3, [r7, #4]
20006b5a:	2200      	movs	r2, #0
20006b5c:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
  }

  return status;
20006b60:	7bfb      	ldrb	r3, [r7, #15]
}
20006b62:	4618      	mov	r0, r3
20006b64:	3714      	adds	r7, #20
20006b66:	46bd      	mov	sp, r7
20006b68:	f85d 7b04 	ldr.w	r7, [sp], #4
20006b6c:	4770      	bx	lr
	...

20006b70 <HAL_QSPI_Transmit_DMA>:
  * @note   If DMA peripheral access is configured as word, the number
  *         of data and the fifo threshold should be aligned on word
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_QSPI_Transmit_DMA(QSPI_HandleTypeDef *hqspi, uint8_t *pData)
{
20006b70:	b580      	push	{r7, lr}
20006b72:	b084      	sub	sp, #16
20006b74:	af00      	add	r7, sp, #0
20006b76:	6078      	str	r0, [r7, #4]
20006b78:	6039      	str	r1, [r7, #0]
  HAL_StatusTypeDef status = HAL_OK;
20006b7a:	2300      	movs	r3, #0
20006b7c:	73fb      	strb	r3, [r7, #15]
  uint32_t data_size = (READ_REG(hqspi->Instance->DLR) + 1U);
20006b7e:	687b      	ldr	r3, [r7, #4]
20006b80:	681b      	ldr	r3, [r3, #0]
20006b82:	691b      	ldr	r3, [r3, #16]
20006b84:	3301      	adds	r3, #1
20006b86:	60bb      	str	r3, [r7, #8]

  /* Process locked */
  __HAL_LOCK(hqspi);
20006b88:	687b      	ldr	r3, [r7, #4]
20006b8a:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
20006b8e:	b2db      	uxtb	r3, r3
20006b90:	2b01      	cmp	r3, #1
20006b92:	d101      	bne.n	20006b98 <HAL_QSPI_Transmit_DMA+0x28>
20006b94:	2302      	movs	r3, #2
20006b96:	e0e3      	b.n	20006d60 <HAL_QSPI_Transmit_DMA+0x1f0>
20006b98:	687b      	ldr	r3, [r7, #4]
20006b9a:	2201      	movs	r2, #1
20006b9c:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

  if(hqspi->State == HAL_QSPI_STATE_READY)
20006ba0:	687b      	ldr	r3, [r7, #4]
20006ba2:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
20006ba6:	b2db      	uxtb	r3, r3
20006ba8:	2b01      	cmp	r3, #1
20006baa:	f040 80d2 	bne.w	20006d52 <HAL_QSPI_Transmit_DMA+0x1e2>
  {
    /* Clear the error code */
    hqspi->ErrorCode = HAL_QSPI_ERROR_NONE;
20006bae:	687b      	ldr	r3, [r7, #4]
20006bb0:	2200      	movs	r2, #0
20006bb2:	645a      	str	r2, [r3, #68]	; 0x44

    if(pData != NULL )
20006bb4:	683b      	ldr	r3, [r7, #0]
20006bb6:	2b00      	cmp	r3, #0
20006bb8:	f000 80be 	beq.w	20006d38 <HAL_QSPI_Transmit_DMA+0x1c8>
    {
      /* Configure counters of the handle */
      if (hqspi->hdma->Init.PeriphDataAlignment == DMA_PDATAALIGN_BYTE)
20006bbc:	687b      	ldr	r3, [r7, #4]
20006bbe:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
20006bc0:	695b      	ldr	r3, [r3, #20]
20006bc2:	2b00      	cmp	r3, #0
20006bc4:	d103      	bne.n	20006bce <HAL_QSPI_Transmit_DMA+0x5e>
      {
        hqspi->TxXferCount = data_size;
20006bc6:	687b      	ldr	r3, [r7, #4]
20006bc8:	68ba      	ldr	r2, [r7, #8]
20006bca:	62da      	str	r2, [r3, #44]	; 0x2c
20006bcc:	e044      	b.n	20006c58 <HAL_QSPI_Transmit_DMA+0xe8>
      }
      else if (hqspi->hdma->Init.PeriphDataAlignment == DMA_PDATAALIGN_HALFWORD)
20006bce:	687b      	ldr	r3, [r7, #4]
20006bd0:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
20006bd2:	695b      	ldr	r3, [r3, #20]
20006bd4:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
20006bd8:	d11c      	bne.n	20006c14 <HAL_QSPI_Transmit_DMA+0xa4>
      {
        if (((data_size % 2U) != 0U) || ((hqspi->Init.FifoThreshold % 2U) != 0U))
20006bda:	68bb      	ldr	r3, [r7, #8]
20006bdc:	f003 0301 	and.w	r3, r3, #1
20006be0:	2b00      	cmp	r3, #0
20006be2:	d105      	bne.n	20006bf0 <HAL_QSPI_Transmit_DMA+0x80>
20006be4:	687b      	ldr	r3, [r7, #4]
20006be6:	689b      	ldr	r3, [r3, #8]
20006be8:	f003 0301 	and.w	r3, r3, #1
20006bec:	2b00      	cmp	r3, #0
20006bee:	d00c      	beq.n	20006c0a <HAL_QSPI_Transmit_DMA+0x9a>
        {
          /* The number of data or the fifo threshold is not aligned on halfword
          => no transfer possible with DMA peripheral access configured as halfword */
          hqspi->ErrorCode |= HAL_QSPI_ERROR_INVALID_PARAM;
20006bf0:	687b      	ldr	r3, [r7, #4]
20006bf2:	6c5b      	ldr	r3, [r3, #68]	; 0x44
20006bf4:	f043 0208 	orr.w	r2, r3, #8
20006bf8:	687b      	ldr	r3, [r7, #4]
20006bfa:	645a      	str	r2, [r3, #68]	; 0x44
          status = HAL_ERROR;
20006bfc:	2301      	movs	r3, #1
20006bfe:	73fb      	strb	r3, [r7, #15]

          /* Process unlocked */
          __HAL_UNLOCK(hqspi);
20006c00:	687b      	ldr	r3, [r7, #4]
20006c02:	2200      	movs	r2, #0
20006c04:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
20006c08:	e026      	b.n	20006c58 <HAL_QSPI_Transmit_DMA+0xe8>
        }
        else
        {
          hqspi->TxXferCount = (data_size >> 1U);
20006c0a:	68bb      	ldr	r3, [r7, #8]
20006c0c:	085a      	lsrs	r2, r3, #1
20006c0e:	687b      	ldr	r3, [r7, #4]
20006c10:	62da      	str	r2, [r3, #44]	; 0x2c
20006c12:	e021      	b.n	20006c58 <HAL_QSPI_Transmit_DMA+0xe8>
        }
      }
      else if (hqspi->hdma->Init.PeriphDataAlignment == DMA_PDATAALIGN_WORD)
20006c14:	687b      	ldr	r3, [r7, #4]
20006c16:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
20006c18:	695b      	ldr	r3, [r3, #20]
20006c1a:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
20006c1e:	d11b      	bne.n	20006c58 <HAL_QSPI_Transmit_DMA+0xe8>
      {
        if (((data_size % 4U) != 0U) || ((hqspi->Init.FifoThreshold % 4U) != 0U))
20006c20:	68bb      	ldr	r3, [r7, #8]
20006c22:	f003 0303 	and.w	r3, r3, #3
20006c26:	2b00      	cmp	r3, #0
20006c28:	d105      	bne.n	20006c36 <HAL_QSPI_Transmit_DMA+0xc6>
20006c2a:	687b      	ldr	r3, [r7, #4]
20006c2c:	689b      	ldr	r3, [r3, #8]
20006c2e:	f003 0303 	and.w	r3, r3, #3
20006c32:	2b00      	cmp	r3, #0
20006c34:	d00c      	beq.n	20006c50 <HAL_QSPI_Transmit_DMA+0xe0>
        {
          /* The number of data or the fifo threshold is not aligned on word
          => no transfer possible with DMA peripheral access configured as word */
          hqspi->ErrorCode |= HAL_QSPI_ERROR_INVALID_PARAM;
20006c36:	687b      	ldr	r3, [r7, #4]
20006c38:	6c5b      	ldr	r3, [r3, #68]	; 0x44
20006c3a:	f043 0208 	orr.w	r2, r3, #8
20006c3e:	687b      	ldr	r3, [r7, #4]
20006c40:	645a      	str	r2, [r3, #68]	; 0x44
          status = HAL_ERROR;
20006c42:	2301      	movs	r3, #1
20006c44:	73fb      	strb	r3, [r7, #15]

          /* Process unlocked */
          __HAL_UNLOCK(hqspi);
20006c46:	687b      	ldr	r3, [r7, #4]
20006c48:	2200      	movs	r2, #0
20006c4a:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
20006c4e:	e003      	b.n	20006c58 <HAL_QSPI_Transmit_DMA+0xe8>
        }
        else
        {
          hqspi->TxXferCount = (data_size >> 2U);
20006c50:	68bb      	ldr	r3, [r7, #8]
20006c52:	089a      	lsrs	r2, r3, #2
20006c54:	687b      	ldr	r3, [r7, #4]
20006c56:	62da      	str	r2, [r3, #44]	; 0x2c
      else
      {
        /* Nothing to do */
      }

      if (status == HAL_OK)
20006c58:	7bfb      	ldrb	r3, [r7, #15]
20006c5a:	2b00      	cmp	r3, #0
20006c5c:	d17f      	bne.n	20006d5e <HAL_QSPI_Transmit_DMA+0x1ee>
      {
        /* Update state */
        hqspi->State = HAL_QSPI_STATE_BUSY_INDIRECT_TX;
20006c5e:	687b      	ldr	r3, [r7, #4]
20006c60:	2212      	movs	r2, #18
20006c62:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41

        /* Clear interrupt */
        __HAL_QSPI_CLEAR_FLAG(hqspi, (QSPI_FLAG_TE | QSPI_FLAG_TC));
20006c66:	687b      	ldr	r3, [r7, #4]
20006c68:	681b      	ldr	r3, [r3, #0]
20006c6a:	2203      	movs	r2, #3
20006c6c:	60da      	str	r2, [r3, #12]

        /* Configure size and pointer of the handle */
        hqspi->TxXferSize = hqspi->TxXferCount;
20006c6e:	687b      	ldr	r3, [r7, #4]
20006c70:	6ada      	ldr	r2, [r3, #44]	; 0x2c
20006c72:	687b      	ldr	r3, [r7, #4]
20006c74:	629a      	str	r2, [r3, #40]	; 0x28
        hqspi->pTxBuffPtr = pData;
20006c76:	687b      	ldr	r3, [r7, #4]
20006c78:	683a      	ldr	r2, [r7, #0]
20006c7a:	625a      	str	r2, [r3, #36]	; 0x24

        /* Configure QSPI: CCR register with functional mode as indirect write */
        MODIFY_REG(hqspi->Instance->CCR, QUADSPI_CCR_FMODE, QSPI_FUNCTIONAL_MODE_INDIRECT_WRITE);
20006c7c:	687b      	ldr	r3, [r7, #4]
20006c7e:	681b      	ldr	r3, [r3, #0]
20006c80:	695a      	ldr	r2, [r3, #20]
20006c82:	687b      	ldr	r3, [r7, #4]
20006c84:	681b      	ldr	r3, [r3, #0]
20006c86:	f022 6240 	bic.w	r2, r2, #201326592	; 0xc000000
20006c8a:	615a      	str	r2, [r3, #20]

        /* Set the QSPI DMA transfer complete callback */
        hqspi->hdma->XferCpltCallback = QSPI_DMATxCplt;
20006c8c:	687b      	ldr	r3, [r7, #4]
20006c8e:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
20006c90:	4a35      	ldr	r2, [pc, #212]	; (20006d68 <HAL_QSPI_Transmit_DMA+0x1f8>)
20006c92:	62da      	str	r2, [r3, #44]	; 0x2c

        /* Set the QSPI DMA Half transfer complete callback */
        hqspi->hdma->XferHalfCpltCallback = QSPI_DMATxHalfCplt;
20006c94:	687b      	ldr	r3, [r7, #4]
20006c96:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
20006c98:	4a34      	ldr	r2, [pc, #208]	; (20006d6c <HAL_QSPI_Transmit_DMA+0x1fc>)
20006c9a:	631a      	str	r2, [r3, #48]	; 0x30

        /* Set the DMA error callback */
        hqspi->hdma->XferErrorCallback = QSPI_DMAError;
20006c9c:	687b      	ldr	r3, [r7, #4]
20006c9e:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
20006ca0:	4a33      	ldr	r2, [pc, #204]	; (20006d70 <HAL_QSPI_Transmit_DMA+0x200>)
20006ca2:	635a      	str	r2, [r3, #52]	; 0x34

        /* Clear the DMA abort callback */
        hqspi->hdma->XferAbortCallback = NULL;
20006ca4:	687b      	ldr	r3, [r7, #4]
20006ca6:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
20006ca8:	2200      	movs	r2, #0
20006caa:	639a      	str	r2, [r3, #56]	; 0x38

        /* Configure the direction of the DMA */
        hqspi->hdma->Init.Direction = DMA_MEMORY_TO_PERIPH;
20006cac:	687b      	ldr	r3, [r7, #4]
20006cae:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
20006cb0:	2210      	movs	r2, #16
20006cb2:	609a      	str	r2, [r3, #8]
        MODIFY_REG(hqspi->hdma->Instance->CCR, DMA_CCR_DIR, hqspi->hdma->Init.Direction);
20006cb4:	687b      	ldr	r3, [r7, #4]
20006cb6:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
20006cb8:	681b      	ldr	r3, [r3, #0]
20006cba:	681b      	ldr	r3, [r3, #0]
20006cbc:	f023 0110 	bic.w	r1, r3, #16
20006cc0:	687b      	ldr	r3, [r7, #4]
20006cc2:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
20006cc4:	689a      	ldr	r2, [r3, #8]
20006cc6:	687b      	ldr	r3, [r7, #4]
20006cc8:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
20006cca:	681b      	ldr	r3, [r3, #0]
20006ccc:	430a      	orrs	r2, r1
20006cce:	601a      	str	r2, [r3, #0]

        /* Enable the QSPI transmit DMA Channel */
        if (HAL_DMA_Start_IT(hqspi->hdma, (uint32_t)pData, (uint32_t)&hqspi->Instance->DR, hqspi->TxXferSize) == HAL_OK)
20006cd0:	687b      	ldr	r3, [r7, #4]
20006cd2:	6bd8      	ldr	r0, [r3, #60]	; 0x3c
20006cd4:	6839      	ldr	r1, [r7, #0]
20006cd6:	687b      	ldr	r3, [r7, #4]
20006cd8:	681b      	ldr	r3, [r3, #0]
20006cda:	3320      	adds	r3, #32
20006cdc:	461a      	mov	r2, r3
20006cde:	687b      	ldr	r3, [r7, #4]
20006ce0:	6a9b      	ldr	r3, [r3, #40]	; 0x28
20006ce2:	f7fb fc8e 	bl	20002602 <HAL_DMA_Start_IT>
20006ce6:	4603      	mov	r3, r0
20006ce8:	2b00      	cmp	r3, #0
20006cea:	d114      	bne.n	20006d16 <HAL_QSPI_Transmit_DMA+0x1a6>
        {
          /* Process unlocked */
          __HAL_UNLOCK(hqspi);
20006cec:	687b      	ldr	r3, [r7, #4]
20006cee:	2200      	movs	r2, #0
20006cf0:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
          
          /* Enable the QSPI transfer error Interrupt */
          __HAL_QSPI_ENABLE_IT(hqspi, QSPI_IT_TE);
20006cf4:	687b      	ldr	r3, [r7, #4]
20006cf6:	681b      	ldr	r3, [r3, #0]
20006cf8:	681a      	ldr	r2, [r3, #0]
20006cfa:	687b      	ldr	r3, [r7, #4]
20006cfc:	681b      	ldr	r3, [r3, #0]
20006cfe:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
20006d02:	601a      	str	r2, [r3, #0]
          
          /* Enable the DMA transfer by setting the DMAEN bit in the QSPI CR register */
          SET_BIT(hqspi->Instance->CR, QUADSPI_CR_DMAEN);
20006d04:	687b      	ldr	r3, [r7, #4]
20006d06:	681b      	ldr	r3, [r3, #0]
20006d08:	681a      	ldr	r2, [r3, #0]
20006d0a:	687b      	ldr	r3, [r7, #4]
20006d0c:	681b      	ldr	r3, [r3, #0]
20006d0e:	f042 0204 	orr.w	r2, r2, #4
20006d12:	601a      	str	r2, [r3, #0]
20006d14:	e023      	b.n	20006d5e <HAL_QSPI_Transmit_DMA+0x1ee>
        }
        else
        {
          status = HAL_ERROR;
20006d16:	2301      	movs	r3, #1
20006d18:	73fb      	strb	r3, [r7, #15]
          hqspi->ErrorCode |= HAL_QSPI_ERROR_DMA;
20006d1a:	687b      	ldr	r3, [r7, #4]
20006d1c:	6c5b      	ldr	r3, [r3, #68]	; 0x44
20006d1e:	f043 0204 	orr.w	r2, r3, #4
20006d22:	687b      	ldr	r3, [r7, #4]
20006d24:	645a      	str	r2, [r3, #68]	; 0x44
          hqspi->State = HAL_QSPI_STATE_READY;
20006d26:	687b      	ldr	r3, [r7, #4]
20006d28:	2201      	movs	r2, #1
20006d2a:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41

          /* Process unlocked */
          __HAL_UNLOCK(hqspi);
20006d2e:	687b      	ldr	r3, [r7, #4]
20006d30:	2200      	movs	r2, #0
20006d32:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
20006d36:	e012      	b.n	20006d5e <HAL_QSPI_Transmit_DMA+0x1ee>
        }
     }
    }
    else
    {
      hqspi->ErrorCode |= HAL_QSPI_ERROR_INVALID_PARAM;
20006d38:	687b      	ldr	r3, [r7, #4]
20006d3a:	6c5b      	ldr	r3, [r3, #68]	; 0x44
20006d3c:	f043 0208 	orr.w	r2, r3, #8
20006d40:	687b      	ldr	r3, [r7, #4]
20006d42:	645a      	str	r2, [r3, #68]	; 0x44
      status = HAL_ERROR;
20006d44:	2301      	movs	r3, #1
20006d46:	73fb      	strb	r3, [r7, #15]

      /* Process unlocked */
      __HAL_UNLOCK(hqspi);
20006d48:	687b      	ldr	r3, [r7, #4]
20006d4a:	2200      	movs	r2, #0
20006d4c:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
20006d50:	e005      	b.n	20006d5e <HAL_QSPI_Transmit_DMA+0x1ee>
    }
  }
  else
  {
    status = HAL_BUSY;
20006d52:	2302      	movs	r3, #2
20006d54:	73fb      	strb	r3, [r7, #15]

    /* Process unlocked */
    __HAL_UNLOCK(hqspi);
20006d56:	687b      	ldr	r3, [r7, #4]
20006d58:	2200      	movs	r2, #0
20006d5a:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
  }

  return status;
20006d5e:	7bfb      	ldrb	r3, [r7, #15]
}
20006d60:	4618      	mov	r0, r3
20006d62:	3710      	adds	r7, #16
20006d64:	46bd      	mov	sp, r7
20006d66:	bd80      	pop	{r7, pc}
20006d68:	20007605 	.word	0x20007605
20006d6c:	20007651 	.word	0x20007651
20006d70:	2000766d 	.word	0x2000766d

20006d74 <HAL_QSPI_Receive_DMA>:
  * @note   If DMA peripheral access is configured as word, the number
  *         of data and the fifo threshold should be aligned on word
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_QSPI_Receive_DMA(QSPI_HandleTypeDef *hqspi, uint8_t *pData)
{
20006d74:	b580      	push	{r7, lr}
20006d76:	b086      	sub	sp, #24
20006d78:	af00      	add	r7, sp, #0
20006d7a:	6078      	str	r0, [r7, #4]
20006d7c:	6039      	str	r1, [r7, #0]
  HAL_StatusTypeDef status = HAL_OK;
20006d7e:	2300      	movs	r3, #0
20006d80:	75fb      	strb	r3, [r7, #23]
  uint32_t addr_reg = READ_REG(hqspi->Instance->AR);
20006d82:	687b      	ldr	r3, [r7, #4]
20006d84:	681b      	ldr	r3, [r3, #0]
20006d86:	699b      	ldr	r3, [r3, #24]
20006d88:	613b      	str	r3, [r7, #16]
  uint32_t data_size = (READ_REG(hqspi->Instance->DLR) + 1U);
20006d8a:	687b      	ldr	r3, [r7, #4]
20006d8c:	681b      	ldr	r3, [r3, #0]
20006d8e:	691b      	ldr	r3, [r3, #16]
20006d90:	3301      	adds	r3, #1
20006d92:	60fb      	str	r3, [r7, #12]

  /* Process locked */
  __HAL_LOCK(hqspi);
20006d94:	687b      	ldr	r3, [r7, #4]
20006d96:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
20006d9a:	b2db      	uxtb	r3, r3
20006d9c:	2b01      	cmp	r3, #1
20006d9e:	d101      	bne.n	20006da4 <HAL_QSPI_Receive_DMA+0x30>
20006da0:	2302      	movs	r3, #2
20006da2:	e0ea      	b.n	20006f7a <HAL_QSPI_Receive_DMA+0x206>
20006da4:	687b      	ldr	r3, [r7, #4]
20006da6:	2201      	movs	r2, #1
20006da8:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

  if(hqspi->State == HAL_QSPI_STATE_READY)
20006dac:	687b      	ldr	r3, [r7, #4]
20006dae:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
20006db2:	b2db      	uxtb	r3, r3
20006db4:	2b01      	cmp	r3, #1
20006db6:	f040 80d9 	bne.w	20006f6c <HAL_QSPI_Receive_DMA+0x1f8>
  {
    /* Clear the error code */
    hqspi->ErrorCode = HAL_QSPI_ERROR_NONE;
20006dba:	687b      	ldr	r3, [r7, #4]
20006dbc:	2200      	movs	r2, #0
20006dbe:	645a      	str	r2, [r3, #68]	; 0x44

    if(pData != NULL )
20006dc0:	683b      	ldr	r3, [r7, #0]
20006dc2:	2b00      	cmp	r3, #0
20006dc4:	f000 80c5 	beq.w	20006f52 <HAL_QSPI_Receive_DMA+0x1de>
    {
      /* Configure counters of the handle */
      if (hqspi->hdma->Init.PeriphDataAlignment == DMA_PDATAALIGN_BYTE)
20006dc8:	687b      	ldr	r3, [r7, #4]
20006dca:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
20006dcc:	695b      	ldr	r3, [r3, #20]
20006dce:	2b00      	cmp	r3, #0
20006dd0:	d103      	bne.n	20006dda <HAL_QSPI_Receive_DMA+0x66>
      {
        hqspi->RxXferCount = data_size;
20006dd2:	687b      	ldr	r3, [r7, #4]
20006dd4:	68fa      	ldr	r2, [r7, #12]
20006dd6:	639a      	str	r2, [r3, #56]	; 0x38
20006dd8:	e044      	b.n	20006e64 <HAL_QSPI_Receive_DMA+0xf0>
      }
      else if (hqspi->hdma->Init.PeriphDataAlignment == DMA_PDATAALIGN_HALFWORD)
20006dda:	687b      	ldr	r3, [r7, #4]
20006ddc:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
20006dde:	695b      	ldr	r3, [r3, #20]
20006de0:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
20006de4:	d11c      	bne.n	20006e20 <HAL_QSPI_Receive_DMA+0xac>
      {
        if (((data_size % 2U) != 0U) || ((hqspi->Init.FifoThreshold % 2U) != 0U))
20006de6:	68fb      	ldr	r3, [r7, #12]
20006de8:	f003 0301 	and.w	r3, r3, #1
20006dec:	2b00      	cmp	r3, #0
20006dee:	d105      	bne.n	20006dfc <HAL_QSPI_Receive_DMA+0x88>
20006df0:	687b      	ldr	r3, [r7, #4]
20006df2:	689b      	ldr	r3, [r3, #8]
20006df4:	f003 0301 	and.w	r3, r3, #1
20006df8:	2b00      	cmp	r3, #0
20006dfa:	d00c      	beq.n	20006e16 <HAL_QSPI_Receive_DMA+0xa2>
        {
          /* The number of data or the fifo threshold is not aligned on halfword
             => no transfer possible with DMA peripheral access configured as halfword */
          hqspi->ErrorCode |= HAL_QSPI_ERROR_INVALID_PARAM;
20006dfc:	687b      	ldr	r3, [r7, #4]
20006dfe:	6c5b      	ldr	r3, [r3, #68]	; 0x44
20006e00:	f043 0208 	orr.w	r2, r3, #8
20006e04:	687b      	ldr	r3, [r7, #4]
20006e06:	645a      	str	r2, [r3, #68]	; 0x44
          status = HAL_ERROR;
20006e08:	2301      	movs	r3, #1
20006e0a:	75fb      	strb	r3, [r7, #23]

          /* Process unlocked */
          __HAL_UNLOCK(hqspi);
20006e0c:	687b      	ldr	r3, [r7, #4]
20006e0e:	2200      	movs	r2, #0
20006e10:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
20006e14:	e026      	b.n	20006e64 <HAL_QSPI_Receive_DMA+0xf0>
        }
        else
        {
          hqspi->RxXferCount = (data_size >> 1U);
20006e16:	68fb      	ldr	r3, [r7, #12]
20006e18:	085a      	lsrs	r2, r3, #1
20006e1a:	687b      	ldr	r3, [r7, #4]
20006e1c:	639a      	str	r2, [r3, #56]	; 0x38
20006e1e:	e021      	b.n	20006e64 <HAL_QSPI_Receive_DMA+0xf0>
        }
      }
      else if (hqspi->hdma->Init.PeriphDataAlignment == DMA_PDATAALIGN_WORD)
20006e20:	687b      	ldr	r3, [r7, #4]
20006e22:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
20006e24:	695b      	ldr	r3, [r3, #20]
20006e26:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
20006e2a:	d11b      	bne.n	20006e64 <HAL_QSPI_Receive_DMA+0xf0>
      {
        if (((data_size % 4U) != 0U) || ((hqspi->Init.FifoThreshold % 4U) != 0U))
20006e2c:	68fb      	ldr	r3, [r7, #12]
20006e2e:	f003 0303 	and.w	r3, r3, #3
20006e32:	2b00      	cmp	r3, #0
20006e34:	d105      	bne.n	20006e42 <HAL_QSPI_Receive_DMA+0xce>
20006e36:	687b      	ldr	r3, [r7, #4]
20006e38:	689b      	ldr	r3, [r3, #8]
20006e3a:	f003 0303 	and.w	r3, r3, #3
20006e3e:	2b00      	cmp	r3, #0
20006e40:	d00c      	beq.n	20006e5c <HAL_QSPI_Receive_DMA+0xe8>
        {
          /* The number of data or the fifo threshold is not aligned on word
             => no transfer possible with DMA peripheral access configured as word */
          hqspi->ErrorCode |= HAL_QSPI_ERROR_INVALID_PARAM;
20006e42:	687b      	ldr	r3, [r7, #4]
20006e44:	6c5b      	ldr	r3, [r3, #68]	; 0x44
20006e46:	f043 0208 	orr.w	r2, r3, #8
20006e4a:	687b      	ldr	r3, [r7, #4]
20006e4c:	645a      	str	r2, [r3, #68]	; 0x44
          status = HAL_ERROR;
20006e4e:	2301      	movs	r3, #1
20006e50:	75fb      	strb	r3, [r7, #23]

          /* Process unlocked */
          __HAL_UNLOCK(hqspi);
20006e52:	687b      	ldr	r3, [r7, #4]
20006e54:	2200      	movs	r2, #0
20006e56:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
20006e5a:	e003      	b.n	20006e64 <HAL_QSPI_Receive_DMA+0xf0>
        }
        else
        {
          hqspi->RxXferCount = (data_size >> 2U);
20006e5c:	68fb      	ldr	r3, [r7, #12]
20006e5e:	089a      	lsrs	r2, r3, #2
20006e60:	687b      	ldr	r3, [r7, #4]
20006e62:	639a      	str	r2, [r3, #56]	; 0x38
      else
      {
        /* Nothing to do */
      }

      if (status == HAL_OK)
20006e64:	7dfb      	ldrb	r3, [r7, #23]
20006e66:	2b00      	cmp	r3, #0
20006e68:	f040 8086 	bne.w	20006f78 <HAL_QSPI_Receive_DMA+0x204>
      {
        /* Update state */
        hqspi->State = HAL_QSPI_STATE_BUSY_INDIRECT_RX;
20006e6c:	687b      	ldr	r3, [r7, #4]
20006e6e:	2222      	movs	r2, #34	; 0x22
20006e70:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41

        /* Clear interrupt */
        __HAL_QSPI_CLEAR_FLAG(hqspi, (QSPI_FLAG_TE | QSPI_FLAG_TC));
20006e74:	687b      	ldr	r3, [r7, #4]
20006e76:	681b      	ldr	r3, [r3, #0]
20006e78:	2203      	movs	r2, #3
20006e7a:	60da      	str	r2, [r3, #12]

        /* Configure size and pointer of the handle */
        hqspi->RxXferSize = hqspi->RxXferCount;
20006e7c:	687b      	ldr	r3, [r7, #4]
20006e7e:	6b9a      	ldr	r2, [r3, #56]	; 0x38
20006e80:	687b      	ldr	r3, [r7, #4]
20006e82:	635a      	str	r2, [r3, #52]	; 0x34
        hqspi->pRxBuffPtr = pData;
20006e84:	687b      	ldr	r3, [r7, #4]
20006e86:	683a      	ldr	r2, [r7, #0]
20006e88:	631a      	str	r2, [r3, #48]	; 0x30

        /* Set the QSPI DMA transfer complete callback */
        hqspi->hdma->XferCpltCallback = QSPI_DMARxCplt;
20006e8a:	687b      	ldr	r3, [r7, #4]
20006e8c:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
20006e8e:	4a3d      	ldr	r2, [pc, #244]	; (20006f84 <HAL_QSPI_Receive_DMA+0x210>)
20006e90:	62da      	str	r2, [r3, #44]	; 0x2c

        /* Set the QSPI DMA Half transfer complete callback */
        hqspi->hdma->XferHalfCpltCallback = QSPI_DMARxHalfCplt;
20006e92:	687b      	ldr	r3, [r7, #4]
20006e94:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
20006e96:	4a3c      	ldr	r2, [pc, #240]	; (20006f88 <HAL_QSPI_Receive_DMA+0x214>)
20006e98:	631a      	str	r2, [r3, #48]	; 0x30

        /* Set the DMA error callback */
        hqspi->hdma->XferErrorCallback = QSPI_DMAError;
20006e9a:	687b      	ldr	r3, [r7, #4]
20006e9c:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
20006e9e:	4a3b      	ldr	r2, [pc, #236]	; (20006f8c <HAL_QSPI_Receive_DMA+0x218>)
20006ea0:	635a      	str	r2, [r3, #52]	; 0x34

        /* Clear the DMA abort callback */
        hqspi->hdma->XferAbortCallback = NULL;
20006ea2:	687b      	ldr	r3, [r7, #4]
20006ea4:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
20006ea6:	2200      	movs	r2, #0
20006ea8:	639a      	str	r2, [r3, #56]	; 0x38

        /* Configure the direction of the DMA */
        hqspi->hdma->Init.Direction = DMA_PERIPH_TO_MEMORY;
20006eaa:	687b      	ldr	r3, [r7, #4]
20006eac:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
20006eae:	2200      	movs	r2, #0
20006eb0:	609a      	str	r2, [r3, #8]
        MODIFY_REG(hqspi->hdma->Instance->CCR, DMA_CCR_DIR, hqspi->hdma->Init.Direction);
20006eb2:	687b      	ldr	r3, [r7, #4]
20006eb4:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
20006eb6:	681b      	ldr	r3, [r3, #0]
20006eb8:	681b      	ldr	r3, [r3, #0]
20006eba:	f023 0110 	bic.w	r1, r3, #16
20006ebe:	687b      	ldr	r3, [r7, #4]
20006ec0:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
20006ec2:	689a      	ldr	r2, [r3, #8]
20006ec4:	687b      	ldr	r3, [r7, #4]
20006ec6:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
20006ec8:	681b      	ldr	r3, [r3, #0]
20006eca:	430a      	orrs	r2, r1
20006ecc:	601a      	str	r2, [r3, #0]

        /* Enable the DMA Channel */
        if (HAL_DMA_Start_IT(hqspi->hdma, (uint32_t)&hqspi->Instance->DR, (uint32_t)pData, hqspi->RxXferSize) == HAL_OK)
20006ece:	687b      	ldr	r3, [r7, #4]
20006ed0:	6bd8      	ldr	r0, [r3, #60]	; 0x3c
20006ed2:	687b      	ldr	r3, [r7, #4]
20006ed4:	681b      	ldr	r3, [r3, #0]
20006ed6:	3320      	adds	r3, #32
20006ed8:	4619      	mov	r1, r3
20006eda:	683a      	ldr	r2, [r7, #0]
20006edc:	687b      	ldr	r3, [r7, #4]
20006ede:	6b5b      	ldr	r3, [r3, #52]	; 0x34
20006ee0:	f7fb fb8f 	bl	20002602 <HAL_DMA_Start_IT>
20006ee4:	4603      	mov	r3, r0
20006ee6:	2b00      	cmp	r3, #0
20006ee8:	d122      	bne.n	20006f30 <HAL_QSPI_Receive_DMA+0x1bc>
        {
          /* Configure QSPI: CCR register with functional as indirect read */
          MODIFY_REG(hqspi->Instance->CCR, QUADSPI_CCR_FMODE, QSPI_FUNCTIONAL_MODE_INDIRECT_READ);
20006eea:	687b      	ldr	r3, [r7, #4]
20006eec:	681b      	ldr	r3, [r3, #0]
20006eee:	695b      	ldr	r3, [r3, #20]
20006ef0:	f023 6240 	bic.w	r2, r3, #201326592	; 0xc000000
20006ef4:	687b      	ldr	r3, [r7, #4]
20006ef6:	681b      	ldr	r3, [r3, #0]
20006ef8:	f042 6280 	orr.w	r2, r2, #67108864	; 0x4000000
20006efc:	615a      	str	r2, [r3, #20]

          /* Start the transfer by re-writing the address in AR register */
          WRITE_REG(hqspi->Instance->AR, addr_reg);
20006efe:	687b      	ldr	r3, [r7, #4]
20006f00:	681b      	ldr	r3, [r3, #0]
20006f02:	693a      	ldr	r2, [r7, #16]
20006f04:	619a      	str	r2, [r3, #24]

          /* Process unlocked */
          __HAL_UNLOCK(hqspi);
20006f06:	687b      	ldr	r3, [r7, #4]
20006f08:	2200      	movs	r2, #0
20006f0a:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
          
          /* Enable the QSPI transfer error Interrupt */
          __HAL_QSPI_ENABLE_IT(hqspi, QSPI_IT_TE);
20006f0e:	687b      	ldr	r3, [r7, #4]
20006f10:	681b      	ldr	r3, [r3, #0]
20006f12:	681a      	ldr	r2, [r3, #0]
20006f14:	687b      	ldr	r3, [r7, #4]
20006f16:	681b      	ldr	r3, [r3, #0]
20006f18:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
20006f1c:	601a      	str	r2, [r3, #0]
          
          /* Enable the DMA transfer by setting the DMAEN bit in the QSPI CR register */
          SET_BIT(hqspi->Instance->CR, QUADSPI_CR_DMAEN);
20006f1e:	687b      	ldr	r3, [r7, #4]
20006f20:	681b      	ldr	r3, [r3, #0]
20006f22:	681a      	ldr	r2, [r3, #0]
20006f24:	687b      	ldr	r3, [r7, #4]
20006f26:	681b      	ldr	r3, [r3, #0]
20006f28:	f042 0204 	orr.w	r2, r2, #4
20006f2c:	601a      	str	r2, [r3, #0]
20006f2e:	e023      	b.n	20006f78 <HAL_QSPI_Receive_DMA+0x204>
        }
        else
        {
          status = HAL_ERROR;
20006f30:	2301      	movs	r3, #1
20006f32:	75fb      	strb	r3, [r7, #23]
          hqspi->ErrorCode |= HAL_QSPI_ERROR_DMA;
20006f34:	687b      	ldr	r3, [r7, #4]
20006f36:	6c5b      	ldr	r3, [r3, #68]	; 0x44
20006f38:	f043 0204 	orr.w	r2, r3, #4
20006f3c:	687b      	ldr	r3, [r7, #4]
20006f3e:	645a      	str	r2, [r3, #68]	; 0x44
          hqspi->State = HAL_QSPI_STATE_READY;
20006f40:	687b      	ldr	r3, [r7, #4]
20006f42:	2201      	movs	r2, #1
20006f44:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41

          /* Process unlocked */
          __HAL_UNLOCK(hqspi);
20006f48:	687b      	ldr	r3, [r7, #4]
20006f4a:	2200      	movs	r2, #0
20006f4c:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
20006f50:	e012      	b.n	20006f78 <HAL_QSPI_Receive_DMA+0x204>
        }
      }
    }
    else
    {
      hqspi->ErrorCode |= HAL_QSPI_ERROR_INVALID_PARAM;
20006f52:	687b      	ldr	r3, [r7, #4]
20006f54:	6c5b      	ldr	r3, [r3, #68]	; 0x44
20006f56:	f043 0208 	orr.w	r2, r3, #8
20006f5a:	687b      	ldr	r3, [r7, #4]
20006f5c:	645a      	str	r2, [r3, #68]	; 0x44
      status = HAL_ERROR;
20006f5e:	2301      	movs	r3, #1
20006f60:	75fb      	strb	r3, [r7, #23]

      /* Process unlocked */
      __HAL_UNLOCK(hqspi);
20006f62:	687b      	ldr	r3, [r7, #4]
20006f64:	2200      	movs	r2, #0
20006f66:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
20006f6a:	e005      	b.n	20006f78 <HAL_QSPI_Receive_DMA+0x204>
    }
  }
  else
  {
    status = HAL_BUSY;
20006f6c:	2302      	movs	r3, #2
20006f6e:	75fb      	strb	r3, [r7, #23]

    /* Process unlocked */
    __HAL_UNLOCK(hqspi);
20006f70:	687b      	ldr	r3, [r7, #4]
20006f72:	2200      	movs	r2, #0
20006f74:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
  }

  return status;
20006f78:	7dfb      	ldrb	r3, [r7, #23]
}
20006f7a:	4618      	mov	r0, r3
20006f7c:	3718      	adds	r7, #24
20006f7e:	46bd      	mov	sp, r7
20006f80:	bd80      	pop	{r7, pc}
20006f82:	bf00      	nop
20006f84:	200075d5 	.word	0x200075d5
20006f88:	20007635 	.word	0x20007635
20006f8c:	2000766d 	.word	0x2000766d

20006f90 <HAL_QSPI_AutoPolling>:
  * @param  Timeout : Timeout duration
  * @note   This function is used only in Automatic Polling Mode
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_QSPI_AutoPolling(QSPI_HandleTypeDef *hqspi, QSPI_CommandTypeDef *cmd, QSPI_AutoPollingTypeDef *cfg, uint32_t Timeout)
{
20006f90:	b580      	push	{r7, lr}
20006f92:	b088      	sub	sp, #32
20006f94:	af02      	add	r7, sp, #8
20006f96:	60f8      	str	r0, [r7, #12]
20006f98:	60b9      	str	r1, [r7, #8]
20006f9a:	607a      	str	r2, [r7, #4]
20006f9c:	603b      	str	r3, [r7, #0]
  HAL_StatusTypeDef status;
  uint32_t tickstart = HAL_GetTick();
20006f9e:	f7fa fc7d 	bl	2000189c <HAL_GetTick>
20006fa2:	6138      	str	r0, [r7, #16]
  assert_param(IS_QSPI_INTERVAL(cfg->Interval));
  assert_param(IS_QSPI_STATUS_BYTES_SIZE(cfg->StatusBytesSize));
  assert_param(IS_QSPI_MATCH_MODE(cfg->MatchMode));

  /* Process locked */
  __HAL_LOCK(hqspi);
20006fa4:	68fb      	ldr	r3, [r7, #12]
20006fa6:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
20006faa:	b2db      	uxtb	r3, r3
20006fac:	2b01      	cmp	r3, #1
20006fae:	d101      	bne.n	20006fb4 <HAL_QSPI_AutoPolling+0x24>
20006fb0:	2302      	movs	r3, #2
20006fb2:	e060      	b.n	20007076 <HAL_QSPI_AutoPolling+0xe6>
20006fb4:	68fb      	ldr	r3, [r7, #12]
20006fb6:	2201      	movs	r2, #1
20006fb8:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

  if(hqspi->State == HAL_QSPI_STATE_READY)
20006fbc:	68fb      	ldr	r3, [r7, #12]
20006fbe:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
20006fc2:	b2db      	uxtb	r3, r3
20006fc4:	2b01      	cmp	r3, #1
20006fc6:	d14f      	bne.n	20007068 <HAL_QSPI_AutoPolling+0xd8>
  {
    hqspi->ErrorCode = HAL_QSPI_ERROR_NONE;
20006fc8:	68fb      	ldr	r3, [r7, #12]
20006fca:	2200      	movs	r2, #0
20006fcc:	645a      	str	r2, [r3, #68]	; 0x44

    /* Update state */
    hqspi->State = HAL_QSPI_STATE_BUSY_AUTO_POLLING;
20006fce:	68fb      	ldr	r3, [r7, #12]
20006fd0:	2242      	movs	r2, #66	; 0x42
20006fd2:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41

    /* Wait till BUSY flag reset */
    status = QSPI_WaitFlagStateUntilTimeout(hqspi, QSPI_FLAG_BUSY, RESET, tickstart, Timeout);
20006fd6:	683b      	ldr	r3, [r7, #0]
20006fd8:	9300      	str	r3, [sp, #0]
20006fda:	693b      	ldr	r3, [r7, #16]
20006fdc:	2200      	movs	r2, #0
20006fde:	2120      	movs	r1, #32
20006fe0:	68f8      	ldr	r0, [r7, #12]
20006fe2:	f000 fb98 	bl	20007716 <QSPI_WaitFlagStateUntilTimeout>
20006fe6:	4603      	mov	r3, r0
20006fe8:	75fb      	strb	r3, [r7, #23]

    if (status == HAL_OK)
20006fea:	7dfb      	ldrb	r3, [r7, #23]
20006fec:	2b00      	cmp	r3, #0
20006fee:	d13d      	bne.n	2000706c <HAL_QSPI_AutoPolling+0xdc>
    {
      /* Configure QSPI: PSMAR register with the status match value */
      WRITE_REG(hqspi->Instance->PSMAR, cfg->Match);
20006ff0:	68fb      	ldr	r3, [r7, #12]
20006ff2:	681b      	ldr	r3, [r3, #0]
20006ff4:	687a      	ldr	r2, [r7, #4]
20006ff6:	6812      	ldr	r2, [r2, #0]
20006ff8:	629a      	str	r2, [r3, #40]	; 0x28

      /* Configure QSPI: PSMKR register with the status mask value */
      WRITE_REG(hqspi->Instance->PSMKR, cfg->Mask);
20006ffa:	68fb      	ldr	r3, [r7, #12]
20006ffc:	681b      	ldr	r3, [r3, #0]
20006ffe:	687a      	ldr	r2, [r7, #4]
20007000:	6852      	ldr	r2, [r2, #4]
20007002:	625a      	str	r2, [r3, #36]	; 0x24

      /* Configure QSPI: PIR register with the interval value */
      WRITE_REG(hqspi->Instance->PIR, cfg->Interval);
20007004:	68fb      	ldr	r3, [r7, #12]
20007006:	681b      	ldr	r3, [r3, #0]
20007008:	687a      	ldr	r2, [r7, #4]
2000700a:	6892      	ldr	r2, [r2, #8]
2000700c:	62da      	str	r2, [r3, #44]	; 0x2c

      /* Configure QSPI: CR register with Match mode and Automatic stop enabled
      (otherwise there will be an infinite loop in blocking mode) */
      MODIFY_REG(hqspi->Instance->CR, (QUADSPI_CR_PMM | QUADSPI_CR_APMS),
2000700e:	68fb      	ldr	r3, [r7, #12]
20007010:	681b      	ldr	r3, [r3, #0]
20007012:	681b      	ldr	r3, [r3, #0]
20007014:	f423 0240 	bic.w	r2, r3, #12582912	; 0xc00000
20007018:	687b      	ldr	r3, [r7, #4]
2000701a:	691b      	ldr	r3, [r3, #16]
2000701c:	431a      	orrs	r2, r3
2000701e:	68fb      	ldr	r3, [r7, #12]
20007020:	681b      	ldr	r3, [r3, #0]
20007022:	f442 0280 	orr.w	r2, r2, #4194304	; 0x400000
20007026:	601a      	str	r2, [r3, #0]
               (cfg->MatchMode | QSPI_AUTOMATIC_STOP_ENABLE));

      /* Call the configuration function */
      cmd->NbData = cfg->StatusBytesSize;
20007028:	687b      	ldr	r3, [r7, #4]
2000702a:	68da      	ldr	r2, [r3, #12]
2000702c:	68bb      	ldr	r3, [r7, #8]
2000702e:	629a      	str	r2, [r3, #40]	; 0x28
      QSPI_Config(hqspi, cmd, QSPI_FUNCTIONAL_MODE_AUTO_POLLING);
20007030:	f04f 6200 	mov.w	r2, #134217728	; 0x8000000
20007034:	68b9      	ldr	r1, [r7, #8]
20007036:	68f8      	ldr	r0, [r7, #12]
20007038:	f000 fba4 	bl	20007784 <QSPI_Config>

      /* Wait until SM flag is set to go back in idle state */
      status = QSPI_WaitFlagStateUntilTimeout(hqspi, QSPI_FLAG_SM, SET, tickstart, Timeout);
2000703c:	683b      	ldr	r3, [r7, #0]
2000703e:	9300      	str	r3, [sp, #0]
20007040:	693b      	ldr	r3, [r7, #16]
20007042:	2201      	movs	r2, #1
20007044:	2108      	movs	r1, #8
20007046:	68f8      	ldr	r0, [r7, #12]
20007048:	f000 fb65 	bl	20007716 <QSPI_WaitFlagStateUntilTimeout>
2000704c:	4603      	mov	r3, r0
2000704e:	75fb      	strb	r3, [r7, #23]

      if (status == HAL_OK)
20007050:	7dfb      	ldrb	r3, [r7, #23]
20007052:	2b00      	cmp	r3, #0
20007054:	d10a      	bne.n	2000706c <HAL_QSPI_AutoPolling+0xdc>
      {
        __HAL_QSPI_CLEAR_FLAG(hqspi, QSPI_FLAG_SM);
20007056:	68fb      	ldr	r3, [r7, #12]
20007058:	681b      	ldr	r3, [r3, #0]
2000705a:	2208      	movs	r2, #8
2000705c:	60da      	str	r2, [r3, #12]

        /* Update state */
        hqspi->State = HAL_QSPI_STATE_READY;
2000705e:	68fb      	ldr	r3, [r7, #12]
20007060:	2201      	movs	r2, #1
20007062:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
20007066:	e001      	b.n	2000706c <HAL_QSPI_AutoPolling+0xdc>
      }
    }
  }
  else
  {
    status = HAL_BUSY;
20007068:	2302      	movs	r3, #2
2000706a:	75fb      	strb	r3, [r7, #23]
  }

  /* Process unlocked */
  __HAL_UNLOCK(hqspi);
2000706c:	68fb      	ldr	r3, [r7, #12]
2000706e:	2200      	movs	r2, #0
20007070:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

  /* Return function status */
  return status;
20007074:	7dfb      	ldrb	r3, [r7, #23]
}
20007076:	4618      	mov	r0, r3
20007078:	3718      	adds	r7, #24
2000707a:	46bd      	mov	sp, r7
2000707c:	bd80      	pop	{r7, pc}

2000707e <HAL_QSPI_AutoPolling_IT>:
  * @param  cfg : structure that contains the polling configuration information.
  * @note   This function is used only in Automatic Polling Mode
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_QSPI_AutoPolling_IT(QSPI_HandleTypeDef *hqspi, QSPI_CommandTypeDef *cmd, QSPI_AutoPollingTypeDef *cfg)
{
2000707e:	b580      	push	{r7, lr}
20007080:	b088      	sub	sp, #32
20007082:	af02      	add	r7, sp, #8
20007084:	60f8      	str	r0, [r7, #12]
20007086:	60b9      	str	r1, [r7, #8]
20007088:	607a      	str	r2, [r7, #4]
  HAL_StatusTypeDef status;
  uint32_t tickstart = HAL_GetTick();
2000708a:	f7fa fc07 	bl	2000189c <HAL_GetTick>
2000708e:	6138      	str	r0, [r7, #16]
  assert_param(IS_QSPI_STATUS_BYTES_SIZE(cfg->StatusBytesSize));
  assert_param(IS_QSPI_MATCH_MODE(cfg->MatchMode));
  assert_param(IS_QSPI_AUTOMATIC_STOP(cfg->AutomaticStop));

  /* Process locked */
  __HAL_LOCK(hqspi);
20007090:	68fb      	ldr	r3, [r7, #12]
20007092:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
20007096:	b2db      	uxtb	r3, r3
20007098:	2b01      	cmp	r3, #1
2000709a:	d101      	bne.n	200070a0 <HAL_QSPI_AutoPolling_IT+0x22>
2000709c:	2302      	movs	r3, #2
2000709e:	e062      	b.n	20007166 <HAL_QSPI_AutoPolling_IT+0xe8>
200070a0:	68fb      	ldr	r3, [r7, #12]
200070a2:	2201      	movs	r2, #1
200070a4:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

  if(hqspi->State == HAL_QSPI_STATE_READY)
200070a8:	68fb      	ldr	r3, [r7, #12]
200070aa:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
200070ae:	b2db      	uxtb	r3, r3
200070b0:	2b01      	cmp	r3, #1
200070b2:	d151      	bne.n	20007158 <HAL_QSPI_AutoPolling_IT+0xda>
  {
    hqspi->ErrorCode = HAL_QSPI_ERROR_NONE;
200070b4:	68fb      	ldr	r3, [r7, #12]
200070b6:	2200      	movs	r2, #0
200070b8:	645a      	str	r2, [r3, #68]	; 0x44

    /* Update state */
    hqspi->State = HAL_QSPI_STATE_BUSY_AUTO_POLLING;
200070ba:	68fb      	ldr	r3, [r7, #12]
200070bc:	2242      	movs	r2, #66	; 0x42
200070be:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41

    /* Wait till BUSY flag reset */
    status = QSPI_WaitFlagStateUntilTimeout(hqspi, QSPI_FLAG_BUSY, RESET, tickstart, hqspi->Timeout);
200070c2:	68fb      	ldr	r3, [r7, #12]
200070c4:	6c9b      	ldr	r3, [r3, #72]	; 0x48
200070c6:	9300      	str	r3, [sp, #0]
200070c8:	693b      	ldr	r3, [r7, #16]
200070ca:	2200      	movs	r2, #0
200070cc:	2120      	movs	r1, #32
200070ce:	68f8      	ldr	r0, [r7, #12]
200070d0:	f000 fb21 	bl	20007716 <QSPI_WaitFlagStateUntilTimeout>
200070d4:	4603      	mov	r3, r0
200070d6:	75fb      	strb	r3, [r7, #23]

    if (status == HAL_OK)
200070d8:	7dfb      	ldrb	r3, [r7, #23]
200070da:	2b00      	cmp	r3, #0
200070dc:	d137      	bne.n	2000714e <HAL_QSPI_AutoPolling_IT+0xd0>
    {
      /* Configure QSPI: PSMAR register with the status match value */
      WRITE_REG(hqspi->Instance->PSMAR, cfg->Match);
200070de:	68fb      	ldr	r3, [r7, #12]
200070e0:	681b      	ldr	r3, [r3, #0]
200070e2:	687a      	ldr	r2, [r7, #4]
200070e4:	6812      	ldr	r2, [r2, #0]
200070e6:	629a      	str	r2, [r3, #40]	; 0x28

      /* Configure QSPI: PSMKR register with the status mask value */
      WRITE_REG(hqspi->Instance->PSMKR, cfg->Mask);
200070e8:	68fb      	ldr	r3, [r7, #12]
200070ea:	681b      	ldr	r3, [r3, #0]
200070ec:	687a      	ldr	r2, [r7, #4]
200070ee:	6852      	ldr	r2, [r2, #4]
200070f0:	625a      	str	r2, [r3, #36]	; 0x24

      /* Configure QSPI: PIR register with the interval value */
      WRITE_REG(hqspi->Instance->PIR, cfg->Interval);
200070f2:	68fb      	ldr	r3, [r7, #12]
200070f4:	681b      	ldr	r3, [r3, #0]
200070f6:	687a      	ldr	r2, [r7, #4]
200070f8:	6892      	ldr	r2, [r2, #8]
200070fa:	62da      	str	r2, [r3, #44]	; 0x2c

      /* Configure QSPI: CR register with Match mode and Automatic stop mode */
      MODIFY_REG(hqspi->Instance->CR, (QUADSPI_CR_PMM | QUADSPI_CR_APMS),
200070fc:	68fb      	ldr	r3, [r7, #12]
200070fe:	681b      	ldr	r3, [r3, #0]
20007100:	681b      	ldr	r3, [r3, #0]
20007102:	f423 0140 	bic.w	r1, r3, #12582912	; 0xc00000
20007106:	687b      	ldr	r3, [r7, #4]
20007108:	691a      	ldr	r2, [r3, #16]
2000710a:	687b      	ldr	r3, [r7, #4]
2000710c:	695b      	ldr	r3, [r3, #20]
2000710e:	431a      	orrs	r2, r3
20007110:	68fb      	ldr	r3, [r7, #12]
20007112:	681b      	ldr	r3, [r3, #0]
20007114:	430a      	orrs	r2, r1
20007116:	601a      	str	r2, [r3, #0]
               (cfg->MatchMode | cfg->AutomaticStop));

      /* Clear interrupt */
      __HAL_QSPI_CLEAR_FLAG(hqspi, QSPI_FLAG_TE | QSPI_FLAG_SM);
20007118:	68fb      	ldr	r3, [r7, #12]
2000711a:	681b      	ldr	r3, [r3, #0]
2000711c:	2209      	movs	r2, #9
2000711e:	60da      	str	r2, [r3, #12]

      /* Call the configuration function */
      cmd->NbData = cfg->StatusBytesSize;
20007120:	687b      	ldr	r3, [r7, #4]
20007122:	68da      	ldr	r2, [r3, #12]
20007124:	68bb      	ldr	r3, [r7, #8]
20007126:	629a      	str	r2, [r3, #40]	; 0x28
      QSPI_Config(hqspi, cmd, QSPI_FUNCTIONAL_MODE_AUTO_POLLING);
20007128:	f04f 6200 	mov.w	r2, #134217728	; 0x8000000
2000712c:	68b9      	ldr	r1, [r7, #8]
2000712e:	68f8      	ldr	r0, [r7, #12]
20007130:	f000 fb28 	bl	20007784 <QSPI_Config>

      /* Process unlocked */
      __HAL_UNLOCK(hqspi);
20007134:	68fb      	ldr	r3, [r7, #12]
20007136:	2200      	movs	r2, #0
20007138:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

      /* Enable the QSPI Transfer Error and status match Interrupt */
      __HAL_QSPI_ENABLE_IT(hqspi, (QSPI_IT_SM | QSPI_IT_TE));
2000713c:	68fb      	ldr	r3, [r7, #12]
2000713e:	681b      	ldr	r3, [r3, #0]
20007140:	681a      	ldr	r2, [r3, #0]
20007142:	68fb      	ldr	r3, [r7, #12]
20007144:	681b      	ldr	r3, [r3, #0]
20007146:	f442 2210 	orr.w	r2, r2, #589824	; 0x90000
2000714a:	601a      	str	r2, [r3, #0]
2000714c:	e00a      	b.n	20007164 <HAL_QSPI_AutoPolling_IT+0xe6>

    }
    else
    {
      /* Process unlocked */
      __HAL_UNLOCK(hqspi);
2000714e:	68fb      	ldr	r3, [r7, #12]
20007150:	2200      	movs	r2, #0
20007152:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
20007156:	e005      	b.n	20007164 <HAL_QSPI_AutoPolling_IT+0xe6>
    }
  }
  else
  {
    status = HAL_BUSY;
20007158:	2302      	movs	r3, #2
2000715a:	75fb      	strb	r3, [r7, #23]

    /* Process unlocked */
    __HAL_UNLOCK(hqspi);
2000715c:	68fb      	ldr	r3, [r7, #12]
2000715e:	2200      	movs	r2, #0
20007160:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
  }

  /* Return function status */
  return status;
20007164:	7dfb      	ldrb	r3, [r7, #23]
}
20007166:	4618      	mov	r0, r3
20007168:	3718      	adds	r7, #24
2000716a:	46bd      	mov	sp, r7
2000716c:	bd80      	pop	{r7, pc}

2000716e <HAL_QSPI_MemoryMapped>:
  * @param  cfg : structure that contains the memory mapped configuration information.
  * @note   This function is used only in Memory mapped Mode
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_QSPI_MemoryMapped(QSPI_HandleTypeDef *hqspi, QSPI_CommandTypeDef *cmd, QSPI_MemoryMappedTypeDef *cfg)
{
2000716e:	b580      	push	{r7, lr}
20007170:	b088      	sub	sp, #32
20007172:	af02      	add	r7, sp, #8
20007174:	60f8      	str	r0, [r7, #12]
20007176:	60b9      	str	r1, [r7, #8]
20007178:	607a      	str	r2, [r7, #4]
  HAL_StatusTypeDef status;
  uint32_t tickstart = HAL_GetTick();
2000717a:	f7fa fb8f 	bl	2000189c <HAL_GetTick>
2000717e:	6138      	str	r0, [r7, #16]
  assert_param(IS_QSPI_SIOO_MODE(cmd->SIOOMode));

  assert_param(IS_QSPI_TIMEOUT_ACTIVATION(cfg->TimeOutActivation));

  /* Process locked */
  __HAL_LOCK(hqspi);
20007180:	68fb      	ldr	r3, [r7, #12]
20007182:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
20007186:	b2db      	uxtb	r3, r3
20007188:	2b01      	cmp	r3, #1
2000718a:	d101      	bne.n	20007190 <HAL_QSPI_MemoryMapped+0x22>
2000718c:	2302      	movs	r3, #2
2000718e:	e04c      	b.n	2000722a <HAL_QSPI_MemoryMapped+0xbc>
20007190:	68fb      	ldr	r3, [r7, #12]
20007192:	2201      	movs	r2, #1
20007194:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

  if(hqspi->State == HAL_QSPI_STATE_READY)
20007198:	68fb      	ldr	r3, [r7, #12]
2000719a:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2000719e:	b2db      	uxtb	r3, r3
200071a0:	2b01      	cmp	r3, #1
200071a2:	d13b      	bne.n	2000721c <HAL_QSPI_MemoryMapped+0xae>
  {
    hqspi->ErrorCode = HAL_QSPI_ERROR_NONE;
200071a4:	68fb      	ldr	r3, [r7, #12]
200071a6:	2200      	movs	r2, #0
200071a8:	645a      	str	r2, [r3, #68]	; 0x44

    /* Update state */
    hqspi->State = HAL_QSPI_STATE_BUSY_MEM_MAPPED;
200071aa:	68fb      	ldr	r3, [r7, #12]
200071ac:	2282      	movs	r2, #130	; 0x82
200071ae:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41

    /* Wait till BUSY flag reset */
    status = QSPI_WaitFlagStateUntilTimeout(hqspi, QSPI_FLAG_BUSY, RESET, tickstart, hqspi->Timeout);
200071b2:	68fb      	ldr	r3, [r7, #12]
200071b4:	6c9b      	ldr	r3, [r3, #72]	; 0x48
200071b6:	9300      	str	r3, [sp, #0]
200071b8:	693b      	ldr	r3, [r7, #16]
200071ba:	2200      	movs	r2, #0
200071bc:	2120      	movs	r1, #32
200071be:	68f8      	ldr	r0, [r7, #12]
200071c0:	f000 faa9 	bl	20007716 <QSPI_WaitFlagStateUntilTimeout>
200071c4:	4603      	mov	r3, r0
200071c6:	75fb      	strb	r3, [r7, #23]

    if (status == HAL_OK)
200071c8:	7dfb      	ldrb	r3, [r7, #23]
200071ca:	2b00      	cmp	r3, #0
200071cc:	d128      	bne.n	20007220 <HAL_QSPI_MemoryMapped+0xb2>
    {
      /* Configure QSPI: CR register with timeout counter enable */
    MODIFY_REG(hqspi->Instance->CR, QUADSPI_CR_TCEN, cfg->TimeOutActivation);
200071ce:	68fb      	ldr	r3, [r7, #12]
200071d0:	681b      	ldr	r3, [r3, #0]
200071d2:	681b      	ldr	r3, [r3, #0]
200071d4:	f023 0108 	bic.w	r1, r3, #8
200071d8:	687b      	ldr	r3, [r7, #4]
200071da:	685a      	ldr	r2, [r3, #4]
200071dc:	68fb      	ldr	r3, [r7, #12]
200071de:	681b      	ldr	r3, [r3, #0]
200071e0:	430a      	orrs	r2, r1
200071e2:	601a      	str	r2, [r3, #0]

    if (cfg->TimeOutActivation == QSPI_TIMEOUT_COUNTER_ENABLE)
200071e4:	687b      	ldr	r3, [r7, #4]
200071e6:	685b      	ldr	r3, [r3, #4]
200071e8:	2b08      	cmp	r3, #8
200071ea:	d110      	bne.n	2000720e <HAL_QSPI_MemoryMapped+0xa0>
      {
        assert_param(IS_QSPI_TIMEOUT_PERIOD(cfg->TimeOutPeriod));

        /* Configure QSPI: LPTR register with the low-power timeout value */
        WRITE_REG(hqspi->Instance->LPTR, cfg->TimeOutPeriod);
200071ec:	68fb      	ldr	r3, [r7, #12]
200071ee:	681b      	ldr	r3, [r3, #0]
200071f0:	687a      	ldr	r2, [r7, #4]
200071f2:	6812      	ldr	r2, [r2, #0]
200071f4:	631a      	str	r2, [r3, #48]	; 0x30

        /* Clear interrupt */
        __HAL_QSPI_CLEAR_FLAG(hqspi, QSPI_FLAG_TO);
200071f6:	68fb      	ldr	r3, [r7, #12]
200071f8:	681b      	ldr	r3, [r3, #0]
200071fa:	2210      	movs	r2, #16
200071fc:	60da      	str	r2, [r3, #12]

        /* Enable the QSPI TimeOut Interrupt */
        __HAL_QSPI_ENABLE_IT(hqspi, QSPI_IT_TO);
200071fe:	68fb      	ldr	r3, [r7, #12]
20007200:	681b      	ldr	r3, [r3, #0]
20007202:	681a      	ldr	r2, [r3, #0]
20007204:	68fb      	ldr	r3, [r7, #12]
20007206:	681b      	ldr	r3, [r3, #0]
20007208:	f442 1280 	orr.w	r2, r2, #1048576	; 0x100000
2000720c:	601a      	str	r2, [r3, #0]
      }

      /* Call the configuration function */
      QSPI_Config(hqspi, cmd, QSPI_FUNCTIONAL_MODE_MEMORY_MAPPED);
2000720e:	f04f 6240 	mov.w	r2, #201326592	; 0xc000000
20007212:	68b9      	ldr	r1, [r7, #8]
20007214:	68f8      	ldr	r0, [r7, #12]
20007216:	f000 fab5 	bl	20007784 <QSPI_Config>
2000721a:	e001      	b.n	20007220 <HAL_QSPI_MemoryMapped+0xb2>
    }
  }
  else
  {
    status = HAL_BUSY;
2000721c:	2302      	movs	r3, #2
2000721e:	75fb      	strb	r3, [r7, #23]
  }

  /* Process unlocked */
  __HAL_UNLOCK(hqspi);
20007220:	68fb      	ldr	r3, [r7, #12]
20007222:	2200      	movs	r2, #0
20007224:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

  /* Return function status */
  return status;
20007228:	7dfb      	ldrb	r3, [r7, #23]
}
2000722a:	4618      	mov	r0, r3
2000722c:	3718      	adds	r7, #24
2000722e:	46bd      	mov	sp, r7
20007230:	bd80      	pop	{r7, pc}

20007232 <HAL_QSPI_ErrorCallback>:
  * @brief  Transfer Error callback.
  * @param  hqspi : QSPI handle
  * @retval None
  */
__weak void HAL_QSPI_ErrorCallback(QSPI_HandleTypeDef *hqspi)
{
20007232:	b480      	push	{r7}
20007234:	b083      	sub	sp, #12
20007236:	af00      	add	r7, sp, #0
20007238:	6078      	str	r0, [r7, #4]
  UNUSED(hqspi);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_QSPI_ErrorCallback could be implemented in the user file
   */
}
2000723a:	bf00      	nop
2000723c:	370c      	adds	r7, #12
2000723e:	46bd      	mov	sp, r7
20007240:	f85d 7b04 	ldr.w	r7, [sp], #4
20007244:	4770      	bx	lr

20007246 <HAL_QSPI_AbortCpltCallback>:
  * @brief  Abort completed callback.
  * @param  hqspi : QSPI handle
  * @retval None
  */
__weak void HAL_QSPI_AbortCpltCallback(QSPI_HandleTypeDef *hqspi)
{
20007246:	b480      	push	{r7}
20007248:	b083      	sub	sp, #12
2000724a:	af00      	add	r7, sp, #0
2000724c:	6078      	str	r0, [r7, #4]
  UNUSED(hqspi);

  /* NOTE: This function should not be modified, when the callback is needed,
           the HAL_QSPI_AbortCpltCallback could be implemented in the user file
   */
}
2000724e:	bf00      	nop
20007250:	370c      	adds	r7, #12
20007252:	46bd      	mov	sp, r7
20007254:	f85d 7b04 	ldr.w	r7, [sp], #4
20007258:	4770      	bx	lr

2000725a <HAL_QSPI_CmdCpltCallback>:
  * @brief  Command completed callback.
  * @param  hqspi : QSPI handle
  * @retval None
  */
__weak void HAL_QSPI_CmdCpltCallback(QSPI_HandleTypeDef *hqspi)
{
2000725a:	b480      	push	{r7}
2000725c:	b083      	sub	sp, #12
2000725e:	af00      	add	r7, sp, #0
20007260:	6078      	str	r0, [r7, #4]
  UNUSED(hqspi);

  /* NOTE: This function should not be modified, when the callback is needed,
           the HAL_QSPI_CmdCpltCallback could be implemented in the user file
   */
}
20007262:	bf00      	nop
20007264:	370c      	adds	r7, #12
20007266:	46bd      	mov	sp, r7
20007268:	f85d 7b04 	ldr.w	r7, [sp], #4
2000726c:	4770      	bx	lr

2000726e <HAL_QSPI_RxCpltCallback>:
  * @brief  Rx Transfer completed callback.
  * @param  hqspi : QSPI handle
  * @retval None
  */
__weak void HAL_QSPI_RxCpltCallback(QSPI_HandleTypeDef *hqspi)
{
2000726e:	b480      	push	{r7}
20007270:	b083      	sub	sp, #12
20007272:	af00      	add	r7, sp, #0
20007274:	6078      	str	r0, [r7, #4]
  UNUSED(hqspi);

  /* NOTE: This function should not be modified, when the callback is needed,
           the HAL_QSPI_RxCpltCallback could be implemented in the user file
   */
}
20007276:	bf00      	nop
20007278:	370c      	adds	r7, #12
2000727a:	46bd      	mov	sp, r7
2000727c:	f85d 7b04 	ldr.w	r7, [sp], #4
20007280:	4770      	bx	lr

20007282 <HAL_QSPI_TxCpltCallback>:
  * @brief  Tx Transfer completed callback.
  * @param  hqspi : QSPI handle
  * @retval None
  */
__weak void HAL_QSPI_TxCpltCallback(QSPI_HandleTypeDef *hqspi)
{
20007282:	b480      	push	{r7}
20007284:	b083      	sub	sp, #12
20007286:	af00      	add	r7, sp, #0
20007288:	6078      	str	r0, [r7, #4]
  UNUSED(hqspi);

  /* NOTE: This function should not be modified, when the callback is needed,
           the HAL_QSPI_TxCpltCallback could be implemented in the user file
   */
}
2000728a:	bf00      	nop
2000728c:	370c      	adds	r7, #12
2000728e:	46bd      	mov	sp, r7
20007290:	f85d 7b04 	ldr.w	r7, [sp], #4
20007294:	4770      	bx	lr

20007296 <HAL_QSPI_RxHalfCpltCallback>:
  * @brief  Rx Half Transfer completed callback.
  * @param  hqspi : QSPI handle
  * @retval None
  */
__weak void HAL_QSPI_RxHalfCpltCallback(QSPI_HandleTypeDef *hqspi)
{
20007296:	b480      	push	{r7}
20007298:	b083      	sub	sp, #12
2000729a:	af00      	add	r7, sp, #0
2000729c:	6078      	str	r0, [r7, #4]
  UNUSED(hqspi);

  /* NOTE: This function should not be modified, when the callback is needed,
           the HAL_QSPI_RxHalfCpltCallback could be implemented in the user file
   */
}
2000729e:	bf00      	nop
200072a0:	370c      	adds	r7, #12
200072a2:	46bd      	mov	sp, r7
200072a4:	f85d 7b04 	ldr.w	r7, [sp], #4
200072a8:	4770      	bx	lr

200072aa <HAL_QSPI_TxHalfCpltCallback>:
  * @brief  Tx Half Transfer completed callback.
  * @param  hqspi : QSPI handle
  * @retval None
  */
__weak void HAL_QSPI_TxHalfCpltCallback(QSPI_HandleTypeDef *hqspi)
{
200072aa:	b480      	push	{r7}
200072ac:	b083      	sub	sp, #12
200072ae:	af00      	add	r7, sp, #0
200072b0:	6078      	str	r0, [r7, #4]
  UNUSED(hqspi);

  /* NOTE: This function should not be modified, when the callback is needed,
           the HAL_QSPI_TxHalfCpltCallback could be implemented in the user file
   */
}
200072b2:	bf00      	nop
200072b4:	370c      	adds	r7, #12
200072b6:	46bd      	mov	sp, r7
200072b8:	f85d 7b04 	ldr.w	r7, [sp], #4
200072bc:	4770      	bx	lr

200072be <HAL_QSPI_FifoThresholdCallback>:
  * @brief  FIFO Threshold callback.
  * @param  hqspi : QSPI handle
  * @retval None
  */
__weak void HAL_QSPI_FifoThresholdCallback(QSPI_HandleTypeDef *hqspi)
{
200072be:	b480      	push	{r7}
200072c0:	b083      	sub	sp, #12
200072c2:	af00      	add	r7, sp, #0
200072c4:	6078      	str	r0, [r7, #4]
  UNUSED(hqspi);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_QSPI_FIFOThresholdCallback could be implemented in the user file
   */
}
200072c6:	bf00      	nop
200072c8:	370c      	adds	r7, #12
200072ca:	46bd      	mov	sp, r7
200072cc:	f85d 7b04 	ldr.w	r7, [sp], #4
200072d0:	4770      	bx	lr

200072d2 <HAL_QSPI_StatusMatchCallback>:
  * @brief  Status Match callback.
  * @param  hqspi : QSPI handle
  * @retval None
  */
__weak void HAL_QSPI_StatusMatchCallback(QSPI_HandleTypeDef *hqspi)
{
200072d2:	b480      	push	{r7}
200072d4:	b083      	sub	sp, #12
200072d6:	af00      	add	r7, sp, #0
200072d8:	6078      	str	r0, [r7, #4]
  UNUSED(hqspi);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_QSPI_StatusMatchCallback could be implemented in the user file
   */
}
200072da:	bf00      	nop
200072dc:	370c      	adds	r7, #12
200072de:	46bd      	mov	sp, r7
200072e0:	f85d 7b04 	ldr.w	r7, [sp], #4
200072e4:	4770      	bx	lr

200072e6 <HAL_QSPI_TimeOutCallback>:
  * @brief  Timeout callback.
  * @param  hqspi : QSPI handle
  * @retval None
  */
__weak void HAL_QSPI_TimeOutCallback(QSPI_HandleTypeDef *hqspi)
{
200072e6:	b480      	push	{r7}
200072e8:	b083      	sub	sp, #12
200072ea:	af00      	add	r7, sp, #0
200072ec:	6078      	str	r0, [r7, #4]
  UNUSED(hqspi);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_QSPI_TimeOutCallback could be implemented in the user file
   */
}
200072ee:	bf00      	nop
200072f0:	370c      	adds	r7, #12
200072f2:	46bd      	mov	sp, r7
200072f4:	f85d 7b04 	ldr.w	r7, [sp], #4
200072f8:	4770      	bx	lr

200072fa <HAL_QSPI_GetState>:
  * @brief  Return the QSPI handle state.
  * @param  hqspi : QSPI handle
  * @retval HAL state
  */
HAL_QSPI_StateTypeDef HAL_QSPI_GetState(QSPI_HandleTypeDef *hqspi)
{
200072fa:	b480      	push	{r7}
200072fc:	b083      	sub	sp, #12
200072fe:	af00      	add	r7, sp, #0
20007300:	6078      	str	r0, [r7, #4]
  /* Return QSPI handle state */
  return hqspi->State;
20007302:	687b      	ldr	r3, [r7, #4]
20007304:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
20007308:	b2db      	uxtb	r3, r3
}
2000730a:	4618      	mov	r0, r3
2000730c:	370c      	adds	r7, #12
2000730e:	46bd      	mov	sp, r7
20007310:	f85d 7b04 	ldr.w	r7, [sp], #4
20007314:	4770      	bx	lr

20007316 <HAL_QSPI_GetError>:
* @brief  Return the QSPI error code.
* @param  hqspi : QSPI handle
* @retval QSPI Error Code
*/
uint32_t HAL_QSPI_GetError(QSPI_HandleTypeDef *hqspi)
{
20007316:	b480      	push	{r7}
20007318:	b083      	sub	sp, #12
2000731a:	af00      	add	r7, sp, #0
2000731c:	6078      	str	r0, [r7, #4]
  return hqspi->ErrorCode;
2000731e:	687b      	ldr	r3, [r7, #4]
20007320:	6c5b      	ldr	r3, [r3, #68]	; 0x44
}
20007322:	4618      	mov	r0, r3
20007324:	370c      	adds	r7, #12
20007326:	46bd      	mov	sp, r7
20007328:	f85d 7b04 	ldr.w	r7, [sp], #4
2000732c:	4770      	bx	lr

2000732e <HAL_QSPI_Abort>:
* @brief  Abort the current transmission.
* @param  hqspi : QSPI handle
* @retval HAL status
*/
HAL_StatusTypeDef HAL_QSPI_Abort(QSPI_HandleTypeDef *hqspi)
{
2000732e:	b580      	push	{r7, lr}
20007330:	b086      	sub	sp, #24
20007332:	af02      	add	r7, sp, #8
20007334:	6078      	str	r0, [r7, #4]
  HAL_StatusTypeDef status = HAL_OK;
20007336:	2300      	movs	r3, #0
20007338:	73fb      	strb	r3, [r7, #15]
  uint32_t tickstart = HAL_GetTick();
2000733a:	f7fa faaf 	bl	2000189c <HAL_GetTick>
2000733e:	60b8      	str	r0, [r7, #8]

  /* Check if the state is in one of the busy states */
  if (((uint32_t)hqspi->State & 0x2U) != 0U)
20007340:	687b      	ldr	r3, [r7, #4]
20007342:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
20007346:	b2db      	uxtb	r3, r3
20007348:	f003 0302 	and.w	r3, r3, #2
2000734c:	2b00      	cmp	r3, #0
2000734e:	d056      	beq.n	200073fe <HAL_QSPI_Abort+0xd0>
  {
    /* Process unlocked */
    __HAL_UNLOCK(hqspi);
20007350:	687b      	ldr	r3, [r7, #4]
20007352:	2200      	movs	r2, #0
20007354:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    if ((hqspi->Instance->CR & QUADSPI_CR_DMAEN) != 0U)
20007358:	687b      	ldr	r3, [r7, #4]
2000735a:	681b      	ldr	r3, [r3, #0]
2000735c:	681b      	ldr	r3, [r3, #0]
2000735e:	f003 0304 	and.w	r3, r3, #4
20007362:	2b00      	cmp	r3, #0
20007364:	d017      	beq.n	20007396 <HAL_QSPI_Abort+0x68>
    {
      /* Disable the DMA transfer by clearing the DMAEN bit in the QSPI CR register */
      CLEAR_BIT(hqspi->Instance->CR, QUADSPI_CR_DMAEN);
20007366:	687b      	ldr	r3, [r7, #4]
20007368:	681b      	ldr	r3, [r3, #0]
2000736a:	681a      	ldr	r2, [r3, #0]
2000736c:	687b      	ldr	r3, [r7, #4]
2000736e:	681b      	ldr	r3, [r3, #0]
20007370:	f022 0204 	bic.w	r2, r2, #4
20007374:	601a      	str	r2, [r3, #0]

      /* Abort DMA channel */
      status = HAL_DMA_Abort(hqspi->hdma);
20007376:	687b      	ldr	r3, [r7, #4]
20007378:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2000737a:	4618      	mov	r0, r3
2000737c:	f7fb f9bc 	bl	200026f8 <HAL_DMA_Abort>
20007380:	4603      	mov	r3, r0
20007382:	73fb      	strb	r3, [r7, #15]
      if(status != HAL_OK)
20007384:	7bfb      	ldrb	r3, [r7, #15]
20007386:	2b00      	cmp	r3, #0
20007388:	d005      	beq.n	20007396 <HAL_QSPI_Abort+0x68>
      {
        hqspi->ErrorCode |= HAL_QSPI_ERROR_DMA;
2000738a:	687b      	ldr	r3, [r7, #4]
2000738c:	6c5b      	ldr	r3, [r3, #68]	; 0x44
2000738e:	f043 0204 	orr.w	r2, r3, #4
20007392:	687b      	ldr	r3, [r7, #4]
20007394:	645a      	str	r2, [r3, #68]	; 0x44
      }
    }

    /* Configure QSPI: CR register with Abort request */
    SET_BIT(hqspi->Instance->CR, QUADSPI_CR_ABORT);
20007396:	687b      	ldr	r3, [r7, #4]
20007398:	681b      	ldr	r3, [r3, #0]
2000739a:	681a      	ldr	r2, [r3, #0]
2000739c:	687b      	ldr	r3, [r7, #4]
2000739e:	681b      	ldr	r3, [r3, #0]
200073a0:	f042 0202 	orr.w	r2, r2, #2
200073a4:	601a      	str	r2, [r3, #0]

    /* Wait until TC flag is set to go back in idle state */
    status = QSPI_WaitFlagStateUntilTimeout(hqspi, QSPI_FLAG_TC, SET, tickstart, hqspi->Timeout);
200073a6:	687b      	ldr	r3, [r7, #4]
200073a8:	6c9b      	ldr	r3, [r3, #72]	; 0x48
200073aa:	9300      	str	r3, [sp, #0]
200073ac:	68bb      	ldr	r3, [r7, #8]
200073ae:	2201      	movs	r2, #1
200073b0:	2102      	movs	r1, #2
200073b2:	6878      	ldr	r0, [r7, #4]
200073b4:	f000 f9af 	bl	20007716 <QSPI_WaitFlagStateUntilTimeout>
200073b8:	4603      	mov	r3, r0
200073ba:	73fb      	strb	r3, [r7, #15]

    if (status == HAL_OK)
200073bc:	7bfb      	ldrb	r3, [r7, #15]
200073be:	2b00      	cmp	r3, #0
200073c0:	d10e      	bne.n	200073e0 <HAL_QSPI_Abort+0xb2>
    {
      __HAL_QSPI_CLEAR_FLAG(hqspi, QSPI_FLAG_TC);
200073c2:	687b      	ldr	r3, [r7, #4]
200073c4:	681b      	ldr	r3, [r3, #0]
200073c6:	2202      	movs	r2, #2
200073c8:	60da      	str	r2, [r3, #12]

      /* Wait until BUSY flag is reset */
      status = QSPI_WaitFlagStateUntilTimeout(hqspi, QSPI_FLAG_BUSY, RESET, tickstart, hqspi->Timeout);
200073ca:	687b      	ldr	r3, [r7, #4]
200073cc:	6c9b      	ldr	r3, [r3, #72]	; 0x48
200073ce:	9300      	str	r3, [sp, #0]
200073d0:	68bb      	ldr	r3, [r7, #8]
200073d2:	2200      	movs	r2, #0
200073d4:	2120      	movs	r1, #32
200073d6:	6878      	ldr	r0, [r7, #4]
200073d8:	f000 f99d 	bl	20007716 <QSPI_WaitFlagStateUntilTimeout>
200073dc:	4603      	mov	r3, r0
200073de:	73fb      	strb	r3, [r7, #15]
    }

    if (status == HAL_OK)
200073e0:	7bfb      	ldrb	r3, [r7, #15]
200073e2:	2b00      	cmp	r3, #0
200073e4:	d10b      	bne.n	200073fe <HAL_QSPI_Abort+0xd0>
    {
      /* Reset functional mode configuration to indirect write mode by default */
      CLEAR_BIT(hqspi->Instance->CCR, QUADSPI_CCR_FMODE);
200073e6:	687b      	ldr	r3, [r7, #4]
200073e8:	681b      	ldr	r3, [r3, #0]
200073ea:	695a      	ldr	r2, [r3, #20]
200073ec:	687b      	ldr	r3, [r7, #4]
200073ee:	681b      	ldr	r3, [r3, #0]
200073f0:	f022 6240 	bic.w	r2, r2, #201326592	; 0xc000000
200073f4:	615a      	str	r2, [r3, #20]

      /* Update state */
      hqspi->State = HAL_QSPI_STATE_READY;
200073f6:	687b      	ldr	r3, [r7, #4]
200073f8:	2201      	movs	r2, #1
200073fa:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    }
  }

  return status;
200073fe:	7bfb      	ldrb	r3, [r7, #15]
}
20007400:	4618      	mov	r0, r3
20007402:	3710      	adds	r7, #16
20007404:	46bd      	mov	sp, r7
20007406:	bd80      	pop	{r7, pc}

20007408 <HAL_QSPI_Abort_IT>:
* @brief  Abort the current transmission (non-blocking function)
* @param  hqspi : QSPI handle
* @retval HAL status
*/
HAL_StatusTypeDef HAL_QSPI_Abort_IT(QSPI_HandleTypeDef *hqspi)
{
20007408:	b580      	push	{r7, lr}
2000740a:	b084      	sub	sp, #16
2000740c:	af00      	add	r7, sp, #0
2000740e:	6078      	str	r0, [r7, #4]
  HAL_StatusTypeDef status = HAL_OK;
20007410:	2300      	movs	r3, #0
20007412:	73fb      	strb	r3, [r7, #15]

  /* Check if the state is in one of the busy states */
  if (((uint32_t)hqspi->State & 0x2U) != 0U)
20007414:	687b      	ldr	r3, [r7, #4]
20007416:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2000741a:	b2db      	uxtb	r3, r3
2000741c:	f003 0302 	and.w	r3, r3, #2
20007420:	2b00      	cmp	r3, #0
20007422:	d046      	beq.n	200074b2 <HAL_QSPI_Abort_IT+0xaa>
  {
    /* Process unlocked */
    __HAL_UNLOCK(hqspi);
20007424:	687b      	ldr	r3, [r7, #4]
20007426:	2200      	movs	r2, #0
20007428:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    /* Update QSPI state */
    hqspi->State = HAL_QSPI_STATE_ABORT;
2000742c:	687b      	ldr	r3, [r7, #4]
2000742e:	2208      	movs	r2, #8
20007430:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41

    /* Disable all interrupts */
    __HAL_QSPI_DISABLE_IT(hqspi, (QSPI_IT_TO | QSPI_IT_SM | QSPI_IT_FT | QSPI_IT_TC | QSPI_IT_TE));
20007434:	687b      	ldr	r3, [r7, #4]
20007436:	681b      	ldr	r3, [r3, #0]
20007438:	681a      	ldr	r2, [r3, #0]
2000743a:	687b      	ldr	r3, [r7, #4]
2000743c:	681b      	ldr	r3, [r3, #0]
2000743e:	f422 12f8 	bic.w	r2, r2, #2031616	; 0x1f0000
20007442:	601a      	str	r2, [r3, #0]

    if ((hqspi->Instance->CR & QUADSPI_CR_DMAEN) != 0U)
20007444:	687b      	ldr	r3, [r7, #4]
20007446:	681b      	ldr	r3, [r3, #0]
20007448:	681b      	ldr	r3, [r3, #0]
2000744a:	f003 0304 	and.w	r3, r3, #4
2000744e:	2b00      	cmp	r3, #0
20007450:	d01b      	beq.n	2000748a <HAL_QSPI_Abort_IT+0x82>
    {
      /* Disable the DMA transfer by clearing the DMAEN bit in the QSPI CR register */
      CLEAR_BIT(hqspi->Instance->CR, QUADSPI_CR_DMAEN);
20007452:	687b      	ldr	r3, [r7, #4]
20007454:	681b      	ldr	r3, [r3, #0]
20007456:	681a      	ldr	r2, [r3, #0]
20007458:	687b      	ldr	r3, [r7, #4]
2000745a:	681b      	ldr	r3, [r3, #0]
2000745c:	f022 0204 	bic.w	r2, r2, #4
20007460:	601a      	str	r2, [r3, #0]

      /* Abort DMA channel */
      hqspi->hdma->XferAbortCallback = QSPI_DMAAbortCplt;
20007462:	687b      	ldr	r3, [r7, #4]
20007464:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
20007466:	4a15      	ldr	r2, [pc, #84]	; (200074bc <HAL_QSPI_Abort_IT+0xb4>)
20007468:	639a      	str	r2, [r3, #56]	; 0x38
      if (HAL_DMA_Abort_IT(hqspi->hdma) != HAL_OK)
2000746a:	687b      	ldr	r3, [r7, #4]
2000746c:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2000746e:	4618      	mov	r0, r3
20007470:	f7fb f99b 	bl	200027aa <HAL_DMA_Abort_IT>
20007474:	4603      	mov	r3, r0
20007476:	2b00      	cmp	r3, #0
20007478:	d01b      	beq.n	200074b2 <HAL_QSPI_Abort_IT+0xaa>
      {
        /* Change state of QSPI */
        hqspi->State = HAL_QSPI_STATE_READY;
2000747a:	687b      	ldr	r3, [r7, #4]
2000747c:	2201      	movs	r2, #1
2000747e:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
        
        /* Abort Complete callback */
#if (USE_HAL_QSPI_REGISTER_CALLBACKS == 1)
        hqspi->AbortCpltCallback(hqspi);
#else
        HAL_QSPI_AbortCpltCallback(hqspi);
20007482:	6878      	ldr	r0, [r7, #4]
20007484:	f7ff fedf 	bl	20007246 <HAL_QSPI_AbortCpltCallback>
20007488:	e013      	b.n	200074b2 <HAL_QSPI_Abort_IT+0xaa>
      }
    }
    else
    {
      /* Clear interrupt */
      __HAL_QSPI_CLEAR_FLAG(hqspi, QSPI_FLAG_TC);
2000748a:	687b      	ldr	r3, [r7, #4]
2000748c:	681b      	ldr	r3, [r3, #0]
2000748e:	2202      	movs	r2, #2
20007490:	60da      	str	r2, [r3, #12]

      /* Enable the QSPI Transfer Complete Interrupt */
      __HAL_QSPI_ENABLE_IT(hqspi, QSPI_IT_TC);
20007492:	687b      	ldr	r3, [r7, #4]
20007494:	681b      	ldr	r3, [r3, #0]
20007496:	681a      	ldr	r2, [r3, #0]
20007498:	687b      	ldr	r3, [r7, #4]
2000749a:	681b      	ldr	r3, [r3, #0]
2000749c:	f442 3200 	orr.w	r2, r2, #131072	; 0x20000
200074a0:	601a      	str	r2, [r3, #0]

      /* Configure QSPI: CR register with Abort request */
      SET_BIT(hqspi->Instance->CR, QUADSPI_CR_ABORT);
200074a2:	687b      	ldr	r3, [r7, #4]
200074a4:	681b      	ldr	r3, [r3, #0]
200074a6:	681a      	ldr	r2, [r3, #0]
200074a8:	687b      	ldr	r3, [r7, #4]
200074aa:	681b      	ldr	r3, [r3, #0]
200074ac:	f042 0202 	orr.w	r2, r2, #2
200074b0:	601a      	str	r2, [r3, #0]
    }
  }
  return status;
200074b2:	7bfb      	ldrb	r3, [r7, #15]
}
200074b4:	4618      	mov	r0, r3
200074b6:	3710      	adds	r7, #16
200074b8:	46bd      	mov	sp, r7
200074ba:	bd80      	pop	{r7, pc}
200074bc:	200076b1 	.word	0x200076b1

200074c0 <HAL_QSPI_SetTimeout>:
  * @param  hqspi : QSPI handle.
  * @param  Timeout : Timeout for the QSPI memory access.
  * @retval None
  */
void HAL_QSPI_SetTimeout(QSPI_HandleTypeDef *hqspi, uint32_t Timeout)
{
200074c0:	b480      	push	{r7}
200074c2:	b083      	sub	sp, #12
200074c4:	af00      	add	r7, sp, #0
200074c6:	6078      	str	r0, [r7, #4]
200074c8:	6039      	str	r1, [r7, #0]
  hqspi->Timeout = Timeout;
200074ca:	687b      	ldr	r3, [r7, #4]
200074cc:	683a      	ldr	r2, [r7, #0]
200074ce:	649a      	str	r2, [r3, #72]	; 0x48
}
200074d0:	bf00      	nop
200074d2:	370c      	adds	r7, #12
200074d4:	46bd      	mov	sp, r7
200074d6:	f85d 7b04 	ldr.w	r7, [sp], #4
200074da:	4770      	bx	lr

200074dc <HAL_QSPI_SetFifoThreshold>:
  * @param  hqspi : QSPI handle.
  * @param  Threshold : Threshold of the Fifo (value between 1 and 16).
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_QSPI_SetFifoThreshold(QSPI_HandleTypeDef *hqspi, uint32_t Threshold)
{
200074dc:	b480      	push	{r7}
200074de:	b085      	sub	sp, #20
200074e0:	af00      	add	r7, sp, #0
200074e2:	6078      	str	r0, [r7, #4]
200074e4:	6039      	str	r1, [r7, #0]
  HAL_StatusTypeDef status = HAL_OK;
200074e6:	2300      	movs	r3, #0
200074e8:	73fb      	strb	r3, [r7, #15]

  /* Process locked */
  __HAL_LOCK(hqspi);
200074ea:	687b      	ldr	r3, [r7, #4]
200074ec:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
200074f0:	b2db      	uxtb	r3, r3
200074f2:	2b01      	cmp	r3, #1
200074f4:	d101      	bne.n	200074fa <HAL_QSPI_SetFifoThreshold+0x1e>
200074f6:	2302      	movs	r3, #2
200074f8:	e021      	b.n	2000753e <HAL_QSPI_SetFifoThreshold+0x62>
200074fa:	687b      	ldr	r3, [r7, #4]
200074fc:	2201      	movs	r2, #1
200074fe:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

  if(hqspi->State == HAL_QSPI_STATE_READY)
20007502:	687b      	ldr	r3, [r7, #4]
20007504:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
20007508:	b2db      	uxtb	r3, r3
2000750a:	2b01      	cmp	r3, #1
2000750c:	d110      	bne.n	20007530 <HAL_QSPI_SetFifoThreshold+0x54>
  {
    /* Synchronize init structure with new FIFO threshold value */
    hqspi->Init.FifoThreshold = Threshold;
2000750e:	687b      	ldr	r3, [r7, #4]
20007510:	683a      	ldr	r2, [r7, #0]
20007512:	609a      	str	r2, [r3, #8]

    /* Configure QSPI FIFO Threshold */
    MODIFY_REG(hqspi->Instance->CR, QUADSPI_CR_FTHRES,
20007514:	687b      	ldr	r3, [r7, #4]
20007516:	681b      	ldr	r3, [r3, #0]
20007518:	681b      	ldr	r3, [r3, #0]
2000751a:	f423 6170 	bic.w	r1, r3, #3840	; 0xf00
2000751e:	687b      	ldr	r3, [r7, #4]
20007520:	689b      	ldr	r3, [r3, #8]
20007522:	3b01      	subs	r3, #1
20007524:	021a      	lsls	r2, r3, #8
20007526:	687b      	ldr	r3, [r7, #4]
20007528:	681b      	ldr	r3, [r3, #0]
2000752a:	430a      	orrs	r2, r1
2000752c:	601a      	str	r2, [r3, #0]
2000752e:	e001      	b.n	20007534 <HAL_QSPI_SetFifoThreshold+0x58>
               ((hqspi->Init.FifoThreshold - 1U) << QUADSPI_CR_FTHRES_Pos));
  }
  else
  {
    status = HAL_BUSY;
20007530:	2302      	movs	r3, #2
20007532:	73fb      	strb	r3, [r7, #15]
  }

  /* Process unlocked */
  __HAL_UNLOCK(hqspi);
20007534:	687b      	ldr	r3, [r7, #4]
20007536:	2200      	movs	r2, #0
20007538:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

  /* Return function status */
  return status;
2000753c:	7bfb      	ldrb	r3, [r7, #15]
}
2000753e:	4618      	mov	r0, r3
20007540:	3714      	adds	r7, #20
20007542:	46bd      	mov	sp, r7
20007544:	f85d 7b04 	ldr.w	r7, [sp], #4
20007548:	4770      	bx	lr

2000754a <HAL_QSPI_GetFifoThreshold>:
/** @brief Get QSPI Fifo threshold.
  * @param  hqspi : QSPI handle.
  * @retval Fifo threshold (value between 1 and 16)
  */
uint32_t HAL_QSPI_GetFifoThreshold(QSPI_HandleTypeDef *hqspi)
{
2000754a:	b480      	push	{r7}
2000754c:	b083      	sub	sp, #12
2000754e:	af00      	add	r7, sp, #0
20007550:	6078      	str	r0, [r7, #4]
  return ((READ_BIT(hqspi->Instance->CR, QUADSPI_CR_FTHRES) >> QUADSPI_CR_FTHRES_Pos) + 1U);
20007552:	687b      	ldr	r3, [r7, #4]
20007554:	681b      	ldr	r3, [r3, #0]
20007556:	681b      	ldr	r3, [r3, #0]
20007558:	0a1b      	lsrs	r3, r3, #8
2000755a:	f003 030f 	and.w	r3, r3, #15
2000755e:	3301      	adds	r3, #1
}
20007560:	4618      	mov	r0, r3
20007562:	370c      	adds	r7, #12
20007564:	46bd      	mov	sp, r7
20007566:	f85d 7b04 	ldr.w	r7, [sp], #4
2000756a:	4770      	bx	lr

2000756c <HAL_QSPI_SetFlashID>:
  *                   This parameter can be a value of @ref QSPI_Flash_Select.
  * @note   The FlashID is ignored when dual flash mode is enabled.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_QSPI_SetFlashID(QSPI_HandleTypeDef *hqspi, uint32_t FlashID)
{
2000756c:	b480      	push	{r7}
2000756e:	b085      	sub	sp, #20
20007570:	af00      	add	r7, sp, #0
20007572:	6078      	str	r0, [r7, #4]
20007574:	6039      	str	r1, [r7, #0]
  HAL_StatusTypeDef status = HAL_OK;
20007576:	2300      	movs	r3, #0
20007578:	73fb      	strb	r3, [r7, #15]

  /* Check the parameter */
  assert_param(IS_QSPI_FLASH_ID(FlashID));

  /* Process locked */
  __HAL_LOCK(hqspi);
2000757a:	687b      	ldr	r3, [r7, #4]
2000757c:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
20007580:	b2db      	uxtb	r3, r3
20007582:	2b01      	cmp	r3, #1
20007584:	d101      	bne.n	2000758a <HAL_QSPI_SetFlashID+0x1e>
20007586:	2302      	movs	r3, #2
20007588:	e01e      	b.n	200075c8 <HAL_QSPI_SetFlashID+0x5c>
2000758a:	687b      	ldr	r3, [r7, #4]
2000758c:	2201      	movs	r2, #1
2000758e:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

  if(hqspi->State == HAL_QSPI_STATE_READY)
20007592:	687b      	ldr	r3, [r7, #4]
20007594:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
20007598:	b2db      	uxtb	r3, r3
2000759a:	2b01      	cmp	r3, #1
2000759c:	d10d      	bne.n	200075ba <HAL_QSPI_SetFlashID+0x4e>
  {
    /* Synchronize init structure with new FlashID value */
    hqspi->Init.FlashID = FlashID;
2000759e:	687b      	ldr	r3, [r7, #4]
200075a0:	683a      	ldr	r2, [r7, #0]
200075a2:	61da      	str	r2, [r3, #28]

    /* Configure QSPI FlashID */
    MODIFY_REG(hqspi->Instance->CR, QUADSPI_CR_FSEL, FlashID);
200075a4:	687b      	ldr	r3, [r7, #4]
200075a6:	681b      	ldr	r3, [r3, #0]
200075a8:	681b      	ldr	r3, [r3, #0]
200075aa:	f023 0180 	bic.w	r1, r3, #128	; 0x80
200075ae:	687b      	ldr	r3, [r7, #4]
200075b0:	681b      	ldr	r3, [r3, #0]
200075b2:	683a      	ldr	r2, [r7, #0]
200075b4:	430a      	orrs	r2, r1
200075b6:	601a      	str	r2, [r3, #0]
200075b8:	e001      	b.n	200075be <HAL_QSPI_SetFlashID+0x52>
  }
  else
  {
    status = HAL_BUSY;
200075ba:	2302      	movs	r3, #2
200075bc:	73fb      	strb	r3, [r7, #15]
  }

  /* Process unlocked */
  __HAL_UNLOCK(hqspi);
200075be:	687b      	ldr	r3, [r7, #4]
200075c0:	2200      	movs	r2, #0
200075c2:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

  /* Return function status */
  return status;
200075c6:	7bfb      	ldrb	r3, [r7, #15]
}
200075c8:	4618      	mov	r0, r3
200075ca:	3714      	adds	r7, #20
200075cc:	46bd      	mov	sp, r7
200075ce:	f85d 7b04 	ldr.w	r7, [sp], #4
200075d2:	4770      	bx	lr

200075d4 <QSPI_DMARxCplt>:
  * @brief  DMA QSPI receive process complete callback.
  * @param  hdma : DMA handle
  * @retval None
  */
static void QSPI_DMARxCplt(DMA_HandleTypeDef *hdma)
{
200075d4:	b480      	push	{r7}
200075d6:	b085      	sub	sp, #20
200075d8:	af00      	add	r7, sp, #0
200075da:	6078      	str	r0, [r7, #4]
  QSPI_HandleTypeDef* hqspi = (QSPI_HandleTypeDef*)(hdma->Parent);
200075dc:	687b      	ldr	r3, [r7, #4]
200075de:	6a9b      	ldr	r3, [r3, #40]	; 0x28
200075e0:	60fb      	str	r3, [r7, #12]
  hqspi->RxXferCount = 0U;
200075e2:	68fb      	ldr	r3, [r7, #12]
200075e4:	2200      	movs	r2, #0
200075e6:	639a      	str	r2, [r3, #56]	; 0x38

  /* Enable the QSPI transfer complete Interrupt */
  __HAL_QSPI_ENABLE_IT(hqspi, QSPI_IT_TC);
200075e8:	68fb      	ldr	r3, [r7, #12]
200075ea:	681b      	ldr	r3, [r3, #0]
200075ec:	681a      	ldr	r2, [r3, #0]
200075ee:	68fb      	ldr	r3, [r7, #12]
200075f0:	681b      	ldr	r3, [r3, #0]
200075f2:	f442 3200 	orr.w	r2, r2, #131072	; 0x20000
200075f6:	601a      	str	r2, [r3, #0]
}
200075f8:	bf00      	nop
200075fa:	3714      	adds	r7, #20
200075fc:	46bd      	mov	sp, r7
200075fe:	f85d 7b04 	ldr.w	r7, [sp], #4
20007602:	4770      	bx	lr

20007604 <QSPI_DMATxCplt>:
  * @brief  DMA QSPI transmit process complete callback.
  * @param  hdma : DMA handle
  * @retval None
  */
static void QSPI_DMATxCplt(DMA_HandleTypeDef *hdma)
{
20007604:	b480      	push	{r7}
20007606:	b085      	sub	sp, #20
20007608:	af00      	add	r7, sp, #0
2000760a:	6078      	str	r0, [r7, #4]
  QSPI_HandleTypeDef* hqspi = (QSPI_HandleTypeDef*)(hdma->Parent);
2000760c:	687b      	ldr	r3, [r7, #4]
2000760e:	6a9b      	ldr	r3, [r3, #40]	; 0x28
20007610:	60fb      	str	r3, [r7, #12]
  hqspi->TxXferCount = 0U;
20007612:	68fb      	ldr	r3, [r7, #12]
20007614:	2200      	movs	r2, #0
20007616:	62da      	str	r2, [r3, #44]	; 0x2c

  /* Enable the QSPI transfer complete Interrupt */
  __HAL_QSPI_ENABLE_IT(hqspi, QSPI_IT_TC);
20007618:	68fb      	ldr	r3, [r7, #12]
2000761a:	681b      	ldr	r3, [r3, #0]
2000761c:	681a      	ldr	r2, [r3, #0]
2000761e:	68fb      	ldr	r3, [r7, #12]
20007620:	681b      	ldr	r3, [r3, #0]
20007622:	f442 3200 	orr.w	r2, r2, #131072	; 0x20000
20007626:	601a      	str	r2, [r3, #0]
}
20007628:	bf00      	nop
2000762a:	3714      	adds	r7, #20
2000762c:	46bd      	mov	sp, r7
2000762e:	f85d 7b04 	ldr.w	r7, [sp], #4
20007632:	4770      	bx	lr

20007634 <QSPI_DMARxHalfCplt>:
  * @brief  DMA QSPI receive process half complete callback.
  * @param  hdma : DMA handle
  * @retval None
  */
static void QSPI_DMARxHalfCplt(DMA_HandleTypeDef *hdma)
{
20007634:	b580      	push	{r7, lr}
20007636:	b084      	sub	sp, #16
20007638:	af00      	add	r7, sp, #0
2000763a:	6078      	str	r0, [r7, #4]
  QSPI_HandleTypeDef* hqspi = (QSPI_HandleTypeDef*)(hdma->Parent);
2000763c:	687b      	ldr	r3, [r7, #4]
2000763e:	6a9b      	ldr	r3, [r3, #40]	; 0x28
20007640:	60fb      	str	r3, [r7, #12]

#if (USE_HAL_QSPI_REGISTER_CALLBACKS == 1)
  hqspi->RxHalfCpltCallback(hqspi);
#else
  HAL_QSPI_RxHalfCpltCallback(hqspi);
20007642:	68f8      	ldr	r0, [r7, #12]
20007644:	f7ff fe27 	bl	20007296 <HAL_QSPI_RxHalfCpltCallback>
#endif
}
20007648:	bf00      	nop
2000764a:	3710      	adds	r7, #16
2000764c:	46bd      	mov	sp, r7
2000764e:	bd80      	pop	{r7, pc}

20007650 <QSPI_DMATxHalfCplt>:
  * @brief  DMA QSPI transmit process half complete callback.
  * @param  hdma : DMA handle
  * @retval None
  */
static void QSPI_DMATxHalfCplt(DMA_HandleTypeDef *hdma)
{
20007650:	b580      	push	{r7, lr}
20007652:	b084      	sub	sp, #16
20007654:	af00      	add	r7, sp, #0
20007656:	6078      	str	r0, [r7, #4]
  QSPI_HandleTypeDef* hqspi = (QSPI_HandleTypeDef*)(hdma->Parent);
20007658:	687b      	ldr	r3, [r7, #4]
2000765a:	6a9b      	ldr	r3, [r3, #40]	; 0x28
2000765c:	60fb      	str	r3, [r7, #12]

#if (USE_HAL_QSPI_REGISTER_CALLBACKS == 1)
  hqspi->TxHalfCpltCallback(hqspi);
#else
  HAL_QSPI_TxHalfCpltCallback(hqspi);
2000765e:	68f8      	ldr	r0, [r7, #12]
20007660:	f7ff fe23 	bl	200072aa <HAL_QSPI_TxHalfCpltCallback>
#endif
}
20007664:	bf00      	nop
20007666:	3710      	adds	r7, #16
20007668:	46bd      	mov	sp, r7
2000766a:	bd80      	pop	{r7, pc}

2000766c <QSPI_DMAError>:
  * @brief  DMA QSPI communication error callback.
  * @param  hdma : DMA handle
  * @retval None
  */
static void QSPI_DMAError(DMA_HandleTypeDef *hdma)
{
2000766c:	b580      	push	{r7, lr}
2000766e:	b084      	sub	sp, #16
20007670:	af00      	add	r7, sp, #0
20007672:	6078      	str	r0, [r7, #4]
  QSPI_HandleTypeDef* hqspi = ( QSPI_HandleTypeDef* )(hdma->Parent);
20007674:	687b      	ldr	r3, [r7, #4]
20007676:	6a9b      	ldr	r3, [r3, #40]	; 0x28
20007678:	60fb      	str	r3, [r7, #12]

  hqspi->RxXferCount = 0U;
2000767a:	68fb      	ldr	r3, [r7, #12]
2000767c:	2200      	movs	r2, #0
2000767e:	639a      	str	r2, [r3, #56]	; 0x38
  hqspi->TxXferCount = 0U;
20007680:	68fb      	ldr	r3, [r7, #12]
20007682:	2200      	movs	r2, #0
20007684:	62da      	str	r2, [r3, #44]	; 0x2c
  hqspi->ErrorCode   |= HAL_QSPI_ERROR_DMA;
20007686:	68fb      	ldr	r3, [r7, #12]
20007688:	6c5b      	ldr	r3, [r3, #68]	; 0x44
2000768a:	f043 0204 	orr.w	r2, r3, #4
2000768e:	68fb      	ldr	r3, [r7, #12]
20007690:	645a      	str	r2, [r3, #68]	; 0x44

  /* Disable the DMA transfer by clearing the DMAEN bit in the QSPI CR register */
  CLEAR_BIT(hqspi->Instance->CR, QUADSPI_CR_DMAEN);
20007692:	68fb      	ldr	r3, [r7, #12]
20007694:	681b      	ldr	r3, [r3, #0]
20007696:	681a      	ldr	r2, [r3, #0]
20007698:	68fb      	ldr	r3, [r7, #12]
2000769a:	681b      	ldr	r3, [r3, #0]
2000769c:	f022 0204 	bic.w	r2, r2, #4
200076a0:	601a      	str	r2, [r3, #0]

  /* Abort the QSPI */
  (void)HAL_QSPI_Abort_IT(hqspi);
200076a2:	68f8      	ldr	r0, [r7, #12]
200076a4:	f7ff feb0 	bl	20007408 <HAL_QSPI_Abort_IT>

}
200076a8:	bf00      	nop
200076aa:	3710      	adds	r7, #16
200076ac:	46bd      	mov	sp, r7
200076ae:	bd80      	pop	{r7, pc}

200076b0 <QSPI_DMAAbortCplt>:
  * @brief  DMA QSPI abort complete callback.
  * @param  hdma : DMA handle
  * @retval None
  */
static void QSPI_DMAAbortCplt(DMA_HandleTypeDef *hdma)
{
200076b0:	b580      	push	{r7, lr}
200076b2:	b084      	sub	sp, #16
200076b4:	af00      	add	r7, sp, #0
200076b6:	6078      	str	r0, [r7, #4]
  QSPI_HandleTypeDef* hqspi = ( QSPI_HandleTypeDef* )(hdma->Parent);
200076b8:	687b      	ldr	r3, [r7, #4]
200076ba:	6a9b      	ldr	r3, [r3, #40]	; 0x28
200076bc:	60fb      	str	r3, [r7, #12]

  hqspi->RxXferCount = 0U;
200076be:	68fb      	ldr	r3, [r7, #12]
200076c0:	2200      	movs	r2, #0
200076c2:	639a      	str	r2, [r3, #56]	; 0x38
  hqspi->TxXferCount = 0U;
200076c4:	68fb      	ldr	r3, [r7, #12]
200076c6:	2200      	movs	r2, #0
200076c8:	62da      	str	r2, [r3, #44]	; 0x2c

  if(hqspi->State == HAL_QSPI_STATE_ABORT)
200076ca:	68fb      	ldr	r3, [r7, #12]
200076cc:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
200076d0:	b2db      	uxtb	r3, r3
200076d2:	2b08      	cmp	r3, #8
200076d4:	d114      	bne.n	20007700 <QSPI_DMAAbortCplt+0x50>
  {
    /* DMA Abort called by QSPI abort */
    /* Clear interrupt */
    __HAL_QSPI_CLEAR_FLAG(hqspi, QSPI_FLAG_TC);
200076d6:	68fb      	ldr	r3, [r7, #12]
200076d8:	681b      	ldr	r3, [r3, #0]
200076da:	2202      	movs	r2, #2
200076dc:	60da      	str	r2, [r3, #12]

    /* Enable the QSPI Transfer Complete Interrupt */
    __HAL_QSPI_ENABLE_IT(hqspi, QSPI_IT_TC);
200076de:	68fb      	ldr	r3, [r7, #12]
200076e0:	681b      	ldr	r3, [r3, #0]
200076e2:	681a      	ldr	r2, [r3, #0]
200076e4:	68fb      	ldr	r3, [r7, #12]
200076e6:	681b      	ldr	r3, [r3, #0]
200076e8:	f442 3200 	orr.w	r2, r2, #131072	; 0x20000
200076ec:	601a      	str	r2, [r3, #0]

    /* Configure QSPI: CR register with Abort request */
    SET_BIT(hqspi->Instance->CR, QUADSPI_CR_ABORT);
200076ee:	68fb      	ldr	r3, [r7, #12]
200076f0:	681b      	ldr	r3, [r3, #0]
200076f2:	681a      	ldr	r2, [r3, #0]
200076f4:	68fb      	ldr	r3, [r7, #12]
200076f6:	681b      	ldr	r3, [r3, #0]
200076f8:	f042 0202 	orr.w	r2, r2, #2
200076fc:	601a      	str	r2, [r3, #0]
    hqspi->ErrorCallback(hqspi);
#else
    HAL_QSPI_ErrorCallback(hqspi);
#endif
  }
}
200076fe:	e006      	b.n	2000770e <QSPI_DMAAbortCplt+0x5e>
    hqspi->State = HAL_QSPI_STATE_READY;
20007700:	68fb      	ldr	r3, [r7, #12]
20007702:	2201      	movs	r2, #1
20007704:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    HAL_QSPI_ErrorCallback(hqspi);
20007708:	68f8      	ldr	r0, [r7, #12]
2000770a:	f7ff fd92 	bl	20007232 <HAL_QSPI_ErrorCallback>
}
2000770e:	bf00      	nop
20007710:	3710      	adds	r7, #16
20007712:	46bd      	mov	sp, r7
20007714:	bd80      	pop	{r7, pc}

20007716 <QSPI_WaitFlagStateUntilTimeout>:
  * @param  Timeout : Duration of the timeout
  * @retval HAL status
  */
static HAL_StatusTypeDef QSPI_WaitFlagStateUntilTimeout(QSPI_HandleTypeDef *hqspi, uint32_t Flag,
                                                        FlagStatus State, uint32_t Tickstart, uint32_t Timeout)
{
20007716:	b580      	push	{r7, lr}
20007718:	b084      	sub	sp, #16
2000771a:	af00      	add	r7, sp, #0
2000771c:	60f8      	str	r0, [r7, #12]
2000771e:	60b9      	str	r1, [r7, #8]
20007720:	603b      	str	r3, [r7, #0]
20007722:	4613      	mov	r3, r2
20007724:	71fb      	strb	r3, [r7, #7]
  /* Wait until flag is in expected state */
  while((__HAL_QSPI_GET_FLAG(hqspi, Flag)) != State)
20007726:	e01a      	b.n	2000775e <QSPI_WaitFlagStateUntilTimeout+0x48>
  {
    /* Check for the Timeout */
    if (Timeout != HAL_MAX_DELAY)
20007728:	69bb      	ldr	r3, [r7, #24]
2000772a:	f1b3 3fff 	cmp.w	r3, #4294967295
2000772e:	d016      	beq.n	2000775e <QSPI_WaitFlagStateUntilTimeout+0x48>
    {
      if(((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
20007730:	f7fa f8b4 	bl	2000189c <HAL_GetTick>
20007734:	4602      	mov	r2, r0
20007736:	683b      	ldr	r3, [r7, #0]
20007738:	1ad3      	subs	r3, r2, r3
2000773a:	69ba      	ldr	r2, [r7, #24]
2000773c:	429a      	cmp	r2, r3
2000773e:	d302      	bcc.n	20007746 <QSPI_WaitFlagStateUntilTimeout+0x30>
20007740:	69bb      	ldr	r3, [r7, #24]
20007742:	2b00      	cmp	r3, #0
20007744:	d10b      	bne.n	2000775e <QSPI_WaitFlagStateUntilTimeout+0x48>
      {
        hqspi->State     = HAL_QSPI_STATE_ERROR;
20007746:	68fb      	ldr	r3, [r7, #12]
20007748:	2204      	movs	r2, #4
2000774a:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
        hqspi->ErrorCode |= HAL_QSPI_ERROR_TIMEOUT;
2000774e:	68fb      	ldr	r3, [r7, #12]
20007750:	6c5b      	ldr	r3, [r3, #68]	; 0x44
20007752:	f043 0201 	orr.w	r2, r3, #1
20007756:	68fb      	ldr	r3, [r7, #12]
20007758:	645a      	str	r2, [r3, #68]	; 0x44

        return HAL_ERROR;
2000775a:	2301      	movs	r3, #1
2000775c:	e00e      	b.n	2000777c <QSPI_WaitFlagStateUntilTimeout+0x66>
  while((__HAL_QSPI_GET_FLAG(hqspi, Flag)) != State)
2000775e:	68fb      	ldr	r3, [r7, #12]
20007760:	681b      	ldr	r3, [r3, #0]
20007762:	689a      	ldr	r2, [r3, #8]
20007764:	68bb      	ldr	r3, [r7, #8]
20007766:	4013      	ands	r3, r2
20007768:	2b00      	cmp	r3, #0
2000776a:	bf14      	ite	ne
2000776c:	2301      	movne	r3, #1
2000776e:	2300      	moveq	r3, #0
20007770:	b2db      	uxtb	r3, r3
20007772:	461a      	mov	r2, r3
20007774:	79fb      	ldrb	r3, [r7, #7]
20007776:	429a      	cmp	r2, r3
20007778:	d1d6      	bne.n	20007728 <QSPI_WaitFlagStateUntilTimeout+0x12>
      }
    }
  }
  return HAL_OK;
2000777a:	2300      	movs	r3, #0
}
2000777c:	4618      	mov	r0, r3
2000777e:	3710      	adds	r7, #16
20007780:	46bd      	mov	sp, r7
20007782:	bd80      	pop	{r7, pc}

20007784 <QSPI_Config>:
  *            @arg QSPI_FUNCTIONAL_MODE_AUTO_POLLING: Automatic polling mode
  *            @arg QSPI_FUNCTIONAL_MODE_MEMORY_MAPPED: Memory-mapped mode
  * @retval None
  */
static void QSPI_Config(QSPI_HandleTypeDef *hqspi, QSPI_CommandTypeDef *cmd, uint32_t FunctionalMode)
{
20007784:	b480      	push	{r7}
20007786:	b085      	sub	sp, #20
20007788:	af00      	add	r7, sp, #0
2000778a:	60f8      	str	r0, [r7, #12]
2000778c:	60b9      	str	r1, [r7, #8]
2000778e:	607a      	str	r2, [r7, #4]
  assert_param(IS_QSPI_FUNCTIONAL_MODE(FunctionalMode));

  if ((cmd->DataMode != QSPI_DATA_NONE) && (FunctionalMode != QSPI_FUNCTIONAL_MODE_MEMORY_MAPPED))
20007790:	68bb      	ldr	r3, [r7, #8]
20007792:	6a5b      	ldr	r3, [r3, #36]	; 0x24
20007794:	2b00      	cmp	r3, #0
20007796:	d009      	beq.n	200077ac <QSPI_Config+0x28>
20007798:	687b      	ldr	r3, [r7, #4]
2000779a:	f1b3 6f40 	cmp.w	r3, #201326592	; 0xc000000
2000779e:	d005      	beq.n	200077ac <QSPI_Config+0x28>
  {
    /* Configure QSPI: DLR register with the number of data to read or write */
    WRITE_REG(hqspi->Instance->DLR, (cmd->NbData - 1U));
200077a0:	68bb      	ldr	r3, [r7, #8]
200077a2:	6a9a      	ldr	r2, [r3, #40]	; 0x28
200077a4:	68fb      	ldr	r3, [r7, #12]
200077a6:	681b      	ldr	r3, [r3, #0]
200077a8:	3a01      	subs	r2, #1
200077aa:	611a      	str	r2, [r3, #16]
  }

  if (cmd->InstructionMode != QSPI_INSTRUCTION_NONE)
200077ac:	68bb      	ldr	r3, [r7, #8]
200077ae:	699b      	ldr	r3, [r3, #24]
200077b0:	2b00      	cmp	r3, #0
200077b2:	f000 80b9 	beq.w	20007928 <QSPI_Config+0x1a4>
  {
    if (cmd->AlternateByteMode != QSPI_ALTERNATE_BYTES_NONE)
200077b6:	68bb      	ldr	r3, [r7, #8]
200077b8:	6a1b      	ldr	r3, [r3, #32]
200077ba:	2b00      	cmp	r3, #0
200077bc:	d05f      	beq.n	2000787e <QSPI_Config+0xfa>
    {
      /* Configure QSPI: ABR register with alternate bytes value */
      WRITE_REG(hqspi->Instance->ABR, cmd->AlternateBytes);
200077be:	68fb      	ldr	r3, [r7, #12]
200077c0:	681b      	ldr	r3, [r3, #0]
200077c2:	68ba      	ldr	r2, [r7, #8]
200077c4:	6892      	ldr	r2, [r2, #8]
200077c6:	61da      	str	r2, [r3, #28]

      if (cmd->AddressMode != QSPI_ADDRESS_NONE)
200077c8:	68bb      	ldr	r3, [r7, #8]
200077ca:	69db      	ldr	r3, [r3, #28]
200077cc:	2b00      	cmp	r3, #0
200077ce:	d031      	beq.n	20007834 <QSPI_Config+0xb0>
      {
        /*---- Command with instruction, address and alternate bytes ----*/
        /* Configure QSPI: CCR register with all communications parameters */
        WRITE_REG(hqspi->Instance->CCR, (cmd->DdrMode | cmd->DdrHoldHalfCycle | cmd->SIOOMode |
200077d0:	68bb      	ldr	r3, [r7, #8]
200077d2:	6ada      	ldr	r2, [r3, #44]	; 0x2c
200077d4:	68bb      	ldr	r3, [r7, #8]
200077d6:	6b1b      	ldr	r3, [r3, #48]	; 0x30
200077d8:	431a      	orrs	r2, r3
200077da:	68bb      	ldr	r3, [r7, #8]
200077dc:	6b5b      	ldr	r3, [r3, #52]	; 0x34
200077de:	431a      	orrs	r2, r3
200077e0:	68bb      	ldr	r3, [r7, #8]
200077e2:	6a5b      	ldr	r3, [r3, #36]	; 0x24
200077e4:	431a      	orrs	r2, r3
200077e6:	68bb      	ldr	r3, [r7, #8]
200077e8:	695b      	ldr	r3, [r3, #20]
200077ea:	049b      	lsls	r3, r3, #18
200077ec:	431a      	orrs	r2, r3
200077ee:	68bb      	ldr	r3, [r7, #8]
200077f0:	691b      	ldr	r3, [r3, #16]
200077f2:	431a      	orrs	r2, r3
200077f4:	68bb      	ldr	r3, [r7, #8]
200077f6:	6a1b      	ldr	r3, [r3, #32]
200077f8:	431a      	orrs	r2, r3
200077fa:	68bb      	ldr	r3, [r7, #8]
200077fc:	68db      	ldr	r3, [r3, #12]
200077fe:	431a      	orrs	r2, r3
20007800:	68bb      	ldr	r3, [r7, #8]
20007802:	69db      	ldr	r3, [r3, #28]
20007804:	431a      	orrs	r2, r3
20007806:	68bb      	ldr	r3, [r7, #8]
20007808:	699b      	ldr	r3, [r3, #24]
2000780a:	431a      	orrs	r2, r3
2000780c:	68bb      	ldr	r3, [r7, #8]
2000780e:	681b      	ldr	r3, [r3, #0]
20007810:	ea42 0103 	orr.w	r1, r2, r3
20007814:	68fb      	ldr	r3, [r7, #12]
20007816:	681b      	ldr	r3, [r3, #0]
20007818:	687a      	ldr	r2, [r7, #4]
2000781a:	430a      	orrs	r2, r1
2000781c:	615a      	str	r2, [r3, #20]
                                         cmd->DataMode | (cmd->DummyCycles << QUADSPI_CCR_DCYC_Pos) |
                                         cmd->AlternateBytesSize | cmd->AlternateByteMode |
                                         cmd->AddressSize | cmd->AddressMode | cmd->InstructionMode |
                                         cmd->Instruction | FunctionalMode));

        if (FunctionalMode != QSPI_FUNCTIONAL_MODE_MEMORY_MAPPED)
2000781e:	687b      	ldr	r3, [r7, #4]
20007820:	f1b3 6f40 	cmp.w	r3, #201326592	; 0xc000000
20007824:	f000 812e 	beq.w	20007a84 <QSPI_Config+0x300>
        {
          /* Configure QSPI: AR register with address value */
          WRITE_REG(hqspi->Instance->AR, cmd->Address);
20007828:	68fb      	ldr	r3, [r7, #12]
2000782a:	681b      	ldr	r3, [r3, #0]
2000782c:	68ba      	ldr	r2, [r7, #8]
2000782e:	6852      	ldr	r2, [r2, #4]
20007830:	619a      	str	r2, [r3, #24]
                                           cmd->InstructionMode | FunctionalMode));
        }
      }
    }
  }
}
20007832:	e127      	b.n	20007a84 <QSPI_Config+0x300>
        WRITE_REG(hqspi->Instance->CCR, (cmd->DdrMode | cmd->DdrHoldHalfCycle | cmd->SIOOMode |
20007834:	68bb      	ldr	r3, [r7, #8]
20007836:	6ada      	ldr	r2, [r3, #44]	; 0x2c
20007838:	68bb      	ldr	r3, [r7, #8]
2000783a:	6b1b      	ldr	r3, [r3, #48]	; 0x30
2000783c:	431a      	orrs	r2, r3
2000783e:	68bb      	ldr	r3, [r7, #8]
20007840:	6b5b      	ldr	r3, [r3, #52]	; 0x34
20007842:	431a      	orrs	r2, r3
20007844:	68bb      	ldr	r3, [r7, #8]
20007846:	6a5b      	ldr	r3, [r3, #36]	; 0x24
20007848:	431a      	orrs	r2, r3
2000784a:	68bb      	ldr	r3, [r7, #8]
2000784c:	695b      	ldr	r3, [r3, #20]
2000784e:	049b      	lsls	r3, r3, #18
20007850:	431a      	orrs	r2, r3
20007852:	68bb      	ldr	r3, [r7, #8]
20007854:	691b      	ldr	r3, [r3, #16]
20007856:	431a      	orrs	r2, r3
20007858:	68bb      	ldr	r3, [r7, #8]
2000785a:	6a1b      	ldr	r3, [r3, #32]
2000785c:	431a      	orrs	r2, r3
2000785e:	68bb      	ldr	r3, [r7, #8]
20007860:	69db      	ldr	r3, [r3, #28]
20007862:	431a      	orrs	r2, r3
20007864:	68bb      	ldr	r3, [r7, #8]
20007866:	699b      	ldr	r3, [r3, #24]
20007868:	431a      	orrs	r2, r3
2000786a:	68bb      	ldr	r3, [r7, #8]
2000786c:	681b      	ldr	r3, [r3, #0]
2000786e:	ea42 0103 	orr.w	r1, r2, r3
20007872:	68fb      	ldr	r3, [r7, #12]
20007874:	681b      	ldr	r3, [r3, #0]
20007876:	687a      	ldr	r2, [r7, #4]
20007878:	430a      	orrs	r2, r1
2000787a:	615a      	str	r2, [r3, #20]
}
2000787c:	e102      	b.n	20007a84 <QSPI_Config+0x300>
      if (cmd->AddressMode != QSPI_ADDRESS_NONE)
2000787e:	68bb      	ldr	r3, [r7, #8]
20007880:	69db      	ldr	r3, [r3, #28]
20007882:	2b00      	cmp	r3, #0
20007884:	d02e      	beq.n	200078e4 <QSPI_Config+0x160>
        WRITE_REG(hqspi->Instance->CCR, (cmd->DdrMode | cmd->DdrHoldHalfCycle | cmd->SIOOMode |
20007886:	68bb      	ldr	r3, [r7, #8]
20007888:	6ada      	ldr	r2, [r3, #44]	; 0x2c
2000788a:	68bb      	ldr	r3, [r7, #8]
2000788c:	6b1b      	ldr	r3, [r3, #48]	; 0x30
2000788e:	431a      	orrs	r2, r3
20007890:	68bb      	ldr	r3, [r7, #8]
20007892:	6b5b      	ldr	r3, [r3, #52]	; 0x34
20007894:	431a      	orrs	r2, r3
20007896:	68bb      	ldr	r3, [r7, #8]
20007898:	6a5b      	ldr	r3, [r3, #36]	; 0x24
2000789a:	431a      	orrs	r2, r3
2000789c:	68bb      	ldr	r3, [r7, #8]
2000789e:	695b      	ldr	r3, [r3, #20]
200078a0:	049b      	lsls	r3, r3, #18
200078a2:	431a      	orrs	r2, r3
200078a4:	68bb      	ldr	r3, [r7, #8]
200078a6:	6a1b      	ldr	r3, [r3, #32]
200078a8:	431a      	orrs	r2, r3
200078aa:	68bb      	ldr	r3, [r7, #8]
200078ac:	68db      	ldr	r3, [r3, #12]
200078ae:	431a      	orrs	r2, r3
200078b0:	68bb      	ldr	r3, [r7, #8]
200078b2:	69db      	ldr	r3, [r3, #28]
200078b4:	431a      	orrs	r2, r3
200078b6:	68bb      	ldr	r3, [r7, #8]
200078b8:	699b      	ldr	r3, [r3, #24]
200078ba:	431a      	orrs	r2, r3
200078bc:	68bb      	ldr	r3, [r7, #8]
200078be:	681b      	ldr	r3, [r3, #0]
200078c0:	ea42 0103 	orr.w	r1, r2, r3
200078c4:	68fb      	ldr	r3, [r7, #12]
200078c6:	681b      	ldr	r3, [r3, #0]
200078c8:	687a      	ldr	r2, [r7, #4]
200078ca:	430a      	orrs	r2, r1
200078cc:	615a      	str	r2, [r3, #20]
        if (FunctionalMode != QSPI_FUNCTIONAL_MODE_MEMORY_MAPPED)
200078ce:	687b      	ldr	r3, [r7, #4]
200078d0:	f1b3 6f40 	cmp.w	r3, #201326592	; 0xc000000
200078d4:	f000 80d6 	beq.w	20007a84 <QSPI_Config+0x300>
          WRITE_REG(hqspi->Instance->AR, cmd->Address);
200078d8:	68fb      	ldr	r3, [r7, #12]
200078da:	681b      	ldr	r3, [r3, #0]
200078dc:	68ba      	ldr	r2, [r7, #8]
200078de:	6852      	ldr	r2, [r2, #4]
200078e0:	619a      	str	r2, [r3, #24]
}
200078e2:	e0cf      	b.n	20007a84 <QSPI_Config+0x300>
        WRITE_REG(hqspi->Instance->CCR, (cmd->DdrMode | cmd->DdrHoldHalfCycle | cmd->SIOOMode |
200078e4:	68bb      	ldr	r3, [r7, #8]
200078e6:	6ada      	ldr	r2, [r3, #44]	; 0x2c
200078e8:	68bb      	ldr	r3, [r7, #8]
200078ea:	6b1b      	ldr	r3, [r3, #48]	; 0x30
200078ec:	431a      	orrs	r2, r3
200078ee:	68bb      	ldr	r3, [r7, #8]
200078f0:	6b5b      	ldr	r3, [r3, #52]	; 0x34
200078f2:	431a      	orrs	r2, r3
200078f4:	68bb      	ldr	r3, [r7, #8]
200078f6:	6a5b      	ldr	r3, [r3, #36]	; 0x24
200078f8:	431a      	orrs	r2, r3
200078fa:	68bb      	ldr	r3, [r7, #8]
200078fc:	695b      	ldr	r3, [r3, #20]
200078fe:	049b      	lsls	r3, r3, #18
20007900:	431a      	orrs	r2, r3
20007902:	68bb      	ldr	r3, [r7, #8]
20007904:	6a1b      	ldr	r3, [r3, #32]
20007906:	431a      	orrs	r2, r3
20007908:	68bb      	ldr	r3, [r7, #8]
2000790a:	69db      	ldr	r3, [r3, #28]
2000790c:	431a      	orrs	r2, r3
2000790e:	68bb      	ldr	r3, [r7, #8]
20007910:	699b      	ldr	r3, [r3, #24]
20007912:	431a      	orrs	r2, r3
20007914:	68bb      	ldr	r3, [r7, #8]
20007916:	681b      	ldr	r3, [r3, #0]
20007918:	ea42 0103 	orr.w	r1, r2, r3
2000791c:	68fb      	ldr	r3, [r7, #12]
2000791e:	681b      	ldr	r3, [r3, #0]
20007920:	687a      	ldr	r2, [r7, #4]
20007922:	430a      	orrs	r2, r1
20007924:	615a      	str	r2, [r3, #20]
}
20007926:	e0ad      	b.n	20007a84 <QSPI_Config+0x300>
    if (cmd->AlternateByteMode != QSPI_ALTERNATE_BYTES_NONE)
20007928:	68bb      	ldr	r3, [r7, #8]
2000792a:	6a1b      	ldr	r3, [r3, #32]
2000792c:	2b00      	cmp	r3, #0
2000792e:	d058      	beq.n	200079e2 <QSPI_Config+0x25e>
      WRITE_REG(hqspi->Instance->ABR, cmd->AlternateBytes);
20007930:	68fb      	ldr	r3, [r7, #12]
20007932:	681b      	ldr	r3, [r3, #0]
20007934:	68ba      	ldr	r2, [r7, #8]
20007936:	6892      	ldr	r2, [r2, #8]
20007938:	61da      	str	r2, [r3, #28]
      if (cmd->AddressMode != QSPI_ADDRESS_NONE)
2000793a:	68bb      	ldr	r3, [r7, #8]
2000793c:	69db      	ldr	r3, [r3, #28]
2000793e:	2b00      	cmp	r3, #0
20007940:	d02d      	beq.n	2000799e <QSPI_Config+0x21a>
        WRITE_REG(hqspi->Instance->CCR, (cmd->DdrMode | cmd->DdrHoldHalfCycle | cmd->SIOOMode |
20007942:	68bb      	ldr	r3, [r7, #8]
20007944:	6ada      	ldr	r2, [r3, #44]	; 0x2c
20007946:	68bb      	ldr	r3, [r7, #8]
20007948:	6b1b      	ldr	r3, [r3, #48]	; 0x30
2000794a:	431a      	orrs	r2, r3
2000794c:	68bb      	ldr	r3, [r7, #8]
2000794e:	6b5b      	ldr	r3, [r3, #52]	; 0x34
20007950:	431a      	orrs	r2, r3
20007952:	68bb      	ldr	r3, [r7, #8]
20007954:	6a5b      	ldr	r3, [r3, #36]	; 0x24
20007956:	431a      	orrs	r2, r3
20007958:	68bb      	ldr	r3, [r7, #8]
2000795a:	695b      	ldr	r3, [r3, #20]
2000795c:	049b      	lsls	r3, r3, #18
2000795e:	431a      	orrs	r2, r3
20007960:	68bb      	ldr	r3, [r7, #8]
20007962:	691b      	ldr	r3, [r3, #16]
20007964:	431a      	orrs	r2, r3
20007966:	68bb      	ldr	r3, [r7, #8]
20007968:	6a1b      	ldr	r3, [r3, #32]
2000796a:	431a      	orrs	r2, r3
2000796c:	68bb      	ldr	r3, [r7, #8]
2000796e:	68db      	ldr	r3, [r3, #12]
20007970:	431a      	orrs	r2, r3
20007972:	68bb      	ldr	r3, [r7, #8]
20007974:	69db      	ldr	r3, [r3, #28]
20007976:	431a      	orrs	r2, r3
20007978:	68bb      	ldr	r3, [r7, #8]
2000797a:	699b      	ldr	r3, [r3, #24]
2000797c:	ea42 0103 	orr.w	r1, r2, r3
20007980:	68fb      	ldr	r3, [r7, #12]
20007982:	681b      	ldr	r3, [r3, #0]
20007984:	687a      	ldr	r2, [r7, #4]
20007986:	430a      	orrs	r2, r1
20007988:	615a      	str	r2, [r3, #20]
        if (FunctionalMode != QSPI_FUNCTIONAL_MODE_MEMORY_MAPPED)
2000798a:	687b      	ldr	r3, [r7, #4]
2000798c:	f1b3 6f40 	cmp.w	r3, #201326592	; 0xc000000
20007990:	d078      	beq.n	20007a84 <QSPI_Config+0x300>
          WRITE_REG(hqspi->Instance->AR, cmd->Address);
20007992:	68fb      	ldr	r3, [r7, #12]
20007994:	681b      	ldr	r3, [r3, #0]
20007996:	68ba      	ldr	r2, [r7, #8]
20007998:	6852      	ldr	r2, [r2, #4]
2000799a:	619a      	str	r2, [r3, #24]
}
2000799c:	e072      	b.n	20007a84 <QSPI_Config+0x300>
        WRITE_REG(hqspi->Instance->CCR, (cmd->DdrMode | cmd->DdrHoldHalfCycle | cmd->SIOOMode |
2000799e:	68bb      	ldr	r3, [r7, #8]
200079a0:	6ada      	ldr	r2, [r3, #44]	; 0x2c
200079a2:	68bb      	ldr	r3, [r7, #8]
200079a4:	6b1b      	ldr	r3, [r3, #48]	; 0x30
200079a6:	431a      	orrs	r2, r3
200079a8:	68bb      	ldr	r3, [r7, #8]
200079aa:	6b5b      	ldr	r3, [r3, #52]	; 0x34
200079ac:	431a      	orrs	r2, r3
200079ae:	68bb      	ldr	r3, [r7, #8]
200079b0:	6a5b      	ldr	r3, [r3, #36]	; 0x24
200079b2:	431a      	orrs	r2, r3
200079b4:	68bb      	ldr	r3, [r7, #8]
200079b6:	695b      	ldr	r3, [r3, #20]
200079b8:	049b      	lsls	r3, r3, #18
200079ba:	431a      	orrs	r2, r3
200079bc:	68bb      	ldr	r3, [r7, #8]
200079be:	691b      	ldr	r3, [r3, #16]
200079c0:	431a      	orrs	r2, r3
200079c2:	68bb      	ldr	r3, [r7, #8]
200079c4:	6a1b      	ldr	r3, [r3, #32]
200079c6:	431a      	orrs	r2, r3
200079c8:	68bb      	ldr	r3, [r7, #8]
200079ca:	69db      	ldr	r3, [r3, #28]
200079cc:	431a      	orrs	r2, r3
200079ce:	68bb      	ldr	r3, [r7, #8]
200079d0:	699b      	ldr	r3, [r3, #24]
200079d2:	ea42 0103 	orr.w	r1, r2, r3
200079d6:	68fb      	ldr	r3, [r7, #12]
200079d8:	681b      	ldr	r3, [r3, #0]
200079da:	687a      	ldr	r2, [r7, #4]
200079dc:	430a      	orrs	r2, r1
200079de:	615a      	str	r2, [r3, #20]
}
200079e0:	e050      	b.n	20007a84 <QSPI_Config+0x300>
      if (cmd->AddressMode != QSPI_ADDRESS_NONE)
200079e2:	68bb      	ldr	r3, [r7, #8]
200079e4:	69db      	ldr	r3, [r3, #28]
200079e6:	2b00      	cmp	r3, #0
200079e8:	d02a      	beq.n	20007a40 <QSPI_Config+0x2bc>
        WRITE_REG(hqspi->Instance->CCR, (cmd->DdrMode | cmd->DdrHoldHalfCycle | cmd->SIOOMode |
200079ea:	68bb      	ldr	r3, [r7, #8]
200079ec:	6ada      	ldr	r2, [r3, #44]	; 0x2c
200079ee:	68bb      	ldr	r3, [r7, #8]
200079f0:	6b1b      	ldr	r3, [r3, #48]	; 0x30
200079f2:	431a      	orrs	r2, r3
200079f4:	68bb      	ldr	r3, [r7, #8]
200079f6:	6b5b      	ldr	r3, [r3, #52]	; 0x34
200079f8:	431a      	orrs	r2, r3
200079fa:	68bb      	ldr	r3, [r7, #8]
200079fc:	6a5b      	ldr	r3, [r3, #36]	; 0x24
200079fe:	431a      	orrs	r2, r3
20007a00:	68bb      	ldr	r3, [r7, #8]
20007a02:	695b      	ldr	r3, [r3, #20]
20007a04:	049b      	lsls	r3, r3, #18
20007a06:	431a      	orrs	r2, r3
20007a08:	68bb      	ldr	r3, [r7, #8]
20007a0a:	6a1b      	ldr	r3, [r3, #32]
20007a0c:	431a      	orrs	r2, r3
20007a0e:	68bb      	ldr	r3, [r7, #8]
20007a10:	68db      	ldr	r3, [r3, #12]
20007a12:	431a      	orrs	r2, r3
20007a14:	68bb      	ldr	r3, [r7, #8]
20007a16:	69db      	ldr	r3, [r3, #28]
20007a18:	431a      	orrs	r2, r3
20007a1a:	68bb      	ldr	r3, [r7, #8]
20007a1c:	699b      	ldr	r3, [r3, #24]
20007a1e:	ea42 0103 	orr.w	r1, r2, r3
20007a22:	68fb      	ldr	r3, [r7, #12]
20007a24:	681b      	ldr	r3, [r3, #0]
20007a26:	687a      	ldr	r2, [r7, #4]
20007a28:	430a      	orrs	r2, r1
20007a2a:	615a      	str	r2, [r3, #20]
        if (FunctionalMode != QSPI_FUNCTIONAL_MODE_MEMORY_MAPPED)
20007a2c:	687b      	ldr	r3, [r7, #4]
20007a2e:	f1b3 6f40 	cmp.w	r3, #201326592	; 0xc000000
20007a32:	d027      	beq.n	20007a84 <QSPI_Config+0x300>
          WRITE_REG(hqspi->Instance->AR, cmd->Address);
20007a34:	68fb      	ldr	r3, [r7, #12]
20007a36:	681b      	ldr	r3, [r3, #0]
20007a38:	68ba      	ldr	r2, [r7, #8]
20007a3a:	6852      	ldr	r2, [r2, #4]
20007a3c:	619a      	str	r2, [r3, #24]
}
20007a3e:	e021      	b.n	20007a84 <QSPI_Config+0x300>
        if (cmd->DataMode != QSPI_DATA_NONE)
20007a40:	68bb      	ldr	r3, [r7, #8]
20007a42:	6a5b      	ldr	r3, [r3, #36]	; 0x24
20007a44:	2b00      	cmp	r3, #0
20007a46:	d01d      	beq.n	20007a84 <QSPI_Config+0x300>
          WRITE_REG(hqspi->Instance->CCR, (cmd->DdrMode | cmd->DdrHoldHalfCycle | cmd->SIOOMode |
20007a48:	68bb      	ldr	r3, [r7, #8]
20007a4a:	6ada      	ldr	r2, [r3, #44]	; 0x2c
20007a4c:	68bb      	ldr	r3, [r7, #8]
20007a4e:	6b1b      	ldr	r3, [r3, #48]	; 0x30
20007a50:	431a      	orrs	r2, r3
20007a52:	68bb      	ldr	r3, [r7, #8]
20007a54:	6b5b      	ldr	r3, [r3, #52]	; 0x34
20007a56:	431a      	orrs	r2, r3
20007a58:	68bb      	ldr	r3, [r7, #8]
20007a5a:	6a5b      	ldr	r3, [r3, #36]	; 0x24
20007a5c:	431a      	orrs	r2, r3
20007a5e:	68bb      	ldr	r3, [r7, #8]
20007a60:	695b      	ldr	r3, [r3, #20]
20007a62:	049b      	lsls	r3, r3, #18
20007a64:	431a      	orrs	r2, r3
20007a66:	68bb      	ldr	r3, [r7, #8]
20007a68:	6a1b      	ldr	r3, [r3, #32]
20007a6a:	431a      	orrs	r2, r3
20007a6c:	68bb      	ldr	r3, [r7, #8]
20007a6e:	69db      	ldr	r3, [r3, #28]
20007a70:	431a      	orrs	r2, r3
20007a72:	68bb      	ldr	r3, [r7, #8]
20007a74:	699b      	ldr	r3, [r3, #24]
20007a76:	ea42 0103 	orr.w	r1, r2, r3
20007a7a:	68fb      	ldr	r3, [r7, #12]
20007a7c:	681b      	ldr	r3, [r3, #0]
20007a7e:	687a      	ldr	r2, [r7, #4]
20007a80:	430a      	orrs	r2, r1
20007a82:	615a      	str	r2, [r3, #20]
}
20007a84:	bf00      	nop
20007a86:	3714      	adds	r7, #20
20007a88:	46bd      	mov	sp, r7
20007a8a:	f85d 7b04 	ldr.w	r7, [sp], #4
20007a8e:	4770      	bx	lr

20007a90 <HAL_RCC_DeInit>:
  *            - Peripheral clocks
  *            - LSI, LSE and RTC clocks
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RCC_DeInit(void)
{
20007a90:	b580      	push	{r7, lr}
20007a92:	b082      	sub	sp, #8
20007a94:	af00      	add	r7, sp, #0
  uint32_t tickstart;

  /* Get Start Tick*/
  tickstart = HAL_GetTick();
20007a96:	f7f9 ff01 	bl	2000189c <HAL_GetTick>
20007a9a:	6078      	str	r0, [r7, #4]

  /* Set HSION bit to the reset value */
  SET_BIT(RCC->CR, RCC_CR_HSION);
20007a9c:	4b39      	ldr	r3, [pc, #228]	; (20007b84 <HAL_RCC_DeInit+0xf4>)
20007a9e:	681b      	ldr	r3, [r3, #0]
20007aa0:	4a38      	ldr	r2, [pc, #224]	; (20007b84 <HAL_RCC_DeInit+0xf4>)
20007aa2:	f443 7380 	orr.w	r3, r3, #256	; 0x100
20007aa6:	6013      	str	r3, [r2, #0]

  /* Wait till HSI is ready */
  while (READ_BIT(RCC->CR, RCC_CR_HSIRDY) == 0U)
20007aa8:	e008      	b.n	20007abc <HAL_RCC_DeInit+0x2c>
  {
    if ((HAL_GetTick() - tickstart) > HSI_TIMEOUT_VALUE)
20007aaa:	f7f9 fef7 	bl	2000189c <HAL_GetTick>
20007aae:	4602      	mov	r2, r0
20007ab0:	687b      	ldr	r3, [r7, #4]
20007ab2:	1ad3      	subs	r3, r2, r3
20007ab4:	2b02      	cmp	r3, #2
20007ab6:	d901      	bls.n	20007abc <HAL_RCC_DeInit+0x2c>
    {
      return HAL_TIMEOUT;
20007ab8:	2303      	movs	r3, #3
20007aba:	e05f      	b.n	20007b7c <HAL_RCC_DeInit+0xec>
  while (READ_BIT(RCC->CR, RCC_CR_HSIRDY) == 0U)
20007abc:	4b31      	ldr	r3, [pc, #196]	; (20007b84 <HAL_RCC_DeInit+0xf4>)
20007abe:	681b      	ldr	r3, [r3, #0]
20007ac0:	f403 6380 	and.w	r3, r3, #1024	; 0x400
20007ac4:	2b00      	cmp	r3, #0
20007ac6:	d0f0      	beq.n	20007aaa <HAL_RCC_DeInit+0x1a>
    }
  }

 /* Set HSITRIM[6:0] bits to the reset value */
  SET_BIT(RCC->ICSCR, RCC_HSICALIBRATION_DEFAULT << RCC_ICSCR_HSITRIM_Pos);
20007ac8:	4b2e      	ldr	r3, [pc, #184]	; (20007b84 <HAL_RCC_DeInit+0xf4>)
20007aca:	685b      	ldr	r3, [r3, #4]
20007acc:	4a2d      	ldr	r2, [pc, #180]	; (20007b84 <HAL_RCC_DeInit+0xf4>)
20007ace:	f043 4380 	orr.w	r3, r3, #1073741824	; 0x40000000
20007ad2:	6053      	str	r3, [r2, #4]

  /* Get Start Tick*/
  tickstart = HAL_GetTick();
20007ad4:	f7f9 fee2 	bl	2000189c <HAL_GetTick>
20007ad8:	6078      	str	r0, [r7, #4]

  /* Reset CFGR register (HSI is selected as system clock source) */
  RCC->CFGR = 0x00000001u;
20007ada:	4b2a      	ldr	r3, [pc, #168]	; (20007b84 <HAL_RCC_DeInit+0xf4>)
20007adc:	2201      	movs	r2, #1
20007ade:	609a      	str	r2, [r3, #8]

  /* Wait till HSI is ready */
  while (READ_BIT(RCC->CFGR, RCC_CFGR_SWS) != RCC_CFGR_SWS_HSI)
20007ae0:	e00a      	b.n	20007af8 <HAL_RCC_DeInit+0x68>
  {
    if ((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
20007ae2:	f7f9 fedb 	bl	2000189c <HAL_GetTick>
20007ae6:	4602      	mov	r2, r0
20007ae8:	687b      	ldr	r3, [r7, #4]
20007aea:	1ad3      	subs	r3, r2, r3
20007aec:	f241 3288 	movw	r2, #5000	; 0x1388
20007af0:	4293      	cmp	r3, r2
20007af2:	d901      	bls.n	20007af8 <HAL_RCC_DeInit+0x68>
    {
      return HAL_TIMEOUT;
20007af4:	2303      	movs	r3, #3
20007af6:	e041      	b.n	20007b7c <HAL_RCC_DeInit+0xec>
  while (READ_BIT(RCC->CFGR, RCC_CFGR_SWS) != RCC_CFGR_SWS_HSI)
20007af8:	4b22      	ldr	r3, [pc, #136]	; (20007b84 <HAL_RCC_DeInit+0xf4>)
20007afa:	689b      	ldr	r3, [r3, #8]
20007afc:	f003 030c 	and.w	r3, r3, #12
20007b00:	2b04      	cmp	r3, #4
20007b02:	d1ee      	bne.n	20007ae2 <HAL_RCC_DeInit+0x52>
    }
  }

  /* Update the SystemCoreClock global variable */
  SystemCoreClock = HSI_VALUE;
20007b04:	4b20      	ldr	r3, [pc, #128]	; (20007b88 <HAL_RCC_DeInit+0xf8>)
20007b06:	4a21      	ldr	r2, [pc, #132]	; (20007b8c <HAL_RCC_DeInit+0xfc>)
20007b08:	601a      	str	r2, [r3, #0]

  /* Adapt Systick interrupt period */
  if (HAL_InitTick(uwTickPrio) != HAL_OK)
20007b0a:	4b21      	ldr	r3, [pc, #132]	; (20007b90 <HAL_RCC_DeInit+0x100>)
20007b0c:	681b      	ldr	r3, [r3, #0]
20007b0e:	4618      	mov	r0, r3
20007b10:	f7f9 fe78 	bl	20001804 <HAL_InitTick>
20007b14:	4603      	mov	r3, r0
20007b16:	2b00      	cmp	r3, #0
20007b18:	d001      	beq.n	20007b1e <HAL_RCC_DeInit+0x8e>
  {
    return HAL_ERROR;
20007b1a:	2301      	movs	r3, #1
20007b1c:	e02e      	b.n	20007b7c <HAL_RCC_DeInit+0xec>
  }

  /* Clear CR register in 2 steps: first to clear HSEON in case bypass was enabled */
  RCC->CR = RCC_CR_HSION;
20007b1e:	4b19      	ldr	r3, [pc, #100]	; (20007b84 <HAL_RCC_DeInit+0xf4>)
20007b20:	f44f 7280 	mov.w	r2, #256	; 0x100
20007b24:	601a      	str	r2, [r3, #0]

  /* Then again to HSEBYP in case bypass was enabled */
  RCC->CR = RCC_CR_HSION;
20007b26:	4b17      	ldr	r3, [pc, #92]	; (20007b84 <HAL_RCC_DeInit+0xf4>)
20007b28:	f44f 7280 	mov.w	r2, #256	; 0x100
20007b2c:	601a      	str	r2, [r3, #0]

  /* Get Start Tick*/
  tickstart = HAL_GetTick();
20007b2e:	f7f9 feb5 	bl	2000189c <HAL_GetTick>
20007b32:	6078      	str	r0, [r7, #4]

  /* Wait till PLL is OFF */
  while (READ_BIT(RCC->CR, RCC_CR_PLLRDY) != 0U)
20007b34:	e008      	b.n	20007b48 <HAL_RCC_DeInit+0xb8>
  {
    if ((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
20007b36:	f7f9 feb1 	bl	2000189c <HAL_GetTick>
20007b3a:	4602      	mov	r2, r0
20007b3c:	687b      	ldr	r3, [r7, #4]
20007b3e:	1ad3      	subs	r3, r2, r3
20007b40:	2b02      	cmp	r3, #2
20007b42:	d901      	bls.n	20007b48 <HAL_RCC_DeInit+0xb8>
    {
      return HAL_TIMEOUT;
20007b44:	2303      	movs	r3, #3
20007b46:	e019      	b.n	20007b7c <HAL_RCC_DeInit+0xec>
  while (READ_BIT(RCC->CR, RCC_CR_PLLRDY) != 0U)
20007b48:	4b0e      	ldr	r3, [pc, #56]	; (20007b84 <HAL_RCC_DeInit+0xf4>)
20007b4a:	681b      	ldr	r3, [r3, #0]
20007b4c:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
20007b50:	2b00      	cmp	r3, #0
20007b52:	d1f0      	bne.n	20007b36 <HAL_RCC_DeInit+0xa6>
    }
  }

  /* once PLL is OFF, reset PLLCFGR register to default value */
  RCC->PLLCFGR = RCC_PLLCFGR_PLLN_4;
20007b54:	4b0b      	ldr	r3, [pc, #44]	; (20007b84 <HAL_RCC_DeInit+0xf4>)
20007b56:	f44f 5280 	mov.w	r2, #4096	; 0x1000
20007b5a:	60da      	str	r2, [r3, #12]

  /* Disable all interrupts */
  CLEAR_REG(RCC->CIER);
20007b5c:	4b09      	ldr	r3, [pc, #36]	; (20007b84 <HAL_RCC_DeInit+0xf4>)
20007b5e:	2200      	movs	r2, #0
20007b60:	619a      	str	r2, [r3, #24]

  /* Clear all interrupt flags */
  WRITE_REG(RCC->CICR, 0xFFFFFFFFU);
20007b62:	4b08      	ldr	r3, [pc, #32]	; (20007b84 <HAL_RCC_DeInit+0xf4>)
20007b64:	f04f 32ff 	mov.w	r2, #4294967295
20007b68:	621a      	str	r2, [r3, #32]

  /* Clear all reset flags */
  SET_BIT(RCC->CSR, RCC_CSR_RMVF);
20007b6a:	4b06      	ldr	r3, [pc, #24]	; (20007b84 <HAL_RCC_DeInit+0xf4>)
20007b6c:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
20007b70:	4a04      	ldr	r2, [pc, #16]	; (20007b84 <HAL_RCC_DeInit+0xf4>)
20007b72:	f443 0300 	orr.w	r3, r3, #8388608	; 0x800000
20007b76:	f8c2 3094 	str.w	r3, [r2, #148]	; 0x94

  return HAL_OK;
20007b7a:	2300      	movs	r3, #0
}
20007b7c:	4618      	mov	r0, r3
20007b7e:	3708      	adds	r7, #8
20007b80:	46bd      	mov	sp, r7
20007b82:	bd80      	pop	{r7, pc}
20007b84:	40021000 	.word	0x40021000
20007b88:	200003f0 	.word	0x200003f0
20007b8c:	00f42400 	.word	0x00f42400
20007b90:	200003f4 	.word	0x200003f4

20007b94 <HAL_RCC_OscConfig>:
  *         supported by this macro. User should request a transition to HSE Off
  *         first and then HSE On or HSE Bypass.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RCC_OscConfig(RCC_OscInitTypeDef  *RCC_OscInitStruct)
{
20007b94:	b580      	push	{r7, lr}
20007b96:	b088      	sub	sp, #32
20007b98:	af00      	add	r7, sp, #0
20007b9a:	6078      	str	r0, [r7, #4]
  uint32_t tickstart;
  uint32_t temp_sysclksrc;
  uint32_t temp_pllckcfg;

  /* Check Null pointer */
  if (RCC_OscInitStruct == NULL)
20007b9c:	687b      	ldr	r3, [r7, #4]
20007b9e:	2b00      	cmp	r3, #0
20007ba0:	d101      	bne.n	20007ba6 <HAL_RCC_OscConfig+0x12>
  {
    return HAL_ERROR;
20007ba2:	2301      	movs	r3, #1
20007ba4:	e308      	b.n	200081b8 <HAL_RCC_OscConfig+0x624>

  /* Check the parameters */
  assert_param(IS_RCC_OSCILLATORTYPE(RCC_OscInitStruct->OscillatorType));

  /*------------------------------- HSE Configuration ------------------------*/
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
20007ba6:	687b      	ldr	r3, [r7, #4]
20007ba8:	681b      	ldr	r3, [r3, #0]
20007baa:	f003 0301 	and.w	r3, r3, #1
20007bae:	2b00      	cmp	r3, #0
20007bb0:	d075      	beq.n	20007c9e <HAL_RCC_OscConfig+0x10a>
  {
    /* Check the parameters */
    assert_param(IS_RCC_HSE(RCC_OscInitStruct->HSEState));

    temp_sysclksrc = __HAL_RCC_GET_SYSCLK_SOURCE();
20007bb2:	4ba3      	ldr	r3, [pc, #652]	; (20007e40 <HAL_RCC_OscConfig+0x2ac>)
20007bb4:	689b      	ldr	r3, [r3, #8]
20007bb6:	f003 030c 	and.w	r3, r3, #12
20007bba:	61bb      	str	r3, [r7, #24]
    temp_pllckcfg = __HAL_RCC_GET_PLL_OSCSOURCE();
20007bbc:	4ba0      	ldr	r3, [pc, #640]	; (20007e40 <HAL_RCC_OscConfig+0x2ac>)
20007bbe:	68db      	ldr	r3, [r3, #12]
20007bc0:	f003 0303 	and.w	r3, r3, #3
20007bc4:	617b      	str	r3, [r7, #20]

    /* When the HSE is used as system clock or clock source for PLL in these cases it is not allowed to be disabled */
    if (((temp_sysclksrc == RCC_CFGR_SWS_PLL) && (temp_pllckcfg == RCC_PLLSOURCE_HSE)) || (temp_sysclksrc == RCC_CFGR_SWS_HSE))
20007bc6:	69bb      	ldr	r3, [r7, #24]
20007bc8:	2b0c      	cmp	r3, #12
20007bca:	d102      	bne.n	20007bd2 <HAL_RCC_OscConfig+0x3e>
20007bcc:	697b      	ldr	r3, [r7, #20]
20007bce:	2b03      	cmp	r3, #3
20007bd0:	d002      	beq.n	20007bd8 <HAL_RCC_OscConfig+0x44>
20007bd2:	69bb      	ldr	r3, [r7, #24]
20007bd4:	2b08      	cmp	r3, #8
20007bd6:	d10b      	bne.n	20007bf0 <HAL_RCC_OscConfig+0x5c>
    {
      if ((READ_BIT(RCC->CR, RCC_CR_HSERDY) != 0U) && (RCC_OscInitStruct->HSEState == RCC_HSE_OFF))
20007bd8:	4b99      	ldr	r3, [pc, #612]	; (20007e40 <HAL_RCC_OscConfig+0x2ac>)
20007bda:	681b      	ldr	r3, [r3, #0]
20007bdc:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
20007be0:	2b00      	cmp	r3, #0
20007be2:	d05b      	beq.n	20007c9c <HAL_RCC_OscConfig+0x108>
20007be4:	687b      	ldr	r3, [r7, #4]
20007be6:	685b      	ldr	r3, [r3, #4]
20007be8:	2b00      	cmp	r3, #0
20007bea:	d157      	bne.n	20007c9c <HAL_RCC_OscConfig+0x108>
      {
        return HAL_ERROR;
20007bec:	2301      	movs	r3, #1
20007bee:	e2e3      	b.n	200081b8 <HAL_RCC_OscConfig+0x624>
      }
    }
    else
    {
      /* Set the new HSE configuration ---------------------------------------*/
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
20007bf0:	687b      	ldr	r3, [r7, #4]
20007bf2:	685b      	ldr	r3, [r3, #4]
20007bf4:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
20007bf8:	d106      	bne.n	20007c08 <HAL_RCC_OscConfig+0x74>
20007bfa:	4b91      	ldr	r3, [pc, #580]	; (20007e40 <HAL_RCC_OscConfig+0x2ac>)
20007bfc:	681b      	ldr	r3, [r3, #0]
20007bfe:	4a90      	ldr	r2, [pc, #576]	; (20007e40 <HAL_RCC_OscConfig+0x2ac>)
20007c00:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
20007c04:	6013      	str	r3, [r2, #0]
20007c06:	e01d      	b.n	20007c44 <HAL_RCC_OscConfig+0xb0>
20007c08:	687b      	ldr	r3, [r7, #4]
20007c0a:	685b      	ldr	r3, [r3, #4]
20007c0c:	f5b3 2fa0 	cmp.w	r3, #327680	; 0x50000
20007c10:	d10c      	bne.n	20007c2c <HAL_RCC_OscConfig+0x98>
20007c12:	4b8b      	ldr	r3, [pc, #556]	; (20007e40 <HAL_RCC_OscConfig+0x2ac>)
20007c14:	681b      	ldr	r3, [r3, #0]
20007c16:	4a8a      	ldr	r2, [pc, #552]	; (20007e40 <HAL_RCC_OscConfig+0x2ac>)
20007c18:	f443 2380 	orr.w	r3, r3, #262144	; 0x40000
20007c1c:	6013      	str	r3, [r2, #0]
20007c1e:	4b88      	ldr	r3, [pc, #544]	; (20007e40 <HAL_RCC_OscConfig+0x2ac>)
20007c20:	681b      	ldr	r3, [r3, #0]
20007c22:	4a87      	ldr	r2, [pc, #540]	; (20007e40 <HAL_RCC_OscConfig+0x2ac>)
20007c24:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
20007c28:	6013      	str	r3, [r2, #0]
20007c2a:	e00b      	b.n	20007c44 <HAL_RCC_OscConfig+0xb0>
20007c2c:	4b84      	ldr	r3, [pc, #528]	; (20007e40 <HAL_RCC_OscConfig+0x2ac>)
20007c2e:	681b      	ldr	r3, [r3, #0]
20007c30:	4a83      	ldr	r2, [pc, #524]	; (20007e40 <HAL_RCC_OscConfig+0x2ac>)
20007c32:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
20007c36:	6013      	str	r3, [r2, #0]
20007c38:	4b81      	ldr	r3, [pc, #516]	; (20007e40 <HAL_RCC_OscConfig+0x2ac>)
20007c3a:	681b      	ldr	r3, [r3, #0]
20007c3c:	4a80      	ldr	r2, [pc, #512]	; (20007e40 <HAL_RCC_OscConfig+0x2ac>)
20007c3e:	f423 2380 	bic.w	r3, r3, #262144	; 0x40000
20007c42:	6013      	str	r3, [r2, #0]

      /* Check the HSE State */
      if (RCC_OscInitStruct->HSEState != RCC_HSE_OFF)
20007c44:	687b      	ldr	r3, [r7, #4]
20007c46:	685b      	ldr	r3, [r3, #4]
20007c48:	2b00      	cmp	r3, #0
20007c4a:	d013      	beq.n	20007c74 <HAL_RCC_OscConfig+0xe0>
      {
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
20007c4c:	f7f9 fe26 	bl	2000189c <HAL_GetTick>
20007c50:	6138      	str	r0, [r7, #16]

        /* Wait till HSE is ready */
        while (READ_BIT(RCC->CR, RCC_CR_HSERDY) == 0U)
20007c52:	e008      	b.n	20007c66 <HAL_RCC_OscConfig+0xd2>
        {
          if ((HAL_GetTick() - tickstart) > HSE_TIMEOUT_VALUE)
20007c54:	f7f9 fe22 	bl	2000189c <HAL_GetTick>
20007c58:	4602      	mov	r2, r0
20007c5a:	693b      	ldr	r3, [r7, #16]
20007c5c:	1ad3      	subs	r3, r2, r3
20007c5e:	2b64      	cmp	r3, #100	; 0x64
20007c60:	d901      	bls.n	20007c66 <HAL_RCC_OscConfig+0xd2>
          {
            return HAL_TIMEOUT;
20007c62:	2303      	movs	r3, #3
20007c64:	e2a8      	b.n	200081b8 <HAL_RCC_OscConfig+0x624>
        while (READ_BIT(RCC->CR, RCC_CR_HSERDY) == 0U)
20007c66:	4b76      	ldr	r3, [pc, #472]	; (20007e40 <HAL_RCC_OscConfig+0x2ac>)
20007c68:	681b      	ldr	r3, [r3, #0]
20007c6a:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
20007c6e:	2b00      	cmp	r3, #0
20007c70:	d0f0      	beq.n	20007c54 <HAL_RCC_OscConfig+0xc0>
20007c72:	e014      	b.n	20007c9e <HAL_RCC_OscConfig+0x10a>
        }
      }
      else
      {
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
20007c74:	f7f9 fe12 	bl	2000189c <HAL_GetTick>
20007c78:	6138      	str	r0, [r7, #16]

        /* Wait till HSE is disabled */
        while (READ_BIT(RCC->CR, RCC_CR_HSERDY) != 0U)
20007c7a:	e008      	b.n	20007c8e <HAL_RCC_OscConfig+0xfa>
        {
          if ((HAL_GetTick() - tickstart) > HSE_TIMEOUT_VALUE)
20007c7c:	f7f9 fe0e 	bl	2000189c <HAL_GetTick>
20007c80:	4602      	mov	r2, r0
20007c82:	693b      	ldr	r3, [r7, #16]
20007c84:	1ad3      	subs	r3, r2, r3
20007c86:	2b64      	cmp	r3, #100	; 0x64
20007c88:	d901      	bls.n	20007c8e <HAL_RCC_OscConfig+0xfa>
          {
            return HAL_TIMEOUT;
20007c8a:	2303      	movs	r3, #3
20007c8c:	e294      	b.n	200081b8 <HAL_RCC_OscConfig+0x624>
        while (READ_BIT(RCC->CR, RCC_CR_HSERDY) != 0U)
20007c8e:	4b6c      	ldr	r3, [pc, #432]	; (20007e40 <HAL_RCC_OscConfig+0x2ac>)
20007c90:	681b      	ldr	r3, [r3, #0]
20007c92:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
20007c96:	2b00      	cmp	r3, #0
20007c98:	d1f0      	bne.n	20007c7c <HAL_RCC_OscConfig+0xe8>
20007c9a:	e000      	b.n	20007c9e <HAL_RCC_OscConfig+0x10a>
      if ((READ_BIT(RCC->CR, RCC_CR_HSERDY) != 0U) && (RCC_OscInitStruct->HSEState == RCC_HSE_OFF))
20007c9c:	bf00      	nop
        }
      }
    }
  }
  /*----------------------------- HSI Configuration --------------------------*/
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI) == RCC_OSCILLATORTYPE_HSI)
20007c9e:	687b      	ldr	r3, [r7, #4]
20007ca0:	681b      	ldr	r3, [r3, #0]
20007ca2:	f003 0302 	and.w	r3, r3, #2
20007ca6:	2b00      	cmp	r3, #0
20007ca8:	d075      	beq.n	20007d96 <HAL_RCC_OscConfig+0x202>
    /* Check the parameters */
    assert_param(IS_RCC_HSI(RCC_OscInitStruct->HSIState));
    assert_param(IS_RCC_HSI_CALIBRATION_VALUE(RCC_OscInitStruct->HSICalibrationValue));

    /* Check if HSI is used as system clock or as PLL source when PLL is selected as system clock */
    temp_sysclksrc = __HAL_RCC_GET_SYSCLK_SOURCE();
20007caa:	4b65      	ldr	r3, [pc, #404]	; (20007e40 <HAL_RCC_OscConfig+0x2ac>)
20007cac:	689b      	ldr	r3, [r3, #8]
20007cae:	f003 030c 	and.w	r3, r3, #12
20007cb2:	61bb      	str	r3, [r7, #24]
    temp_pllckcfg = __HAL_RCC_GET_PLL_OSCSOURCE();
20007cb4:	4b62      	ldr	r3, [pc, #392]	; (20007e40 <HAL_RCC_OscConfig+0x2ac>)
20007cb6:	68db      	ldr	r3, [r3, #12]
20007cb8:	f003 0303 	and.w	r3, r3, #3
20007cbc:	617b      	str	r3, [r7, #20]
    if (((temp_sysclksrc == RCC_CFGR_SWS_PLL) && (temp_pllckcfg == RCC_PLLSOURCE_HSI)) || (temp_sysclksrc == RCC_CFGR_SWS_HSI))
20007cbe:	69bb      	ldr	r3, [r7, #24]
20007cc0:	2b0c      	cmp	r3, #12
20007cc2:	d102      	bne.n	20007cca <HAL_RCC_OscConfig+0x136>
20007cc4:	697b      	ldr	r3, [r7, #20]
20007cc6:	2b02      	cmp	r3, #2
20007cc8:	d002      	beq.n	20007cd0 <HAL_RCC_OscConfig+0x13c>
20007cca:	69bb      	ldr	r3, [r7, #24]
20007ccc:	2b04      	cmp	r3, #4
20007cce:	d11f      	bne.n	20007d10 <HAL_RCC_OscConfig+0x17c>
    {
      /* When HSI is used as system clock it will not be disabled */
      if ((READ_BIT(RCC->CR, RCC_CR_HSIRDY) != 0U) && (RCC_OscInitStruct->HSIState == RCC_HSI_OFF))
20007cd0:	4b5b      	ldr	r3, [pc, #364]	; (20007e40 <HAL_RCC_OscConfig+0x2ac>)
20007cd2:	681b      	ldr	r3, [r3, #0]
20007cd4:	f403 6380 	and.w	r3, r3, #1024	; 0x400
20007cd8:	2b00      	cmp	r3, #0
20007cda:	d005      	beq.n	20007ce8 <HAL_RCC_OscConfig+0x154>
20007cdc:	687b      	ldr	r3, [r7, #4]
20007cde:	68db      	ldr	r3, [r3, #12]
20007ce0:	2b00      	cmp	r3, #0
20007ce2:	d101      	bne.n	20007ce8 <HAL_RCC_OscConfig+0x154>
      {
        return HAL_ERROR;
20007ce4:	2301      	movs	r3, #1
20007ce6:	e267      	b.n	200081b8 <HAL_RCC_OscConfig+0x624>
      }
      /* Otherwise, just the calibration is allowed */
      else
      {
        /* Adjusts the Internal High Speed oscillator (HSI) calibration value.*/
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
20007ce8:	4b55      	ldr	r3, [pc, #340]	; (20007e40 <HAL_RCC_OscConfig+0x2ac>)
20007cea:	685b      	ldr	r3, [r3, #4]
20007cec:	f023 42fe 	bic.w	r2, r3, #2130706432	; 0x7f000000
20007cf0:	687b      	ldr	r3, [r7, #4]
20007cf2:	691b      	ldr	r3, [r3, #16]
20007cf4:	061b      	lsls	r3, r3, #24
20007cf6:	4952      	ldr	r1, [pc, #328]	; (20007e40 <HAL_RCC_OscConfig+0x2ac>)
20007cf8:	4313      	orrs	r3, r2
20007cfa:	604b      	str	r3, [r1, #4]

        /* Adapt Systick interrupt period */
        if (HAL_InitTick(uwTickPrio) != HAL_OK)
20007cfc:	4b51      	ldr	r3, [pc, #324]	; (20007e44 <HAL_RCC_OscConfig+0x2b0>)
20007cfe:	681b      	ldr	r3, [r3, #0]
20007d00:	4618      	mov	r0, r3
20007d02:	f7f9 fd7f 	bl	20001804 <HAL_InitTick>
20007d06:	4603      	mov	r3, r0
20007d08:	2b00      	cmp	r3, #0
20007d0a:	d043      	beq.n	20007d94 <HAL_RCC_OscConfig+0x200>
        {
          return HAL_ERROR;
20007d0c:	2301      	movs	r3, #1
20007d0e:	e253      	b.n	200081b8 <HAL_RCC_OscConfig+0x624>
      }
    }
    else
    {
      /* Check the HSI State */
      if (RCC_OscInitStruct->HSIState != RCC_HSI_OFF)
20007d10:	687b      	ldr	r3, [r7, #4]
20007d12:	68db      	ldr	r3, [r3, #12]
20007d14:	2b00      	cmp	r3, #0
20007d16:	d023      	beq.n	20007d60 <HAL_RCC_OscConfig+0x1cc>
      {
        /* Enable the Internal High Speed oscillator (HSI). */
        __HAL_RCC_HSI_ENABLE();
20007d18:	4b49      	ldr	r3, [pc, #292]	; (20007e40 <HAL_RCC_OscConfig+0x2ac>)
20007d1a:	681b      	ldr	r3, [r3, #0]
20007d1c:	4a48      	ldr	r2, [pc, #288]	; (20007e40 <HAL_RCC_OscConfig+0x2ac>)
20007d1e:	f443 7380 	orr.w	r3, r3, #256	; 0x100
20007d22:	6013      	str	r3, [r2, #0]

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
20007d24:	f7f9 fdba 	bl	2000189c <HAL_GetTick>
20007d28:	6138      	str	r0, [r7, #16]

        /* Wait till HSI is ready */
        while (READ_BIT(RCC->CR, RCC_CR_HSIRDY) == 0U)
20007d2a:	e008      	b.n	20007d3e <HAL_RCC_OscConfig+0x1aa>
        {
          if ((HAL_GetTick() - tickstart) > HSI_TIMEOUT_VALUE)
20007d2c:	f7f9 fdb6 	bl	2000189c <HAL_GetTick>
20007d30:	4602      	mov	r2, r0
20007d32:	693b      	ldr	r3, [r7, #16]
20007d34:	1ad3      	subs	r3, r2, r3
20007d36:	2b02      	cmp	r3, #2
20007d38:	d901      	bls.n	20007d3e <HAL_RCC_OscConfig+0x1aa>
          {
            return HAL_TIMEOUT;
20007d3a:	2303      	movs	r3, #3
20007d3c:	e23c      	b.n	200081b8 <HAL_RCC_OscConfig+0x624>
        while (READ_BIT(RCC->CR, RCC_CR_HSIRDY) == 0U)
20007d3e:	4b40      	ldr	r3, [pc, #256]	; (20007e40 <HAL_RCC_OscConfig+0x2ac>)
20007d40:	681b      	ldr	r3, [r3, #0]
20007d42:	f403 6380 	and.w	r3, r3, #1024	; 0x400
20007d46:	2b00      	cmp	r3, #0
20007d48:	d0f0      	beq.n	20007d2c <HAL_RCC_OscConfig+0x198>
          }
        }

        /* Adjusts the Internal High Speed oscillator (HSI) calibration value.*/
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
20007d4a:	4b3d      	ldr	r3, [pc, #244]	; (20007e40 <HAL_RCC_OscConfig+0x2ac>)
20007d4c:	685b      	ldr	r3, [r3, #4]
20007d4e:	f023 42fe 	bic.w	r2, r3, #2130706432	; 0x7f000000
20007d52:	687b      	ldr	r3, [r7, #4]
20007d54:	691b      	ldr	r3, [r3, #16]
20007d56:	061b      	lsls	r3, r3, #24
20007d58:	4939      	ldr	r1, [pc, #228]	; (20007e40 <HAL_RCC_OscConfig+0x2ac>)
20007d5a:	4313      	orrs	r3, r2
20007d5c:	604b      	str	r3, [r1, #4]
20007d5e:	e01a      	b.n	20007d96 <HAL_RCC_OscConfig+0x202>
      }
      else
      {
        /* Disable the Internal High Speed oscillator (HSI). */
        __HAL_RCC_HSI_DISABLE();
20007d60:	4b37      	ldr	r3, [pc, #220]	; (20007e40 <HAL_RCC_OscConfig+0x2ac>)
20007d62:	681b      	ldr	r3, [r3, #0]
20007d64:	4a36      	ldr	r2, [pc, #216]	; (20007e40 <HAL_RCC_OscConfig+0x2ac>)
20007d66:	f423 7380 	bic.w	r3, r3, #256	; 0x100
20007d6a:	6013      	str	r3, [r2, #0]

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
20007d6c:	f7f9 fd96 	bl	2000189c <HAL_GetTick>
20007d70:	6138      	str	r0, [r7, #16]

        /* Wait till HSI is disabled */
        while (READ_BIT(RCC->CR, RCC_CR_HSIRDY) != 0U)
20007d72:	e008      	b.n	20007d86 <HAL_RCC_OscConfig+0x1f2>
        {
          if ((HAL_GetTick() - tickstart) > HSI_TIMEOUT_VALUE)
20007d74:	f7f9 fd92 	bl	2000189c <HAL_GetTick>
20007d78:	4602      	mov	r2, r0
20007d7a:	693b      	ldr	r3, [r7, #16]
20007d7c:	1ad3      	subs	r3, r2, r3
20007d7e:	2b02      	cmp	r3, #2
20007d80:	d901      	bls.n	20007d86 <HAL_RCC_OscConfig+0x1f2>
          {
            return HAL_TIMEOUT;
20007d82:	2303      	movs	r3, #3
20007d84:	e218      	b.n	200081b8 <HAL_RCC_OscConfig+0x624>
        while (READ_BIT(RCC->CR, RCC_CR_HSIRDY) != 0U)
20007d86:	4b2e      	ldr	r3, [pc, #184]	; (20007e40 <HAL_RCC_OscConfig+0x2ac>)
20007d88:	681b      	ldr	r3, [r3, #0]
20007d8a:	f403 6380 	and.w	r3, r3, #1024	; 0x400
20007d8e:	2b00      	cmp	r3, #0
20007d90:	d1f0      	bne.n	20007d74 <HAL_RCC_OscConfig+0x1e0>
20007d92:	e000      	b.n	20007d96 <HAL_RCC_OscConfig+0x202>
      if ((READ_BIT(RCC->CR, RCC_CR_HSIRDY) != 0U) && (RCC_OscInitStruct->HSIState == RCC_HSI_OFF))
20007d94:	bf00      	nop
        }
      }
    }
  }
  /*------------------------------ LSI Configuration -------------------------*/
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSI) == RCC_OSCILLATORTYPE_LSI)
20007d96:	687b      	ldr	r3, [r7, #4]
20007d98:	681b      	ldr	r3, [r3, #0]
20007d9a:	f003 0308 	and.w	r3, r3, #8
20007d9e:	2b00      	cmp	r3, #0
20007da0:	d03c      	beq.n	20007e1c <HAL_RCC_OscConfig+0x288>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LSI(RCC_OscInitStruct->LSIState));

    /* Check the LSI State */
    if(RCC_OscInitStruct->LSIState != RCC_LSI_OFF)
20007da2:	687b      	ldr	r3, [r7, #4]
20007da4:	695b      	ldr	r3, [r3, #20]
20007da6:	2b00      	cmp	r3, #0
20007da8:	d01c      	beq.n	20007de4 <HAL_RCC_OscConfig+0x250>
    {
      /* Enable the Internal Low Speed oscillator (LSI). */
      __HAL_RCC_LSI_ENABLE();
20007daa:	4b25      	ldr	r3, [pc, #148]	; (20007e40 <HAL_RCC_OscConfig+0x2ac>)
20007dac:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
20007db0:	4a23      	ldr	r2, [pc, #140]	; (20007e40 <HAL_RCC_OscConfig+0x2ac>)
20007db2:	f043 0301 	orr.w	r3, r3, #1
20007db6:	f8c2 3094 	str.w	r3, [r2, #148]	; 0x94

      /* Get Start Tick*/
      tickstart = HAL_GetTick();
20007dba:	f7f9 fd6f 	bl	2000189c <HAL_GetTick>
20007dbe:	6138      	str	r0, [r7, #16]

      /* Wait till LSI is ready */
      while (READ_BIT(RCC->CSR, RCC_CSR_LSIRDY) == 0U)
20007dc0:	e008      	b.n	20007dd4 <HAL_RCC_OscConfig+0x240>
      {
        if ((HAL_GetTick() - tickstart) > LSI_TIMEOUT_VALUE)
20007dc2:	f7f9 fd6b 	bl	2000189c <HAL_GetTick>
20007dc6:	4602      	mov	r2, r0
20007dc8:	693b      	ldr	r3, [r7, #16]
20007dca:	1ad3      	subs	r3, r2, r3
20007dcc:	2b02      	cmp	r3, #2
20007dce:	d901      	bls.n	20007dd4 <HAL_RCC_OscConfig+0x240>
        {
          return HAL_TIMEOUT;
20007dd0:	2303      	movs	r3, #3
20007dd2:	e1f1      	b.n	200081b8 <HAL_RCC_OscConfig+0x624>
      while (READ_BIT(RCC->CSR, RCC_CSR_LSIRDY) == 0U)
20007dd4:	4b1a      	ldr	r3, [pc, #104]	; (20007e40 <HAL_RCC_OscConfig+0x2ac>)
20007dd6:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
20007dda:	f003 0302 	and.w	r3, r3, #2
20007dde:	2b00      	cmp	r3, #0
20007de0:	d0ef      	beq.n	20007dc2 <HAL_RCC_OscConfig+0x22e>
20007de2:	e01b      	b.n	20007e1c <HAL_RCC_OscConfig+0x288>
      }
    }
    else
    {
      /* Disable the Internal Low Speed oscillator (LSI). */
      __HAL_RCC_LSI_DISABLE();
20007de4:	4b16      	ldr	r3, [pc, #88]	; (20007e40 <HAL_RCC_OscConfig+0x2ac>)
20007de6:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
20007dea:	4a15      	ldr	r2, [pc, #84]	; (20007e40 <HAL_RCC_OscConfig+0x2ac>)
20007dec:	f023 0301 	bic.w	r3, r3, #1
20007df0:	f8c2 3094 	str.w	r3, [r2, #148]	; 0x94

      /* Get Start Tick*/
      tickstart = HAL_GetTick();
20007df4:	f7f9 fd52 	bl	2000189c <HAL_GetTick>
20007df8:	6138      	str	r0, [r7, #16]

      /* Wait till LSI is disabled */
      while(READ_BIT(RCC->CSR, RCC_CSR_LSIRDY) != 0U)
20007dfa:	e008      	b.n	20007e0e <HAL_RCC_OscConfig+0x27a>
      {
        if((HAL_GetTick() - tickstart) > LSI_TIMEOUT_VALUE)
20007dfc:	f7f9 fd4e 	bl	2000189c <HAL_GetTick>
20007e00:	4602      	mov	r2, r0
20007e02:	693b      	ldr	r3, [r7, #16]
20007e04:	1ad3      	subs	r3, r2, r3
20007e06:	2b02      	cmp	r3, #2
20007e08:	d901      	bls.n	20007e0e <HAL_RCC_OscConfig+0x27a>
        {
          return HAL_TIMEOUT;
20007e0a:	2303      	movs	r3, #3
20007e0c:	e1d4      	b.n	200081b8 <HAL_RCC_OscConfig+0x624>
      while(READ_BIT(RCC->CSR, RCC_CSR_LSIRDY) != 0U)
20007e0e:	4b0c      	ldr	r3, [pc, #48]	; (20007e40 <HAL_RCC_OscConfig+0x2ac>)
20007e10:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
20007e14:	f003 0302 	and.w	r3, r3, #2
20007e18:	2b00      	cmp	r3, #0
20007e1a:	d1ef      	bne.n	20007dfc <HAL_RCC_OscConfig+0x268>
        }
      }
    }
  }
  /*------------------------------ LSE Configuration -------------------------*/
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSE) == RCC_OSCILLATORTYPE_LSE)
20007e1c:	687b      	ldr	r3, [r7, #4]
20007e1e:	681b      	ldr	r3, [r3, #0]
20007e20:	f003 0304 	and.w	r3, r3, #4
20007e24:	2b00      	cmp	r3, #0
20007e26:	f000 80ab 	beq.w	20007f80 <HAL_RCC_OscConfig+0x3ec>
  {
    FlagStatus       pwrclkchanged = RESET;
20007e2a:	2300      	movs	r3, #0
20007e2c:	77fb      	strb	r3, [r7, #31]
    /* Check the parameters */
    assert_param(IS_RCC_LSE(RCC_OscInitStruct->LSEState));

    /* Update LSE configuration in Backup Domain control register    */
    /* Requires to enable write access to Backup Domain if necessary */
    if (__HAL_RCC_PWR_IS_CLK_DISABLED() != 0U)
20007e2e:	4b04      	ldr	r3, [pc, #16]	; (20007e40 <HAL_RCC_OscConfig+0x2ac>)
20007e30:	6d9b      	ldr	r3, [r3, #88]	; 0x58
20007e32:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
20007e36:	2b00      	cmp	r3, #0
20007e38:	d106      	bne.n	20007e48 <HAL_RCC_OscConfig+0x2b4>
20007e3a:	2301      	movs	r3, #1
20007e3c:	e005      	b.n	20007e4a <HAL_RCC_OscConfig+0x2b6>
20007e3e:	bf00      	nop
20007e40:	40021000 	.word	0x40021000
20007e44:	200003f4 	.word	0x200003f4
20007e48:	2300      	movs	r3, #0
20007e4a:	2b00      	cmp	r3, #0
20007e4c:	d00d      	beq.n	20007e6a <HAL_RCC_OscConfig+0x2d6>
    {
      __HAL_RCC_PWR_CLK_ENABLE();
20007e4e:	4baf      	ldr	r3, [pc, #700]	; (2000810c <HAL_RCC_OscConfig+0x578>)
20007e50:	6d9b      	ldr	r3, [r3, #88]	; 0x58
20007e52:	4aae      	ldr	r2, [pc, #696]	; (2000810c <HAL_RCC_OscConfig+0x578>)
20007e54:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
20007e58:	6593      	str	r3, [r2, #88]	; 0x58
20007e5a:	4bac      	ldr	r3, [pc, #688]	; (2000810c <HAL_RCC_OscConfig+0x578>)
20007e5c:	6d9b      	ldr	r3, [r3, #88]	; 0x58
20007e5e:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
20007e62:	60fb      	str	r3, [r7, #12]
20007e64:	68fb      	ldr	r3, [r7, #12]
      pwrclkchanged = SET;
20007e66:	2301      	movs	r3, #1
20007e68:	77fb      	strb	r3, [r7, #31]
    }

    if (HAL_IS_BIT_CLR(PWR->CR1, PWR_CR1_DBP))
20007e6a:	4ba9      	ldr	r3, [pc, #676]	; (20008110 <HAL_RCC_OscConfig+0x57c>)
20007e6c:	681b      	ldr	r3, [r3, #0]
20007e6e:	f403 7380 	and.w	r3, r3, #256	; 0x100
20007e72:	2b00      	cmp	r3, #0
20007e74:	d118      	bne.n	20007ea8 <HAL_RCC_OscConfig+0x314>
    {
      /* Enable write access to Backup domain */
      SET_BIT(PWR->CR1, PWR_CR1_DBP);
20007e76:	4ba6      	ldr	r3, [pc, #664]	; (20008110 <HAL_RCC_OscConfig+0x57c>)
20007e78:	681b      	ldr	r3, [r3, #0]
20007e7a:	4aa5      	ldr	r2, [pc, #660]	; (20008110 <HAL_RCC_OscConfig+0x57c>)
20007e7c:	f443 7380 	orr.w	r3, r3, #256	; 0x100
20007e80:	6013      	str	r3, [r2, #0]

      /* Wait for Backup domain Write protection disable */
      tickstart = HAL_GetTick();
20007e82:	f7f9 fd0b 	bl	2000189c <HAL_GetTick>
20007e86:	6138      	str	r0, [r7, #16]

      while (HAL_IS_BIT_CLR(PWR->CR1, PWR_CR1_DBP))
20007e88:	e008      	b.n	20007e9c <HAL_RCC_OscConfig+0x308>
      {
        if ((HAL_GetTick() - tickstart) > RCC_DBP_TIMEOUT_VALUE)
20007e8a:	f7f9 fd07 	bl	2000189c <HAL_GetTick>
20007e8e:	4602      	mov	r2, r0
20007e90:	693b      	ldr	r3, [r7, #16]
20007e92:	1ad3      	subs	r3, r2, r3
20007e94:	2b02      	cmp	r3, #2
20007e96:	d901      	bls.n	20007e9c <HAL_RCC_OscConfig+0x308>
        {
          return HAL_TIMEOUT;
20007e98:	2303      	movs	r3, #3
20007e9a:	e18d      	b.n	200081b8 <HAL_RCC_OscConfig+0x624>
      while (HAL_IS_BIT_CLR(PWR->CR1, PWR_CR1_DBP))
20007e9c:	4b9c      	ldr	r3, [pc, #624]	; (20008110 <HAL_RCC_OscConfig+0x57c>)
20007e9e:	681b      	ldr	r3, [r3, #0]
20007ea0:	f403 7380 	and.w	r3, r3, #256	; 0x100
20007ea4:	2b00      	cmp	r3, #0
20007ea6:	d0f0      	beq.n	20007e8a <HAL_RCC_OscConfig+0x2f6>
        }
      }
    }

    /* Set the new LSE configuration -----------------------------------------*/
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
20007ea8:	687b      	ldr	r3, [r7, #4]
20007eaa:	689b      	ldr	r3, [r3, #8]
20007eac:	2b01      	cmp	r3, #1
20007eae:	d108      	bne.n	20007ec2 <HAL_RCC_OscConfig+0x32e>
20007eb0:	4b96      	ldr	r3, [pc, #600]	; (2000810c <HAL_RCC_OscConfig+0x578>)
20007eb2:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
20007eb6:	4a95      	ldr	r2, [pc, #596]	; (2000810c <HAL_RCC_OscConfig+0x578>)
20007eb8:	f043 0301 	orr.w	r3, r3, #1
20007ebc:	f8c2 3090 	str.w	r3, [r2, #144]	; 0x90
20007ec0:	e024      	b.n	20007f0c <HAL_RCC_OscConfig+0x378>
20007ec2:	687b      	ldr	r3, [r7, #4]
20007ec4:	689b      	ldr	r3, [r3, #8]
20007ec6:	2b05      	cmp	r3, #5
20007ec8:	d110      	bne.n	20007eec <HAL_RCC_OscConfig+0x358>
20007eca:	4b90      	ldr	r3, [pc, #576]	; (2000810c <HAL_RCC_OscConfig+0x578>)
20007ecc:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
20007ed0:	4a8e      	ldr	r2, [pc, #568]	; (2000810c <HAL_RCC_OscConfig+0x578>)
20007ed2:	f043 0304 	orr.w	r3, r3, #4
20007ed6:	f8c2 3090 	str.w	r3, [r2, #144]	; 0x90
20007eda:	4b8c      	ldr	r3, [pc, #560]	; (2000810c <HAL_RCC_OscConfig+0x578>)
20007edc:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
20007ee0:	4a8a      	ldr	r2, [pc, #552]	; (2000810c <HAL_RCC_OscConfig+0x578>)
20007ee2:	f043 0301 	orr.w	r3, r3, #1
20007ee6:	f8c2 3090 	str.w	r3, [r2, #144]	; 0x90
20007eea:	e00f      	b.n	20007f0c <HAL_RCC_OscConfig+0x378>
20007eec:	4b87      	ldr	r3, [pc, #540]	; (2000810c <HAL_RCC_OscConfig+0x578>)
20007eee:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
20007ef2:	4a86      	ldr	r2, [pc, #536]	; (2000810c <HAL_RCC_OscConfig+0x578>)
20007ef4:	f023 0301 	bic.w	r3, r3, #1
20007ef8:	f8c2 3090 	str.w	r3, [r2, #144]	; 0x90
20007efc:	4b83      	ldr	r3, [pc, #524]	; (2000810c <HAL_RCC_OscConfig+0x578>)
20007efe:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
20007f02:	4a82      	ldr	r2, [pc, #520]	; (2000810c <HAL_RCC_OscConfig+0x578>)
20007f04:	f023 0304 	bic.w	r3, r3, #4
20007f08:	f8c2 3090 	str.w	r3, [r2, #144]	; 0x90

    /* Check the LSE State */
    if (RCC_OscInitStruct->LSEState != RCC_LSE_OFF)
20007f0c:	687b      	ldr	r3, [r7, #4]
20007f0e:	689b      	ldr	r3, [r3, #8]
20007f10:	2b00      	cmp	r3, #0
20007f12:	d016      	beq.n	20007f42 <HAL_RCC_OscConfig+0x3ae>
    {
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
20007f14:	f7f9 fcc2 	bl	2000189c <HAL_GetTick>
20007f18:	6138      	str	r0, [r7, #16]

      /* Wait till LSE is ready */
      while (READ_BIT(RCC->BDCR, RCC_BDCR_LSERDY) == 0U)
20007f1a:	e00a      	b.n	20007f32 <HAL_RCC_OscConfig+0x39e>
      {
        if((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
20007f1c:	f7f9 fcbe 	bl	2000189c <HAL_GetTick>
20007f20:	4602      	mov	r2, r0
20007f22:	693b      	ldr	r3, [r7, #16]
20007f24:	1ad3      	subs	r3, r2, r3
20007f26:	f241 3288 	movw	r2, #5000	; 0x1388
20007f2a:	4293      	cmp	r3, r2
20007f2c:	d901      	bls.n	20007f32 <HAL_RCC_OscConfig+0x39e>
        {
          return HAL_TIMEOUT;
20007f2e:	2303      	movs	r3, #3
20007f30:	e142      	b.n	200081b8 <HAL_RCC_OscConfig+0x624>
      while (READ_BIT(RCC->BDCR, RCC_BDCR_LSERDY) == 0U)
20007f32:	4b76      	ldr	r3, [pc, #472]	; (2000810c <HAL_RCC_OscConfig+0x578>)
20007f34:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
20007f38:	f003 0302 	and.w	r3, r3, #2
20007f3c:	2b00      	cmp	r3, #0
20007f3e:	d0ed      	beq.n	20007f1c <HAL_RCC_OscConfig+0x388>
20007f40:	e015      	b.n	20007f6e <HAL_RCC_OscConfig+0x3da>
      }
    }
    else
    {
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
20007f42:	f7f9 fcab 	bl	2000189c <HAL_GetTick>
20007f46:	6138      	str	r0, [r7, #16]

      /* Wait till LSE is disabled */
      while (READ_BIT(RCC->BDCR, RCC_BDCR_LSERDY) != 0U)
20007f48:	e00a      	b.n	20007f60 <HAL_RCC_OscConfig+0x3cc>
      {
        if((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
20007f4a:	f7f9 fca7 	bl	2000189c <HAL_GetTick>
20007f4e:	4602      	mov	r2, r0
20007f50:	693b      	ldr	r3, [r7, #16]
20007f52:	1ad3      	subs	r3, r2, r3
20007f54:	f241 3288 	movw	r2, #5000	; 0x1388
20007f58:	4293      	cmp	r3, r2
20007f5a:	d901      	bls.n	20007f60 <HAL_RCC_OscConfig+0x3cc>
        {
          return HAL_TIMEOUT;
20007f5c:	2303      	movs	r3, #3
20007f5e:	e12b      	b.n	200081b8 <HAL_RCC_OscConfig+0x624>
      while (READ_BIT(RCC->BDCR, RCC_BDCR_LSERDY) != 0U)
20007f60:	4b6a      	ldr	r3, [pc, #424]	; (2000810c <HAL_RCC_OscConfig+0x578>)
20007f62:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
20007f66:	f003 0302 	and.w	r3, r3, #2
20007f6a:	2b00      	cmp	r3, #0
20007f6c:	d1ed      	bne.n	20007f4a <HAL_RCC_OscConfig+0x3b6>
        }
      }
    }

    /* Restore clock configuration if changed */
    if (pwrclkchanged == SET)
20007f6e:	7ffb      	ldrb	r3, [r7, #31]
20007f70:	2b01      	cmp	r3, #1
20007f72:	d105      	bne.n	20007f80 <HAL_RCC_OscConfig+0x3ec>
    {
      __HAL_RCC_PWR_CLK_DISABLE();
20007f74:	4b65      	ldr	r3, [pc, #404]	; (2000810c <HAL_RCC_OscConfig+0x578>)
20007f76:	6d9b      	ldr	r3, [r3, #88]	; 0x58
20007f78:	4a64      	ldr	r2, [pc, #400]	; (2000810c <HAL_RCC_OscConfig+0x578>)
20007f7a:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
20007f7e:	6593      	str	r3, [r2, #88]	; 0x58
    }
  }

  /*------------------------------ HSI48 Configuration -----------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI48) == RCC_OSCILLATORTYPE_HSI48)
20007f80:	687b      	ldr	r3, [r7, #4]
20007f82:	681b      	ldr	r3, [r3, #0]
20007f84:	f003 0320 	and.w	r3, r3, #32
20007f88:	2b00      	cmp	r3, #0
20007f8a:	d03c      	beq.n	20008006 <HAL_RCC_OscConfig+0x472>
  {
    /* Check the parameters */
    assert_param(IS_RCC_HSI48(RCC_OscInitStruct->HSI48State));

    /* Check the HSI48 State */
    if(RCC_OscInitStruct->HSI48State != RCC_HSI48_OFF)
20007f8c:	687b      	ldr	r3, [r7, #4]
20007f8e:	699b      	ldr	r3, [r3, #24]
20007f90:	2b00      	cmp	r3, #0
20007f92:	d01c      	beq.n	20007fce <HAL_RCC_OscConfig+0x43a>
    {
      /* Enable the Internal Low Speed oscillator (HSI48). */
      __HAL_RCC_HSI48_ENABLE();
20007f94:	4b5d      	ldr	r3, [pc, #372]	; (2000810c <HAL_RCC_OscConfig+0x578>)
20007f96:	f8d3 3098 	ldr.w	r3, [r3, #152]	; 0x98
20007f9a:	4a5c      	ldr	r2, [pc, #368]	; (2000810c <HAL_RCC_OscConfig+0x578>)
20007f9c:	f043 0301 	orr.w	r3, r3, #1
20007fa0:	f8c2 3098 	str.w	r3, [r2, #152]	; 0x98

      /* Get Start Tick*/
      tickstart = HAL_GetTick();
20007fa4:	f7f9 fc7a 	bl	2000189c <HAL_GetTick>
20007fa8:	6138      	str	r0, [r7, #16]

      /* Wait till HSI48 is ready */
      while(READ_BIT(RCC->CRRCR, RCC_CRRCR_HSI48RDY) == 0U)
20007faa:	e008      	b.n	20007fbe <HAL_RCC_OscConfig+0x42a>
      {
        if((HAL_GetTick() - tickstart) > HSI48_TIMEOUT_VALUE)
20007fac:	f7f9 fc76 	bl	2000189c <HAL_GetTick>
20007fb0:	4602      	mov	r2, r0
20007fb2:	693b      	ldr	r3, [r7, #16]
20007fb4:	1ad3      	subs	r3, r2, r3
20007fb6:	2b02      	cmp	r3, #2
20007fb8:	d901      	bls.n	20007fbe <HAL_RCC_OscConfig+0x42a>
        {
          return HAL_TIMEOUT;
20007fba:	2303      	movs	r3, #3
20007fbc:	e0fc      	b.n	200081b8 <HAL_RCC_OscConfig+0x624>
      while(READ_BIT(RCC->CRRCR, RCC_CRRCR_HSI48RDY) == 0U)
20007fbe:	4b53      	ldr	r3, [pc, #332]	; (2000810c <HAL_RCC_OscConfig+0x578>)
20007fc0:	f8d3 3098 	ldr.w	r3, [r3, #152]	; 0x98
20007fc4:	f003 0302 	and.w	r3, r3, #2
20007fc8:	2b00      	cmp	r3, #0
20007fca:	d0ef      	beq.n	20007fac <HAL_RCC_OscConfig+0x418>
20007fcc:	e01b      	b.n	20008006 <HAL_RCC_OscConfig+0x472>
      }
    }
    else
    {
      /* Disable the Internal Low Speed oscillator (HSI48). */
      __HAL_RCC_HSI48_DISABLE();
20007fce:	4b4f      	ldr	r3, [pc, #316]	; (2000810c <HAL_RCC_OscConfig+0x578>)
20007fd0:	f8d3 3098 	ldr.w	r3, [r3, #152]	; 0x98
20007fd4:	4a4d      	ldr	r2, [pc, #308]	; (2000810c <HAL_RCC_OscConfig+0x578>)
20007fd6:	f023 0301 	bic.w	r3, r3, #1
20007fda:	f8c2 3098 	str.w	r3, [r2, #152]	; 0x98

      /* Get Start Tick*/
      tickstart = HAL_GetTick();
20007fde:	f7f9 fc5d 	bl	2000189c <HAL_GetTick>
20007fe2:	6138      	str	r0, [r7, #16]

      /* Wait till HSI48 is disabled */
      while(READ_BIT(RCC->CRRCR, RCC_CRRCR_HSI48RDY) != 0U)
20007fe4:	e008      	b.n	20007ff8 <HAL_RCC_OscConfig+0x464>
      {
        if((HAL_GetTick() - tickstart) > HSI48_TIMEOUT_VALUE)
20007fe6:	f7f9 fc59 	bl	2000189c <HAL_GetTick>
20007fea:	4602      	mov	r2, r0
20007fec:	693b      	ldr	r3, [r7, #16]
20007fee:	1ad3      	subs	r3, r2, r3
20007ff0:	2b02      	cmp	r3, #2
20007ff2:	d901      	bls.n	20007ff8 <HAL_RCC_OscConfig+0x464>
        {
          return HAL_TIMEOUT;
20007ff4:	2303      	movs	r3, #3
20007ff6:	e0df      	b.n	200081b8 <HAL_RCC_OscConfig+0x624>
      while(READ_BIT(RCC->CRRCR, RCC_CRRCR_HSI48RDY) != 0U)
20007ff8:	4b44      	ldr	r3, [pc, #272]	; (2000810c <HAL_RCC_OscConfig+0x578>)
20007ffa:	f8d3 3098 	ldr.w	r3, [r3, #152]	; 0x98
20007ffe:	f003 0302 	and.w	r3, r3, #2
20008002:	2b00      	cmp	r3, #0
20008004:	d1ef      	bne.n	20007fe6 <HAL_RCC_OscConfig+0x452>

  /*-------------------------------- PLL Configuration -----------------------*/
  /* Check the parameters */
  assert_param(IS_RCC_PLL(RCC_OscInitStruct->PLL.PLLState));

  if (RCC_OscInitStruct->PLL.PLLState != RCC_PLL_NONE)
20008006:	687b      	ldr	r3, [r7, #4]
20008008:	69db      	ldr	r3, [r3, #28]
2000800a:	2b00      	cmp	r3, #0
2000800c:	f000 80d3 	beq.w	200081b6 <HAL_RCC_OscConfig+0x622>
  {
    /* Check if the PLL is used as system clock or not */
    if (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_CFGR_SWS_PLL)
20008010:	4b3e      	ldr	r3, [pc, #248]	; (2000810c <HAL_RCC_OscConfig+0x578>)
20008012:	689b      	ldr	r3, [r3, #8]
20008014:	f003 030c 	and.w	r3, r3, #12
20008018:	2b0c      	cmp	r3, #12
2000801a:	f000 808d 	beq.w	20008138 <HAL_RCC_OscConfig+0x5a4>
    {
      if (RCC_OscInitStruct->PLL.PLLState == RCC_PLL_ON)
2000801e:	687b      	ldr	r3, [r7, #4]
20008020:	69db      	ldr	r3, [r3, #28]
20008022:	2b02      	cmp	r3, #2
20008024:	d15a      	bne.n	200080dc <HAL_RCC_OscConfig+0x548>
        assert_param(IS_RCC_PLLP_VALUE(RCC_OscInitStruct->PLL.PLLP));
        assert_param(IS_RCC_PLLQ_VALUE(RCC_OscInitStruct->PLL.PLLQ));
        assert_param(IS_RCC_PLLR_VALUE(RCC_OscInitStruct->PLL.PLLR));

        /* Disable the main PLL. */
        __HAL_RCC_PLL_DISABLE();
20008026:	4b39      	ldr	r3, [pc, #228]	; (2000810c <HAL_RCC_OscConfig+0x578>)
20008028:	681b      	ldr	r3, [r3, #0]
2000802a:	4a38      	ldr	r2, [pc, #224]	; (2000810c <HAL_RCC_OscConfig+0x578>)
2000802c:	f023 7380 	bic.w	r3, r3, #16777216	; 0x1000000
20008030:	6013      	str	r3, [r2, #0]

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
20008032:	f7f9 fc33 	bl	2000189c <HAL_GetTick>
20008036:	6138      	str	r0, [r7, #16]

        /* Wait till PLL is ready */
        while (READ_BIT(RCC->CR, RCC_CR_PLLRDY) != 0U)
20008038:	e008      	b.n	2000804c <HAL_RCC_OscConfig+0x4b8>
        {
          if ((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
2000803a:	f7f9 fc2f 	bl	2000189c <HAL_GetTick>
2000803e:	4602      	mov	r2, r0
20008040:	693b      	ldr	r3, [r7, #16]
20008042:	1ad3      	subs	r3, r2, r3
20008044:	2b02      	cmp	r3, #2
20008046:	d901      	bls.n	2000804c <HAL_RCC_OscConfig+0x4b8>
          {
            return HAL_TIMEOUT;
20008048:	2303      	movs	r3, #3
2000804a:	e0b5      	b.n	200081b8 <HAL_RCC_OscConfig+0x624>
        while (READ_BIT(RCC->CR, RCC_CR_PLLRDY) != 0U)
2000804c:	4b2f      	ldr	r3, [pc, #188]	; (2000810c <HAL_RCC_OscConfig+0x578>)
2000804e:	681b      	ldr	r3, [r3, #0]
20008050:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
20008054:	2b00      	cmp	r3, #0
20008056:	d1f0      	bne.n	2000803a <HAL_RCC_OscConfig+0x4a6>
          }
        }

        /* Configure the main PLL clock source, multiplication and division factors. */
        __HAL_RCC_PLL_CONFIG(RCC_OscInitStruct->PLL.PLLSource,
20008058:	4b2c      	ldr	r3, [pc, #176]	; (2000810c <HAL_RCC_OscConfig+0x578>)
2000805a:	68da      	ldr	r2, [r3, #12]
2000805c:	4b2d      	ldr	r3, [pc, #180]	; (20008114 <HAL_RCC_OscConfig+0x580>)
2000805e:	4013      	ands	r3, r2
20008060:	687a      	ldr	r2, [r7, #4]
20008062:	6a11      	ldr	r1, [r2, #32]
20008064:	687a      	ldr	r2, [r7, #4]
20008066:	6a52      	ldr	r2, [r2, #36]	; 0x24
20008068:	3a01      	subs	r2, #1
2000806a:	0112      	lsls	r2, r2, #4
2000806c:	4311      	orrs	r1, r2
2000806e:	687a      	ldr	r2, [r7, #4]
20008070:	6a92      	ldr	r2, [r2, #40]	; 0x28
20008072:	0212      	lsls	r2, r2, #8
20008074:	4311      	orrs	r1, r2
20008076:	687a      	ldr	r2, [r7, #4]
20008078:	6b12      	ldr	r2, [r2, #48]	; 0x30
2000807a:	0852      	lsrs	r2, r2, #1
2000807c:	3a01      	subs	r2, #1
2000807e:	0552      	lsls	r2, r2, #21
20008080:	4311      	orrs	r1, r2
20008082:	687a      	ldr	r2, [r7, #4]
20008084:	6b52      	ldr	r2, [r2, #52]	; 0x34
20008086:	0852      	lsrs	r2, r2, #1
20008088:	3a01      	subs	r2, #1
2000808a:	0652      	lsls	r2, r2, #25
2000808c:	4311      	orrs	r1, r2
2000808e:	687a      	ldr	r2, [r7, #4]
20008090:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
20008092:	06d2      	lsls	r2, r2, #27
20008094:	430a      	orrs	r2, r1
20008096:	491d      	ldr	r1, [pc, #116]	; (2000810c <HAL_RCC_OscConfig+0x578>)
20008098:	4313      	orrs	r3, r2
2000809a:	60cb      	str	r3, [r1, #12]
                             RCC_OscInitStruct->PLL.PLLP,
                             RCC_OscInitStruct->PLL.PLLQ,
                             RCC_OscInitStruct->PLL.PLLR);

        /* Enable the main PLL. */
        __HAL_RCC_PLL_ENABLE();
2000809c:	4b1b      	ldr	r3, [pc, #108]	; (2000810c <HAL_RCC_OscConfig+0x578>)
2000809e:	681b      	ldr	r3, [r3, #0]
200080a0:	4a1a      	ldr	r2, [pc, #104]	; (2000810c <HAL_RCC_OscConfig+0x578>)
200080a2:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
200080a6:	6013      	str	r3, [r2, #0]

        /* Enable PLL System Clock output. */
         __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_SYSCLK);
200080a8:	4b18      	ldr	r3, [pc, #96]	; (2000810c <HAL_RCC_OscConfig+0x578>)
200080aa:	68db      	ldr	r3, [r3, #12]
200080ac:	4a17      	ldr	r2, [pc, #92]	; (2000810c <HAL_RCC_OscConfig+0x578>)
200080ae:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
200080b2:	60d3      	str	r3, [r2, #12]

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
200080b4:	f7f9 fbf2 	bl	2000189c <HAL_GetTick>
200080b8:	6138      	str	r0, [r7, #16]

        /* Wait till PLL is ready */
        while (READ_BIT(RCC->CR, RCC_CR_PLLRDY) == 0U)
200080ba:	e008      	b.n	200080ce <HAL_RCC_OscConfig+0x53a>
        {
          if ((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
200080bc:	f7f9 fbee 	bl	2000189c <HAL_GetTick>
200080c0:	4602      	mov	r2, r0
200080c2:	693b      	ldr	r3, [r7, #16]
200080c4:	1ad3      	subs	r3, r2, r3
200080c6:	2b02      	cmp	r3, #2
200080c8:	d901      	bls.n	200080ce <HAL_RCC_OscConfig+0x53a>
          {
            return HAL_TIMEOUT;
200080ca:	2303      	movs	r3, #3
200080cc:	e074      	b.n	200081b8 <HAL_RCC_OscConfig+0x624>
        while (READ_BIT(RCC->CR, RCC_CR_PLLRDY) == 0U)
200080ce:	4b0f      	ldr	r3, [pc, #60]	; (2000810c <HAL_RCC_OscConfig+0x578>)
200080d0:	681b      	ldr	r3, [r3, #0]
200080d2:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
200080d6:	2b00      	cmp	r3, #0
200080d8:	d0f0      	beq.n	200080bc <HAL_RCC_OscConfig+0x528>
200080da:	e06c      	b.n	200081b6 <HAL_RCC_OscConfig+0x622>
        }
      }
      else
      {
        /* Disable the main PLL. */
        __HAL_RCC_PLL_DISABLE();
200080dc:	4b0b      	ldr	r3, [pc, #44]	; (2000810c <HAL_RCC_OscConfig+0x578>)
200080de:	681b      	ldr	r3, [r3, #0]
200080e0:	4a0a      	ldr	r2, [pc, #40]	; (2000810c <HAL_RCC_OscConfig+0x578>)
200080e2:	f023 7380 	bic.w	r3, r3, #16777216	; 0x1000000
200080e6:	6013      	str	r3, [r2, #0]

        /* Disable all PLL outputs to save power if no PLLs on */
          MODIFY_REG(RCC->PLLCFGR, RCC_PLLCFGR_PLLSRC, RCC_PLLSOURCE_NONE);
200080e8:	4b08      	ldr	r3, [pc, #32]	; (2000810c <HAL_RCC_OscConfig+0x578>)
200080ea:	68db      	ldr	r3, [r3, #12]
200080ec:	4a07      	ldr	r2, [pc, #28]	; (2000810c <HAL_RCC_OscConfig+0x578>)
200080ee:	f023 0303 	bic.w	r3, r3, #3
200080f2:	60d3      	str	r3, [r2, #12]
        __HAL_RCC_PLLCLKOUT_DISABLE(RCC_PLL_SYSCLK | RCC_PLL_48M1CLK | RCC_PLL_ADCCLK);
200080f4:	4b05      	ldr	r3, [pc, #20]	; (2000810c <HAL_RCC_OscConfig+0x578>)
200080f6:	68db      	ldr	r3, [r3, #12]
200080f8:	4a04      	ldr	r2, [pc, #16]	; (2000810c <HAL_RCC_OscConfig+0x578>)
200080fa:	f023 7388 	bic.w	r3, r3, #17825792	; 0x1100000
200080fe:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
20008102:	60d3      	str	r3, [r2, #12]

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
20008104:	f7f9 fbca 	bl	2000189c <HAL_GetTick>
20008108:	6138      	str	r0, [r7, #16]

        /* Wait till PLL is disabled */
        while (READ_BIT(RCC->CR, RCC_CR_PLLRDY) != 0U)
2000810a:	e00e      	b.n	2000812a <HAL_RCC_OscConfig+0x596>
2000810c:	40021000 	.word	0x40021000
20008110:	40007000 	.word	0x40007000
20008114:	019f800c 	.word	0x019f800c
        {
          if ((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
20008118:	f7f9 fbc0 	bl	2000189c <HAL_GetTick>
2000811c:	4602      	mov	r2, r0
2000811e:	693b      	ldr	r3, [r7, #16]
20008120:	1ad3      	subs	r3, r2, r3
20008122:	2b02      	cmp	r3, #2
20008124:	d901      	bls.n	2000812a <HAL_RCC_OscConfig+0x596>
          {
            return HAL_TIMEOUT;
20008126:	2303      	movs	r3, #3
20008128:	e046      	b.n	200081b8 <HAL_RCC_OscConfig+0x624>
        while (READ_BIT(RCC->CR, RCC_CR_PLLRDY) != 0U)
2000812a:	4b25      	ldr	r3, [pc, #148]	; (200081c0 <HAL_RCC_OscConfig+0x62c>)
2000812c:	681b      	ldr	r3, [r3, #0]
2000812e:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
20008132:	2b00      	cmp	r3, #0
20008134:	d1f0      	bne.n	20008118 <HAL_RCC_OscConfig+0x584>
20008136:	e03e      	b.n	200081b6 <HAL_RCC_OscConfig+0x622>
      }
    }
    else
    {
      /* Check if there is a request to disable the PLL used as System clock source */
      if((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_OFF)
20008138:	687b      	ldr	r3, [r7, #4]
2000813a:	69db      	ldr	r3, [r3, #28]
2000813c:	2b01      	cmp	r3, #1
2000813e:	d101      	bne.n	20008144 <HAL_RCC_OscConfig+0x5b0>
      {
        return HAL_ERROR;
20008140:	2301      	movs	r3, #1
20008142:	e039      	b.n	200081b8 <HAL_RCC_OscConfig+0x624>
      }
      else
      {
      /* Do not return HAL_ERROR if request repeats the current configuration */
      temp_pllckcfg = RCC->PLLCFGR;
20008144:	4b1e      	ldr	r3, [pc, #120]	; (200081c0 <HAL_RCC_OscConfig+0x62c>)
20008146:	68db      	ldr	r3, [r3, #12]
20008148:	617b      	str	r3, [r7, #20]
      if((READ_BIT(temp_pllckcfg, RCC_PLLCFGR_PLLSRC) != RCC_OscInitStruct->PLL.PLLSource) ||
2000814a:	697b      	ldr	r3, [r7, #20]
2000814c:	f003 0203 	and.w	r2, r3, #3
20008150:	687b      	ldr	r3, [r7, #4]
20008152:	6a1b      	ldr	r3, [r3, #32]
20008154:	429a      	cmp	r2, r3
20008156:	d12c      	bne.n	200081b2 <HAL_RCC_OscConfig+0x61e>
         (READ_BIT(temp_pllckcfg, RCC_PLLCFGR_PLLM) != (((RCC_OscInitStruct->PLL.PLLM) - 1U) << RCC_PLLCFGR_PLLM_Pos)) ||
20008158:	697b      	ldr	r3, [r7, #20]
2000815a:	f003 02f0 	and.w	r2, r3, #240	; 0xf0
2000815e:	687b      	ldr	r3, [r7, #4]
20008160:	6a5b      	ldr	r3, [r3, #36]	; 0x24
20008162:	3b01      	subs	r3, #1
20008164:	011b      	lsls	r3, r3, #4
      if((READ_BIT(temp_pllckcfg, RCC_PLLCFGR_PLLSRC) != RCC_OscInitStruct->PLL.PLLSource) ||
20008166:	429a      	cmp	r2, r3
20008168:	d123      	bne.n	200081b2 <HAL_RCC_OscConfig+0x61e>
         (READ_BIT(temp_pllckcfg, RCC_PLLCFGR_PLLN) != ((RCC_OscInitStruct->PLL.PLLN) << RCC_PLLCFGR_PLLN_Pos)) ||
2000816a:	697b      	ldr	r3, [r7, #20]
2000816c:	f403 42fe 	and.w	r2, r3, #32512	; 0x7f00
20008170:	687b      	ldr	r3, [r7, #4]
20008172:	6a9b      	ldr	r3, [r3, #40]	; 0x28
20008174:	021b      	lsls	r3, r3, #8
         (READ_BIT(temp_pllckcfg, RCC_PLLCFGR_PLLM) != (((RCC_OscInitStruct->PLL.PLLM) - 1U) << RCC_PLLCFGR_PLLM_Pos)) ||
20008176:	429a      	cmp	r2, r3
20008178:	d11b      	bne.n	200081b2 <HAL_RCC_OscConfig+0x61e>
         (READ_BIT(temp_pllckcfg, RCC_PLLCFGR_PLLPDIV) != ((RCC_OscInitStruct->PLL.PLLP) << RCC_PLLCFGR_PLLPDIV_Pos)) ||
2000817a:	697b      	ldr	r3, [r7, #20]
2000817c:	f003 4278 	and.w	r2, r3, #4160749568	; 0xf8000000
20008180:	687b      	ldr	r3, [r7, #4]
20008182:	6adb      	ldr	r3, [r3, #44]	; 0x2c
20008184:	06db      	lsls	r3, r3, #27
         (READ_BIT(temp_pllckcfg, RCC_PLLCFGR_PLLN) != ((RCC_OscInitStruct->PLL.PLLN) << RCC_PLLCFGR_PLLN_Pos)) ||
20008186:	429a      	cmp	r2, r3
20008188:	d113      	bne.n	200081b2 <HAL_RCC_OscConfig+0x61e>
         (READ_BIT(temp_pllckcfg, RCC_PLLCFGR_PLLQ) != ((((RCC_OscInitStruct->PLL.PLLQ) >> 1U) - 1U) << RCC_PLLCFGR_PLLQ_Pos)) ||
2000818a:	697b      	ldr	r3, [r7, #20]
2000818c:	f403 02c0 	and.w	r2, r3, #6291456	; 0x600000
20008190:	687b      	ldr	r3, [r7, #4]
20008192:	6b1b      	ldr	r3, [r3, #48]	; 0x30
20008194:	085b      	lsrs	r3, r3, #1
20008196:	3b01      	subs	r3, #1
20008198:	055b      	lsls	r3, r3, #21
         (READ_BIT(temp_pllckcfg, RCC_PLLCFGR_PLLPDIV) != ((RCC_OscInitStruct->PLL.PLLP) << RCC_PLLCFGR_PLLPDIV_Pos)) ||
2000819a:	429a      	cmp	r2, r3
2000819c:	d109      	bne.n	200081b2 <HAL_RCC_OscConfig+0x61e>
         (READ_BIT(temp_pllckcfg, RCC_PLLCFGR_PLLR) != ((((RCC_OscInitStruct->PLL.PLLR) >> 1U) - 1U) << RCC_PLLCFGR_PLLR_Pos)))
2000819e:	697b      	ldr	r3, [r7, #20]
200081a0:	f003 62c0 	and.w	r2, r3, #100663296	; 0x6000000
200081a4:	687b      	ldr	r3, [r7, #4]
200081a6:	6b5b      	ldr	r3, [r3, #52]	; 0x34
200081a8:	085b      	lsrs	r3, r3, #1
200081aa:	3b01      	subs	r3, #1
200081ac:	065b      	lsls	r3, r3, #25
         (READ_BIT(temp_pllckcfg, RCC_PLLCFGR_PLLQ) != ((((RCC_OscInitStruct->PLL.PLLQ) >> 1U) - 1U) << RCC_PLLCFGR_PLLQ_Pos)) ||
200081ae:	429a      	cmp	r2, r3
200081b0:	d001      	beq.n	200081b6 <HAL_RCC_OscConfig+0x622>
      {
        return HAL_ERROR;
200081b2:	2301      	movs	r3, #1
200081b4:	e000      	b.n	200081b8 <HAL_RCC_OscConfig+0x624>
      }
    }
  }
  }

  return HAL_OK;
200081b6:	2300      	movs	r3, #0
}
200081b8:	4618      	mov	r0, r3
200081ba:	3720      	adds	r7, #32
200081bc:	46bd      	mov	sp, r7
200081be:	bd80      	pop	{r7, pc}
200081c0:	40021000 	.word	0x40021000

200081c4 <HAL_RCC_ClockConfig>:
  *         HPRE[3:0] bits to ensure that HCLK not exceed the maximum allowed frequency
  *         (for more details refer to section above "Initialization/de-initialization functions")
  * @retval None
  */
HAL_StatusTypeDef HAL_RCC_ClockConfig(RCC_ClkInitTypeDef  *RCC_ClkInitStruct, uint32_t FLatency)
{
200081c4:	b580      	push	{r7, lr}
200081c6:	b086      	sub	sp, #24
200081c8:	af00      	add	r7, sp, #0
200081ca:	6078      	str	r0, [r7, #4]
200081cc:	6039      	str	r1, [r7, #0]
  uint32_t tickstart;
  uint32_t pllfreq;
  uint32_t hpre = RCC_SYSCLK_DIV1;
200081ce:	2300      	movs	r3, #0
200081d0:	617b      	str	r3, [r7, #20]

  /* Check Null pointer */
  if (RCC_ClkInitStruct == NULL)
200081d2:	687b      	ldr	r3, [r7, #4]
200081d4:	2b00      	cmp	r3, #0
200081d6:	d101      	bne.n	200081dc <HAL_RCC_ClockConfig+0x18>
  {
    return HAL_ERROR;
200081d8:	2301      	movs	r3, #1
200081da:	e11e      	b.n	2000841a <HAL_RCC_ClockConfig+0x256>
  /* To correctly read data from FLASH memory, the number of wait states (LATENCY)
    must be correctly programmed according to the frequency of the CPU clock
    (HCLK) and the supply voltage of the device. */

  /* Increasing the number of wait states because of higher CPU frequency */
  if (FLatency > __HAL_FLASH_GET_LATENCY())
200081dc:	4b91      	ldr	r3, [pc, #580]	; (20008424 <HAL_RCC_ClockConfig+0x260>)
200081de:	681b      	ldr	r3, [r3, #0]
200081e0:	f003 030f 	and.w	r3, r3, #15
200081e4:	683a      	ldr	r2, [r7, #0]
200081e6:	429a      	cmp	r2, r3
200081e8:	d910      	bls.n	2000820c <HAL_RCC_ClockConfig+0x48>
  {
    /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */
    __HAL_FLASH_SET_LATENCY(FLatency);
200081ea:	4b8e      	ldr	r3, [pc, #568]	; (20008424 <HAL_RCC_ClockConfig+0x260>)
200081ec:	681b      	ldr	r3, [r3, #0]
200081ee:	f023 020f 	bic.w	r2, r3, #15
200081f2:	498c      	ldr	r1, [pc, #560]	; (20008424 <HAL_RCC_ClockConfig+0x260>)
200081f4:	683b      	ldr	r3, [r7, #0]
200081f6:	4313      	orrs	r3, r2
200081f8:	600b      	str	r3, [r1, #0]

    /* Check that the new number of wait states is taken into account to access the Flash
    memory by reading the FLASH_ACR register */
    if (__HAL_FLASH_GET_LATENCY() != FLatency)
200081fa:	4b8a      	ldr	r3, [pc, #552]	; (20008424 <HAL_RCC_ClockConfig+0x260>)
200081fc:	681b      	ldr	r3, [r3, #0]
200081fe:	f003 030f 	and.w	r3, r3, #15
20008202:	683a      	ldr	r2, [r7, #0]
20008204:	429a      	cmp	r2, r3
20008206:	d001      	beq.n	2000820c <HAL_RCC_ClockConfig+0x48>
    {
      return HAL_ERROR;
20008208:	2301      	movs	r3, #1
2000820a:	e106      	b.n	2000841a <HAL_RCC_ClockConfig+0x256>
    }
  }

  /*------------------------- SYSCLK Configuration ---------------------------*/
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_SYSCLK) == RCC_CLOCKTYPE_SYSCLK)
2000820c:	687b      	ldr	r3, [r7, #4]
2000820e:	681b      	ldr	r3, [r3, #0]
20008210:	f003 0301 	and.w	r3, r3, #1
20008214:	2b00      	cmp	r3, #0
20008216:	d073      	beq.n	20008300 <HAL_RCC_ClockConfig+0x13c>
  {
    assert_param(IS_RCC_SYSCLKSOURCE(RCC_ClkInitStruct->SYSCLKSource));

    /* PLL is selected as System Clock Source */
    if (RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
20008218:	687b      	ldr	r3, [r7, #4]
2000821a:	685b      	ldr	r3, [r3, #4]
2000821c:	2b03      	cmp	r3, #3
2000821e:	d129      	bne.n	20008274 <HAL_RCC_ClockConfig+0xb0>
    {
      /* Check the PLL ready flag */
      if (READ_BIT(RCC->CR, RCC_CR_PLLRDY) == 0U)
20008220:	4b81      	ldr	r3, [pc, #516]	; (20008428 <HAL_RCC_ClockConfig+0x264>)
20008222:	681b      	ldr	r3, [r3, #0]
20008224:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
20008228:	2b00      	cmp	r3, #0
2000822a:	d101      	bne.n	20008230 <HAL_RCC_ClockConfig+0x6c>
      {
        return HAL_ERROR;
2000822c:	2301      	movs	r3, #1
2000822e:	e0f4      	b.n	2000841a <HAL_RCC_ClockConfig+0x256>
      }
      /* Undershoot management when selection PLL as SYSCLK source and frequency above 80Mhz */
      /* Compute target PLL output frequency */
      pllfreq = RCC_GetSysClockFreqFromPLLSource();
20008230:	f000 fb06 	bl	20008840 <RCC_GetSysClockFreqFromPLLSource>
20008234:	6138      	str	r0, [r7, #16]

      /* Intermediate step with HCLK prescaler 2 necessary before to go over 80Mhz */
      if(pllfreq > 80000000U)
20008236:	693b      	ldr	r3, [r7, #16]
20008238:	4a7c      	ldr	r2, [pc, #496]	; (2000842c <HAL_RCC_ClockConfig+0x268>)
2000823a:	4293      	cmp	r3, r2
2000823c:	d93f      	bls.n	200082be <HAL_RCC_ClockConfig+0xfa>
      {
        if (((READ_BIT(RCC->CFGR, RCC_CFGR_HPRE) == RCC_SYSCLK_DIV1)) ||
2000823e:	4b7a      	ldr	r3, [pc, #488]	; (20008428 <HAL_RCC_ClockConfig+0x264>)
20008240:	689b      	ldr	r3, [r3, #8]
20008242:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
20008246:	2b00      	cmp	r3, #0
20008248:	d009      	beq.n	2000825e <HAL_RCC_ClockConfig+0x9a>
            (((((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK) &&
2000824a:	687b      	ldr	r3, [r7, #4]
2000824c:	681b      	ldr	r3, [r3, #0]
2000824e:	f003 0302 	and.w	r3, r3, #2
        if (((READ_BIT(RCC->CFGR, RCC_CFGR_HPRE) == RCC_SYSCLK_DIV1)) ||
20008252:	2b00      	cmp	r3, #0
20008254:	d033      	beq.n	200082be <HAL_RCC_ClockConfig+0xfa>
              (RCC_ClkInitStruct->AHBCLKDivider == RCC_SYSCLK_DIV1))))
20008256:	687b      	ldr	r3, [r7, #4]
20008258:	689b      	ldr	r3, [r3, #8]
            (((((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK) &&
2000825a:	2b00      	cmp	r3, #0
2000825c:	d12f      	bne.n	200082be <HAL_RCC_ClockConfig+0xfa>
        {
          MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, RCC_SYSCLK_DIV2);
2000825e:	4b72      	ldr	r3, [pc, #456]	; (20008428 <HAL_RCC_ClockConfig+0x264>)
20008260:	689b      	ldr	r3, [r3, #8]
20008262:	f023 03f0 	bic.w	r3, r3, #240	; 0xf0
20008266:	4a70      	ldr	r2, [pc, #448]	; (20008428 <HAL_RCC_ClockConfig+0x264>)
20008268:	f043 0380 	orr.w	r3, r3, #128	; 0x80
2000826c:	6093      	str	r3, [r2, #8]
          hpre = RCC_SYSCLK_DIV2;
2000826e:	2380      	movs	r3, #128	; 0x80
20008270:	617b      	str	r3, [r7, #20]
20008272:	e024      	b.n	200082be <HAL_RCC_ClockConfig+0xfa>
      }
    }
    else
    {
      /* HSE is selected as System Clock Source */
      if (RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
20008274:	687b      	ldr	r3, [r7, #4]
20008276:	685b      	ldr	r3, [r3, #4]
20008278:	2b02      	cmp	r3, #2
2000827a:	d107      	bne.n	2000828c <HAL_RCC_ClockConfig+0xc8>
      {
        /* Check the HSE ready flag */
        if(READ_BIT(RCC->CR, RCC_CR_HSERDY) == 0U)
2000827c:	4b6a      	ldr	r3, [pc, #424]	; (20008428 <HAL_RCC_ClockConfig+0x264>)
2000827e:	681b      	ldr	r3, [r3, #0]
20008280:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
20008284:	2b00      	cmp	r3, #0
20008286:	d109      	bne.n	2000829c <HAL_RCC_ClockConfig+0xd8>
        {
          return HAL_ERROR;
20008288:	2301      	movs	r3, #1
2000828a:	e0c6      	b.n	2000841a <HAL_RCC_ClockConfig+0x256>
      }
      /* HSI is selected as System Clock Source */
      else
      {
        /* Check the HSI ready flag */
        if(READ_BIT(RCC->CR, RCC_CR_HSIRDY) == 0U)
2000828c:	4b66      	ldr	r3, [pc, #408]	; (20008428 <HAL_RCC_ClockConfig+0x264>)
2000828e:	681b      	ldr	r3, [r3, #0]
20008290:	f403 6380 	and.w	r3, r3, #1024	; 0x400
20008294:	2b00      	cmp	r3, #0
20008296:	d101      	bne.n	2000829c <HAL_RCC_ClockConfig+0xd8>
        {
          return HAL_ERROR;
20008298:	2301      	movs	r3, #1
2000829a:	e0be      	b.n	2000841a <HAL_RCC_ClockConfig+0x256>
        }
      }
      /* Overshoot management when going down from PLL as SYSCLK source and frequency above 80Mhz */
      pllfreq = HAL_RCC_GetSysClockFreq();
2000829c:	f000 f902 	bl	200084a4 <HAL_RCC_GetSysClockFreq>
200082a0:	6138      	str	r0, [r7, #16]

      /* Intermediate step with HCLK prescaler 2 necessary before to go under 80Mhz */
      if(pllfreq > 80000000U)
200082a2:	693b      	ldr	r3, [r7, #16]
200082a4:	4a61      	ldr	r2, [pc, #388]	; (2000842c <HAL_RCC_ClockConfig+0x268>)
200082a6:	4293      	cmp	r3, r2
200082a8:	d909      	bls.n	200082be <HAL_RCC_ClockConfig+0xfa>
      {
        MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, RCC_SYSCLK_DIV2);
200082aa:	4b5f      	ldr	r3, [pc, #380]	; (20008428 <HAL_RCC_ClockConfig+0x264>)
200082ac:	689b      	ldr	r3, [r3, #8]
200082ae:	f023 03f0 	bic.w	r3, r3, #240	; 0xf0
200082b2:	4a5d      	ldr	r2, [pc, #372]	; (20008428 <HAL_RCC_ClockConfig+0x264>)
200082b4:	f043 0380 	orr.w	r3, r3, #128	; 0x80
200082b8:	6093      	str	r3, [r2, #8]
        hpre = RCC_SYSCLK_DIV2;
200082ba:	2380      	movs	r3, #128	; 0x80
200082bc:	617b      	str	r3, [r7, #20]
      }

    }

    MODIFY_REG(RCC->CFGR, RCC_CFGR_SW, RCC_ClkInitStruct->SYSCLKSource);
200082be:	4b5a      	ldr	r3, [pc, #360]	; (20008428 <HAL_RCC_ClockConfig+0x264>)
200082c0:	689b      	ldr	r3, [r3, #8]
200082c2:	f023 0203 	bic.w	r2, r3, #3
200082c6:	687b      	ldr	r3, [r7, #4]
200082c8:	685b      	ldr	r3, [r3, #4]
200082ca:	4957      	ldr	r1, [pc, #348]	; (20008428 <HAL_RCC_ClockConfig+0x264>)
200082cc:	4313      	orrs	r3, r2
200082ce:	608b      	str	r3, [r1, #8]

    /* Get Start Tick*/
    tickstart = HAL_GetTick();
200082d0:	f7f9 fae4 	bl	2000189c <HAL_GetTick>
200082d4:	60f8      	str	r0, [r7, #12]

    while (__HAL_RCC_GET_SYSCLK_SOURCE() != (RCC_ClkInitStruct->SYSCLKSource << RCC_CFGR_SWS_Pos))
200082d6:	e00a      	b.n	200082ee <HAL_RCC_ClockConfig+0x12a>
    {
      if ((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
200082d8:	f7f9 fae0 	bl	2000189c <HAL_GetTick>
200082dc:	4602      	mov	r2, r0
200082de:	68fb      	ldr	r3, [r7, #12]
200082e0:	1ad3      	subs	r3, r2, r3
200082e2:	f241 3288 	movw	r2, #5000	; 0x1388
200082e6:	4293      	cmp	r3, r2
200082e8:	d901      	bls.n	200082ee <HAL_RCC_ClockConfig+0x12a>
      {
        return HAL_TIMEOUT;
200082ea:	2303      	movs	r3, #3
200082ec:	e095      	b.n	2000841a <HAL_RCC_ClockConfig+0x256>
    while (__HAL_RCC_GET_SYSCLK_SOURCE() != (RCC_ClkInitStruct->SYSCLKSource << RCC_CFGR_SWS_Pos))
200082ee:	4b4e      	ldr	r3, [pc, #312]	; (20008428 <HAL_RCC_ClockConfig+0x264>)
200082f0:	689b      	ldr	r3, [r3, #8]
200082f2:	f003 020c 	and.w	r2, r3, #12
200082f6:	687b      	ldr	r3, [r7, #4]
200082f8:	685b      	ldr	r3, [r3, #4]
200082fa:	009b      	lsls	r3, r3, #2
200082fc:	429a      	cmp	r2, r3
200082fe:	d1eb      	bne.n	200082d8 <HAL_RCC_ClockConfig+0x114>
      }
    }
  }

  /*-------------------------- HCLK Configuration --------------------------*/
  if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
20008300:	687b      	ldr	r3, [r7, #4]
20008302:	681b      	ldr	r3, [r3, #0]
20008304:	f003 0302 	and.w	r3, r3, #2
20008308:	2b00      	cmp	r3, #0
2000830a:	d023      	beq.n	20008354 <HAL_RCC_ClockConfig+0x190>
  {
    /* Set the highest APB divider in order to ensure that we do not go through
       a non-spec phase whatever we decrease or increase HCLK. */
    if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
2000830c:	687b      	ldr	r3, [r7, #4]
2000830e:	681b      	ldr	r3, [r3, #0]
20008310:	f003 0304 	and.w	r3, r3, #4
20008314:	2b00      	cmp	r3, #0
20008316:	d005      	beq.n	20008324 <HAL_RCC_ClockConfig+0x160>
    {
      MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE1, RCC_HCLK_DIV16);
20008318:	4b43      	ldr	r3, [pc, #268]	; (20008428 <HAL_RCC_ClockConfig+0x264>)
2000831a:	689b      	ldr	r3, [r3, #8]
2000831c:	4a42      	ldr	r2, [pc, #264]	; (20008428 <HAL_RCC_ClockConfig+0x264>)
2000831e:	f443 63e0 	orr.w	r3, r3, #1792	; 0x700
20008322:	6093      	str	r3, [r2, #8]
    }
    if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
20008324:	687b      	ldr	r3, [r7, #4]
20008326:	681b      	ldr	r3, [r3, #0]
20008328:	f003 0308 	and.w	r3, r3, #8
2000832c:	2b00      	cmp	r3, #0
2000832e:	d007      	beq.n	20008340 <HAL_RCC_ClockConfig+0x17c>
    {
      MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE2, RCC_HCLK_DIV16);
20008330:	4b3d      	ldr	r3, [pc, #244]	; (20008428 <HAL_RCC_ClockConfig+0x264>)
20008332:	689b      	ldr	r3, [r3, #8]
20008334:	f423 537c 	bic.w	r3, r3, #16128	; 0x3f00
20008338:	4a3b      	ldr	r2, [pc, #236]	; (20008428 <HAL_RCC_ClockConfig+0x264>)
2000833a:	f443 63e0 	orr.w	r3, r3, #1792	; 0x700
2000833e:	6093      	str	r3, [r2, #8]
    }

    /* Set the new HCLK clock divider */
    assert_param(IS_RCC_HCLK(RCC_ClkInitStruct->AHBCLKDivider));
    MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, RCC_ClkInitStruct->AHBCLKDivider);
20008340:	4b39      	ldr	r3, [pc, #228]	; (20008428 <HAL_RCC_ClockConfig+0x264>)
20008342:	689b      	ldr	r3, [r3, #8]
20008344:	f023 02f0 	bic.w	r2, r3, #240	; 0xf0
20008348:	687b      	ldr	r3, [r7, #4]
2000834a:	689b      	ldr	r3, [r3, #8]
2000834c:	4936      	ldr	r1, [pc, #216]	; (20008428 <HAL_RCC_ClockConfig+0x264>)
2000834e:	4313      	orrs	r3, r2
20008350:	608b      	str	r3, [r1, #8]
20008352:	e008      	b.n	20008366 <HAL_RCC_ClockConfig+0x1a2>
  }
  else
  {
    /* Is intermediate HCLK prescaler 2 applied internally, complete with HCLK prescaler 1 */
    if(hpre == RCC_SYSCLK_DIV2)
20008354:	697b      	ldr	r3, [r7, #20]
20008356:	2b80      	cmp	r3, #128	; 0x80
20008358:	d105      	bne.n	20008366 <HAL_RCC_ClockConfig+0x1a2>
    {
      MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, RCC_SYSCLK_DIV1);
2000835a:	4b33      	ldr	r3, [pc, #204]	; (20008428 <HAL_RCC_ClockConfig+0x264>)
2000835c:	689b      	ldr	r3, [r3, #8]
2000835e:	4a32      	ldr	r2, [pc, #200]	; (20008428 <HAL_RCC_ClockConfig+0x264>)
20008360:	f023 03f0 	bic.w	r3, r3, #240	; 0xf0
20008364:	6093      	str	r3, [r2, #8]
    }
  }

  /* Decreasing the number of wait states because of lower CPU frequency */
  if (FLatency < __HAL_FLASH_GET_LATENCY())
20008366:	4b2f      	ldr	r3, [pc, #188]	; (20008424 <HAL_RCC_ClockConfig+0x260>)
20008368:	681b      	ldr	r3, [r3, #0]
2000836a:	f003 030f 	and.w	r3, r3, #15
2000836e:	683a      	ldr	r2, [r7, #0]
20008370:	429a      	cmp	r2, r3
20008372:	d21d      	bcs.n	200083b0 <HAL_RCC_ClockConfig+0x1ec>
  {
    /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */
    __HAL_FLASH_SET_LATENCY(FLatency);
20008374:	4b2b      	ldr	r3, [pc, #172]	; (20008424 <HAL_RCC_ClockConfig+0x260>)
20008376:	681b      	ldr	r3, [r3, #0]
20008378:	f023 020f 	bic.w	r2, r3, #15
2000837c:	4929      	ldr	r1, [pc, #164]	; (20008424 <HAL_RCC_ClockConfig+0x260>)
2000837e:	683b      	ldr	r3, [r7, #0]
20008380:	4313      	orrs	r3, r2
20008382:	600b      	str	r3, [r1, #0]

    /* Check that the new number of wait states is taken into account to access the Flash
    memory by polling the FLASH_ACR register */
    tickstart = HAL_GetTick();
20008384:	f7f9 fa8a 	bl	2000189c <HAL_GetTick>
20008388:	60f8      	str	r0, [r7, #12]

    while (__HAL_FLASH_GET_LATENCY() != FLatency)
2000838a:	e00a      	b.n	200083a2 <HAL_RCC_ClockConfig+0x1de>
    {
      if ((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
2000838c:	f7f9 fa86 	bl	2000189c <HAL_GetTick>
20008390:	4602      	mov	r2, r0
20008392:	68fb      	ldr	r3, [r7, #12]
20008394:	1ad3      	subs	r3, r2, r3
20008396:	f241 3288 	movw	r2, #5000	; 0x1388
2000839a:	4293      	cmp	r3, r2
2000839c:	d901      	bls.n	200083a2 <HAL_RCC_ClockConfig+0x1de>
      {
        return HAL_TIMEOUT;
2000839e:	2303      	movs	r3, #3
200083a0:	e03b      	b.n	2000841a <HAL_RCC_ClockConfig+0x256>
    while (__HAL_FLASH_GET_LATENCY() != FLatency)
200083a2:	4b20      	ldr	r3, [pc, #128]	; (20008424 <HAL_RCC_ClockConfig+0x260>)
200083a4:	681b      	ldr	r3, [r3, #0]
200083a6:	f003 030f 	and.w	r3, r3, #15
200083aa:	683a      	ldr	r2, [r7, #0]
200083ac:	429a      	cmp	r2, r3
200083ae:	d1ed      	bne.n	2000838c <HAL_RCC_ClockConfig+0x1c8>
      }
    }
  }

  /*-------------------------- PCLK1 Configuration ---------------------------*/
  if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
200083b0:	687b      	ldr	r3, [r7, #4]
200083b2:	681b      	ldr	r3, [r3, #0]
200083b4:	f003 0304 	and.w	r3, r3, #4
200083b8:	2b00      	cmp	r3, #0
200083ba:	d008      	beq.n	200083ce <HAL_RCC_ClockConfig+0x20a>
  {
    assert_param(IS_RCC_PCLK(RCC_ClkInitStruct->APB1CLKDivider));
    MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE1, RCC_ClkInitStruct->APB1CLKDivider);
200083bc:	4b1a      	ldr	r3, [pc, #104]	; (20008428 <HAL_RCC_ClockConfig+0x264>)
200083be:	689b      	ldr	r3, [r3, #8]
200083c0:	f423 62e0 	bic.w	r2, r3, #1792	; 0x700
200083c4:	687b      	ldr	r3, [r7, #4]
200083c6:	68db      	ldr	r3, [r3, #12]
200083c8:	4917      	ldr	r1, [pc, #92]	; (20008428 <HAL_RCC_ClockConfig+0x264>)
200083ca:	4313      	orrs	r3, r2
200083cc:	608b      	str	r3, [r1, #8]
  }

  /*-------------------------- PCLK2 Configuration ---------------------------*/
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
200083ce:	687b      	ldr	r3, [r7, #4]
200083d0:	681b      	ldr	r3, [r3, #0]
200083d2:	f003 0308 	and.w	r3, r3, #8
200083d6:	2b00      	cmp	r3, #0
200083d8:	d009      	beq.n	200083ee <HAL_RCC_ClockConfig+0x22a>
  {
    assert_param(IS_RCC_PCLK(RCC_ClkInitStruct->APB2CLKDivider));
    MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE2, ((RCC_ClkInitStruct->APB2CLKDivider) << 3U));
200083da:	4b13      	ldr	r3, [pc, #76]	; (20008428 <HAL_RCC_ClockConfig+0x264>)
200083dc:	689b      	ldr	r3, [r3, #8]
200083de:	f423 5260 	bic.w	r2, r3, #14336	; 0x3800
200083e2:	687b      	ldr	r3, [r7, #4]
200083e4:	691b      	ldr	r3, [r3, #16]
200083e6:	00db      	lsls	r3, r3, #3
200083e8:	490f      	ldr	r1, [pc, #60]	; (20008428 <HAL_RCC_ClockConfig+0x264>)
200083ea:	4313      	orrs	r3, r2
200083ec:	608b      	str	r3, [r1, #8]
  }

  /* Update the SystemCoreClock global variable */
  SystemCoreClock = HAL_RCC_GetSysClockFreq() >> (AHBPrescTable[READ_BIT(RCC->CFGR, RCC_CFGR_HPRE) >> RCC_CFGR_HPRE_Pos] & 0x1FU);
200083ee:	f000 f859 	bl	200084a4 <HAL_RCC_GetSysClockFreq>
200083f2:	4602      	mov	r2, r0
200083f4:	4b0c      	ldr	r3, [pc, #48]	; (20008428 <HAL_RCC_ClockConfig+0x264>)
200083f6:	689b      	ldr	r3, [r3, #8]
200083f8:	091b      	lsrs	r3, r3, #4
200083fa:	f003 030f 	and.w	r3, r3, #15
200083fe:	490c      	ldr	r1, [pc, #48]	; (20008430 <HAL_RCC_ClockConfig+0x26c>)
20008400:	5ccb      	ldrb	r3, [r1, r3]
20008402:	f003 031f 	and.w	r3, r3, #31
20008406:	fa22 f303 	lsr.w	r3, r2, r3
2000840a:	4a0a      	ldr	r2, [pc, #40]	; (20008434 <HAL_RCC_ClockConfig+0x270>)
2000840c:	6013      	str	r3, [r2, #0]

  /* Configure the source of time base considering new system clocks settings*/
  return HAL_InitTick(uwTickPrio);
2000840e:	4b0a      	ldr	r3, [pc, #40]	; (20008438 <HAL_RCC_ClockConfig+0x274>)
20008410:	681b      	ldr	r3, [r3, #0]
20008412:	4618      	mov	r0, r3
20008414:	f7f9 f9f6 	bl	20001804 <HAL_InitTick>
20008418:	4603      	mov	r3, r0
}
2000841a:	4618      	mov	r0, r3
2000841c:	3718      	adds	r7, #24
2000841e:	46bd      	mov	sp, r7
20008420:	bd80      	pop	{r7, pc}
20008422:	bf00      	nop
20008424:	40022000 	.word	0x40022000
20008428:	40021000 	.word	0x40021000
2000842c:	04c4b400 	.word	0x04c4b400
20008430:	2000a1f0 	.word	0x2000a1f0
20008434:	200003f0 	.word	0x200003f0
20008438:	200003f4 	.word	0x200003f4

2000843c <HAL_RCC_MCOConfig>:
  *            @arg @ref RCC_MCODIV_8  division by 8 applied to MCO clock
  *            @arg @ref RCC_MCODIV_16  division by 16 applied to MCO clock
  * @retval None
  */
void HAL_RCC_MCOConfig(uint32_t RCC_MCOx, uint32_t RCC_MCOSource, uint32_t RCC_MCODiv)
{
2000843c:	b580      	push	{r7, lr}
2000843e:	b08a      	sub	sp, #40	; 0x28
20008440:	af00      	add	r7, sp, #0
20008442:	60f8      	str	r0, [r7, #12]
20008444:	60b9      	str	r1, [r7, #8]
20008446:	607a      	str	r2, [r7, #4]

  /* Prevent unused argument(s) compilation warning if no assert_param check */
  UNUSED(RCC_MCOx);

  /* MCO Clock Enable */
  MCO1_CLK_ENABLE();
20008448:	4b15      	ldr	r3, [pc, #84]	; (200084a0 <HAL_RCC_MCOConfig+0x64>)
2000844a:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
2000844c:	4a14      	ldr	r2, [pc, #80]	; (200084a0 <HAL_RCC_MCOConfig+0x64>)
2000844e:	f043 0301 	orr.w	r3, r3, #1
20008452:	64d3      	str	r3, [r2, #76]	; 0x4c
20008454:	4b12      	ldr	r3, [pc, #72]	; (200084a0 <HAL_RCC_MCOConfig+0x64>)
20008456:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
20008458:	f003 0301 	and.w	r3, r3, #1
2000845c:	613b      	str	r3, [r7, #16]
2000845e:	693b      	ldr	r3, [r7, #16]

  /* Configure the MCO1 pin in alternate function mode */
  GPIO_InitStruct.Pin = MCO1_PIN;
20008460:	f44f 7380 	mov.w	r3, #256	; 0x100
20008464:	617b      	str	r3, [r7, #20]
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
20008466:	2302      	movs	r3, #2
20008468:	61bb      	str	r3, [r7, #24]
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
2000846a:	2303      	movs	r3, #3
2000846c:	623b      	str	r3, [r7, #32]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
2000846e:	2300      	movs	r3, #0
20008470:	61fb      	str	r3, [r7, #28]
  GPIO_InitStruct.Alternate = GPIO_AF0_MCO;
20008472:	2300      	movs	r3, #0
20008474:	627b      	str	r3, [r7, #36]	; 0x24
  HAL_GPIO_Init(MCO1_GPIO_PORT, &GPIO_InitStruct);
20008476:	f107 0314 	add.w	r3, r7, #20
2000847a:	4619      	mov	r1, r3
2000847c:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
20008480:	f7fc fb2a 	bl	20004ad8 <HAL_GPIO_Init>

  /* Mask MCOSEL[] and MCOPRE[] bits then set MCO1 clock source and prescaler */
  MODIFY_REG(RCC->CFGR, (RCC_CFGR_MCOSEL | RCC_CFGR_MCOPRE), (RCC_MCOSource | RCC_MCODiv));
20008484:	4b06      	ldr	r3, [pc, #24]	; (200084a0 <HAL_RCC_MCOConfig+0x64>)
20008486:	689b      	ldr	r3, [r3, #8]
20008488:	f023 42fe 	bic.w	r2, r3, #2130706432	; 0x7f000000
2000848c:	68b9      	ldr	r1, [r7, #8]
2000848e:	687b      	ldr	r3, [r7, #4]
20008490:	430b      	orrs	r3, r1
20008492:	4903      	ldr	r1, [pc, #12]	; (200084a0 <HAL_RCC_MCOConfig+0x64>)
20008494:	4313      	orrs	r3, r2
20008496:	608b      	str	r3, [r1, #8]
}
20008498:	bf00      	nop
2000849a:	3728      	adds	r7, #40	; 0x28
2000849c:	46bd      	mov	sp, r7
2000849e:	bd80      	pop	{r7, pc}
200084a0:	40021000 	.word	0x40021000

200084a4 <HAL_RCC_GetSysClockFreq>:
  *
  *
  * @retval SYSCLK frequency
  */
uint32_t HAL_RCC_GetSysClockFreq(void)
{
200084a4:	b480      	push	{r7}
200084a6:	b087      	sub	sp, #28
200084a8:	af00      	add	r7, sp, #0
  uint32_t pllvco, pllsource, pllr, pllm;
  uint32_t sysclockfreq;

  if (__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSI)
200084aa:	4b2c      	ldr	r3, [pc, #176]	; (2000855c <HAL_RCC_GetSysClockFreq+0xb8>)
200084ac:	689b      	ldr	r3, [r3, #8]
200084ae:	f003 030c 	and.w	r3, r3, #12
200084b2:	2b04      	cmp	r3, #4
200084b4:	d102      	bne.n	200084bc <HAL_RCC_GetSysClockFreq+0x18>
  {
    /* HSI used as system clock source */
    sysclockfreq = HSI_VALUE;
200084b6:	4b2a      	ldr	r3, [pc, #168]	; (20008560 <HAL_RCC_GetSysClockFreq+0xbc>)
200084b8:	613b      	str	r3, [r7, #16]
200084ba:	e047      	b.n	2000854c <HAL_RCC_GetSysClockFreq+0xa8>
  }
  else if (__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSE)
200084bc:	4b27      	ldr	r3, [pc, #156]	; (2000855c <HAL_RCC_GetSysClockFreq+0xb8>)
200084be:	689b      	ldr	r3, [r3, #8]
200084c0:	f003 030c 	and.w	r3, r3, #12
200084c4:	2b08      	cmp	r3, #8
200084c6:	d102      	bne.n	200084ce <HAL_RCC_GetSysClockFreq+0x2a>
  {
    /* HSE used as system clock source */
    sysclockfreq = HSE_VALUE;
200084c8:	4b26      	ldr	r3, [pc, #152]	; (20008564 <HAL_RCC_GetSysClockFreq+0xc0>)
200084ca:	613b      	str	r3, [r7, #16]
200084cc:	e03e      	b.n	2000854c <HAL_RCC_GetSysClockFreq+0xa8>
  }
  else if (__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL)
200084ce:	4b23      	ldr	r3, [pc, #140]	; (2000855c <HAL_RCC_GetSysClockFreq+0xb8>)
200084d0:	689b      	ldr	r3, [r3, #8]
200084d2:	f003 030c 	and.w	r3, r3, #12
200084d6:	2b0c      	cmp	r3, #12
200084d8:	d136      	bne.n	20008548 <HAL_RCC_GetSysClockFreq+0xa4>
    /* PLL used as system clock  source */

    /* PLL_VCO = ((HSE_VALUE or HSI_VALUE)/ PLLM) * PLLN
    SYSCLK = PLL_VCO / PLLR
    */
    pllsource = READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLSRC);
200084da:	4b20      	ldr	r3, [pc, #128]	; (2000855c <HAL_RCC_GetSysClockFreq+0xb8>)
200084dc:	68db      	ldr	r3, [r3, #12]
200084de:	f003 0303 	and.w	r3, r3, #3
200084e2:	60fb      	str	r3, [r7, #12]
    pllm = (READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLM) >> RCC_PLLCFGR_PLLM_Pos) + 1U ;
200084e4:	4b1d      	ldr	r3, [pc, #116]	; (2000855c <HAL_RCC_GetSysClockFreq+0xb8>)
200084e6:	68db      	ldr	r3, [r3, #12]
200084e8:	091b      	lsrs	r3, r3, #4
200084ea:	f003 030f 	and.w	r3, r3, #15
200084ee:	3301      	adds	r3, #1
200084f0:	60bb      	str	r3, [r7, #8]

    switch (pllsource)
200084f2:	68fb      	ldr	r3, [r7, #12]
200084f4:	2b03      	cmp	r3, #3
200084f6:	d10c      	bne.n	20008512 <HAL_RCC_GetSysClockFreq+0x6e>
    {
    case RCC_PLLSOURCE_HSE:  /* HSE used as PLL clock source */
      pllvco = (HSE_VALUE / pllm) * (READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos);
200084f8:	4a1a      	ldr	r2, [pc, #104]	; (20008564 <HAL_RCC_GetSysClockFreq+0xc0>)
200084fa:	68bb      	ldr	r3, [r7, #8]
200084fc:	fbb2 f3f3 	udiv	r3, r2, r3
20008500:	4a16      	ldr	r2, [pc, #88]	; (2000855c <HAL_RCC_GetSysClockFreq+0xb8>)
20008502:	68d2      	ldr	r2, [r2, #12]
20008504:	0a12      	lsrs	r2, r2, #8
20008506:	f002 027f 	and.w	r2, r2, #127	; 0x7f
2000850a:	fb02 f303 	mul.w	r3, r2, r3
2000850e:	617b      	str	r3, [r7, #20]
      break;
20008510:	e00c      	b.n	2000852c <HAL_RCC_GetSysClockFreq+0x88>

    case RCC_PLLSOURCE_HSI:  /* HSI used as PLL clock source */
    default:
      pllvco = (HSI_VALUE / pllm) * (READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos);
20008512:	4a13      	ldr	r2, [pc, #76]	; (20008560 <HAL_RCC_GetSysClockFreq+0xbc>)
20008514:	68bb      	ldr	r3, [r7, #8]
20008516:	fbb2 f3f3 	udiv	r3, r2, r3
2000851a:	4a10      	ldr	r2, [pc, #64]	; (2000855c <HAL_RCC_GetSysClockFreq+0xb8>)
2000851c:	68d2      	ldr	r2, [r2, #12]
2000851e:	0a12      	lsrs	r2, r2, #8
20008520:	f002 027f 	and.w	r2, r2, #127	; 0x7f
20008524:	fb02 f303 	mul.w	r3, r2, r3
20008528:	617b      	str	r3, [r7, #20]
      break;
2000852a:	bf00      	nop
    }
    pllr = ((READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLR) >> RCC_PLLCFGR_PLLR_Pos) + 1U ) * 2U;
2000852c:	4b0b      	ldr	r3, [pc, #44]	; (2000855c <HAL_RCC_GetSysClockFreq+0xb8>)
2000852e:	68db      	ldr	r3, [r3, #12]
20008530:	0e5b      	lsrs	r3, r3, #25
20008532:	f003 0303 	and.w	r3, r3, #3
20008536:	3301      	adds	r3, #1
20008538:	005b      	lsls	r3, r3, #1
2000853a:	607b      	str	r3, [r7, #4]
    sysclockfreq = pllvco/pllr;
2000853c:	697a      	ldr	r2, [r7, #20]
2000853e:	687b      	ldr	r3, [r7, #4]
20008540:	fbb2 f3f3 	udiv	r3, r2, r3
20008544:	613b      	str	r3, [r7, #16]
20008546:	e001      	b.n	2000854c <HAL_RCC_GetSysClockFreq+0xa8>
  }
  else
  {
    sysclockfreq = 0U;
20008548:	2300      	movs	r3, #0
2000854a:	613b      	str	r3, [r7, #16]
  }

  return sysclockfreq;
2000854c:	693b      	ldr	r3, [r7, #16]
}
2000854e:	4618      	mov	r0, r3
20008550:	371c      	adds	r7, #28
20008552:	46bd      	mov	sp, r7
20008554:	f85d 7b04 	ldr.w	r7, [sp], #4
20008558:	4770      	bx	lr
2000855a:	bf00      	nop
2000855c:	40021000 	.word	0x40021000
20008560:	00f42400 	.word	0x00f42400
20008564:	007a1200 	.word	0x007a1200

20008568 <HAL_RCC_GetHCLKFreq>:
  *
  * @note   The SystemCoreClock CMSIS variable is used to store System Clock Frequency.
  * @retval HCLK frequency in Hz
  */
uint32_t HAL_RCC_GetHCLKFreq(void)
{
20008568:	b480      	push	{r7}
2000856a:	af00      	add	r7, sp, #0
  return SystemCoreClock;
2000856c:	4b03      	ldr	r3, [pc, #12]	; (2000857c <HAL_RCC_GetHCLKFreq+0x14>)
2000856e:	681b      	ldr	r3, [r3, #0]
}
20008570:	4618      	mov	r0, r3
20008572:	46bd      	mov	sp, r7
20008574:	f85d 7b04 	ldr.w	r7, [sp], #4
20008578:	4770      	bx	lr
2000857a:	bf00      	nop
2000857c:	200003f0 	.word	0x200003f0

20008580 <HAL_RCC_GetPCLK1Freq>:
  * @note   Each time PCLK1 changes, this function must be called to update the
  *         right PCLK1 value. Otherwise, any configuration based on this function will be incorrect.
  * @retval PCLK1 frequency in Hz
  */
uint32_t HAL_RCC_GetPCLK1Freq(void)
{
20008580:	b580      	push	{r7, lr}
20008582:	af00      	add	r7, sp, #0
  /* Get HCLK source and Compute PCLK1 frequency ---------------------------*/
  return (HAL_RCC_GetHCLKFreq() >> (APBPrescTable[READ_BIT(RCC->CFGR, RCC_CFGR_PPRE1) >> RCC_CFGR_PPRE1_Pos] & 0x1FU));
20008584:	f7ff fff0 	bl	20008568 <HAL_RCC_GetHCLKFreq>
20008588:	4602      	mov	r2, r0
2000858a:	4b06      	ldr	r3, [pc, #24]	; (200085a4 <HAL_RCC_GetPCLK1Freq+0x24>)
2000858c:	689b      	ldr	r3, [r3, #8]
2000858e:	0a1b      	lsrs	r3, r3, #8
20008590:	f003 0307 	and.w	r3, r3, #7
20008594:	4904      	ldr	r1, [pc, #16]	; (200085a8 <HAL_RCC_GetPCLK1Freq+0x28>)
20008596:	5ccb      	ldrb	r3, [r1, r3]
20008598:	f003 031f 	and.w	r3, r3, #31
2000859c:	fa22 f303 	lsr.w	r3, r2, r3
}
200085a0:	4618      	mov	r0, r3
200085a2:	bd80      	pop	{r7, pc}
200085a4:	40021000 	.word	0x40021000
200085a8:	2000a200 	.word	0x2000a200

200085ac <HAL_RCC_GetPCLK2Freq>:
  * @note   Each time PCLK2 changes, this function must be called to update the
  *         right PCLK2 value. Otherwise, any configuration based on this function will be incorrect.
  * @retval PCLK2 frequency in Hz
  */
uint32_t HAL_RCC_GetPCLK2Freq(void)
{
200085ac:	b580      	push	{r7, lr}
200085ae:	af00      	add	r7, sp, #0
  /* Get HCLK source and Compute PCLK2 frequency ---------------------------*/
  return (HAL_RCC_GetHCLKFreq()>> (APBPrescTable[READ_BIT(RCC->CFGR, RCC_CFGR_PPRE2) >> RCC_CFGR_PPRE2_Pos] & 0x1FU));
200085b0:	f7ff ffda 	bl	20008568 <HAL_RCC_GetHCLKFreq>
200085b4:	4602      	mov	r2, r0
200085b6:	4b06      	ldr	r3, [pc, #24]	; (200085d0 <HAL_RCC_GetPCLK2Freq+0x24>)
200085b8:	689b      	ldr	r3, [r3, #8]
200085ba:	0adb      	lsrs	r3, r3, #11
200085bc:	f003 0307 	and.w	r3, r3, #7
200085c0:	4904      	ldr	r1, [pc, #16]	; (200085d4 <HAL_RCC_GetPCLK2Freq+0x28>)
200085c2:	5ccb      	ldrb	r3, [r1, r3]
200085c4:	f003 031f 	and.w	r3, r3, #31
200085c8:	fa22 f303 	lsr.w	r3, r2, r3
}
200085cc:	4618      	mov	r0, r3
200085ce:	bd80      	pop	{r7, pc}
200085d0:	40021000 	.word	0x40021000
200085d4:	2000a200 	.word	0x2000a200

200085d8 <HAL_RCC_GetOscConfig>:
  * @param  RCC_OscInitStruct  pointer to an RCC_OscInitTypeDef structure that
  *         will be configured.
  * @retval None
  */
void HAL_RCC_GetOscConfig(RCC_OscInitTypeDef  *RCC_OscInitStruct)
{
200085d8:	b480      	push	{r7}
200085da:	b083      	sub	sp, #12
200085dc:	af00      	add	r7, sp, #0
200085de:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(RCC_OscInitStruct != (void *)NULL);

  /* Set all possible values for the Oscillator type parameter ---------------*/
  RCC_OscInitStruct->OscillatorType = RCC_OSCILLATORTYPE_HSE | RCC_OSCILLATORTYPE_HSI | \
200085e0:	687b      	ldr	r3, [r7, #4]
200085e2:	222f      	movs	r2, #47	; 0x2f
200085e4:	601a      	str	r2, [r3, #0]
                                      RCC_OSCILLATORTYPE_LSE | RCC_OSCILLATORTYPE_LSI | RCC_OSCILLATORTYPE_HSI48;

  /* Get the HSE configuration -----------------------------------------------*/
  if(READ_BIT(RCC->CR, RCC_CR_HSEBYP) == RCC_CR_HSEBYP)
200085e6:	4b54      	ldr	r3, [pc, #336]	; (20008738 <HAL_RCC_GetOscConfig+0x160>)
200085e8:	681b      	ldr	r3, [r3, #0]
200085ea:	f403 2380 	and.w	r3, r3, #262144	; 0x40000
200085ee:	f5b3 2f80 	cmp.w	r3, #262144	; 0x40000
200085f2:	d104      	bne.n	200085fe <HAL_RCC_GetOscConfig+0x26>
  {
    RCC_OscInitStruct->HSEState = RCC_HSE_BYPASS;
200085f4:	687b      	ldr	r3, [r7, #4]
200085f6:	f44f 22a0 	mov.w	r2, #327680	; 0x50000
200085fa:	605a      	str	r2, [r3, #4]
200085fc:	e00e      	b.n	2000861c <HAL_RCC_GetOscConfig+0x44>
  }
  else if(READ_BIT(RCC->CR, RCC_CR_HSEON) == RCC_CR_HSEON)
200085fe:	4b4e      	ldr	r3, [pc, #312]	; (20008738 <HAL_RCC_GetOscConfig+0x160>)
20008600:	681b      	ldr	r3, [r3, #0]
20008602:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
20008606:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
2000860a:	d104      	bne.n	20008616 <HAL_RCC_GetOscConfig+0x3e>
  {
    RCC_OscInitStruct->HSEState = RCC_HSE_ON;
2000860c:	687b      	ldr	r3, [r7, #4]
2000860e:	f44f 3280 	mov.w	r2, #65536	; 0x10000
20008612:	605a      	str	r2, [r3, #4]
20008614:	e002      	b.n	2000861c <HAL_RCC_GetOscConfig+0x44>
  }
  else
  {
    RCC_OscInitStruct->HSEState = RCC_HSE_OFF;
20008616:	687b      	ldr	r3, [r7, #4]
20008618:	2200      	movs	r2, #0
2000861a:	605a      	str	r2, [r3, #4]
  }

  /* Get the HSI configuration -----------------------------------------------*/
  if(READ_BIT(RCC->CR, RCC_CR_HSION) == RCC_CR_HSION)
2000861c:	4b46      	ldr	r3, [pc, #280]	; (20008738 <HAL_RCC_GetOscConfig+0x160>)
2000861e:	681b      	ldr	r3, [r3, #0]
20008620:	f403 7380 	and.w	r3, r3, #256	; 0x100
20008624:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
20008628:	d104      	bne.n	20008634 <HAL_RCC_GetOscConfig+0x5c>
  {
    RCC_OscInitStruct->HSIState = RCC_HSI_ON;
2000862a:	687b      	ldr	r3, [r7, #4]
2000862c:	f44f 7280 	mov.w	r2, #256	; 0x100
20008630:	60da      	str	r2, [r3, #12]
20008632:	e002      	b.n	2000863a <HAL_RCC_GetOscConfig+0x62>
  }
  else
  {
    RCC_OscInitStruct->HSIState = RCC_HSI_OFF;
20008634:	687b      	ldr	r3, [r7, #4]
20008636:	2200      	movs	r2, #0
20008638:	60da      	str	r2, [r3, #12]
  }

  RCC_OscInitStruct->HSICalibrationValue = READ_BIT(RCC->ICSCR, RCC_ICSCR_HSITRIM) >> RCC_ICSCR_HSITRIM_Pos;
2000863a:	4b3f      	ldr	r3, [pc, #252]	; (20008738 <HAL_RCC_GetOscConfig+0x160>)
2000863c:	685b      	ldr	r3, [r3, #4]
2000863e:	0e1b      	lsrs	r3, r3, #24
20008640:	f003 027f 	and.w	r2, r3, #127	; 0x7f
20008644:	687b      	ldr	r3, [r7, #4]
20008646:	611a      	str	r2, [r3, #16]

  /* Get the LSE configuration -----------------------------------------------*/
  if(READ_BIT(RCC->BDCR, RCC_BDCR_LSEBYP) == RCC_BDCR_LSEBYP)
20008648:	4b3b      	ldr	r3, [pc, #236]	; (20008738 <HAL_RCC_GetOscConfig+0x160>)
2000864a:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
2000864e:	f003 0304 	and.w	r3, r3, #4
20008652:	2b04      	cmp	r3, #4
20008654:	d103      	bne.n	2000865e <HAL_RCC_GetOscConfig+0x86>
  {
    RCC_OscInitStruct->LSEState = RCC_LSE_BYPASS;
20008656:	687b      	ldr	r3, [r7, #4]
20008658:	2205      	movs	r2, #5
2000865a:	609a      	str	r2, [r3, #8]
2000865c:	e00d      	b.n	2000867a <HAL_RCC_GetOscConfig+0xa2>
  }
  else if(READ_BIT(RCC->BDCR, RCC_BDCR_LSEON) == RCC_BDCR_LSEON)
2000865e:	4b36      	ldr	r3, [pc, #216]	; (20008738 <HAL_RCC_GetOscConfig+0x160>)
20008660:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
20008664:	f003 0301 	and.w	r3, r3, #1
20008668:	2b01      	cmp	r3, #1
2000866a:	d103      	bne.n	20008674 <HAL_RCC_GetOscConfig+0x9c>
  {
    RCC_OscInitStruct->LSEState = RCC_LSE_ON;
2000866c:	687b      	ldr	r3, [r7, #4]
2000866e:	2201      	movs	r2, #1
20008670:	609a      	str	r2, [r3, #8]
20008672:	e002      	b.n	2000867a <HAL_RCC_GetOscConfig+0xa2>
  }
  else
  {
    RCC_OscInitStruct->LSEState = RCC_LSE_OFF;
20008674:	687b      	ldr	r3, [r7, #4]
20008676:	2200      	movs	r2, #0
20008678:	609a      	str	r2, [r3, #8]
  }

  /* Get the LSI configuration -----------------------------------------------*/
  if(READ_BIT(RCC->CSR, RCC_CSR_LSION) == RCC_CSR_LSION)
2000867a:	4b2f      	ldr	r3, [pc, #188]	; (20008738 <HAL_RCC_GetOscConfig+0x160>)
2000867c:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
20008680:	f003 0301 	and.w	r3, r3, #1
20008684:	2b01      	cmp	r3, #1
20008686:	d103      	bne.n	20008690 <HAL_RCC_GetOscConfig+0xb8>
  {
    RCC_OscInitStruct->LSIState = RCC_LSI_ON;
20008688:	687b      	ldr	r3, [r7, #4]
2000868a:	2201      	movs	r2, #1
2000868c:	615a      	str	r2, [r3, #20]
2000868e:	e002      	b.n	20008696 <HAL_RCC_GetOscConfig+0xbe>
  }
  else
  {
    RCC_OscInitStruct->LSIState = RCC_LSI_OFF;
20008690:	687b      	ldr	r3, [r7, #4]
20008692:	2200      	movs	r2, #0
20008694:	615a      	str	r2, [r3, #20]
  }

  /* Get the HSI48 configuration ---------------------------------------------*/
  if(READ_BIT(RCC->CRRCR, RCC_CRRCR_HSI48ON) == RCC_CRRCR_HSI48ON)
20008696:	4b28      	ldr	r3, [pc, #160]	; (20008738 <HAL_RCC_GetOscConfig+0x160>)
20008698:	f8d3 3098 	ldr.w	r3, [r3, #152]	; 0x98
2000869c:	f003 0301 	and.w	r3, r3, #1
200086a0:	2b01      	cmp	r3, #1
200086a2:	d103      	bne.n	200086ac <HAL_RCC_GetOscConfig+0xd4>
  {
    RCC_OscInitStruct->HSI48State = RCC_HSI48_ON;
200086a4:	687b      	ldr	r3, [r7, #4]
200086a6:	2201      	movs	r2, #1
200086a8:	619a      	str	r2, [r3, #24]
200086aa:	e002      	b.n	200086b2 <HAL_RCC_GetOscConfig+0xda>
  }
  else
  {
    RCC_OscInitStruct->HSI48State = RCC_HSI48_OFF;
200086ac:	687b      	ldr	r3, [r7, #4]
200086ae:	2200      	movs	r2, #0
200086b0:	619a      	str	r2, [r3, #24]
  }

  /* Get the PLL configuration -----------------------------------------------*/
  if(READ_BIT(RCC->CR, RCC_CR_PLLON) == RCC_CR_PLLON)
200086b2:	4b21      	ldr	r3, [pc, #132]	; (20008738 <HAL_RCC_GetOscConfig+0x160>)
200086b4:	681b      	ldr	r3, [r3, #0]
200086b6:	f003 7380 	and.w	r3, r3, #16777216	; 0x1000000
200086ba:	f1b3 7f80 	cmp.w	r3, #16777216	; 0x1000000
200086be:	d103      	bne.n	200086c8 <HAL_RCC_GetOscConfig+0xf0>
  {
    RCC_OscInitStruct->PLL.PLLState = RCC_PLL_ON;
200086c0:	687b      	ldr	r3, [r7, #4]
200086c2:	2202      	movs	r2, #2
200086c4:	61da      	str	r2, [r3, #28]
200086c6:	e002      	b.n	200086ce <HAL_RCC_GetOscConfig+0xf6>
  }
  else
  {
    RCC_OscInitStruct->PLL.PLLState = RCC_PLL_OFF;
200086c8:	687b      	ldr	r3, [r7, #4]
200086ca:	2201      	movs	r2, #1
200086cc:	61da      	str	r2, [r3, #28]
  }
  RCC_OscInitStruct->PLL.PLLSource = READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLSRC);
200086ce:	4b1a      	ldr	r3, [pc, #104]	; (20008738 <HAL_RCC_GetOscConfig+0x160>)
200086d0:	68db      	ldr	r3, [r3, #12]
200086d2:	f003 0203 	and.w	r2, r3, #3
200086d6:	687b      	ldr	r3, [r7, #4]
200086d8:	621a      	str	r2, [r3, #32]
  RCC_OscInitStruct->PLL.PLLM = (READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLM) >> RCC_PLLCFGR_PLLM_Pos) + 1U;
200086da:	4b17      	ldr	r3, [pc, #92]	; (20008738 <HAL_RCC_GetOscConfig+0x160>)
200086dc:	68db      	ldr	r3, [r3, #12]
200086de:	091b      	lsrs	r3, r3, #4
200086e0:	f003 030f 	and.w	r3, r3, #15
200086e4:	1c5a      	adds	r2, r3, #1
200086e6:	687b      	ldr	r3, [r7, #4]
200086e8:	625a      	str	r2, [r3, #36]	; 0x24
  RCC_OscInitStruct->PLL.PLLN = READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos;
200086ea:	4b13      	ldr	r3, [pc, #76]	; (20008738 <HAL_RCC_GetOscConfig+0x160>)
200086ec:	68db      	ldr	r3, [r3, #12]
200086ee:	0a1b      	lsrs	r3, r3, #8
200086f0:	f003 027f 	and.w	r2, r3, #127	; 0x7f
200086f4:	687b      	ldr	r3, [r7, #4]
200086f6:	629a      	str	r2, [r3, #40]	; 0x28
  RCC_OscInitStruct->PLL.PLLQ = (((READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLQ) >> RCC_PLLCFGR_PLLQ_Pos) + 1U) << 1U);
200086f8:	4b0f      	ldr	r3, [pc, #60]	; (20008738 <HAL_RCC_GetOscConfig+0x160>)
200086fa:	68db      	ldr	r3, [r3, #12]
200086fc:	0d5b      	lsrs	r3, r3, #21
200086fe:	f003 0303 	and.w	r3, r3, #3
20008702:	3301      	adds	r3, #1
20008704:	005a      	lsls	r2, r3, #1
20008706:	687b      	ldr	r3, [r7, #4]
20008708:	631a      	str	r2, [r3, #48]	; 0x30
  RCC_OscInitStruct->PLL.PLLR = (((READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLR) >> RCC_PLLCFGR_PLLR_Pos) + 1U) << 1U);
2000870a:	4b0b      	ldr	r3, [pc, #44]	; (20008738 <HAL_RCC_GetOscConfig+0x160>)
2000870c:	68db      	ldr	r3, [r3, #12]
2000870e:	0e5b      	lsrs	r3, r3, #25
20008710:	f003 0303 	and.w	r3, r3, #3
20008714:	3301      	adds	r3, #1
20008716:	005a      	lsls	r2, r3, #1
20008718:	687b      	ldr	r3, [r7, #4]
2000871a:	635a      	str	r2, [r3, #52]	; 0x34
  RCC_OscInitStruct->PLL.PLLP = READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLPDIV) >> RCC_PLLCFGR_PLLPDIV_Pos;
2000871c:	4b06      	ldr	r3, [pc, #24]	; (20008738 <HAL_RCC_GetOscConfig+0x160>)
2000871e:	68db      	ldr	r3, [r3, #12]
20008720:	0edb      	lsrs	r3, r3, #27
20008722:	f003 021f 	and.w	r2, r3, #31
20008726:	687b      	ldr	r3, [r7, #4]
20008728:	62da      	str	r2, [r3, #44]	; 0x2c
}
2000872a:	bf00      	nop
2000872c:	370c      	adds	r7, #12
2000872e:	46bd      	mov	sp, r7
20008730:	f85d 7b04 	ldr.w	r7, [sp], #4
20008734:	4770      	bx	lr
20008736:	bf00      	nop
20008738:	40021000 	.word	0x40021000

2000873c <HAL_RCC_GetClockConfig>:
  *         will be configured.
  * @param  pFLatency  Pointer on the Flash Latency.
  * @retval None
  */
void HAL_RCC_GetClockConfig(RCC_ClkInitTypeDef  *RCC_ClkInitStruct, uint32_t *pFLatency)
{
2000873c:	b480      	push	{r7}
2000873e:	b083      	sub	sp, #12
20008740:	af00      	add	r7, sp, #0
20008742:	6078      	str	r0, [r7, #4]
20008744:	6039      	str	r1, [r7, #0]
  /* Check the parameters */
  assert_param(RCC_ClkInitStruct != (void  *)NULL);
  assert_param(pFLatency != (void *)NULL);

  /* Set all possible values for the Clock type parameter --------------------*/
  RCC_ClkInitStruct->ClockType = RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2;
20008746:	687b      	ldr	r3, [r7, #4]
20008748:	220f      	movs	r2, #15
2000874a:	601a      	str	r2, [r3, #0]

  /* Get the SYSCLK configuration --------------------------------------------*/
  RCC_ClkInitStruct->SYSCLKSource = READ_BIT(RCC->CFGR, RCC_CFGR_SW);
2000874c:	4b12      	ldr	r3, [pc, #72]	; (20008798 <HAL_RCC_GetClockConfig+0x5c>)
2000874e:	689b      	ldr	r3, [r3, #8]
20008750:	f003 0203 	and.w	r2, r3, #3
20008754:	687b      	ldr	r3, [r7, #4]
20008756:	605a      	str	r2, [r3, #4]

  /* Get the HCLK configuration ----------------------------------------------*/
  RCC_ClkInitStruct->AHBCLKDivider = READ_BIT(RCC->CFGR, RCC_CFGR_HPRE);
20008758:	4b0f      	ldr	r3, [pc, #60]	; (20008798 <HAL_RCC_GetClockConfig+0x5c>)
2000875a:	689b      	ldr	r3, [r3, #8]
2000875c:	f003 02f0 	and.w	r2, r3, #240	; 0xf0
20008760:	687b      	ldr	r3, [r7, #4]
20008762:	609a      	str	r2, [r3, #8]

  /* Get the APB1 configuration ----------------------------------------------*/
  RCC_ClkInitStruct->APB1CLKDivider = READ_BIT(RCC->CFGR, RCC_CFGR_PPRE1);
20008764:	4b0c      	ldr	r3, [pc, #48]	; (20008798 <HAL_RCC_GetClockConfig+0x5c>)
20008766:	689b      	ldr	r3, [r3, #8]
20008768:	f403 62e0 	and.w	r2, r3, #1792	; 0x700
2000876c:	687b      	ldr	r3, [r7, #4]
2000876e:	60da      	str	r2, [r3, #12]

  /* Get the APB2 configuration ----------------------------------------------*/
  RCC_ClkInitStruct->APB2CLKDivider = (READ_BIT(RCC->CFGR, RCC_CFGR_PPRE2) >> 3U);
20008770:	4b09      	ldr	r3, [pc, #36]	; (20008798 <HAL_RCC_GetClockConfig+0x5c>)
20008772:	689b      	ldr	r3, [r3, #8]
20008774:	08db      	lsrs	r3, r3, #3
20008776:	f403 62e0 	and.w	r2, r3, #1792	; 0x700
2000877a:	687b      	ldr	r3, [r7, #4]
2000877c:	611a      	str	r2, [r3, #16]

  /* Get the Flash Wait State (Latency) configuration ------------------------*/
  *pFLatency = __HAL_FLASH_GET_LATENCY();
2000877e:	4b07      	ldr	r3, [pc, #28]	; (2000879c <HAL_RCC_GetClockConfig+0x60>)
20008780:	681b      	ldr	r3, [r3, #0]
20008782:	f003 020f 	and.w	r2, r3, #15
20008786:	683b      	ldr	r3, [r7, #0]
20008788:	601a      	str	r2, [r3, #0]
}
2000878a:	bf00      	nop
2000878c:	370c      	adds	r7, #12
2000878e:	46bd      	mov	sp, r7
20008790:	f85d 7b04 	ldr.w	r7, [sp], #4
20008794:	4770      	bx	lr
20008796:	bf00      	nop
20008798:	40021000 	.word	0x40021000
2000879c:	40022000 	.word	0x40022000

200087a0 <HAL_RCC_EnableCSS>:
  *         the Cortex-M4 NMI (Non-Maskable Interrupt) exception vector.
  * @note   The Clock Security System can only be cleared by reset.
  * @retval None
  */
void HAL_RCC_EnableCSS(void)
{
200087a0:	b480      	push	{r7}
200087a2:	af00      	add	r7, sp, #0
  SET_BIT(RCC->CR, RCC_CR_CSSON) ;
200087a4:	4b05      	ldr	r3, [pc, #20]	; (200087bc <HAL_RCC_EnableCSS+0x1c>)
200087a6:	681b      	ldr	r3, [r3, #0]
200087a8:	4a04      	ldr	r2, [pc, #16]	; (200087bc <HAL_RCC_EnableCSS+0x1c>)
200087aa:	f443 2300 	orr.w	r3, r3, #524288	; 0x80000
200087ae:	6013      	str	r3, [r2, #0]
}
200087b0:	bf00      	nop
200087b2:	46bd      	mov	sp, r7
200087b4:	f85d 7b04 	ldr.w	r7, [sp], #4
200087b8:	4770      	bx	lr
200087ba:	bf00      	nop
200087bc:	40021000 	.word	0x40021000

200087c0 <HAL_RCC_EnableLSECSS>:
  *         and handle through @ref RCCEx_EXTI_LINE_LSECSS
  * @note   The Clock Security System can only be cleared by reset or after a LSE failure detection.
  * @retval None
  */
void HAL_RCC_EnableLSECSS(void)
{
200087c0:	b480      	push	{r7}
200087c2:	af00      	add	r7, sp, #0
  SET_BIT(RCC->BDCR, RCC_BDCR_LSECSSON) ;
200087c4:	4b06      	ldr	r3, [pc, #24]	; (200087e0 <HAL_RCC_EnableLSECSS+0x20>)
200087c6:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
200087ca:	4a05      	ldr	r2, [pc, #20]	; (200087e0 <HAL_RCC_EnableLSECSS+0x20>)
200087cc:	f043 0320 	orr.w	r3, r3, #32
200087d0:	f8c2 3090 	str.w	r3, [r2, #144]	; 0x90
}
200087d4:	bf00      	nop
200087d6:	46bd      	mov	sp, r7
200087d8:	f85d 7b04 	ldr.w	r7, [sp], #4
200087dc:	4770      	bx	lr
200087de:	bf00      	nop
200087e0:	40021000 	.word	0x40021000

200087e4 <HAL_RCC_DisableLSECSS>:
  * @note   After LSE failure detection, the software must disable LSECSSON
  * @note   The Clock Security System can only be cleared by reset otherwise.
  * @retval None
  */
void HAL_RCC_DisableLSECSS(void)
{
200087e4:	b480      	push	{r7}
200087e6:	af00      	add	r7, sp, #0
  CLEAR_BIT(RCC->BDCR, RCC_BDCR_LSECSSON) ;
200087e8:	4b06      	ldr	r3, [pc, #24]	; (20008804 <HAL_RCC_DisableLSECSS+0x20>)
200087ea:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
200087ee:	4a05      	ldr	r2, [pc, #20]	; (20008804 <HAL_RCC_DisableLSECSS+0x20>)
200087f0:	f023 0320 	bic.w	r3, r3, #32
200087f4:	f8c2 3090 	str.w	r3, [r2, #144]	; 0x90
}
200087f8:	bf00      	nop
200087fa:	46bd      	mov	sp, r7
200087fc:	f85d 7b04 	ldr.w	r7, [sp], #4
20008800:	4770      	bx	lr
20008802:	bf00      	nop
20008804:	40021000 	.word	0x40021000

20008808 <HAL_RCC_NMI_IRQHandler>:
  * @brief Handle the RCC Clock Security System interrupt request.
  * @note This API should be called under the NMI_Handler().
  * @retval None
  */
void HAL_RCC_NMI_IRQHandler(void)
{
20008808:	b580      	push	{r7, lr}
2000880a:	af00      	add	r7, sp, #0
  /* Check RCC CSSF interrupt flag  */
  if(__HAL_RCC_GET_IT(RCC_IT_CSS))
2000880c:	4b07      	ldr	r3, [pc, #28]	; (2000882c <HAL_RCC_NMI_IRQHandler+0x24>)
2000880e:	69db      	ldr	r3, [r3, #28]
20008810:	f403 7380 	and.w	r3, r3, #256	; 0x100
20008814:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
20008818:	d105      	bne.n	20008826 <HAL_RCC_NMI_IRQHandler+0x1e>
  {
    /* RCC Clock Security System interrupt user callback */
    HAL_RCC_CSSCallback();
2000881a:	f000 f809 	bl	20008830 <HAL_RCC_CSSCallback>

    /* Clear RCC CSS pending bit */
    __HAL_RCC_CLEAR_IT(RCC_IT_CSS);
2000881e:	4b03      	ldr	r3, [pc, #12]	; (2000882c <HAL_RCC_NMI_IRQHandler+0x24>)
20008820:	f44f 7280 	mov.w	r2, #256	; 0x100
20008824:	621a      	str	r2, [r3, #32]
  }
}
20008826:	bf00      	nop
20008828:	bd80      	pop	{r7, pc}
2000882a:	bf00      	nop
2000882c:	40021000 	.word	0x40021000

20008830 <HAL_RCC_CSSCallback>:
/**
  * @brief  RCC Clock Security System interrupt callback.
  * @retval none
  */
__weak void HAL_RCC_CSSCallback(void)
{
20008830:	b480      	push	{r7}
20008832:	af00      	add	r7, sp, #0
  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_RCC_CSSCallback should be implemented in the user file
   */
}
20008834:	bf00      	nop
20008836:	46bd      	mov	sp, r7
20008838:	f85d 7b04 	ldr.w	r7, [sp], #4
2000883c:	4770      	bx	lr
	...

20008840 <RCC_GetSysClockFreqFromPLLSource>:
/**
  * @brief  Compute SYSCLK frequency based on PLL SYSCLK source.
  * @retval SYSCLK frequency
  */
static uint32_t RCC_GetSysClockFreqFromPLLSource(void)
{
20008840:	b480      	push	{r7}
20008842:	b087      	sub	sp, #28
20008844:	af00      	add	r7, sp, #0
  uint32_t sysclockfreq;

  /* PLL_VCO = (HSE_VALUE or HSI_VALUE/ PLLM) * PLLN
     SYSCLK = PLL_VCO / PLLR
   */
  pllsource = READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLSRC);
20008846:	4b1e      	ldr	r3, [pc, #120]	; (200088c0 <RCC_GetSysClockFreqFromPLLSource+0x80>)
20008848:	68db      	ldr	r3, [r3, #12]
2000884a:	f003 0303 	and.w	r3, r3, #3
2000884e:	613b      	str	r3, [r7, #16]
  pllm = (READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLM) >> RCC_PLLCFGR_PLLM_Pos) + 1U ;
20008850:	4b1b      	ldr	r3, [pc, #108]	; (200088c0 <RCC_GetSysClockFreqFromPLLSource+0x80>)
20008852:	68db      	ldr	r3, [r3, #12]
20008854:	091b      	lsrs	r3, r3, #4
20008856:	f003 030f 	and.w	r3, r3, #15
2000885a:	3301      	adds	r3, #1
2000885c:	60fb      	str	r3, [r7, #12]

  switch (pllsource)
2000885e:	693b      	ldr	r3, [r7, #16]
20008860:	2b03      	cmp	r3, #3
20008862:	d10c      	bne.n	2000887e <RCC_GetSysClockFreqFromPLLSource+0x3e>
  {
  case RCC_PLLSOURCE_HSE:  /* HSE used as PLL clock source */
    pllvco = (HSE_VALUE / pllm) * (READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos);
20008864:	4a17      	ldr	r2, [pc, #92]	; (200088c4 <RCC_GetSysClockFreqFromPLLSource+0x84>)
20008866:	68fb      	ldr	r3, [r7, #12]
20008868:	fbb2 f3f3 	udiv	r3, r2, r3
2000886c:	4a14      	ldr	r2, [pc, #80]	; (200088c0 <RCC_GetSysClockFreqFromPLLSource+0x80>)
2000886e:	68d2      	ldr	r2, [r2, #12]
20008870:	0a12      	lsrs	r2, r2, #8
20008872:	f002 027f 	and.w	r2, r2, #127	; 0x7f
20008876:	fb02 f303 	mul.w	r3, r2, r3
2000887a:	617b      	str	r3, [r7, #20]
    break;
2000887c:	e00c      	b.n	20008898 <RCC_GetSysClockFreqFromPLLSource+0x58>

  case RCC_PLLSOURCE_HSI:  /* HSI used as PLL clock source */
  default:
    pllvco = (HSI_VALUE / pllm) * (READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos);
2000887e:	4a12      	ldr	r2, [pc, #72]	; (200088c8 <RCC_GetSysClockFreqFromPLLSource+0x88>)
20008880:	68fb      	ldr	r3, [r7, #12]
20008882:	fbb2 f3f3 	udiv	r3, r2, r3
20008886:	4a0e      	ldr	r2, [pc, #56]	; (200088c0 <RCC_GetSysClockFreqFromPLLSource+0x80>)
20008888:	68d2      	ldr	r2, [r2, #12]
2000888a:	0a12      	lsrs	r2, r2, #8
2000888c:	f002 027f 	and.w	r2, r2, #127	; 0x7f
20008890:	fb02 f303 	mul.w	r3, r2, r3
20008894:	617b      	str	r3, [r7, #20]
    break;
20008896:	bf00      	nop
  }

  pllr = ((READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLR) >> RCC_PLLCFGR_PLLR_Pos) + 1U ) * 2U;
20008898:	4b09      	ldr	r3, [pc, #36]	; (200088c0 <RCC_GetSysClockFreqFromPLLSource+0x80>)
2000889a:	68db      	ldr	r3, [r3, #12]
2000889c:	0e5b      	lsrs	r3, r3, #25
2000889e:	f003 0303 	and.w	r3, r3, #3
200088a2:	3301      	adds	r3, #1
200088a4:	005b      	lsls	r3, r3, #1
200088a6:	60bb      	str	r3, [r7, #8]
  sysclockfreq = pllvco/pllr;
200088a8:	697a      	ldr	r2, [r7, #20]
200088aa:	68bb      	ldr	r3, [r7, #8]
200088ac:	fbb2 f3f3 	udiv	r3, r2, r3
200088b0:	607b      	str	r3, [r7, #4]

  return sysclockfreq;
200088b2:	687b      	ldr	r3, [r7, #4]
}
200088b4:	4618      	mov	r0, r3
200088b6:	371c      	adds	r7, #28
200088b8:	46bd      	mov	sp, r7
200088ba:	f85d 7b04 	ldr.w	r7, [sp], #4
200088be:	4770      	bx	lr
200088c0:	40021000 	.word	0x40021000
200088c4:	007a1200 	.word	0x007a1200
200088c8:	00f42400 	.word	0x00f42400

200088cc <HAL_RCCEx_PeriphCLKConfig>:
  *         the RTC clock source: in this case the access to Backup domain is enabled.
  *
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RCCEx_PeriphCLKConfig(RCC_PeriphCLKInitTypeDef  *PeriphClkInit)
{
200088cc:	b580      	push	{r7, lr}
200088ce:	b086      	sub	sp, #24
200088d0:	af00      	add	r7, sp, #0
200088d2:	6078      	str	r0, [r7, #4]
  uint32_t tmpregister;
  uint32_t tickstart;
  HAL_StatusTypeDef ret = HAL_OK;      /* Intermediate status */
200088d4:	2300      	movs	r3, #0
200088d6:	74fb      	strb	r3, [r7, #19]
  HAL_StatusTypeDef status = HAL_OK;   /* Final status */
200088d8:	2300      	movs	r3, #0
200088da:	74bb      	strb	r3, [r7, #18]

  /* Check the parameters */
  assert_param(IS_RCC_PERIPHCLOCK(PeriphClkInit->PeriphClockSelection));

  /*-------------------------- RTC clock source configuration ----------------------*/
  if((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_RTC) == RCC_PERIPHCLK_RTC)
200088dc:	687b      	ldr	r3, [r7, #4]
200088de:	681b      	ldr	r3, [r3, #0]
200088e0:	f403 2300 	and.w	r3, r3, #524288	; 0x80000
200088e4:	2b00      	cmp	r3, #0
200088e6:	f000 8098 	beq.w	20008a1a <HAL_RCCEx_PeriphCLKConfig+0x14e>
  {
    FlagStatus       pwrclkchanged = RESET;
200088ea:	2300      	movs	r3, #0
200088ec:	747b      	strb	r3, [r7, #17]
    
    /* Check for RTC Parameters used to output RTCCLK */
    assert_param(IS_RCC_RTCCLKSOURCE(PeriphClkInit->RTCClockSelection));

    /* Enable Power Clock */
    if(__HAL_RCC_PWR_IS_CLK_DISABLED())
200088ee:	4b43      	ldr	r3, [pc, #268]	; (200089fc <HAL_RCCEx_PeriphCLKConfig+0x130>)
200088f0:	6d9b      	ldr	r3, [r3, #88]	; 0x58
200088f2:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
200088f6:	2b00      	cmp	r3, #0
200088f8:	d10d      	bne.n	20008916 <HAL_RCCEx_PeriphCLKConfig+0x4a>
    {
      __HAL_RCC_PWR_CLK_ENABLE();
200088fa:	4b40      	ldr	r3, [pc, #256]	; (200089fc <HAL_RCCEx_PeriphCLKConfig+0x130>)
200088fc:	6d9b      	ldr	r3, [r3, #88]	; 0x58
200088fe:	4a3f      	ldr	r2, [pc, #252]	; (200089fc <HAL_RCCEx_PeriphCLKConfig+0x130>)
20008900:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
20008904:	6593      	str	r3, [r2, #88]	; 0x58
20008906:	4b3d      	ldr	r3, [pc, #244]	; (200089fc <HAL_RCCEx_PeriphCLKConfig+0x130>)
20008908:	6d9b      	ldr	r3, [r3, #88]	; 0x58
2000890a:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
2000890e:	60bb      	str	r3, [r7, #8]
20008910:	68bb      	ldr	r3, [r7, #8]
      pwrclkchanged = SET;
20008912:	2301      	movs	r3, #1
20008914:	747b      	strb	r3, [r7, #17]
    }
      
    /* Enable write access to Backup domain */
    SET_BIT(PWR->CR1, PWR_CR1_DBP);
20008916:	4b3a      	ldr	r3, [pc, #232]	; (20008a00 <HAL_RCCEx_PeriphCLKConfig+0x134>)
20008918:	681b      	ldr	r3, [r3, #0]
2000891a:	4a39      	ldr	r2, [pc, #228]	; (20008a00 <HAL_RCCEx_PeriphCLKConfig+0x134>)
2000891c:	f443 7380 	orr.w	r3, r3, #256	; 0x100
20008920:	6013      	str	r3, [r2, #0]

    /* Wait for Backup domain Write protection disable */
    tickstart = HAL_GetTick();
20008922:	f7f8 ffbb 	bl	2000189c <HAL_GetTick>
20008926:	60f8      	str	r0, [r7, #12]

    while((PWR->CR1 & PWR_CR1_DBP) == 0U)
20008928:	e009      	b.n	2000893e <HAL_RCCEx_PeriphCLKConfig+0x72>
    {
      if((HAL_GetTick() - tickstart) > RCC_DBP_TIMEOUT_VALUE)
2000892a:	f7f8 ffb7 	bl	2000189c <HAL_GetTick>
2000892e:	4602      	mov	r2, r0
20008930:	68fb      	ldr	r3, [r7, #12]
20008932:	1ad3      	subs	r3, r2, r3
20008934:	2b02      	cmp	r3, #2
20008936:	d902      	bls.n	2000893e <HAL_RCCEx_PeriphCLKConfig+0x72>
      {
        ret = HAL_TIMEOUT;
20008938:	2303      	movs	r3, #3
2000893a:	74fb      	strb	r3, [r7, #19]
        break;
2000893c:	e005      	b.n	2000894a <HAL_RCCEx_PeriphCLKConfig+0x7e>
    while((PWR->CR1 & PWR_CR1_DBP) == 0U)
2000893e:	4b30      	ldr	r3, [pc, #192]	; (20008a00 <HAL_RCCEx_PeriphCLKConfig+0x134>)
20008940:	681b      	ldr	r3, [r3, #0]
20008942:	f403 7380 	and.w	r3, r3, #256	; 0x100
20008946:	2b00      	cmp	r3, #0
20008948:	d0ef      	beq.n	2000892a <HAL_RCCEx_PeriphCLKConfig+0x5e>
      }
    }

    if(ret == HAL_OK)
2000894a:	7cfb      	ldrb	r3, [r7, #19]
2000894c:	2b00      	cmp	r3, #0
2000894e:	d159      	bne.n	20008a04 <HAL_RCCEx_PeriphCLKConfig+0x138>
    { 
      /* Reset the Backup domain only if the RTC Clock source selection is modified from default */
      tmpregister = READ_BIT(RCC->BDCR, RCC_BDCR_RTCSEL);
20008950:	4b2a      	ldr	r3, [pc, #168]	; (200089fc <HAL_RCCEx_PeriphCLKConfig+0x130>)
20008952:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
20008956:	f403 7340 	and.w	r3, r3, #768	; 0x300
2000895a:	617b      	str	r3, [r7, #20]
      
      if((tmpregister != RCC_RTCCLKSOURCE_NONE) && (tmpregister != PeriphClkInit->RTCClockSelection))
2000895c:	697b      	ldr	r3, [r7, #20]
2000895e:	2b00      	cmp	r3, #0
20008960:	d01e      	beq.n	200089a0 <HAL_RCCEx_PeriphCLKConfig+0xd4>
20008962:	687b      	ldr	r3, [r7, #4]
20008964:	6d1b      	ldr	r3, [r3, #80]	; 0x50
20008966:	697a      	ldr	r2, [r7, #20]
20008968:	429a      	cmp	r2, r3
2000896a:	d019      	beq.n	200089a0 <HAL_RCCEx_PeriphCLKConfig+0xd4>
      {
        /* Store the content of BDCR register before the reset of Backup Domain */
        tmpregister = READ_BIT(RCC->BDCR, ~(RCC_BDCR_RTCSEL));
2000896c:	4b23      	ldr	r3, [pc, #140]	; (200089fc <HAL_RCCEx_PeriphCLKConfig+0x130>)
2000896e:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
20008972:	f423 7340 	bic.w	r3, r3, #768	; 0x300
20008976:	617b      	str	r3, [r7, #20]
        /* RTC Clock selection can be changed only if the Backup Domain is reset */
        __HAL_RCC_BACKUPRESET_FORCE();
20008978:	4b20      	ldr	r3, [pc, #128]	; (200089fc <HAL_RCCEx_PeriphCLKConfig+0x130>)
2000897a:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
2000897e:	4a1f      	ldr	r2, [pc, #124]	; (200089fc <HAL_RCCEx_PeriphCLKConfig+0x130>)
20008980:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
20008984:	f8c2 3090 	str.w	r3, [r2, #144]	; 0x90
        __HAL_RCC_BACKUPRESET_RELEASE();
20008988:	4b1c      	ldr	r3, [pc, #112]	; (200089fc <HAL_RCCEx_PeriphCLKConfig+0x130>)
2000898a:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
2000898e:	4a1b      	ldr	r2, [pc, #108]	; (200089fc <HAL_RCCEx_PeriphCLKConfig+0x130>)
20008990:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
20008994:	f8c2 3090 	str.w	r3, [r2, #144]	; 0x90
        /* Restore the Content of BDCR register */
        RCC->BDCR = tmpregister;
20008998:	4a18      	ldr	r2, [pc, #96]	; (200089fc <HAL_RCCEx_PeriphCLKConfig+0x130>)
2000899a:	697b      	ldr	r3, [r7, #20]
2000899c:	f8c2 3090 	str.w	r3, [r2, #144]	; 0x90
      }

      /* Wait for LSE reactivation if LSE was enable prior to Backup Domain reset */
      if (HAL_IS_BIT_SET(tmpregister, RCC_BDCR_LSEON))
200089a0:	697b      	ldr	r3, [r7, #20]
200089a2:	f003 0301 	and.w	r3, r3, #1
200089a6:	2b00      	cmp	r3, #0
200089a8:	d016      	beq.n	200089d8 <HAL_RCCEx_PeriphCLKConfig+0x10c>
      {
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
200089aa:	f7f8 ff77 	bl	2000189c <HAL_GetTick>
200089ae:	60f8      	str	r0, [r7, #12]

        /* Wait till LSE is ready */
        while(READ_BIT(RCC->BDCR, RCC_BDCR_LSERDY) == 0U)
200089b0:	e00b      	b.n	200089ca <HAL_RCCEx_PeriphCLKConfig+0xfe>
        {
          if((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
200089b2:	f7f8 ff73 	bl	2000189c <HAL_GetTick>
200089b6:	4602      	mov	r2, r0
200089b8:	68fb      	ldr	r3, [r7, #12]
200089ba:	1ad3      	subs	r3, r2, r3
200089bc:	f241 3288 	movw	r2, #5000	; 0x1388
200089c0:	4293      	cmp	r3, r2
200089c2:	d902      	bls.n	200089ca <HAL_RCCEx_PeriphCLKConfig+0xfe>
          {
            ret = HAL_TIMEOUT;
200089c4:	2303      	movs	r3, #3
200089c6:	74fb      	strb	r3, [r7, #19]
            break;
200089c8:	e006      	b.n	200089d8 <HAL_RCCEx_PeriphCLKConfig+0x10c>
        while(READ_BIT(RCC->BDCR, RCC_BDCR_LSERDY) == 0U)
200089ca:	4b0c      	ldr	r3, [pc, #48]	; (200089fc <HAL_RCCEx_PeriphCLKConfig+0x130>)
200089cc:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
200089d0:	f003 0302 	and.w	r3, r3, #2
200089d4:	2b00      	cmp	r3, #0
200089d6:	d0ec      	beq.n	200089b2 <HAL_RCCEx_PeriphCLKConfig+0xe6>
          }
        }
      }
      
      if(ret == HAL_OK)
200089d8:	7cfb      	ldrb	r3, [r7, #19]
200089da:	2b00      	cmp	r3, #0
200089dc:	d10b      	bne.n	200089f6 <HAL_RCCEx_PeriphCLKConfig+0x12a>
      {
        /* Apply new RTC clock source selection */
        __HAL_RCC_RTC_CONFIG(PeriphClkInit->RTCClockSelection);
200089de:	4b07      	ldr	r3, [pc, #28]	; (200089fc <HAL_RCCEx_PeriphCLKConfig+0x130>)
200089e0:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
200089e4:	f423 7240 	bic.w	r2, r3, #768	; 0x300
200089e8:	687b      	ldr	r3, [r7, #4]
200089ea:	6d1b      	ldr	r3, [r3, #80]	; 0x50
200089ec:	4903      	ldr	r1, [pc, #12]	; (200089fc <HAL_RCCEx_PeriphCLKConfig+0x130>)
200089ee:	4313      	orrs	r3, r2
200089f0:	f8c1 3090 	str.w	r3, [r1, #144]	; 0x90
200089f4:	e008      	b.n	20008a08 <HAL_RCCEx_PeriphCLKConfig+0x13c>
      }
      else
      {
        /* set overall return value */
        status = ret;
200089f6:	7cfb      	ldrb	r3, [r7, #19]
200089f8:	74bb      	strb	r3, [r7, #18]
200089fa:	e005      	b.n	20008a08 <HAL_RCCEx_PeriphCLKConfig+0x13c>
200089fc:	40021000 	.word	0x40021000
20008a00:	40007000 	.word	0x40007000
      }
    }
    else
    {
      /* set overall return value */
      status = ret;
20008a04:	7cfb      	ldrb	r3, [r7, #19]
20008a06:	74bb      	strb	r3, [r7, #18]
    }

    /* Restore clock configuration if changed */
    if(pwrclkchanged == SET)
20008a08:	7c7b      	ldrb	r3, [r7, #17]
20008a0a:	2b01      	cmp	r3, #1
20008a0c:	d105      	bne.n	20008a1a <HAL_RCCEx_PeriphCLKConfig+0x14e>
    {
      __HAL_RCC_PWR_CLK_DISABLE();
20008a0e:	4baf      	ldr	r3, [pc, #700]	; (20008ccc <HAL_RCCEx_PeriphCLKConfig+0x400>)
20008a10:	6d9b      	ldr	r3, [r3, #88]	; 0x58
20008a12:	4aae      	ldr	r2, [pc, #696]	; (20008ccc <HAL_RCCEx_PeriphCLKConfig+0x400>)
20008a14:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
20008a18:	6593      	str	r3, [r2, #88]	; 0x58
    }
  }

  /*-------------------------- USART1 clock source configuration -------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART1) == RCC_PERIPHCLK_USART1)
20008a1a:	687b      	ldr	r3, [r7, #4]
20008a1c:	681b      	ldr	r3, [r3, #0]
20008a1e:	f003 0301 	and.w	r3, r3, #1
20008a22:	2b00      	cmp	r3, #0
20008a24:	d00a      	beq.n	20008a3c <HAL_RCCEx_PeriphCLKConfig+0x170>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USART1CLKSOURCE(PeriphClkInit->Usart1ClockSelection));

    /* Configure the USART1 clock source */
    __HAL_RCC_USART1_CONFIG(PeriphClkInit->Usart1ClockSelection);
20008a26:	4ba9      	ldr	r3, [pc, #676]	; (20008ccc <HAL_RCCEx_PeriphCLKConfig+0x400>)
20008a28:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
20008a2c:	f023 0203 	bic.w	r2, r3, #3
20008a30:	687b      	ldr	r3, [r7, #4]
20008a32:	685b      	ldr	r3, [r3, #4]
20008a34:	49a5      	ldr	r1, [pc, #660]	; (20008ccc <HAL_RCCEx_PeriphCLKConfig+0x400>)
20008a36:	4313      	orrs	r3, r2
20008a38:	f8c1 3088 	str.w	r3, [r1, #136]	; 0x88
  }

  /*-------------------------- USART2 clock source configuration -------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART2) == RCC_PERIPHCLK_USART2)
20008a3c:	687b      	ldr	r3, [r7, #4]
20008a3e:	681b      	ldr	r3, [r3, #0]
20008a40:	f003 0302 	and.w	r3, r3, #2
20008a44:	2b00      	cmp	r3, #0
20008a46:	d00a      	beq.n	20008a5e <HAL_RCCEx_PeriphCLKConfig+0x192>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USART2CLKSOURCE(PeriphClkInit->Usart2ClockSelection));

    /* Configure the USART2 clock source */
    __HAL_RCC_USART2_CONFIG(PeriphClkInit->Usart2ClockSelection);
20008a48:	4ba0      	ldr	r3, [pc, #640]	; (20008ccc <HAL_RCCEx_PeriphCLKConfig+0x400>)
20008a4a:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
20008a4e:	f023 020c 	bic.w	r2, r3, #12
20008a52:	687b      	ldr	r3, [r7, #4]
20008a54:	689b      	ldr	r3, [r3, #8]
20008a56:	499d      	ldr	r1, [pc, #628]	; (20008ccc <HAL_RCCEx_PeriphCLKConfig+0x400>)
20008a58:	4313      	orrs	r3, r2
20008a5a:	f8c1 3088 	str.w	r3, [r1, #136]	; 0x88
  }

  /*-------------------------- USART3 clock source configuration -------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART3) == RCC_PERIPHCLK_USART3)
20008a5e:	687b      	ldr	r3, [r7, #4]
20008a60:	681b      	ldr	r3, [r3, #0]
20008a62:	f003 0304 	and.w	r3, r3, #4
20008a66:	2b00      	cmp	r3, #0
20008a68:	d00a      	beq.n	20008a80 <HAL_RCCEx_PeriphCLKConfig+0x1b4>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USART3CLKSOURCE(PeriphClkInit->Usart3ClockSelection));

    /* Configure the USART3 clock source */
    __HAL_RCC_USART3_CONFIG(PeriphClkInit->Usart3ClockSelection);
20008a6a:	4b98      	ldr	r3, [pc, #608]	; (20008ccc <HAL_RCCEx_PeriphCLKConfig+0x400>)
20008a6c:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
20008a70:	f023 0230 	bic.w	r2, r3, #48	; 0x30
20008a74:	687b      	ldr	r3, [r7, #4]
20008a76:	68db      	ldr	r3, [r3, #12]
20008a78:	4994      	ldr	r1, [pc, #592]	; (20008ccc <HAL_RCCEx_PeriphCLKConfig+0x400>)
20008a7a:	4313      	orrs	r3, r2
20008a7c:	f8c1 3088 	str.w	r3, [r1, #136]	; 0x88
  }

#if defined(UART4)
  /*-------------------------- UART4 clock source configuration --------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_UART4) == RCC_PERIPHCLK_UART4)
20008a80:	687b      	ldr	r3, [r7, #4]
20008a82:	681b      	ldr	r3, [r3, #0]
20008a84:	f003 0308 	and.w	r3, r3, #8
20008a88:	2b00      	cmp	r3, #0
20008a8a:	d00a      	beq.n	20008aa2 <HAL_RCCEx_PeriphCLKConfig+0x1d6>
  {
    /* Check the parameters */
    assert_param(IS_RCC_UART4CLKSOURCE(PeriphClkInit->Uart4ClockSelection));

    /* Configure the UART4 clock source */
    __HAL_RCC_UART4_CONFIG(PeriphClkInit->Uart4ClockSelection);
20008a8c:	4b8f      	ldr	r3, [pc, #572]	; (20008ccc <HAL_RCCEx_PeriphCLKConfig+0x400>)
20008a8e:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
20008a92:	f023 02c0 	bic.w	r2, r3, #192	; 0xc0
20008a96:	687b      	ldr	r3, [r7, #4]
20008a98:	691b      	ldr	r3, [r3, #16]
20008a9a:	498c      	ldr	r1, [pc, #560]	; (20008ccc <HAL_RCCEx_PeriphCLKConfig+0x400>)
20008a9c:	4313      	orrs	r3, r2
20008a9e:	f8c1 3088 	str.w	r3, [r1, #136]	; 0x88
#endif /* UART4 */

#if defined(UART5)

  /*-------------------------- UART5 clock source configuration --------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_UART5) == RCC_PERIPHCLK_UART5)
20008aa2:	687b      	ldr	r3, [r7, #4]
20008aa4:	681b      	ldr	r3, [r3, #0]
20008aa6:	f003 0310 	and.w	r3, r3, #16
20008aaa:	2b00      	cmp	r3, #0
20008aac:	d00a      	beq.n	20008ac4 <HAL_RCCEx_PeriphCLKConfig+0x1f8>
  {
    /* Check the parameters */
    assert_param(IS_RCC_UART5CLKSOURCE(PeriphClkInit->Uart5ClockSelection));

    /* Configure the UART5 clock source */
    __HAL_RCC_UART5_CONFIG(PeriphClkInit->Uart5ClockSelection);
20008aae:	4b87      	ldr	r3, [pc, #540]	; (20008ccc <HAL_RCCEx_PeriphCLKConfig+0x400>)
20008ab0:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
20008ab4:	f423 7240 	bic.w	r2, r3, #768	; 0x300
20008ab8:	687b      	ldr	r3, [r7, #4]
20008aba:	695b      	ldr	r3, [r3, #20]
20008abc:	4983      	ldr	r1, [pc, #524]	; (20008ccc <HAL_RCCEx_PeriphCLKConfig+0x400>)
20008abe:	4313      	orrs	r3, r2
20008ac0:	f8c1 3088 	str.w	r3, [r1, #136]	; 0x88
  }

#endif /* UART5 */

  /*-------------------------- LPUART1 clock source configuration ------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPUART1) == RCC_PERIPHCLK_LPUART1)
20008ac4:	687b      	ldr	r3, [r7, #4]
20008ac6:	681b      	ldr	r3, [r3, #0]
20008ac8:	f003 0320 	and.w	r3, r3, #32
20008acc:	2b00      	cmp	r3, #0
20008ace:	d00a      	beq.n	20008ae6 <HAL_RCCEx_PeriphCLKConfig+0x21a>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LPUART1CLKSOURCE(PeriphClkInit->Lpuart1ClockSelection));

    /* Configure the LPUAR1 clock source */
    __HAL_RCC_LPUART1_CONFIG(PeriphClkInit->Lpuart1ClockSelection);
20008ad0:	4b7e      	ldr	r3, [pc, #504]	; (20008ccc <HAL_RCCEx_PeriphCLKConfig+0x400>)
20008ad2:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
20008ad6:	f423 6240 	bic.w	r2, r3, #3072	; 0xc00
20008ada:	687b      	ldr	r3, [r7, #4]
20008adc:	699b      	ldr	r3, [r3, #24]
20008ade:	497b      	ldr	r1, [pc, #492]	; (20008ccc <HAL_RCCEx_PeriphCLKConfig+0x400>)
20008ae0:	4313      	orrs	r3, r2
20008ae2:	f8c1 3088 	str.w	r3, [r1, #136]	; 0x88
  }

  /*-------------------------- I2C1 clock source configuration ---------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C1) == RCC_PERIPHCLK_I2C1)
20008ae6:	687b      	ldr	r3, [r7, #4]
20008ae8:	681b      	ldr	r3, [r3, #0]
20008aea:	f003 0340 	and.w	r3, r3, #64	; 0x40
20008aee:	2b00      	cmp	r3, #0
20008af0:	d00a      	beq.n	20008b08 <HAL_RCCEx_PeriphCLKConfig+0x23c>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2C1CLKSOURCE(PeriphClkInit->I2c1ClockSelection));

    /* Configure the I2C1 clock source */
    __HAL_RCC_I2C1_CONFIG(PeriphClkInit->I2c1ClockSelection);
20008af2:	4b76      	ldr	r3, [pc, #472]	; (20008ccc <HAL_RCCEx_PeriphCLKConfig+0x400>)
20008af4:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
20008af8:	f423 5240 	bic.w	r2, r3, #12288	; 0x3000
20008afc:	687b      	ldr	r3, [r7, #4]
20008afe:	69db      	ldr	r3, [r3, #28]
20008b00:	4972      	ldr	r1, [pc, #456]	; (20008ccc <HAL_RCCEx_PeriphCLKConfig+0x400>)
20008b02:	4313      	orrs	r3, r2
20008b04:	f8c1 3088 	str.w	r3, [r1, #136]	; 0x88
  }

  /*-------------------------- I2C2 clock source configuration ---------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C2) == RCC_PERIPHCLK_I2C2)
20008b08:	687b      	ldr	r3, [r7, #4]
20008b0a:	681b      	ldr	r3, [r3, #0]
20008b0c:	f003 0380 	and.w	r3, r3, #128	; 0x80
20008b10:	2b00      	cmp	r3, #0
20008b12:	d00a      	beq.n	20008b2a <HAL_RCCEx_PeriphCLKConfig+0x25e>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2C2CLKSOURCE(PeriphClkInit->I2c2ClockSelection));

    /* Configure the I2C2 clock source */
    __HAL_RCC_I2C2_CONFIG(PeriphClkInit->I2c2ClockSelection);
20008b14:	4b6d      	ldr	r3, [pc, #436]	; (20008ccc <HAL_RCCEx_PeriphCLKConfig+0x400>)
20008b16:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
20008b1a:	f423 4240 	bic.w	r2, r3, #49152	; 0xc000
20008b1e:	687b      	ldr	r3, [r7, #4]
20008b20:	6a1b      	ldr	r3, [r3, #32]
20008b22:	496a      	ldr	r1, [pc, #424]	; (20008ccc <HAL_RCCEx_PeriphCLKConfig+0x400>)
20008b24:	4313      	orrs	r3, r2
20008b26:	f8c1 3088 	str.w	r3, [r1, #136]	; 0x88
  }

  /*-------------------------- I2C3 clock source configuration ---------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C3) == RCC_PERIPHCLK_I2C3)
20008b2a:	687b      	ldr	r3, [r7, #4]
20008b2c:	681b      	ldr	r3, [r3, #0]
20008b2e:	f403 7380 	and.w	r3, r3, #256	; 0x100
20008b32:	2b00      	cmp	r3, #0
20008b34:	d00a      	beq.n	20008b4c <HAL_RCCEx_PeriphCLKConfig+0x280>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2C3CLKSOURCE(PeriphClkInit->I2c3ClockSelection));

    /* Configure the I2C3 clock source */
    __HAL_RCC_I2C3_CONFIG(PeriphClkInit->I2c3ClockSelection);
20008b36:	4b65      	ldr	r3, [pc, #404]	; (20008ccc <HAL_RCCEx_PeriphCLKConfig+0x400>)
20008b38:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
20008b3c:	f423 3240 	bic.w	r2, r3, #196608	; 0x30000
20008b40:	687b      	ldr	r3, [r7, #4]
20008b42:	6a5b      	ldr	r3, [r3, #36]	; 0x24
20008b44:	4961      	ldr	r1, [pc, #388]	; (20008ccc <HAL_RCCEx_PeriphCLKConfig+0x400>)
20008b46:	4313      	orrs	r3, r2
20008b48:	f8c1 3088 	str.w	r3, [r1, #136]	; 0x88
  }

#if defined(I2C4)  

  /*-------------------------- I2C4 clock source configuration ---------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C4) == RCC_PERIPHCLK_I2C4)
20008b4c:	687b      	ldr	r3, [r7, #4]
20008b4e:	681b      	ldr	r3, [r3, #0]
20008b50:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
20008b54:	2b00      	cmp	r3, #0
20008b56:	d00a      	beq.n	20008b6e <HAL_RCCEx_PeriphCLKConfig+0x2a2>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2C4CLKSOURCE(PeriphClkInit->I2c4ClockSelection));

    /* Configure the I2C4 clock source */
    __HAL_RCC_I2C4_CONFIG(PeriphClkInit->I2c4ClockSelection);
20008b58:	4b5c      	ldr	r3, [pc, #368]	; (20008ccc <HAL_RCCEx_PeriphCLKConfig+0x400>)
20008b5a:	f8d3 309c 	ldr.w	r3, [r3, #156]	; 0x9c
20008b5e:	f023 0203 	bic.w	r2, r3, #3
20008b62:	687b      	ldr	r3, [r7, #4]
20008b64:	6a9b      	ldr	r3, [r3, #40]	; 0x28
20008b66:	4959      	ldr	r1, [pc, #356]	; (20008ccc <HAL_RCCEx_PeriphCLKConfig+0x400>)
20008b68:	4313      	orrs	r3, r2
20008b6a:	f8c1 309c 	str.w	r3, [r1, #156]	; 0x9c
  }

#endif /* I2C4 */

  /*-------------------------- LPTIM1 clock source configuration ---------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPTIM1) == RCC_PERIPHCLK_LPTIM1)
20008b6e:	687b      	ldr	r3, [r7, #4]
20008b70:	681b      	ldr	r3, [r3, #0]
20008b72:	f403 7300 	and.w	r3, r3, #512	; 0x200
20008b76:	2b00      	cmp	r3, #0
20008b78:	d00a      	beq.n	20008b90 <HAL_RCCEx_PeriphCLKConfig+0x2c4>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LPTIM1CLKSOURCE(PeriphClkInit->Lptim1ClockSelection));

    /* Configure the LPTIM1 clock source */
    __HAL_RCC_LPTIM1_CONFIG(PeriphClkInit->Lptim1ClockSelection);
20008b7a:	4b54      	ldr	r3, [pc, #336]	; (20008ccc <HAL_RCCEx_PeriphCLKConfig+0x400>)
20008b7c:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
20008b80:	f423 2240 	bic.w	r2, r3, #786432	; 0xc0000
20008b84:	687b      	ldr	r3, [r7, #4]
20008b86:	6adb      	ldr	r3, [r3, #44]	; 0x2c
20008b88:	4950      	ldr	r1, [pc, #320]	; (20008ccc <HAL_RCCEx_PeriphCLKConfig+0x400>)
20008b8a:	4313      	orrs	r3, r2
20008b8c:	f8c1 3088 	str.w	r3, [r1, #136]	; 0x88
  }

  /*-------------------------- SAI1 clock source configuration ---------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI1) == RCC_PERIPHCLK_SAI1)
20008b90:	687b      	ldr	r3, [r7, #4]
20008b92:	681b      	ldr	r3, [r3, #0]
20008b94:	f403 6380 	and.w	r3, r3, #1024	; 0x400
20008b98:	2b00      	cmp	r3, #0
20008b9a:	d015      	beq.n	20008bc8 <HAL_RCCEx_PeriphCLKConfig+0x2fc>
  {
    /* Check the parameters */
    assert_param(IS_RCC_SAI1CLKSOURCE(PeriphClkInit->Sai1ClockSelection));

    /* Configure the SAI1 interface clock source */
    __HAL_RCC_SAI1_CONFIG(PeriphClkInit->Sai1ClockSelection);
20008b9c:	4b4b      	ldr	r3, [pc, #300]	; (20008ccc <HAL_RCCEx_PeriphCLKConfig+0x400>)
20008b9e:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
20008ba2:	f423 1240 	bic.w	r2, r3, #3145728	; 0x300000
20008ba6:	687b      	ldr	r3, [r7, #4]
20008ba8:	6b1b      	ldr	r3, [r3, #48]	; 0x30
20008baa:	4948      	ldr	r1, [pc, #288]	; (20008ccc <HAL_RCCEx_PeriphCLKConfig+0x400>)
20008bac:	4313      	orrs	r3, r2
20008bae:	f8c1 3088 	str.w	r3, [r1, #136]	; 0x88
    
    if(PeriphClkInit->Sai1ClockSelection == RCC_SAI1CLKSOURCE_PLL)
20008bb2:	687b      	ldr	r3, [r7, #4]
20008bb4:	6b1b      	ldr	r3, [r3, #48]	; 0x30
20008bb6:	f5b3 1f80 	cmp.w	r3, #1048576	; 0x100000
20008bba:	d105      	bne.n	20008bc8 <HAL_RCCEx_PeriphCLKConfig+0x2fc>
    {
      /* Enable PLL48M1CLK output */
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_48M1CLK);
20008bbc:	4b43      	ldr	r3, [pc, #268]	; (20008ccc <HAL_RCCEx_PeriphCLKConfig+0x400>)
20008bbe:	68db      	ldr	r3, [r3, #12]
20008bc0:	4a42      	ldr	r2, [pc, #264]	; (20008ccc <HAL_RCCEx_PeriphCLKConfig+0x400>)
20008bc2:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
20008bc6:	60d3      	str	r3, [r2, #12]
    }
  }

  /*-------------------------- I2S clock source configuration ---------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2S) == RCC_PERIPHCLK_I2S)
20008bc8:	687b      	ldr	r3, [r7, #4]
20008bca:	681b      	ldr	r3, [r3, #0]
20008bcc:	f403 6300 	and.w	r3, r3, #2048	; 0x800
20008bd0:	2b00      	cmp	r3, #0
20008bd2:	d015      	beq.n	20008c00 <HAL_RCCEx_PeriphCLKConfig+0x334>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2SCLKSOURCE(PeriphClkInit->I2sClockSelection));

    /* Configure the I2S interface clock source */
    __HAL_RCC_I2S_CONFIG(PeriphClkInit->I2sClockSelection);
20008bd4:	4b3d      	ldr	r3, [pc, #244]	; (20008ccc <HAL_RCCEx_PeriphCLKConfig+0x400>)
20008bd6:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
20008bda:	f423 0240 	bic.w	r2, r3, #12582912	; 0xc00000
20008bde:	687b      	ldr	r3, [r7, #4]
20008be0:	6b5b      	ldr	r3, [r3, #52]	; 0x34
20008be2:	493a      	ldr	r1, [pc, #232]	; (20008ccc <HAL_RCCEx_PeriphCLKConfig+0x400>)
20008be4:	4313      	orrs	r3, r2
20008be6:	f8c1 3088 	str.w	r3, [r1, #136]	; 0x88
    
    if(PeriphClkInit->I2sClockSelection == RCC_I2SCLKSOURCE_PLL)
20008bea:	687b      	ldr	r3, [r7, #4]
20008bec:	6b5b      	ldr	r3, [r3, #52]	; 0x34
20008bee:	f5b3 0f80 	cmp.w	r3, #4194304	; 0x400000
20008bf2:	d105      	bne.n	20008c00 <HAL_RCCEx_PeriphCLKConfig+0x334>
    {
      /* Enable PLL48M1CLK output */
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_48M1CLK);
20008bf4:	4b35      	ldr	r3, [pc, #212]	; (20008ccc <HAL_RCCEx_PeriphCLKConfig+0x400>)
20008bf6:	68db      	ldr	r3, [r3, #12]
20008bf8:	4a34      	ldr	r2, [pc, #208]	; (20008ccc <HAL_RCCEx_PeriphCLKConfig+0x400>)
20008bfa:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
20008bfe:	60d3      	str	r3, [r2, #12]
    }
  }

#if defined(FDCAN1)
  /*-------------------------- FDCAN clock source configuration ---------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_FDCAN) == RCC_PERIPHCLK_FDCAN)
20008c00:	687b      	ldr	r3, [r7, #4]
20008c02:	681b      	ldr	r3, [r3, #0]
20008c04:	f403 5380 	and.w	r3, r3, #4096	; 0x1000
20008c08:	2b00      	cmp	r3, #0
20008c0a:	d015      	beq.n	20008c38 <HAL_RCCEx_PeriphCLKConfig+0x36c>
  {
    /* Check the parameters */
    assert_param(IS_RCC_FDCANCLKSOURCE(PeriphClkInit->FdcanClockSelection));

    /* Configure the FDCAN interface clock source */
    __HAL_RCC_FDCAN_CONFIG(PeriphClkInit->FdcanClockSelection);
20008c0c:	4b2f      	ldr	r3, [pc, #188]	; (20008ccc <HAL_RCCEx_PeriphCLKConfig+0x400>)
20008c0e:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
20008c12:	f023 7240 	bic.w	r2, r3, #50331648	; 0x3000000
20008c16:	687b      	ldr	r3, [r7, #4]
20008c18:	6b9b      	ldr	r3, [r3, #56]	; 0x38
20008c1a:	492c      	ldr	r1, [pc, #176]	; (20008ccc <HAL_RCCEx_PeriphCLKConfig+0x400>)
20008c1c:	4313      	orrs	r3, r2
20008c1e:	f8c1 3088 	str.w	r3, [r1, #136]	; 0x88
    
    if(PeriphClkInit->FdcanClockSelection == RCC_FDCANCLKSOURCE_PLL)
20008c22:	687b      	ldr	r3, [r7, #4]
20008c24:	6b9b      	ldr	r3, [r3, #56]	; 0x38
20008c26:	f1b3 7f80 	cmp.w	r3, #16777216	; 0x1000000
20008c2a:	d105      	bne.n	20008c38 <HAL_RCCEx_PeriphCLKConfig+0x36c>
    {
      /* Enable PLL48M1CLK output */
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_48M1CLK);
20008c2c:	4b27      	ldr	r3, [pc, #156]	; (20008ccc <HAL_RCCEx_PeriphCLKConfig+0x400>)
20008c2e:	68db      	ldr	r3, [r3, #12]
20008c30:	4a26      	ldr	r2, [pc, #152]	; (20008ccc <HAL_RCCEx_PeriphCLKConfig+0x400>)
20008c32:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
20008c36:	60d3      	str	r3, [r2, #12]
#endif /* FDCAN1 */

#if defined(USB)

  /*-------------------------- USB clock source configuration ----------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USB) == (RCC_PERIPHCLK_USB))
20008c38:	687b      	ldr	r3, [r7, #4]
20008c3a:	681b      	ldr	r3, [r3, #0]
20008c3c:	f403 5300 	and.w	r3, r3, #8192	; 0x2000
20008c40:	2b00      	cmp	r3, #0
20008c42:	d015      	beq.n	20008c70 <HAL_RCCEx_PeriphCLKConfig+0x3a4>
  {
    assert_param(IS_RCC_USBCLKSOURCE(PeriphClkInit->UsbClockSelection));
    __HAL_RCC_USB_CONFIG(PeriphClkInit->UsbClockSelection);
20008c44:	4b21      	ldr	r3, [pc, #132]	; (20008ccc <HAL_RCCEx_PeriphCLKConfig+0x400>)
20008c46:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
20008c4a:	f023 6240 	bic.w	r2, r3, #201326592	; 0xc000000
20008c4e:	687b      	ldr	r3, [r7, #4]
20008c50:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
20008c52:	491e      	ldr	r1, [pc, #120]	; (20008ccc <HAL_RCCEx_PeriphCLKConfig+0x400>)
20008c54:	4313      	orrs	r3, r2
20008c56:	f8c1 3088 	str.w	r3, [r1, #136]	; 0x88

    if(PeriphClkInit->UsbClockSelection == RCC_USBCLKSOURCE_PLL)
20008c5a:	687b      	ldr	r3, [r7, #4]
20008c5c:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
20008c5e:	f1b3 6f00 	cmp.w	r3, #134217728	; 0x8000000
20008c62:	d105      	bne.n	20008c70 <HAL_RCCEx_PeriphCLKConfig+0x3a4>
    {
      /* Enable PLL48M1CLK output */
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_48M1CLK);
20008c64:	4b19      	ldr	r3, [pc, #100]	; (20008ccc <HAL_RCCEx_PeriphCLKConfig+0x400>)
20008c66:	68db      	ldr	r3, [r3, #12]
20008c68:	4a18      	ldr	r2, [pc, #96]	; (20008ccc <HAL_RCCEx_PeriphCLKConfig+0x400>)
20008c6a:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
20008c6e:	60d3      	str	r3, [r2, #12]
  }

#endif /* USB */

  /*-------------------------- RNG clock source configuration ----------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_RNG) == (RCC_PERIPHCLK_RNG))
20008c70:	687b      	ldr	r3, [r7, #4]
20008c72:	681b      	ldr	r3, [r3, #0]
20008c74:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
20008c78:	2b00      	cmp	r3, #0
20008c7a:	d015      	beq.n	20008ca8 <HAL_RCCEx_PeriphCLKConfig+0x3dc>
  {
    assert_param(IS_RCC_RNGCLKSOURCE(PeriphClkInit->RngClockSelection));
    __HAL_RCC_RNG_CONFIG(PeriphClkInit->RngClockSelection);
20008c7c:	4b13      	ldr	r3, [pc, #76]	; (20008ccc <HAL_RCCEx_PeriphCLKConfig+0x400>)
20008c7e:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
20008c82:	f023 6240 	bic.w	r2, r3, #201326592	; 0xc000000
20008c86:	687b      	ldr	r3, [r7, #4]
20008c88:	6c1b      	ldr	r3, [r3, #64]	; 0x40
20008c8a:	4910      	ldr	r1, [pc, #64]	; (20008ccc <HAL_RCCEx_PeriphCLKConfig+0x400>)
20008c8c:	4313      	orrs	r3, r2
20008c8e:	f8c1 3088 	str.w	r3, [r1, #136]	; 0x88

    if(PeriphClkInit->RngClockSelection == RCC_RNGCLKSOURCE_PLL)
20008c92:	687b      	ldr	r3, [r7, #4]
20008c94:	6c1b      	ldr	r3, [r3, #64]	; 0x40
20008c96:	f1b3 6f00 	cmp.w	r3, #134217728	; 0x8000000
20008c9a:	d105      	bne.n	20008ca8 <HAL_RCCEx_PeriphCLKConfig+0x3dc>
    {
      /* Enable PLL48M1CLK output */
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_48M1CLK);
20008c9c:	4b0b      	ldr	r3, [pc, #44]	; (20008ccc <HAL_RCCEx_PeriphCLKConfig+0x400>)
20008c9e:	68db      	ldr	r3, [r3, #12]
20008ca0:	4a0a      	ldr	r2, [pc, #40]	; (20008ccc <HAL_RCCEx_PeriphCLKConfig+0x400>)
20008ca2:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
20008ca6:	60d3      	str	r3, [r2, #12]
    }
  }

  /*-------------------------- ADC12 clock source configuration ----------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_ADC12) == RCC_PERIPHCLK_ADC12)
20008ca8:	687b      	ldr	r3, [r7, #4]
20008caa:	681b      	ldr	r3, [r3, #0]
20008cac:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
20008cb0:	2b00      	cmp	r3, #0
20008cb2:	d018      	beq.n	20008ce6 <HAL_RCCEx_PeriphCLKConfig+0x41a>
  {
    /* Check the parameters */
    assert_param(IS_RCC_ADC12CLKSOURCE(PeriphClkInit->Adc12ClockSelection));

    /* Configure the ADC12 interface clock source */
    __HAL_RCC_ADC12_CONFIG(PeriphClkInit->Adc12ClockSelection);
20008cb4:	4b05      	ldr	r3, [pc, #20]	; (20008ccc <HAL_RCCEx_PeriphCLKConfig+0x400>)
20008cb6:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
20008cba:	f023 5240 	bic.w	r2, r3, #805306368	; 0x30000000
20008cbe:	687b      	ldr	r3, [r7, #4]
20008cc0:	6c5b      	ldr	r3, [r3, #68]	; 0x44
20008cc2:	4902      	ldr	r1, [pc, #8]	; (20008ccc <HAL_RCCEx_PeriphCLKConfig+0x400>)
20008cc4:	4313      	orrs	r3, r2
20008cc6:	f8c1 3088 	str.w	r3, [r1, #136]	; 0x88
20008cca:	e001      	b.n	20008cd0 <HAL_RCCEx_PeriphCLKConfig+0x404>
20008ccc:	40021000 	.word	0x40021000
    
    if(PeriphClkInit->Adc12ClockSelection == RCC_ADC12CLKSOURCE_PLL)
20008cd0:	687b      	ldr	r3, [r7, #4]
20008cd2:	6c5b      	ldr	r3, [r3, #68]	; 0x44
20008cd4:	f1b3 5f80 	cmp.w	r3, #268435456	; 0x10000000
20008cd8:	d105      	bne.n	20008ce6 <HAL_RCCEx_PeriphCLKConfig+0x41a>
    {
      /* Enable PLLADCCLK output */
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_ADCCLK);
20008cda:	4b21      	ldr	r3, [pc, #132]	; (20008d60 <HAL_RCCEx_PeriphCLKConfig+0x494>)
20008cdc:	68db      	ldr	r3, [r3, #12]
20008cde:	4a20      	ldr	r2, [pc, #128]	; (20008d60 <HAL_RCCEx_PeriphCLKConfig+0x494>)
20008ce0:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
20008ce4:	60d3      	str	r3, [r2, #12]
    }
  }
  
#if defined(ADC345_COMMON)
  /*-------------------------- ADC345 clock source configuration ----------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_ADC345) == RCC_PERIPHCLK_ADC345)
20008ce6:	687b      	ldr	r3, [r7, #4]
20008ce8:	681b      	ldr	r3, [r3, #0]
20008cea:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
20008cee:	2b00      	cmp	r3, #0
20008cf0:	d015      	beq.n	20008d1e <HAL_RCCEx_PeriphCLKConfig+0x452>
  {
    /* Check the parameters */
    assert_param(IS_RCC_ADC345CLKSOURCE(PeriphClkInit->Adc345ClockSelection));

    /* Configure the ADC345 interface clock source */
    __HAL_RCC_ADC345_CONFIG(PeriphClkInit->Adc345ClockSelection);
20008cf2:	4b1b      	ldr	r3, [pc, #108]	; (20008d60 <HAL_RCCEx_PeriphCLKConfig+0x494>)
20008cf4:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
20008cf8:	f023 4240 	bic.w	r2, r3, #3221225472	; 0xc0000000
20008cfc:	687b      	ldr	r3, [r7, #4]
20008cfe:	6c9b      	ldr	r3, [r3, #72]	; 0x48
20008d00:	4917      	ldr	r1, [pc, #92]	; (20008d60 <HAL_RCCEx_PeriphCLKConfig+0x494>)
20008d02:	4313      	orrs	r3, r2
20008d04:	f8c1 3088 	str.w	r3, [r1, #136]	; 0x88
    
    if(PeriphClkInit->Adc345ClockSelection == RCC_ADC345CLKSOURCE_PLL)
20008d08:	687b      	ldr	r3, [r7, #4]
20008d0a:	6c9b      	ldr	r3, [r3, #72]	; 0x48
20008d0c:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
20008d10:	d105      	bne.n	20008d1e <HAL_RCCEx_PeriphCLKConfig+0x452>
    {
      /* Enable PLLADCCLK output */
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_ADCCLK);
20008d12:	4b13      	ldr	r3, [pc, #76]	; (20008d60 <HAL_RCCEx_PeriphCLKConfig+0x494>)
20008d14:	68db      	ldr	r3, [r3, #12]
20008d16:	4a12      	ldr	r2, [pc, #72]	; (20008d60 <HAL_RCCEx_PeriphCLKConfig+0x494>)
20008d18:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
20008d1c:	60d3      	str	r3, [r2, #12]
#endif /* ADC345_COMMON */

#if defined(QUADSPI)

  /*-------------------------- QuadSPIx clock source configuration ----------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_QSPI) == RCC_PERIPHCLK_QSPI)
20008d1e:	687b      	ldr	r3, [r7, #4]
20008d20:	681b      	ldr	r3, [r3, #0]
20008d22:	f403 2380 	and.w	r3, r3, #262144	; 0x40000
20008d26:	2b00      	cmp	r3, #0
20008d28:	d015      	beq.n	20008d56 <HAL_RCCEx_PeriphCLKConfig+0x48a>
  {
    /* Check the parameters */
    assert_param(IS_RCC_QSPICLKSOURCE(PeriphClkInit->QspiClockSelection));

    /* Configure the QuadSPI clock source */
    __HAL_RCC_QSPI_CONFIG(PeriphClkInit->QspiClockSelection);
20008d2a:	4b0d      	ldr	r3, [pc, #52]	; (20008d60 <HAL_RCCEx_PeriphCLKConfig+0x494>)
20008d2c:	f8d3 309c 	ldr.w	r3, [r3, #156]	; 0x9c
20008d30:	f423 1240 	bic.w	r2, r3, #3145728	; 0x300000
20008d34:	687b      	ldr	r3, [r7, #4]
20008d36:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
20008d38:	4909      	ldr	r1, [pc, #36]	; (20008d60 <HAL_RCCEx_PeriphCLKConfig+0x494>)
20008d3a:	4313      	orrs	r3, r2
20008d3c:	f8c1 309c 	str.w	r3, [r1, #156]	; 0x9c

    if(PeriphClkInit->QspiClockSelection == RCC_QSPICLKSOURCE_PLL)
20008d40:	687b      	ldr	r3, [r7, #4]
20008d42:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
20008d44:	f5b3 1f00 	cmp.w	r3, #2097152	; 0x200000
20008d48:	d105      	bne.n	20008d56 <HAL_RCCEx_PeriphCLKConfig+0x48a>
    {
      /* Enable PLL48M1CLK output */
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_48M1CLK);
20008d4a:	4b05      	ldr	r3, [pc, #20]	; (20008d60 <HAL_RCCEx_PeriphCLKConfig+0x494>)
20008d4c:	68db      	ldr	r3, [r3, #12]
20008d4e:	4a04      	ldr	r2, [pc, #16]	; (20008d60 <HAL_RCCEx_PeriphCLKConfig+0x494>)
20008d50:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
20008d54:	60d3      	str	r3, [r2, #12]
    }
  }

#endif /* QUADSPI */

  return status;
20008d56:	7cbb      	ldrb	r3, [r7, #18]
}
20008d58:	4618      	mov	r0, r3
20008d5a:	3718      	adds	r7, #24
20008d5c:	46bd      	mov	sp, r7
20008d5e:	bd80      	pop	{r7, pc}
20008d60:	40021000 	.word	0x40021000

20008d64 <HAL_RCCEx_GetPeriphCLKConfig>:
  *         clocks(USART1, USART2, USART3, UART4, UART5, LPUART1, I2C1, I2C2, I2C3, I2C4,
  *         LPTIM1, SAI1, I2Sx, FDCANx, USB, RNG, ADCx, RTC, QSPI).
  * @retval None
  */
void HAL_RCCEx_GetPeriphCLKConfig(RCC_PeriphCLKInitTypeDef  *PeriphClkInit)
{
20008d64:	b480      	push	{r7}
20008d66:	b083      	sub	sp, #12
20008d68:	af00      	add	r7, sp, #0
20008d6a:	6078      	str	r0, [r7, #4]
                                        RCC_PERIPHCLK_QSPI    | \
                                        RCC_PERIPHCLK_RTC;

#elif defined(STM32G473xx) || defined(STM32G483xx)

  PeriphClkInit->PeriphClockSelection = RCC_PERIPHCLK_USART1  | RCC_PERIPHCLK_USART2 | RCC_PERIPHCLK_USART3 | RCC_PERIPHCLK_UART4  | \
20008d6c:	687b      	ldr	r3, [r7, #4]
20008d6e:	4a4a      	ldr	r2, [pc, #296]	; (20008e98 <HAL_RCCEx_GetPeriphCLKConfig+0x134>)
20008d70:	601a      	str	r2, [r3, #0]

#endif /* STM32G431xx */


  /* Get the USART1 clock source ---------------------------------------------*/
  PeriphClkInit->Usart1ClockSelection  = __HAL_RCC_GET_USART1_SOURCE();
20008d72:	4b4a      	ldr	r3, [pc, #296]	; (20008e9c <HAL_RCCEx_GetPeriphCLKConfig+0x138>)
20008d74:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
20008d78:	f003 0203 	and.w	r2, r3, #3
20008d7c:	687b      	ldr	r3, [r7, #4]
20008d7e:	605a      	str	r2, [r3, #4]
  /* Get the USART2 clock source ---------------------------------------------*/
  PeriphClkInit->Usart2ClockSelection  = __HAL_RCC_GET_USART2_SOURCE();
20008d80:	4b46      	ldr	r3, [pc, #280]	; (20008e9c <HAL_RCCEx_GetPeriphCLKConfig+0x138>)
20008d82:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
20008d86:	f003 020c 	and.w	r2, r3, #12
20008d8a:	687b      	ldr	r3, [r7, #4]
20008d8c:	609a      	str	r2, [r3, #8]
  /* Get the USART3 clock source ---------------------------------------------*/
  PeriphClkInit->Usart3ClockSelection  = __HAL_RCC_GET_USART3_SOURCE();
20008d8e:	4b43      	ldr	r3, [pc, #268]	; (20008e9c <HAL_RCCEx_GetPeriphCLKConfig+0x138>)
20008d90:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
20008d94:	f003 0230 	and.w	r2, r3, #48	; 0x30
20008d98:	687b      	ldr	r3, [r7, #4]
20008d9a:	60da      	str	r2, [r3, #12]

#if defined(UART4)
  /* Get the UART4 clock source ----------------------------------------------*/
  PeriphClkInit->Uart4ClockSelection   = __HAL_RCC_GET_UART4_SOURCE();
20008d9c:	4b3f      	ldr	r3, [pc, #252]	; (20008e9c <HAL_RCCEx_GetPeriphCLKConfig+0x138>)
20008d9e:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
20008da2:	f003 02c0 	and.w	r2, r3, #192	; 0xc0
20008da6:	687b      	ldr	r3, [r7, #4]
20008da8:	611a      	str	r2, [r3, #16]
#endif /* UART4 */

#if defined(UART5)
  /* Get the UART5 clock source ----------------------------------------------*/
  PeriphClkInit->Uart5ClockSelection   = __HAL_RCC_GET_UART5_SOURCE();
20008daa:	4b3c      	ldr	r3, [pc, #240]	; (20008e9c <HAL_RCCEx_GetPeriphCLKConfig+0x138>)
20008dac:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
20008db0:	f403 7240 	and.w	r2, r3, #768	; 0x300
20008db4:	687b      	ldr	r3, [r7, #4]
20008db6:	615a      	str	r2, [r3, #20]
#endif /* UART5 */
  
  /* Get the LPUART1 clock source --------------------------------------------*/
  PeriphClkInit->Lpuart1ClockSelection = __HAL_RCC_GET_LPUART1_SOURCE();
20008db8:	4b38      	ldr	r3, [pc, #224]	; (20008e9c <HAL_RCCEx_GetPeriphCLKConfig+0x138>)
20008dba:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
20008dbe:	f403 6240 	and.w	r2, r3, #3072	; 0xc00
20008dc2:	687b      	ldr	r3, [r7, #4]
20008dc4:	619a      	str	r2, [r3, #24]

  /* Get the I2C1 clock source -----------------------------------------------*/
  PeriphClkInit->I2c1ClockSelection    = __HAL_RCC_GET_I2C1_SOURCE();
20008dc6:	4b35      	ldr	r3, [pc, #212]	; (20008e9c <HAL_RCCEx_GetPeriphCLKConfig+0x138>)
20008dc8:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
20008dcc:	f403 5240 	and.w	r2, r3, #12288	; 0x3000
20008dd0:	687b      	ldr	r3, [r7, #4]
20008dd2:	61da      	str	r2, [r3, #28]

  /* Get the I2C2 clock source ----------------------------------------------*/
  PeriphClkInit->I2c2ClockSelection    = __HAL_RCC_GET_I2C2_SOURCE();
20008dd4:	4b31      	ldr	r3, [pc, #196]	; (20008e9c <HAL_RCCEx_GetPeriphCLKConfig+0x138>)
20008dd6:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
20008dda:	f403 4240 	and.w	r2, r3, #49152	; 0xc000
20008dde:	687b      	ldr	r3, [r7, #4]
20008de0:	621a      	str	r2, [r3, #32]

  /* Get the I2C3 clock source -----------------------------------------------*/
  PeriphClkInit->I2c3ClockSelection    = __HAL_RCC_GET_I2C3_SOURCE();
20008de2:	4b2e      	ldr	r3, [pc, #184]	; (20008e9c <HAL_RCCEx_GetPeriphCLKConfig+0x138>)
20008de4:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
20008de8:	f403 3240 	and.w	r2, r3, #196608	; 0x30000
20008dec:	687b      	ldr	r3, [r7, #4]
20008dee:	625a      	str	r2, [r3, #36]	; 0x24

#if defined(I2C4)
  /* Get the I2C4 clock source -----------------------------------------------*/
  PeriphClkInit->I2c4ClockSelection    = __HAL_RCC_GET_I2C4_SOURCE();
20008df0:	4b2a      	ldr	r3, [pc, #168]	; (20008e9c <HAL_RCCEx_GetPeriphCLKConfig+0x138>)
20008df2:	f8d3 309c 	ldr.w	r3, [r3, #156]	; 0x9c
20008df6:	f003 0203 	and.w	r2, r3, #3
20008dfa:	687b      	ldr	r3, [r7, #4]
20008dfc:	629a      	str	r2, [r3, #40]	; 0x28
#endif /* I2C4 */

  /* Get the LPTIM1 clock source ---------------------------------------------*/
  PeriphClkInit->Lptim1ClockSelection  = __HAL_RCC_GET_LPTIM1_SOURCE();
20008dfe:	4b27      	ldr	r3, [pc, #156]	; (20008e9c <HAL_RCCEx_GetPeriphCLKConfig+0x138>)
20008e00:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
20008e04:	f403 2240 	and.w	r2, r3, #786432	; 0xc0000
20008e08:	687b      	ldr	r3, [r7, #4]
20008e0a:	62da      	str	r2, [r3, #44]	; 0x2c

  /* Get the SAI1 clock source -----------------------------------------------*/
  PeriphClkInit->Sai1ClockSelection    = __HAL_RCC_GET_SAI1_SOURCE();
20008e0c:	4b23      	ldr	r3, [pc, #140]	; (20008e9c <HAL_RCCEx_GetPeriphCLKConfig+0x138>)
20008e0e:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
20008e12:	f403 1240 	and.w	r2, r3, #3145728	; 0x300000
20008e16:	687b      	ldr	r3, [r7, #4]
20008e18:	631a      	str	r2, [r3, #48]	; 0x30

  /* Get the I2S clock source -----------------------------------------------*/
  PeriphClkInit->I2sClockSelection    = __HAL_RCC_GET_I2S_SOURCE();
20008e1a:	4b20      	ldr	r3, [pc, #128]	; (20008e9c <HAL_RCCEx_GetPeriphCLKConfig+0x138>)
20008e1c:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
20008e20:	f403 0240 	and.w	r2, r3, #12582912	; 0xc00000
20008e24:	687b      	ldr	r3, [r7, #4]
20008e26:	635a      	str	r2, [r3, #52]	; 0x34

#if defined(FDCAN1)
  /* Get the FDCAN clock source -----------------------------------------------*/
  PeriphClkInit->FdcanClockSelection    = __HAL_RCC_GET_FDCAN_SOURCE();
20008e28:	4b1c      	ldr	r3, [pc, #112]	; (20008e9c <HAL_RCCEx_GetPeriphCLKConfig+0x138>)
20008e2a:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
20008e2e:	f003 7240 	and.w	r2, r3, #50331648	; 0x3000000
20008e32:	687b      	ldr	r3, [r7, #4]
20008e34:	639a      	str	r2, [r3, #56]	; 0x38
#endif /* FDCAN1 */

#if defined(USB)
  /* Get the USB clock source ------------------------------------------------*/
  PeriphClkInit->UsbClockSelection   = __HAL_RCC_GET_USB_SOURCE();
20008e36:	4b19      	ldr	r3, [pc, #100]	; (20008e9c <HAL_RCCEx_GetPeriphCLKConfig+0x138>)
20008e38:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
20008e3c:	f003 6240 	and.w	r2, r3, #201326592	; 0xc000000
20008e40:	687b      	ldr	r3, [r7, #4]
20008e42:	63da      	str	r2, [r3, #60]	; 0x3c
#endif /* USB */

  /* Get the RNG clock source ------------------------------------------------*/
  PeriphClkInit->RngClockSelection   = __HAL_RCC_GET_RNG_SOURCE();
20008e44:	4b15      	ldr	r3, [pc, #84]	; (20008e9c <HAL_RCCEx_GetPeriphCLKConfig+0x138>)
20008e46:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
20008e4a:	f003 6240 	and.w	r2, r3, #201326592	; 0xc000000
20008e4e:	687b      	ldr	r3, [r7, #4]
20008e50:	641a      	str	r2, [r3, #64]	; 0x40

  /* Get the ADC12 clock source -----------------------------------------------*/
  PeriphClkInit->Adc12ClockSelection     = __HAL_RCC_GET_ADC12_SOURCE();
20008e52:	4b12      	ldr	r3, [pc, #72]	; (20008e9c <HAL_RCCEx_GetPeriphCLKConfig+0x138>)
20008e54:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
20008e58:	f003 5240 	and.w	r2, r3, #805306368	; 0x30000000
20008e5c:	687b      	ldr	r3, [r7, #4]
20008e5e:	645a      	str	r2, [r3, #68]	; 0x44

#if defined(ADC345_COMMON)
  /* Get the ADC345 clock source ----------------------------------------------*/
  PeriphClkInit->Adc345ClockSelection     = __HAL_RCC_GET_ADC345_SOURCE();
20008e60:	4b0e      	ldr	r3, [pc, #56]	; (20008e9c <HAL_RCCEx_GetPeriphCLKConfig+0x138>)
20008e62:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
20008e66:	f003 4240 	and.w	r2, r3, #3221225472	; 0xc0000000
20008e6a:	687b      	ldr	r3, [r7, #4]
20008e6c:	649a      	str	r2, [r3, #72]	; 0x48
#endif /* ADC345_COMMON */

#if defined(QUADSPI)
  /* Get the QuadSPIclock source --------------------------------------------*/
  PeriphClkInit->QspiClockSelection = __HAL_RCC_GET_QSPI_SOURCE();
20008e6e:	4b0b      	ldr	r3, [pc, #44]	; (20008e9c <HAL_RCCEx_GetPeriphCLKConfig+0x138>)
20008e70:	f8d3 309c 	ldr.w	r3, [r3, #156]	; 0x9c
20008e74:	f403 1240 	and.w	r2, r3, #3145728	; 0x300000
20008e78:	687b      	ldr	r3, [r7, #4]
20008e7a:	64da      	str	r2, [r3, #76]	; 0x4c
#endif /* QUADSPI */

  /* Get the RTC clock source ------------------------------------------------*/
  PeriphClkInit->RTCClockSelection     = __HAL_RCC_GET_RTC_SOURCE();
20008e7c:	4b07      	ldr	r3, [pc, #28]	; (20008e9c <HAL_RCCEx_GetPeriphCLKConfig+0x138>)
20008e7e:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
20008e82:	f403 7240 	and.w	r2, r3, #768	; 0x300
20008e86:	687b      	ldr	r3, [r7, #4]
20008e88:	651a      	str	r2, [r3, #80]	; 0x50

}
20008e8a:	bf00      	nop
20008e8c:	370c      	adds	r7, #12
20008e8e:	46bd      	mov	sp, r7
20008e90:	f85d 7b04 	ldr.w	r7, [sp], #4
20008e94:	4770      	bx	lr
20008e96:	bf00      	nop
20008e98:	000fefff 	.word	0x000fefff
20008e9c:	40021000 	.word	0x40021000

20008ea0 <HAL_RCCEx_GetPeriphCLKFreq>:
  *            @arg @ref RCC_PERIPHCLK_QSPI  QSPI peripheral clock (only for devices with QSPI)
  *            @arg @ref RCC_PERIPHCLK_RTC  RTC peripheral clock
  * @retval Frequency in Hz
  */
uint32_t HAL_RCCEx_GetPeriphCLKFreq(uint32_t PeriphClk)
{
20008ea0:	b580      	push	{r7, lr}
20008ea2:	b088      	sub	sp, #32
20008ea4:	af00      	add	r7, sp, #0
20008ea6:	6078      	str	r0, [r7, #4]
  uint32_t frequency = 0U;
20008ea8:	2300      	movs	r3, #0
20008eaa:	61fb      	str	r3, [r7, #28]
  uint32_t pllvco, plln, pllp;

  /* Check the parameters */
  assert_param(IS_RCC_PERIPHCLOCK(PeriphClk));

  if(PeriphClk == RCC_PERIPHCLK_RTC)
20008eac:	687b      	ldr	r3, [r7, #4]
20008eae:	f5b3 2f00 	cmp.w	r3, #524288	; 0x80000
20008eb2:	d136      	bne.n	20008f22 <HAL_RCCEx_GetPeriphCLKFreq+0x82>
  {
    /* Get the current RTC source */
    srcclk = __HAL_RCC_GET_RTC_SOURCE();
20008eb4:	4bc2      	ldr	r3, [pc, #776]	; (200091c0 <HAL_RCCEx_GetPeriphCLKFreq+0x320>)
20008eb6:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
20008eba:	f403 7340 	and.w	r3, r3, #768	; 0x300
20008ebe:	613b      	str	r3, [r7, #16]

    /* Check if LSE is ready and if RTC clock selection is LSE */
    if ((HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSERDY)) && (srcclk == RCC_RTCCLKSOURCE_LSE))
20008ec0:	4bbf      	ldr	r3, [pc, #764]	; (200091c0 <HAL_RCCEx_GetPeriphCLKFreq+0x320>)
20008ec2:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
20008ec6:	f003 0302 	and.w	r3, r3, #2
20008eca:	2b02      	cmp	r3, #2
20008ecc:	d108      	bne.n	20008ee0 <HAL_RCCEx_GetPeriphCLKFreq+0x40>
20008ece:	693b      	ldr	r3, [r7, #16]
20008ed0:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
20008ed4:	d104      	bne.n	20008ee0 <HAL_RCCEx_GetPeriphCLKFreq+0x40>
    {
      frequency = LSE_VALUE;
20008ed6:	f44f 4300 	mov.w	r3, #32768	; 0x8000
20008eda:	61fb      	str	r3, [r7, #28]
20008edc:	f000 bd14 	b.w	20009908 <HAL_RCCEx_GetPeriphCLKFreq+0xa68>
    }
    /* Check if LSI is ready and if RTC clock selection is LSI */
    else if ((HAL_IS_BIT_SET(RCC->CSR, RCC_CSR_LSIRDY)) && (srcclk == RCC_RTCCLKSOURCE_LSI))
20008ee0:	4bb7      	ldr	r3, [pc, #732]	; (200091c0 <HAL_RCCEx_GetPeriphCLKFreq+0x320>)
20008ee2:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
20008ee6:	f003 0302 	and.w	r3, r3, #2
20008eea:	2b02      	cmp	r3, #2
20008eec:	d108      	bne.n	20008f00 <HAL_RCCEx_GetPeriphCLKFreq+0x60>
20008eee:	693b      	ldr	r3, [r7, #16]
20008ef0:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
20008ef4:	d104      	bne.n	20008f00 <HAL_RCCEx_GetPeriphCLKFreq+0x60>
    {
      frequency = LSI_VALUE;
20008ef6:	f44f 43fa 	mov.w	r3, #32000	; 0x7d00
20008efa:	61fb      	str	r3, [r7, #28]
20008efc:	f000 bd04 	b.w	20009908 <HAL_RCCEx_GetPeriphCLKFreq+0xa68>
    }
    /* Check if HSE is ready  and if RTC clock selection is HSI_DIV32*/
    else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSERDY)) && (srcclk == RCC_RTCCLKSOURCE_HSE_DIV32))
20008f00:	4baf      	ldr	r3, [pc, #700]	; (200091c0 <HAL_RCCEx_GetPeriphCLKFreq+0x320>)
20008f02:	681b      	ldr	r3, [r3, #0]
20008f04:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
20008f08:	f5b3 3f00 	cmp.w	r3, #131072	; 0x20000
20008f0c:	f040 84fc 	bne.w	20009908 <HAL_RCCEx_GetPeriphCLKFreq+0xa68>
20008f10:	693b      	ldr	r3, [r7, #16]
20008f12:	f5b3 7f40 	cmp.w	r3, #768	; 0x300
20008f16:	f040 84f7 	bne.w	20009908 <HAL_RCCEx_GetPeriphCLKFreq+0xa68>
    {
      frequency = HSE_VALUE / 32U;
20008f1a:	4baa      	ldr	r3, [pc, #680]	; (200091c4 <HAL_RCCEx_GetPeriphCLKFreq+0x324>)
20008f1c:	61fb      	str	r3, [r7, #28]
20008f1e:	f000 bcf3 	b.w	20009908 <HAL_RCCEx_GetPeriphCLKFreq+0xa68>
  else
  {
    /* Other external peripheral clock source than RTC */

    /* Compute PLL clock input */
    if(__HAL_RCC_GET_PLL_OSCSOURCE() == RCC_PLLSOURCE_HSI)   /* HSI ? */
20008f22:	4ba7      	ldr	r3, [pc, #668]	; (200091c0 <HAL_RCCEx_GetPeriphCLKFreq+0x320>)
20008f24:	68db      	ldr	r3, [r3, #12]
20008f26:	f003 0303 	and.w	r3, r3, #3
20008f2a:	2b02      	cmp	r3, #2
20008f2c:	d10c      	bne.n	20008f48 <HAL_RCCEx_GetPeriphCLKFreq+0xa8>
    {
      if(HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY))
20008f2e:	4ba4      	ldr	r3, [pc, #656]	; (200091c0 <HAL_RCCEx_GetPeriphCLKFreq+0x320>)
20008f30:	681b      	ldr	r3, [r3, #0]
20008f32:	f403 6380 	and.w	r3, r3, #1024	; 0x400
20008f36:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
20008f3a:	d102      	bne.n	20008f42 <HAL_RCCEx_GetPeriphCLKFreq+0xa2>
      {
        pllvco = HSI_VALUE;
20008f3c:	4ba2      	ldr	r3, [pc, #648]	; (200091c8 <HAL_RCCEx_GetPeriphCLKFreq+0x328>)
20008f3e:	61bb      	str	r3, [r7, #24]
20008f40:	e017      	b.n	20008f72 <HAL_RCCEx_GetPeriphCLKFreq+0xd2>
      }
      else
      {
        pllvco = 0U;
20008f42:	2300      	movs	r3, #0
20008f44:	61bb      	str	r3, [r7, #24]
20008f46:	e014      	b.n	20008f72 <HAL_RCCEx_GetPeriphCLKFreq+0xd2>
      }
    }
    else if(__HAL_RCC_GET_PLL_OSCSOURCE() == RCC_PLLSOURCE_HSE)   /* HSE ? */
20008f48:	4b9d      	ldr	r3, [pc, #628]	; (200091c0 <HAL_RCCEx_GetPeriphCLKFreq+0x320>)
20008f4a:	68db      	ldr	r3, [r3, #12]
20008f4c:	f003 0303 	and.w	r3, r3, #3
20008f50:	2b03      	cmp	r3, #3
20008f52:	d10c      	bne.n	20008f6e <HAL_RCCEx_GetPeriphCLKFreq+0xce>
    {
      if(HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSERDY))
20008f54:	4b9a      	ldr	r3, [pc, #616]	; (200091c0 <HAL_RCCEx_GetPeriphCLKFreq+0x320>)
20008f56:	681b      	ldr	r3, [r3, #0]
20008f58:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
20008f5c:	f5b3 3f00 	cmp.w	r3, #131072	; 0x20000
20008f60:	d102      	bne.n	20008f68 <HAL_RCCEx_GetPeriphCLKFreq+0xc8>
      {
        pllvco = HSE_VALUE;
20008f62:	4b9a      	ldr	r3, [pc, #616]	; (200091cc <HAL_RCCEx_GetPeriphCLKFreq+0x32c>)
20008f64:	61bb      	str	r3, [r7, #24]
20008f66:	e004      	b.n	20008f72 <HAL_RCCEx_GetPeriphCLKFreq+0xd2>
      }
      else
      {
        pllvco = 0U;
20008f68:	2300      	movs	r3, #0
20008f6a:	61bb      	str	r3, [r7, #24]
20008f6c:	e001      	b.n	20008f72 <HAL_RCCEx_GetPeriphCLKFreq+0xd2>
      }
    }
    else /* No source */
    {
      pllvco = 0U;
20008f6e:	2300      	movs	r3, #0
20008f70:	61bb      	str	r3, [r7, #24]
    }

    /* f(PLL Source) / PLLM */
    pllvco = (pllvco / ((READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLM) >> RCC_PLLCFGR_PLLM_Pos) + 1U));
20008f72:	4b93      	ldr	r3, [pc, #588]	; (200091c0 <HAL_RCCEx_GetPeriphCLKFreq+0x320>)
20008f74:	68db      	ldr	r3, [r3, #12]
20008f76:	091b      	lsrs	r3, r3, #4
20008f78:	f003 030f 	and.w	r3, r3, #15
20008f7c:	3301      	adds	r3, #1
20008f7e:	69ba      	ldr	r2, [r7, #24]
20008f80:	fbb2 f3f3 	udiv	r3, r2, r3
20008f84:	61bb      	str	r3, [r7, #24]

    switch(PeriphClk)
20008f86:	687b      	ldr	r3, [r7, #4]
20008f88:	f5b3 2f80 	cmp.w	r3, #262144	; 0x40000
20008f8c:	f000 8468 	beq.w	20009860 <HAL_RCCEx_GetPeriphCLKFreq+0x9c0>
20008f90:	687b      	ldr	r3, [r7, #4]
20008f92:	f5b3 2f80 	cmp.w	r3, #262144	; 0x40000
20008f96:	f200 8490 	bhi.w	200098ba <HAL_RCCEx_GetPeriphCLKFreq+0xa1a>
20008f9a:	687b      	ldr	r3, [r7, #4]
20008f9c:	f5b3 3f00 	cmp.w	r3, #131072	; 0x20000
20008fa0:	f000 825f 	beq.w	20009462 <HAL_RCCEx_GetPeriphCLKFreq+0x5c2>
20008fa4:	687b      	ldr	r3, [r7, #4]
20008fa6:	f5b3 3f00 	cmp.w	r3, #131072	; 0x20000
20008faa:	f200 8486 	bhi.w	200098ba <HAL_RCCEx_GetPeriphCLKFreq+0xa1a>
20008fae:	687b      	ldr	r3, [r7, #4]
20008fb0:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
20008fb4:	f000 8419 	beq.w	200097ea <HAL_RCCEx_GetPeriphCLKFreq+0x94a>
20008fb8:	687b      	ldr	r3, [r7, #4]
20008fba:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
20008fbe:	f200 847c 	bhi.w	200098ba <HAL_RCCEx_GetPeriphCLKFreq+0xa1a>
20008fc2:	687b      	ldr	r3, [r7, #4]
20008fc4:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
20008fc8:	f000 83d2 	beq.w	20009770 <HAL_RCCEx_GetPeriphCLKFreq+0x8d0>
20008fcc:	687b      	ldr	r3, [r7, #4]
20008fce:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
20008fd2:	f200 8472 	bhi.w	200098ba <HAL_RCCEx_GetPeriphCLKFreq+0xa1a>
20008fd6:	687b      	ldr	r3, [r7, #4]
20008fd8:	f5b3 4f80 	cmp.w	r3, #16384	; 0x4000
20008fdc:	f000 8390 	beq.w	20009700 <HAL_RCCEx_GetPeriphCLKFreq+0x860>
20008fe0:	687b      	ldr	r3, [r7, #4]
20008fe2:	f5b3 4f80 	cmp.w	r3, #16384	; 0x4000
20008fe6:	f200 8468 	bhi.w	200098ba <HAL_RCCEx_GetPeriphCLKFreq+0xa1a>
20008fea:	687b      	ldr	r3, [r7, #4]
20008fec:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
20008ff0:	f000 8358 	beq.w	200096a4 <HAL_RCCEx_GetPeriphCLKFreq+0x804>
20008ff4:	687b      	ldr	r3, [r7, #4]
20008ff6:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
20008ffa:	f200 845e 	bhi.w	200098ba <HAL_RCCEx_GetPeriphCLKFreq+0xa1a>
20008ffe:	687b      	ldr	r3, [r7, #4]
20009000:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
20009004:	f000 8319 	beq.w	2000963a <HAL_RCCEx_GetPeriphCLKFreq+0x79a>
20009008:	687b      	ldr	r3, [r7, #4]
2000900a:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
2000900e:	f200 8454 	bhi.w	200098ba <HAL_RCCEx_GetPeriphCLKFreq+0xa1a>
20009012:	687b      	ldr	r3, [r7, #4]
20009014:	f5b3 6f00 	cmp.w	r3, #2048	; 0x800
20009018:	f000 82cb 	beq.w	200095b2 <HAL_RCCEx_GetPeriphCLKFreq+0x712>
2000901c:	687b      	ldr	r3, [r7, #4]
2000901e:	f5b3 6f00 	cmp.w	r3, #2048	; 0x800
20009022:	f200 844a 	bhi.w	200098ba <HAL_RCCEx_GetPeriphCLKFreq+0xa1a>
20009026:	687b      	ldr	r3, [r7, #4]
20009028:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
2000902c:	f000 827d 	beq.w	2000952a <HAL_RCCEx_GetPeriphCLKFreq+0x68a>
20009030:	687b      	ldr	r3, [r7, #4]
20009032:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
20009036:	f200 8440 	bhi.w	200098ba <HAL_RCCEx_GetPeriphCLKFreq+0xa1a>
2000903a:	687b      	ldr	r3, [r7, #4]
2000903c:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
20009040:	f000 8237 	beq.w	200094b2 <HAL_RCCEx_GetPeriphCLKFreq+0x612>
20009044:	687b      	ldr	r3, [r7, #4]
20009046:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
2000904a:	f200 8436 	bhi.w	200098ba <HAL_RCCEx_GetPeriphCLKFreq+0xa1a>
2000904e:	687b      	ldr	r3, [r7, #4]
20009050:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
20009054:	f000 81e0 	beq.w	20009418 <HAL_RCCEx_GetPeriphCLKFreq+0x578>
20009058:	687b      	ldr	r3, [r7, #4]
2000905a:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
2000905e:	f200 842c 	bhi.w	200098ba <HAL_RCCEx_GetPeriphCLKFreq+0xa1a>
20009062:	687b      	ldr	r3, [r7, #4]
20009064:	2b80      	cmp	r3, #128	; 0x80
20009066:	f000 81b2 	beq.w	200093ce <HAL_RCCEx_GetPeriphCLKFreq+0x52e>
2000906a:	687b      	ldr	r3, [r7, #4]
2000906c:	2b80      	cmp	r3, #128	; 0x80
2000906e:	f200 8424 	bhi.w	200098ba <HAL_RCCEx_GetPeriphCLKFreq+0xa1a>
20009072:	687b      	ldr	r3, [r7, #4]
20009074:	2b20      	cmp	r3, #32
20009076:	d84b      	bhi.n	20009110 <HAL_RCCEx_GetPeriphCLKFreq+0x270>
20009078:	687b      	ldr	r3, [r7, #4]
2000907a:	2b00      	cmp	r3, #0
2000907c:	f000 841d 	beq.w	200098ba <HAL_RCCEx_GetPeriphCLKFreq+0xa1a>
20009080:	687b      	ldr	r3, [r7, #4]
20009082:	3b01      	subs	r3, #1
20009084:	2b1f      	cmp	r3, #31
20009086:	f200 8418 	bhi.w	200098ba <HAL_RCCEx_GetPeriphCLKFreq+0xa1a>
2000908a:	a201      	add	r2, pc, #4	; (adr r2, 20009090 <HAL_RCCEx_GetPeriphCLKFreq+0x1f0>)
2000908c:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
20009090:	2000911b 	.word	0x2000911b
20009094:	2000917d 	.word	0x2000917d
20009098:	200098bb 	.word	0x200098bb
2000909c:	200091f1 	.word	0x200091f1
200090a0:	200098bb 	.word	0x200098bb
200090a4:	200098bb 	.word	0x200098bb
200090a8:	200098bb 	.word	0x200098bb
200090ac:	20009253 	.word	0x20009253
200090b0:	200098bb 	.word	0x200098bb
200090b4:	200098bb 	.word	0x200098bb
200090b8:	200098bb 	.word	0x200098bb
200090bc:	200098bb 	.word	0x200098bb
200090c0:	200098bb 	.word	0x200098bb
200090c4:	200098bb 	.word	0x200098bb
200090c8:	200098bb 	.word	0x200098bb
200090cc:	200092b5 	.word	0x200092b5
200090d0:	200098bb 	.word	0x200098bb
200090d4:	200098bb 	.word	0x200098bb
200090d8:	200098bb 	.word	0x200098bb
200090dc:	200098bb 	.word	0x200098bb
200090e0:	200098bb 	.word	0x200098bb
200090e4:	200098bb 	.word	0x200098bb
200090e8:	200098bb 	.word	0x200098bb
200090ec:	200098bb 	.word	0x200098bb
200090f0:	200098bb 	.word	0x200098bb
200090f4:	200098bb 	.word	0x200098bb
200090f8:	200098bb 	.word	0x200098bb
200090fc:	200098bb 	.word	0x200098bb
20009100:	200098bb 	.word	0x200098bb
20009104:	200098bb 	.word	0x200098bb
20009108:	200098bb 	.word	0x200098bb
2000910c:	2000931d 	.word	0x2000931d
20009110:	687b      	ldr	r3, [r7, #4]
20009112:	2b40      	cmp	r3, #64	; 0x40
20009114:	f000 8136 	beq.w	20009384 <HAL_RCCEx_GetPeriphCLKFreq+0x4e4>
      break;

#endif /* QUADSPI */

    default:
      break;
20009118:	e3cf      	b.n	200098ba <HAL_RCCEx_GetPeriphCLKFreq+0xa1a>
      srcclk = __HAL_RCC_GET_USART1_SOURCE();
2000911a:	4b29      	ldr	r3, [pc, #164]	; (200091c0 <HAL_RCCEx_GetPeriphCLKFreq+0x320>)
2000911c:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
20009120:	f003 0303 	and.w	r3, r3, #3
20009124:	613b      	str	r3, [r7, #16]
      if(srcclk == RCC_USART1CLKSOURCE_PCLK2)
20009126:	693b      	ldr	r3, [r7, #16]
20009128:	2b00      	cmp	r3, #0
2000912a:	d103      	bne.n	20009134 <HAL_RCCEx_GetPeriphCLKFreq+0x294>
        frequency = HAL_RCC_GetPCLK2Freq();
2000912c:	f7ff fa3e 	bl	200085ac <HAL_RCC_GetPCLK2Freq>
20009130:	61f8      	str	r0, [r7, #28]
      break;
20009132:	e3c4      	b.n	200098be <HAL_RCCEx_GetPeriphCLKFreq+0xa1e>
      else if(srcclk == RCC_USART1CLKSOURCE_SYSCLK)
20009134:	693b      	ldr	r3, [r7, #16]
20009136:	2b01      	cmp	r3, #1
20009138:	d103      	bne.n	20009142 <HAL_RCCEx_GetPeriphCLKFreq+0x2a2>
        frequency = HAL_RCC_GetSysClockFreq();
2000913a:	f7ff f9b3 	bl	200084a4 <HAL_RCC_GetSysClockFreq>
2000913e:	61f8      	str	r0, [r7, #28]
      break;
20009140:	e3bd      	b.n	200098be <HAL_RCCEx_GetPeriphCLKFreq+0xa1e>
      else if((HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY)) && (srcclk == RCC_USART1CLKSOURCE_HSI) )
20009142:	4b1f      	ldr	r3, [pc, #124]	; (200091c0 <HAL_RCCEx_GetPeriphCLKFreq+0x320>)
20009144:	681b      	ldr	r3, [r3, #0]
20009146:	f403 6380 	and.w	r3, r3, #1024	; 0x400
2000914a:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
2000914e:	d105      	bne.n	2000915c <HAL_RCCEx_GetPeriphCLKFreq+0x2bc>
20009150:	693b      	ldr	r3, [r7, #16]
20009152:	2b02      	cmp	r3, #2
20009154:	d102      	bne.n	2000915c <HAL_RCCEx_GetPeriphCLKFreq+0x2bc>
        frequency = HSI_VALUE;
20009156:	4b1c      	ldr	r3, [pc, #112]	; (200091c8 <HAL_RCCEx_GetPeriphCLKFreq+0x328>)
20009158:	61fb      	str	r3, [r7, #28]
      break;
2000915a:	e3b0      	b.n	200098be <HAL_RCCEx_GetPeriphCLKFreq+0xa1e>
      else if((HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSERDY)) && (srcclk == RCC_USART1CLKSOURCE_LSE))
2000915c:	4b18      	ldr	r3, [pc, #96]	; (200091c0 <HAL_RCCEx_GetPeriphCLKFreq+0x320>)
2000915e:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
20009162:	f003 0302 	and.w	r3, r3, #2
20009166:	2b02      	cmp	r3, #2
20009168:	f040 83a9 	bne.w	200098be <HAL_RCCEx_GetPeriphCLKFreq+0xa1e>
2000916c:	693b      	ldr	r3, [r7, #16]
2000916e:	2b03      	cmp	r3, #3
20009170:	f040 83a5 	bne.w	200098be <HAL_RCCEx_GetPeriphCLKFreq+0xa1e>
        frequency = LSE_VALUE;
20009174:	f44f 4300 	mov.w	r3, #32768	; 0x8000
20009178:	61fb      	str	r3, [r7, #28]
      break;
2000917a:	e3a0      	b.n	200098be <HAL_RCCEx_GetPeriphCLKFreq+0xa1e>
      srcclk = __HAL_RCC_GET_USART2_SOURCE();
2000917c:	4b10      	ldr	r3, [pc, #64]	; (200091c0 <HAL_RCCEx_GetPeriphCLKFreq+0x320>)
2000917e:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
20009182:	f003 030c 	and.w	r3, r3, #12
20009186:	613b      	str	r3, [r7, #16]
      if(srcclk == RCC_USART2CLKSOURCE_PCLK1)
20009188:	693b      	ldr	r3, [r7, #16]
2000918a:	2b00      	cmp	r3, #0
2000918c:	d103      	bne.n	20009196 <HAL_RCCEx_GetPeriphCLKFreq+0x2f6>
        frequency = HAL_RCC_GetPCLK1Freq();
2000918e:	f7ff f9f7 	bl	20008580 <HAL_RCC_GetPCLK1Freq>
20009192:	61f8      	str	r0, [r7, #28]
      break;
20009194:	e395      	b.n	200098c2 <HAL_RCCEx_GetPeriphCLKFreq+0xa22>
      else if(srcclk == RCC_USART2CLKSOURCE_SYSCLK)
20009196:	693b      	ldr	r3, [r7, #16]
20009198:	2b04      	cmp	r3, #4
2000919a:	d103      	bne.n	200091a4 <HAL_RCCEx_GetPeriphCLKFreq+0x304>
        frequency = HAL_RCC_GetSysClockFreq();
2000919c:	f7ff f982 	bl	200084a4 <HAL_RCC_GetSysClockFreq>
200091a0:	61f8      	str	r0, [r7, #28]
      break;
200091a2:	e38e      	b.n	200098c2 <HAL_RCCEx_GetPeriphCLKFreq+0xa22>
      else if((HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY)) && (srcclk == RCC_USART2CLKSOURCE_HSI))
200091a4:	4b06      	ldr	r3, [pc, #24]	; (200091c0 <HAL_RCCEx_GetPeriphCLKFreq+0x320>)
200091a6:	681b      	ldr	r3, [r3, #0]
200091a8:	f403 6380 	and.w	r3, r3, #1024	; 0x400
200091ac:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
200091b0:	d10e      	bne.n	200091d0 <HAL_RCCEx_GetPeriphCLKFreq+0x330>
200091b2:	693b      	ldr	r3, [r7, #16]
200091b4:	2b08      	cmp	r3, #8
200091b6:	d10b      	bne.n	200091d0 <HAL_RCCEx_GetPeriphCLKFreq+0x330>
        frequency = HSI_VALUE;
200091b8:	4b03      	ldr	r3, [pc, #12]	; (200091c8 <HAL_RCCEx_GetPeriphCLKFreq+0x328>)
200091ba:	61fb      	str	r3, [r7, #28]
      break;
200091bc:	e381      	b.n	200098c2 <HAL_RCCEx_GetPeriphCLKFreq+0xa22>
200091be:	bf00      	nop
200091c0:	40021000 	.word	0x40021000
200091c4:	0003d090 	.word	0x0003d090
200091c8:	00f42400 	.word	0x00f42400
200091cc:	007a1200 	.word	0x007a1200
      else if((HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSERDY))  && (srcclk == RCC_USART2CLKSOURCE_LSE))
200091d0:	4bae      	ldr	r3, [pc, #696]	; (2000948c <HAL_RCCEx_GetPeriphCLKFreq+0x5ec>)
200091d2:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
200091d6:	f003 0302 	and.w	r3, r3, #2
200091da:	2b02      	cmp	r3, #2
200091dc:	f040 8371 	bne.w	200098c2 <HAL_RCCEx_GetPeriphCLKFreq+0xa22>
200091e0:	693b      	ldr	r3, [r7, #16]
200091e2:	2b0c      	cmp	r3, #12
200091e4:	f040 836d 	bne.w	200098c2 <HAL_RCCEx_GetPeriphCLKFreq+0xa22>
        frequency = LSE_VALUE;
200091e8:	f44f 4300 	mov.w	r3, #32768	; 0x8000
200091ec:	61fb      	str	r3, [r7, #28]
      break;
200091ee:	e368      	b.n	200098c2 <HAL_RCCEx_GetPeriphCLKFreq+0xa22>
      srcclk = __HAL_RCC_GET_USART3_SOURCE();
200091f0:	4ba6      	ldr	r3, [pc, #664]	; (2000948c <HAL_RCCEx_GetPeriphCLKFreq+0x5ec>)
200091f2:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
200091f6:	f003 0330 	and.w	r3, r3, #48	; 0x30
200091fa:	613b      	str	r3, [r7, #16]
      if(srcclk == RCC_USART3CLKSOURCE_PCLK1)
200091fc:	693b      	ldr	r3, [r7, #16]
200091fe:	2b00      	cmp	r3, #0
20009200:	d103      	bne.n	2000920a <HAL_RCCEx_GetPeriphCLKFreq+0x36a>
        frequency = HAL_RCC_GetPCLK1Freq();
20009202:	f7ff f9bd 	bl	20008580 <HAL_RCC_GetPCLK1Freq>
20009206:	61f8      	str	r0, [r7, #28]
      break;
20009208:	e35d      	b.n	200098c6 <HAL_RCCEx_GetPeriphCLKFreq+0xa26>
      else if(srcclk == RCC_USART3CLKSOURCE_SYSCLK)
2000920a:	693b      	ldr	r3, [r7, #16]
2000920c:	2b10      	cmp	r3, #16
2000920e:	d103      	bne.n	20009218 <HAL_RCCEx_GetPeriphCLKFreq+0x378>
        frequency = HAL_RCC_GetSysClockFreq();
20009210:	f7ff f948 	bl	200084a4 <HAL_RCC_GetSysClockFreq>
20009214:	61f8      	str	r0, [r7, #28]
      break;
20009216:	e356      	b.n	200098c6 <HAL_RCCEx_GetPeriphCLKFreq+0xa26>
      else if((HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY)) && (srcclk == RCC_USART3CLKSOURCE_HSI))
20009218:	4b9c      	ldr	r3, [pc, #624]	; (2000948c <HAL_RCCEx_GetPeriphCLKFreq+0x5ec>)
2000921a:	681b      	ldr	r3, [r3, #0]
2000921c:	f403 6380 	and.w	r3, r3, #1024	; 0x400
20009220:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
20009224:	d105      	bne.n	20009232 <HAL_RCCEx_GetPeriphCLKFreq+0x392>
20009226:	693b      	ldr	r3, [r7, #16]
20009228:	2b20      	cmp	r3, #32
2000922a:	d102      	bne.n	20009232 <HAL_RCCEx_GetPeriphCLKFreq+0x392>
        frequency = HSI_VALUE;
2000922c:	4b98      	ldr	r3, [pc, #608]	; (20009490 <HAL_RCCEx_GetPeriphCLKFreq+0x5f0>)
2000922e:	61fb      	str	r3, [r7, #28]
      break;
20009230:	e349      	b.n	200098c6 <HAL_RCCEx_GetPeriphCLKFreq+0xa26>
      else if((HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSERDY)) && (srcclk == RCC_USART3CLKSOURCE_LSE))
20009232:	4b96      	ldr	r3, [pc, #600]	; (2000948c <HAL_RCCEx_GetPeriphCLKFreq+0x5ec>)
20009234:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
20009238:	f003 0302 	and.w	r3, r3, #2
2000923c:	2b02      	cmp	r3, #2
2000923e:	f040 8342 	bne.w	200098c6 <HAL_RCCEx_GetPeriphCLKFreq+0xa26>
20009242:	693b      	ldr	r3, [r7, #16]
20009244:	2b30      	cmp	r3, #48	; 0x30
20009246:	f040 833e 	bne.w	200098c6 <HAL_RCCEx_GetPeriphCLKFreq+0xa26>
        frequency = LSE_VALUE;
2000924a:	f44f 4300 	mov.w	r3, #32768	; 0x8000
2000924e:	61fb      	str	r3, [r7, #28]
      break;
20009250:	e339      	b.n	200098c6 <HAL_RCCEx_GetPeriphCLKFreq+0xa26>
      srcclk = __HAL_RCC_GET_UART4_SOURCE();
20009252:	4b8e      	ldr	r3, [pc, #568]	; (2000948c <HAL_RCCEx_GetPeriphCLKFreq+0x5ec>)
20009254:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
20009258:	f003 03c0 	and.w	r3, r3, #192	; 0xc0
2000925c:	613b      	str	r3, [r7, #16]
      if(srcclk == RCC_UART4CLKSOURCE_PCLK1)
2000925e:	693b      	ldr	r3, [r7, #16]
20009260:	2b00      	cmp	r3, #0
20009262:	d103      	bne.n	2000926c <HAL_RCCEx_GetPeriphCLKFreq+0x3cc>
        frequency = HAL_RCC_GetPCLK1Freq();
20009264:	f7ff f98c 	bl	20008580 <HAL_RCC_GetPCLK1Freq>
20009268:	61f8      	str	r0, [r7, #28]
      break;
2000926a:	e32e      	b.n	200098ca <HAL_RCCEx_GetPeriphCLKFreq+0xa2a>
      else if(srcclk == RCC_UART4CLKSOURCE_SYSCLK)
2000926c:	693b      	ldr	r3, [r7, #16]
2000926e:	2b40      	cmp	r3, #64	; 0x40
20009270:	d103      	bne.n	2000927a <HAL_RCCEx_GetPeriphCLKFreq+0x3da>
        frequency = HAL_RCC_GetSysClockFreq();
20009272:	f7ff f917 	bl	200084a4 <HAL_RCC_GetSysClockFreq>
20009276:	61f8      	str	r0, [r7, #28]
      break;
20009278:	e327      	b.n	200098ca <HAL_RCCEx_GetPeriphCLKFreq+0xa2a>
      else if((HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY)) && (srcclk == RCC_UART4CLKSOURCE_HSI))
2000927a:	4b84      	ldr	r3, [pc, #528]	; (2000948c <HAL_RCCEx_GetPeriphCLKFreq+0x5ec>)
2000927c:	681b      	ldr	r3, [r3, #0]
2000927e:	f403 6380 	and.w	r3, r3, #1024	; 0x400
20009282:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
20009286:	d105      	bne.n	20009294 <HAL_RCCEx_GetPeriphCLKFreq+0x3f4>
20009288:	693b      	ldr	r3, [r7, #16]
2000928a:	2b80      	cmp	r3, #128	; 0x80
2000928c:	d102      	bne.n	20009294 <HAL_RCCEx_GetPeriphCLKFreq+0x3f4>
        frequency = HSI_VALUE;
2000928e:	4b80      	ldr	r3, [pc, #512]	; (20009490 <HAL_RCCEx_GetPeriphCLKFreq+0x5f0>)
20009290:	61fb      	str	r3, [r7, #28]
      break;
20009292:	e31a      	b.n	200098ca <HAL_RCCEx_GetPeriphCLKFreq+0xa2a>
      else if((HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSERDY)) && (srcclk == RCC_UART4CLKSOURCE_LSE))
20009294:	4b7d      	ldr	r3, [pc, #500]	; (2000948c <HAL_RCCEx_GetPeriphCLKFreq+0x5ec>)
20009296:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
2000929a:	f003 0302 	and.w	r3, r3, #2
2000929e:	2b02      	cmp	r3, #2
200092a0:	f040 8313 	bne.w	200098ca <HAL_RCCEx_GetPeriphCLKFreq+0xa2a>
200092a4:	693b      	ldr	r3, [r7, #16]
200092a6:	2bc0      	cmp	r3, #192	; 0xc0
200092a8:	f040 830f 	bne.w	200098ca <HAL_RCCEx_GetPeriphCLKFreq+0xa2a>
        frequency = LSE_VALUE;
200092ac:	f44f 4300 	mov.w	r3, #32768	; 0x8000
200092b0:	61fb      	str	r3, [r7, #28]
      break;
200092b2:	e30a      	b.n	200098ca <HAL_RCCEx_GetPeriphCLKFreq+0xa2a>
      srcclk = __HAL_RCC_GET_UART5_SOURCE();
200092b4:	4b75      	ldr	r3, [pc, #468]	; (2000948c <HAL_RCCEx_GetPeriphCLKFreq+0x5ec>)
200092b6:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
200092ba:	f403 7340 	and.w	r3, r3, #768	; 0x300
200092be:	613b      	str	r3, [r7, #16]
      if(srcclk == RCC_UART5CLKSOURCE_PCLK1)
200092c0:	693b      	ldr	r3, [r7, #16]
200092c2:	2b00      	cmp	r3, #0
200092c4:	d103      	bne.n	200092ce <HAL_RCCEx_GetPeriphCLKFreq+0x42e>
        frequency = HAL_RCC_GetPCLK1Freq();
200092c6:	f7ff f95b 	bl	20008580 <HAL_RCC_GetPCLK1Freq>
200092ca:	61f8      	str	r0, [r7, #28]
      break;
200092cc:	e2ff      	b.n	200098ce <HAL_RCCEx_GetPeriphCLKFreq+0xa2e>
      else if(srcclk == RCC_UART5CLKSOURCE_SYSCLK)
200092ce:	693b      	ldr	r3, [r7, #16]
200092d0:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
200092d4:	d103      	bne.n	200092de <HAL_RCCEx_GetPeriphCLKFreq+0x43e>
        frequency = HAL_RCC_GetSysClockFreq();
200092d6:	f7ff f8e5 	bl	200084a4 <HAL_RCC_GetSysClockFreq>
200092da:	61f8      	str	r0, [r7, #28]
      break;
200092dc:	e2f7      	b.n	200098ce <HAL_RCCEx_GetPeriphCLKFreq+0xa2e>
      else if((HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY)) && (srcclk == RCC_UART5CLKSOURCE_HSI))
200092de:	4b6b      	ldr	r3, [pc, #428]	; (2000948c <HAL_RCCEx_GetPeriphCLKFreq+0x5ec>)
200092e0:	681b      	ldr	r3, [r3, #0]
200092e2:	f403 6380 	and.w	r3, r3, #1024	; 0x400
200092e6:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
200092ea:	d106      	bne.n	200092fa <HAL_RCCEx_GetPeriphCLKFreq+0x45a>
200092ec:	693b      	ldr	r3, [r7, #16]
200092ee:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
200092f2:	d102      	bne.n	200092fa <HAL_RCCEx_GetPeriphCLKFreq+0x45a>
        frequency = HSI_VALUE;
200092f4:	4b66      	ldr	r3, [pc, #408]	; (20009490 <HAL_RCCEx_GetPeriphCLKFreq+0x5f0>)
200092f6:	61fb      	str	r3, [r7, #28]
      break;
200092f8:	e2e9      	b.n	200098ce <HAL_RCCEx_GetPeriphCLKFreq+0xa2e>
      else if((HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSERDY)) && (srcclk == RCC_UART5CLKSOURCE_LSE))
200092fa:	4b64      	ldr	r3, [pc, #400]	; (2000948c <HAL_RCCEx_GetPeriphCLKFreq+0x5ec>)
200092fc:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
20009300:	f003 0302 	and.w	r3, r3, #2
20009304:	2b02      	cmp	r3, #2
20009306:	f040 82e2 	bne.w	200098ce <HAL_RCCEx_GetPeriphCLKFreq+0xa2e>
2000930a:	693b      	ldr	r3, [r7, #16]
2000930c:	f5b3 7f40 	cmp.w	r3, #768	; 0x300
20009310:	f040 82dd 	bne.w	200098ce <HAL_RCCEx_GetPeriphCLKFreq+0xa2e>
        frequency = LSE_VALUE;
20009314:	f44f 4300 	mov.w	r3, #32768	; 0x8000
20009318:	61fb      	str	r3, [r7, #28]
      break;
2000931a:	e2d8      	b.n	200098ce <HAL_RCCEx_GetPeriphCLKFreq+0xa2e>
      srcclk = __HAL_RCC_GET_LPUART1_SOURCE();
2000931c:	4b5b      	ldr	r3, [pc, #364]	; (2000948c <HAL_RCCEx_GetPeriphCLKFreq+0x5ec>)
2000931e:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
20009322:	f403 6340 	and.w	r3, r3, #3072	; 0xc00
20009326:	613b      	str	r3, [r7, #16]
      if(srcclk == RCC_LPUART1CLKSOURCE_PCLK1)
20009328:	693b      	ldr	r3, [r7, #16]
2000932a:	2b00      	cmp	r3, #0
2000932c:	d103      	bne.n	20009336 <HAL_RCCEx_GetPeriphCLKFreq+0x496>
        frequency = HAL_RCC_GetPCLK1Freq();
2000932e:	f7ff f927 	bl	20008580 <HAL_RCC_GetPCLK1Freq>
20009332:	61f8      	str	r0, [r7, #28]
      break;
20009334:	e2cd      	b.n	200098d2 <HAL_RCCEx_GetPeriphCLKFreq+0xa32>
      else if(srcclk == RCC_LPUART1CLKSOURCE_SYSCLK)
20009336:	693b      	ldr	r3, [r7, #16]
20009338:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
2000933c:	d103      	bne.n	20009346 <HAL_RCCEx_GetPeriphCLKFreq+0x4a6>
        frequency = HAL_RCC_GetSysClockFreq();
2000933e:	f7ff f8b1 	bl	200084a4 <HAL_RCC_GetSysClockFreq>
20009342:	61f8      	str	r0, [r7, #28]
      break;
20009344:	e2c5      	b.n	200098d2 <HAL_RCCEx_GetPeriphCLKFreq+0xa32>
      else if((HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY)) && (srcclk == RCC_LPUART1CLKSOURCE_HSI))
20009346:	4b51      	ldr	r3, [pc, #324]	; (2000948c <HAL_RCCEx_GetPeriphCLKFreq+0x5ec>)
20009348:	681b      	ldr	r3, [r3, #0]
2000934a:	f403 6380 	and.w	r3, r3, #1024	; 0x400
2000934e:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
20009352:	d106      	bne.n	20009362 <HAL_RCCEx_GetPeriphCLKFreq+0x4c2>
20009354:	693b      	ldr	r3, [r7, #16]
20009356:	f5b3 6f00 	cmp.w	r3, #2048	; 0x800
2000935a:	d102      	bne.n	20009362 <HAL_RCCEx_GetPeriphCLKFreq+0x4c2>
        frequency = HSI_VALUE;
2000935c:	4b4c      	ldr	r3, [pc, #304]	; (20009490 <HAL_RCCEx_GetPeriphCLKFreq+0x5f0>)
2000935e:	61fb      	str	r3, [r7, #28]
      break;
20009360:	e2b7      	b.n	200098d2 <HAL_RCCEx_GetPeriphCLKFreq+0xa32>
      else if((HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSERDY)) && (srcclk == RCC_LPUART1CLKSOURCE_LSE))
20009362:	4b4a      	ldr	r3, [pc, #296]	; (2000948c <HAL_RCCEx_GetPeriphCLKFreq+0x5ec>)
20009364:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
20009368:	f003 0302 	and.w	r3, r3, #2
2000936c:	2b02      	cmp	r3, #2
2000936e:	f040 82b0 	bne.w	200098d2 <HAL_RCCEx_GetPeriphCLKFreq+0xa32>
20009372:	693b      	ldr	r3, [r7, #16]
20009374:	f5b3 6f40 	cmp.w	r3, #3072	; 0xc00
20009378:	f040 82ab 	bne.w	200098d2 <HAL_RCCEx_GetPeriphCLKFreq+0xa32>
        frequency = LSE_VALUE;
2000937c:	f44f 4300 	mov.w	r3, #32768	; 0x8000
20009380:	61fb      	str	r3, [r7, #28]
      break;
20009382:	e2a6      	b.n	200098d2 <HAL_RCCEx_GetPeriphCLKFreq+0xa32>
      srcclk = __HAL_RCC_GET_I2C1_SOURCE();
20009384:	4b41      	ldr	r3, [pc, #260]	; (2000948c <HAL_RCCEx_GetPeriphCLKFreq+0x5ec>)
20009386:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
2000938a:	f403 5340 	and.w	r3, r3, #12288	; 0x3000
2000938e:	613b      	str	r3, [r7, #16]
      if(srcclk == RCC_I2C1CLKSOURCE_PCLK1)
20009390:	693b      	ldr	r3, [r7, #16]
20009392:	2b00      	cmp	r3, #0
20009394:	d103      	bne.n	2000939e <HAL_RCCEx_GetPeriphCLKFreq+0x4fe>
        frequency = HAL_RCC_GetPCLK1Freq();
20009396:	f7ff f8f3 	bl	20008580 <HAL_RCC_GetPCLK1Freq>
2000939a:	61f8      	str	r0, [r7, #28]
      break;
2000939c:	e29b      	b.n	200098d6 <HAL_RCCEx_GetPeriphCLKFreq+0xa36>
      else if(srcclk == RCC_I2C1CLKSOURCE_SYSCLK)
2000939e:	693b      	ldr	r3, [r7, #16]
200093a0:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
200093a4:	d103      	bne.n	200093ae <HAL_RCCEx_GetPeriphCLKFreq+0x50e>
        frequency = HAL_RCC_GetSysClockFreq();
200093a6:	f7ff f87d 	bl	200084a4 <HAL_RCC_GetSysClockFreq>
200093aa:	61f8      	str	r0, [r7, #28]
      break;
200093ac:	e293      	b.n	200098d6 <HAL_RCCEx_GetPeriphCLKFreq+0xa36>
      else if((HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY)) && (srcclk == RCC_I2C1CLKSOURCE_HSI))
200093ae:	4b37      	ldr	r3, [pc, #220]	; (2000948c <HAL_RCCEx_GetPeriphCLKFreq+0x5ec>)
200093b0:	681b      	ldr	r3, [r3, #0]
200093b2:	f403 6380 	and.w	r3, r3, #1024	; 0x400
200093b6:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
200093ba:	f040 828c 	bne.w	200098d6 <HAL_RCCEx_GetPeriphCLKFreq+0xa36>
200093be:	693b      	ldr	r3, [r7, #16]
200093c0:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
200093c4:	f040 8287 	bne.w	200098d6 <HAL_RCCEx_GetPeriphCLKFreq+0xa36>
        frequency = HSI_VALUE;
200093c8:	4b31      	ldr	r3, [pc, #196]	; (20009490 <HAL_RCCEx_GetPeriphCLKFreq+0x5f0>)
200093ca:	61fb      	str	r3, [r7, #28]
      break;
200093cc:	e283      	b.n	200098d6 <HAL_RCCEx_GetPeriphCLKFreq+0xa36>
      srcclk = __HAL_RCC_GET_I2C2_SOURCE();
200093ce:	4b2f      	ldr	r3, [pc, #188]	; (2000948c <HAL_RCCEx_GetPeriphCLKFreq+0x5ec>)
200093d0:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
200093d4:	f403 4340 	and.w	r3, r3, #49152	; 0xc000
200093d8:	613b      	str	r3, [r7, #16]
      if(srcclk == RCC_I2C2CLKSOURCE_PCLK1)
200093da:	693b      	ldr	r3, [r7, #16]
200093dc:	2b00      	cmp	r3, #0
200093de:	d103      	bne.n	200093e8 <HAL_RCCEx_GetPeriphCLKFreq+0x548>
        frequency = HAL_RCC_GetPCLK1Freq();
200093e0:	f7ff f8ce 	bl	20008580 <HAL_RCC_GetPCLK1Freq>
200093e4:	61f8      	str	r0, [r7, #28]
      break;
200093e6:	e278      	b.n	200098da <HAL_RCCEx_GetPeriphCLKFreq+0xa3a>
      else if(srcclk == RCC_I2C2CLKSOURCE_SYSCLK)
200093e8:	693b      	ldr	r3, [r7, #16]
200093ea:	f5b3 4f80 	cmp.w	r3, #16384	; 0x4000
200093ee:	d103      	bne.n	200093f8 <HAL_RCCEx_GetPeriphCLKFreq+0x558>
        frequency = HAL_RCC_GetSysClockFreq();
200093f0:	f7ff f858 	bl	200084a4 <HAL_RCC_GetSysClockFreq>
200093f4:	61f8      	str	r0, [r7, #28]
      break;
200093f6:	e270      	b.n	200098da <HAL_RCCEx_GetPeriphCLKFreq+0xa3a>
      else if((HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY)) && (srcclk == RCC_I2C2CLKSOURCE_HSI))
200093f8:	4b24      	ldr	r3, [pc, #144]	; (2000948c <HAL_RCCEx_GetPeriphCLKFreq+0x5ec>)
200093fa:	681b      	ldr	r3, [r3, #0]
200093fc:	f403 6380 	and.w	r3, r3, #1024	; 0x400
20009400:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
20009404:	f040 8269 	bne.w	200098da <HAL_RCCEx_GetPeriphCLKFreq+0xa3a>
20009408:	693b      	ldr	r3, [r7, #16]
2000940a:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
2000940e:	f040 8264 	bne.w	200098da <HAL_RCCEx_GetPeriphCLKFreq+0xa3a>
        frequency = HSI_VALUE;
20009412:	4b1f      	ldr	r3, [pc, #124]	; (20009490 <HAL_RCCEx_GetPeriphCLKFreq+0x5f0>)
20009414:	61fb      	str	r3, [r7, #28]
      break;
20009416:	e260      	b.n	200098da <HAL_RCCEx_GetPeriphCLKFreq+0xa3a>
      srcclk = __HAL_RCC_GET_I2C3_SOURCE();
20009418:	4b1c      	ldr	r3, [pc, #112]	; (2000948c <HAL_RCCEx_GetPeriphCLKFreq+0x5ec>)
2000941a:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
2000941e:	f403 3340 	and.w	r3, r3, #196608	; 0x30000
20009422:	613b      	str	r3, [r7, #16]
      if(srcclk == RCC_I2C3CLKSOURCE_PCLK1)
20009424:	693b      	ldr	r3, [r7, #16]
20009426:	2b00      	cmp	r3, #0
20009428:	d103      	bne.n	20009432 <HAL_RCCEx_GetPeriphCLKFreq+0x592>
        frequency = HAL_RCC_GetPCLK1Freq();
2000942a:	f7ff f8a9 	bl	20008580 <HAL_RCC_GetPCLK1Freq>
2000942e:	61f8      	str	r0, [r7, #28]
      break;
20009430:	e255      	b.n	200098de <HAL_RCCEx_GetPeriphCLKFreq+0xa3e>
      else if(srcclk == RCC_I2C3CLKSOURCE_SYSCLK)
20009432:	693b      	ldr	r3, [r7, #16]
20009434:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
20009438:	d103      	bne.n	20009442 <HAL_RCCEx_GetPeriphCLKFreq+0x5a2>
        frequency = HAL_RCC_GetSysClockFreq();
2000943a:	f7ff f833 	bl	200084a4 <HAL_RCC_GetSysClockFreq>
2000943e:	61f8      	str	r0, [r7, #28]
      break;
20009440:	e24d      	b.n	200098de <HAL_RCCEx_GetPeriphCLKFreq+0xa3e>
      else if((HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY)) && (srcclk == RCC_I2C3CLKSOURCE_HSI))
20009442:	4b12      	ldr	r3, [pc, #72]	; (2000948c <HAL_RCCEx_GetPeriphCLKFreq+0x5ec>)
20009444:	681b      	ldr	r3, [r3, #0]
20009446:	f403 6380 	and.w	r3, r3, #1024	; 0x400
2000944a:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
2000944e:	f040 8246 	bne.w	200098de <HAL_RCCEx_GetPeriphCLKFreq+0xa3e>
20009452:	693b      	ldr	r3, [r7, #16]
20009454:	f5b3 3f00 	cmp.w	r3, #131072	; 0x20000
20009458:	f040 8241 	bne.w	200098de <HAL_RCCEx_GetPeriphCLKFreq+0xa3e>
        frequency = HSI_VALUE;
2000945c:	4b0c      	ldr	r3, [pc, #48]	; (20009490 <HAL_RCCEx_GetPeriphCLKFreq+0x5f0>)
2000945e:	61fb      	str	r3, [r7, #28]
      break;
20009460:	e23d      	b.n	200098de <HAL_RCCEx_GetPeriphCLKFreq+0xa3e>
      srcclk = __HAL_RCC_GET_I2C4_SOURCE();
20009462:	4b0a      	ldr	r3, [pc, #40]	; (2000948c <HAL_RCCEx_GetPeriphCLKFreq+0x5ec>)
20009464:	f8d3 309c 	ldr.w	r3, [r3, #156]	; 0x9c
20009468:	f003 0303 	and.w	r3, r3, #3
2000946c:	613b      	str	r3, [r7, #16]
      if(srcclk == RCC_I2C4CLKSOURCE_PCLK1)
2000946e:	693b      	ldr	r3, [r7, #16]
20009470:	2b00      	cmp	r3, #0
20009472:	d103      	bne.n	2000947c <HAL_RCCEx_GetPeriphCLKFreq+0x5dc>
        frequency = HAL_RCC_GetPCLK1Freq();
20009474:	f7ff f884 	bl	20008580 <HAL_RCC_GetPCLK1Freq>
20009478:	61f8      	str	r0, [r7, #28]
      break;
2000947a:	e232      	b.n	200098e2 <HAL_RCCEx_GetPeriphCLKFreq+0xa42>
      else if(srcclk == RCC_I2C4CLKSOURCE_SYSCLK)
2000947c:	693b      	ldr	r3, [r7, #16]
2000947e:	2b01      	cmp	r3, #1
20009480:	d108      	bne.n	20009494 <HAL_RCCEx_GetPeriphCLKFreq+0x5f4>
        frequency = HAL_RCC_GetSysClockFreq();
20009482:	f7ff f80f 	bl	200084a4 <HAL_RCC_GetSysClockFreq>
20009486:	61f8      	str	r0, [r7, #28]
      break;
20009488:	e22b      	b.n	200098e2 <HAL_RCCEx_GetPeriphCLKFreq+0xa42>
2000948a:	bf00      	nop
2000948c:	40021000 	.word	0x40021000
20009490:	00f42400 	.word	0x00f42400
      else if((HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY)) && (srcclk == RCC_I2C4CLKSOURCE_HSI))
20009494:	4bb1      	ldr	r3, [pc, #708]	; (2000975c <HAL_RCCEx_GetPeriphCLKFreq+0x8bc>)
20009496:	681b      	ldr	r3, [r3, #0]
20009498:	f403 6380 	and.w	r3, r3, #1024	; 0x400
2000949c:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
200094a0:	f040 821f 	bne.w	200098e2 <HAL_RCCEx_GetPeriphCLKFreq+0xa42>
200094a4:	693b      	ldr	r3, [r7, #16]
200094a6:	2b02      	cmp	r3, #2
200094a8:	f040 821b 	bne.w	200098e2 <HAL_RCCEx_GetPeriphCLKFreq+0xa42>
        frequency = HSI_VALUE;
200094ac:	4bac      	ldr	r3, [pc, #688]	; (20009760 <HAL_RCCEx_GetPeriphCLKFreq+0x8c0>)
200094ae:	61fb      	str	r3, [r7, #28]
      break;
200094b0:	e217      	b.n	200098e2 <HAL_RCCEx_GetPeriphCLKFreq+0xa42>
      srcclk = __HAL_RCC_GET_LPTIM1_SOURCE();
200094b2:	4baa      	ldr	r3, [pc, #680]	; (2000975c <HAL_RCCEx_GetPeriphCLKFreq+0x8bc>)
200094b4:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
200094b8:	f403 2340 	and.w	r3, r3, #786432	; 0xc0000
200094bc:	613b      	str	r3, [r7, #16]
      if(srcclk == RCC_LPTIM1CLKSOURCE_PCLK1)
200094be:	693b      	ldr	r3, [r7, #16]
200094c0:	2b00      	cmp	r3, #0
200094c2:	d103      	bne.n	200094cc <HAL_RCCEx_GetPeriphCLKFreq+0x62c>
        frequency = HAL_RCC_GetPCLK1Freq();
200094c4:	f7ff f85c 	bl	20008580 <HAL_RCC_GetPCLK1Freq>
200094c8:	61f8      	str	r0, [r7, #28]
      break;
200094ca:	e20c      	b.n	200098e6 <HAL_RCCEx_GetPeriphCLKFreq+0xa46>
      else if((HAL_IS_BIT_SET(RCC->CSR, RCC_CSR_LSIRDY)) && (srcclk == RCC_LPTIM1CLKSOURCE_LSI))
200094cc:	4ba3      	ldr	r3, [pc, #652]	; (2000975c <HAL_RCCEx_GetPeriphCLKFreq+0x8bc>)
200094ce:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
200094d2:	f003 0302 	and.w	r3, r3, #2
200094d6:	2b02      	cmp	r3, #2
200094d8:	d107      	bne.n	200094ea <HAL_RCCEx_GetPeriphCLKFreq+0x64a>
200094da:	693b      	ldr	r3, [r7, #16]
200094dc:	f5b3 2f80 	cmp.w	r3, #262144	; 0x40000
200094e0:	d103      	bne.n	200094ea <HAL_RCCEx_GetPeriphCLKFreq+0x64a>
        frequency = LSI_VALUE;
200094e2:	f44f 43fa 	mov.w	r3, #32000	; 0x7d00
200094e6:	61fb      	str	r3, [r7, #28]
200094e8:	e01e      	b.n	20009528 <HAL_RCCEx_GetPeriphCLKFreq+0x688>
      else if((HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY)) && (srcclk == RCC_LPTIM1CLKSOURCE_HSI))
200094ea:	4b9c      	ldr	r3, [pc, #624]	; (2000975c <HAL_RCCEx_GetPeriphCLKFreq+0x8bc>)
200094ec:	681b      	ldr	r3, [r3, #0]
200094ee:	f403 6380 	and.w	r3, r3, #1024	; 0x400
200094f2:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
200094f6:	d106      	bne.n	20009506 <HAL_RCCEx_GetPeriphCLKFreq+0x666>
200094f8:	693b      	ldr	r3, [r7, #16]
200094fa:	f5b3 2f00 	cmp.w	r3, #524288	; 0x80000
200094fe:	d102      	bne.n	20009506 <HAL_RCCEx_GetPeriphCLKFreq+0x666>
        frequency = HSI_VALUE;
20009500:	4b97      	ldr	r3, [pc, #604]	; (20009760 <HAL_RCCEx_GetPeriphCLKFreq+0x8c0>)
20009502:	61fb      	str	r3, [r7, #28]
20009504:	e010      	b.n	20009528 <HAL_RCCEx_GetPeriphCLKFreq+0x688>
      else if ((HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSERDY)) && (srcclk == RCC_LPTIM1CLKSOURCE_LSE))
20009506:	4b95      	ldr	r3, [pc, #596]	; (2000975c <HAL_RCCEx_GetPeriphCLKFreq+0x8bc>)
20009508:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
2000950c:	f003 0302 	and.w	r3, r3, #2
20009510:	2b02      	cmp	r3, #2
20009512:	f040 81e8 	bne.w	200098e6 <HAL_RCCEx_GetPeriphCLKFreq+0xa46>
20009516:	693b      	ldr	r3, [r7, #16]
20009518:	f5b3 2f40 	cmp.w	r3, #786432	; 0xc0000
2000951c:	f040 81e3 	bne.w	200098e6 <HAL_RCCEx_GetPeriphCLKFreq+0xa46>
        frequency = LSE_VALUE;
20009520:	f44f 4300 	mov.w	r3, #32768	; 0x8000
20009524:	61fb      	str	r3, [r7, #28]
      break;
20009526:	e1de      	b.n	200098e6 <HAL_RCCEx_GetPeriphCLKFreq+0xa46>
20009528:	e1dd      	b.n	200098e6 <HAL_RCCEx_GetPeriphCLKFreq+0xa46>
      srcclk = __HAL_RCC_GET_SAI1_SOURCE();
2000952a:	4b8c      	ldr	r3, [pc, #560]	; (2000975c <HAL_RCCEx_GetPeriphCLKFreq+0x8bc>)
2000952c:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
20009530:	f403 1340 	and.w	r3, r3, #3145728	; 0x300000
20009534:	613b      	str	r3, [r7, #16]
      if(srcclk == RCC_SAI1CLKSOURCE_SYSCLK)
20009536:	693b      	ldr	r3, [r7, #16]
20009538:	2b00      	cmp	r3, #0
2000953a:	d103      	bne.n	20009544 <HAL_RCCEx_GetPeriphCLKFreq+0x6a4>
        frequency = HAL_RCC_GetSysClockFreq();
2000953c:	f7fe ffb2 	bl	200084a4 <HAL_RCC_GetSysClockFreq>
20009540:	61f8      	str	r0, [r7, #28]
      break;
20009542:	e1d2      	b.n	200098ea <HAL_RCCEx_GetPeriphCLKFreq+0xa4a>
      else if(srcclk == RCC_SAI1CLKSOURCE_PLL)
20009544:	693b      	ldr	r3, [r7, #16]
20009546:	f5b3 1f80 	cmp.w	r3, #1048576	; 0x100000
2000954a:	d11b      	bne.n	20009584 <HAL_RCCEx_GetPeriphCLKFreq+0x6e4>
        if(__HAL_RCC_GET_PLLCLKOUT_CONFIG(RCC_PLL_48M1CLK) != 0U)
2000954c:	4b83      	ldr	r3, [pc, #524]	; (2000975c <HAL_RCCEx_GetPeriphCLKFreq+0x8bc>)
2000954e:	68db      	ldr	r3, [r3, #12]
20009550:	f403 1380 	and.w	r3, r3, #1048576	; 0x100000
20009554:	2b00      	cmp	r3, #0
20009556:	f000 81c8 	beq.w	200098ea <HAL_RCCEx_GetPeriphCLKFreq+0xa4a>
          plln = READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos;
2000955a:	4b80      	ldr	r3, [pc, #512]	; (2000975c <HAL_RCCEx_GetPeriphCLKFreq+0x8bc>)
2000955c:	68db      	ldr	r3, [r3, #12]
2000955e:	0a1b      	lsrs	r3, r3, #8
20009560:	f003 037f 	and.w	r3, r3, #127	; 0x7f
20009564:	60fb      	str	r3, [r7, #12]
          frequency = (pllvco * plln) / (((READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLQ) >> RCC_PLLCFGR_PLLQ_Pos) + 1U) << 1U);
20009566:	69bb      	ldr	r3, [r7, #24]
20009568:	68fa      	ldr	r2, [r7, #12]
2000956a:	fb02 f203 	mul.w	r2, r2, r3
2000956e:	4b7b      	ldr	r3, [pc, #492]	; (2000975c <HAL_RCCEx_GetPeriphCLKFreq+0x8bc>)
20009570:	68db      	ldr	r3, [r3, #12]
20009572:	0d5b      	lsrs	r3, r3, #21
20009574:	f003 0303 	and.w	r3, r3, #3
20009578:	3301      	adds	r3, #1
2000957a:	005b      	lsls	r3, r3, #1
2000957c:	fbb2 f3f3 	udiv	r3, r2, r3
20009580:	61fb      	str	r3, [r7, #28]
      break;
20009582:	e1b2      	b.n	200098ea <HAL_RCCEx_GetPeriphCLKFreq+0xa4a>
      else if(srcclk == RCC_SAI1CLKSOURCE_EXT)
20009584:	693b      	ldr	r3, [r7, #16]
20009586:	f5b3 1f00 	cmp.w	r3, #2097152	; 0x200000
2000958a:	d102      	bne.n	20009592 <HAL_RCCEx_GetPeriphCLKFreq+0x6f2>
        frequency = EXTERNAL_CLOCK_VALUE;
2000958c:	4b75      	ldr	r3, [pc, #468]	; (20009764 <HAL_RCCEx_GetPeriphCLKFreq+0x8c4>)
2000958e:	61fb      	str	r3, [r7, #28]
      break;
20009590:	e1ab      	b.n	200098ea <HAL_RCCEx_GetPeriphCLKFreq+0xa4a>
      else if((HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY)) && (srcclk == RCC_SAI1CLKSOURCE_HSI))
20009592:	4b72      	ldr	r3, [pc, #456]	; (2000975c <HAL_RCCEx_GetPeriphCLKFreq+0x8bc>)
20009594:	681b      	ldr	r3, [r3, #0]
20009596:	f403 6380 	and.w	r3, r3, #1024	; 0x400
2000959a:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
2000959e:	f040 81a4 	bne.w	200098ea <HAL_RCCEx_GetPeriphCLKFreq+0xa4a>
200095a2:	693b      	ldr	r3, [r7, #16]
200095a4:	f5b3 1f40 	cmp.w	r3, #3145728	; 0x300000
200095a8:	f040 819f 	bne.w	200098ea <HAL_RCCEx_GetPeriphCLKFreq+0xa4a>
        frequency = HSI_VALUE;
200095ac:	4b6c      	ldr	r3, [pc, #432]	; (20009760 <HAL_RCCEx_GetPeriphCLKFreq+0x8c0>)
200095ae:	61fb      	str	r3, [r7, #28]
      break;
200095b0:	e19b      	b.n	200098ea <HAL_RCCEx_GetPeriphCLKFreq+0xa4a>
      srcclk = __HAL_RCC_GET_I2S_SOURCE();
200095b2:	4b6a      	ldr	r3, [pc, #424]	; (2000975c <HAL_RCCEx_GetPeriphCLKFreq+0x8bc>)
200095b4:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
200095b8:	f403 0340 	and.w	r3, r3, #12582912	; 0xc00000
200095bc:	613b      	str	r3, [r7, #16]
      if(srcclk == RCC_I2SCLKSOURCE_SYSCLK)
200095be:	693b      	ldr	r3, [r7, #16]
200095c0:	2b00      	cmp	r3, #0
200095c2:	d103      	bne.n	200095cc <HAL_RCCEx_GetPeriphCLKFreq+0x72c>
        frequency = HAL_RCC_GetSysClockFreq();
200095c4:	f7fe ff6e 	bl	200084a4 <HAL_RCC_GetSysClockFreq>
200095c8:	61f8      	str	r0, [r7, #28]
      break;
200095ca:	e190      	b.n	200098ee <HAL_RCCEx_GetPeriphCLKFreq+0xa4e>
      else if(srcclk == RCC_I2SCLKSOURCE_PLL)
200095cc:	693b      	ldr	r3, [r7, #16]
200095ce:	f5b3 0f80 	cmp.w	r3, #4194304	; 0x400000
200095d2:	d11b      	bne.n	2000960c <HAL_RCCEx_GetPeriphCLKFreq+0x76c>
        if(__HAL_RCC_GET_PLLCLKOUT_CONFIG(RCC_PLL_48M1CLK) != 0U)
200095d4:	4b61      	ldr	r3, [pc, #388]	; (2000975c <HAL_RCCEx_GetPeriphCLKFreq+0x8bc>)
200095d6:	68db      	ldr	r3, [r3, #12]
200095d8:	f403 1380 	and.w	r3, r3, #1048576	; 0x100000
200095dc:	2b00      	cmp	r3, #0
200095de:	f000 8186 	beq.w	200098ee <HAL_RCCEx_GetPeriphCLKFreq+0xa4e>
          plln = READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos;
200095e2:	4b5e      	ldr	r3, [pc, #376]	; (2000975c <HAL_RCCEx_GetPeriphCLKFreq+0x8bc>)
200095e4:	68db      	ldr	r3, [r3, #12]
200095e6:	0a1b      	lsrs	r3, r3, #8
200095e8:	f003 037f 	and.w	r3, r3, #127	; 0x7f
200095ec:	60fb      	str	r3, [r7, #12]
          frequency = (pllvco * plln) / (((READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLQ) >> RCC_PLLCFGR_PLLQ_Pos) + 1U) << 1U);
200095ee:	69bb      	ldr	r3, [r7, #24]
200095f0:	68fa      	ldr	r2, [r7, #12]
200095f2:	fb02 f203 	mul.w	r2, r2, r3
200095f6:	4b59      	ldr	r3, [pc, #356]	; (2000975c <HAL_RCCEx_GetPeriphCLKFreq+0x8bc>)
200095f8:	68db      	ldr	r3, [r3, #12]
200095fa:	0d5b      	lsrs	r3, r3, #21
200095fc:	f003 0303 	and.w	r3, r3, #3
20009600:	3301      	adds	r3, #1
20009602:	005b      	lsls	r3, r3, #1
20009604:	fbb2 f3f3 	udiv	r3, r2, r3
20009608:	61fb      	str	r3, [r7, #28]
      break;
2000960a:	e170      	b.n	200098ee <HAL_RCCEx_GetPeriphCLKFreq+0xa4e>
      else if(srcclk == RCC_I2SCLKSOURCE_EXT)
2000960c:	693b      	ldr	r3, [r7, #16]
2000960e:	f5b3 0f00 	cmp.w	r3, #8388608	; 0x800000
20009612:	d102      	bne.n	2000961a <HAL_RCCEx_GetPeriphCLKFreq+0x77a>
        frequency = EXTERNAL_CLOCK_VALUE;
20009614:	4b53      	ldr	r3, [pc, #332]	; (20009764 <HAL_RCCEx_GetPeriphCLKFreq+0x8c4>)
20009616:	61fb      	str	r3, [r7, #28]
      break;
20009618:	e169      	b.n	200098ee <HAL_RCCEx_GetPeriphCLKFreq+0xa4e>
      else if((HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY)) && (srcclk == RCC_I2SCLKSOURCE_HSI))
2000961a:	4b50      	ldr	r3, [pc, #320]	; (2000975c <HAL_RCCEx_GetPeriphCLKFreq+0x8bc>)
2000961c:	681b      	ldr	r3, [r3, #0]
2000961e:	f403 6380 	and.w	r3, r3, #1024	; 0x400
20009622:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
20009626:	f040 8162 	bne.w	200098ee <HAL_RCCEx_GetPeriphCLKFreq+0xa4e>
2000962a:	693b      	ldr	r3, [r7, #16]
2000962c:	f5b3 0f40 	cmp.w	r3, #12582912	; 0xc00000
20009630:	f040 815d 	bne.w	200098ee <HAL_RCCEx_GetPeriphCLKFreq+0xa4e>
        frequency = HSI_VALUE;
20009634:	4b4a      	ldr	r3, [pc, #296]	; (20009760 <HAL_RCCEx_GetPeriphCLKFreq+0x8c0>)
20009636:	61fb      	str	r3, [r7, #28]
      break;
20009638:	e159      	b.n	200098ee <HAL_RCCEx_GetPeriphCLKFreq+0xa4e>
      srcclk = __HAL_RCC_GET_FDCAN_SOURCE();
2000963a:	4b48      	ldr	r3, [pc, #288]	; (2000975c <HAL_RCCEx_GetPeriphCLKFreq+0x8bc>)
2000963c:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
20009640:	f003 7340 	and.w	r3, r3, #50331648	; 0x3000000
20009644:	613b      	str	r3, [r7, #16]
      if(srcclk == RCC_FDCANCLKSOURCE_PCLK1)
20009646:	693b      	ldr	r3, [r7, #16]
20009648:	f1b3 7f00 	cmp.w	r3, #33554432	; 0x2000000
2000964c:	d103      	bne.n	20009656 <HAL_RCCEx_GetPeriphCLKFreq+0x7b6>
        frequency = HAL_RCC_GetPCLK1Freq();
2000964e:	f7fe ff97 	bl	20008580 <HAL_RCC_GetPCLK1Freq>
20009652:	61f8      	str	r0, [r7, #28]
      break;
20009654:	e14d      	b.n	200098f2 <HAL_RCCEx_GetPeriphCLKFreq+0xa52>
      else if(srcclk == RCC_FDCANCLKSOURCE_HSE)
20009656:	693b      	ldr	r3, [r7, #16]
20009658:	2b00      	cmp	r3, #0
2000965a:	d102      	bne.n	20009662 <HAL_RCCEx_GetPeriphCLKFreq+0x7c2>
        frequency = HSE_VALUE;
2000965c:	4b42      	ldr	r3, [pc, #264]	; (20009768 <HAL_RCCEx_GetPeriphCLKFreq+0x8c8>)
2000965e:	61fb      	str	r3, [r7, #28]
      break;
20009660:	e147      	b.n	200098f2 <HAL_RCCEx_GetPeriphCLKFreq+0xa52>
      else if(srcclk == RCC_FDCANCLKSOURCE_PLL)
20009662:	693b      	ldr	r3, [r7, #16]
20009664:	f1b3 7f80 	cmp.w	r3, #16777216	; 0x1000000
20009668:	f040 8143 	bne.w	200098f2 <HAL_RCCEx_GetPeriphCLKFreq+0xa52>
        if(__HAL_RCC_GET_PLLCLKOUT_CONFIG(RCC_PLL_48M1CLK) != 0U)
2000966c:	4b3b      	ldr	r3, [pc, #236]	; (2000975c <HAL_RCCEx_GetPeriphCLKFreq+0x8bc>)
2000966e:	68db      	ldr	r3, [r3, #12]
20009670:	f403 1380 	and.w	r3, r3, #1048576	; 0x100000
20009674:	2b00      	cmp	r3, #0
20009676:	f000 813c 	beq.w	200098f2 <HAL_RCCEx_GetPeriphCLKFreq+0xa52>
          plln = READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos;
2000967a:	4b38      	ldr	r3, [pc, #224]	; (2000975c <HAL_RCCEx_GetPeriphCLKFreq+0x8bc>)
2000967c:	68db      	ldr	r3, [r3, #12]
2000967e:	0a1b      	lsrs	r3, r3, #8
20009680:	f003 037f 	and.w	r3, r3, #127	; 0x7f
20009684:	60fb      	str	r3, [r7, #12]
          frequency = (pllvco * plln) / (((READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLQ) >> RCC_PLLCFGR_PLLQ_Pos) + 1U) << 1U);
20009686:	69bb      	ldr	r3, [r7, #24]
20009688:	68fa      	ldr	r2, [r7, #12]
2000968a:	fb02 f203 	mul.w	r2, r2, r3
2000968e:	4b33      	ldr	r3, [pc, #204]	; (2000975c <HAL_RCCEx_GetPeriphCLKFreq+0x8bc>)
20009690:	68db      	ldr	r3, [r3, #12]
20009692:	0d5b      	lsrs	r3, r3, #21
20009694:	f003 0303 	and.w	r3, r3, #3
20009698:	3301      	adds	r3, #1
2000969a:	005b      	lsls	r3, r3, #1
2000969c:	fbb2 f3f3 	udiv	r3, r2, r3
200096a0:	61fb      	str	r3, [r7, #28]
      break;
200096a2:	e126      	b.n	200098f2 <HAL_RCCEx_GetPeriphCLKFreq+0xa52>
      srcclk = __HAL_RCC_GET_USB_SOURCE();
200096a4:	4b2d      	ldr	r3, [pc, #180]	; (2000975c <HAL_RCCEx_GetPeriphCLKFreq+0x8bc>)
200096a6:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
200096aa:	f003 6340 	and.w	r3, r3, #201326592	; 0xc000000
200096ae:	613b      	str	r3, [r7, #16]
      if(srcclk == RCC_USBCLKSOURCE_PLL)  /* PLL ? */
200096b0:	693b      	ldr	r3, [r7, #16]
200096b2:	f1b3 6f00 	cmp.w	r3, #134217728	; 0x8000000
200096b6:	d114      	bne.n	200096e2 <HAL_RCCEx_GetPeriphCLKFreq+0x842>
        plln = READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos;
200096b8:	4b28      	ldr	r3, [pc, #160]	; (2000975c <HAL_RCCEx_GetPeriphCLKFreq+0x8bc>)
200096ba:	68db      	ldr	r3, [r3, #12]
200096bc:	0a1b      	lsrs	r3, r3, #8
200096be:	f003 037f 	and.w	r3, r3, #127	; 0x7f
200096c2:	60fb      	str	r3, [r7, #12]
        frequency = (pllvco * plln) / (((READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLQ) >> RCC_PLLCFGR_PLLQ_Pos) + 1U) << 1U);
200096c4:	69bb      	ldr	r3, [r7, #24]
200096c6:	68fa      	ldr	r2, [r7, #12]
200096c8:	fb02 f203 	mul.w	r2, r2, r3
200096cc:	4b23      	ldr	r3, [pc, #140]	; (2000975c <HAL_RCCEx_GetPeriphCLKFreq+0x8bc>)
200096ce:	68db      	ldr	r3, [r3, #12]
200096d0:	0d5b      	lsrs	r3, r3, #21
200096d2:	f003 0303 	and.w	r3, r3, #3
200096d6:	3301      	adds	r3, #1
200096d8:	005b      	lsls	r3, r3, #1
200096da:	fbb2 f3f3 	udiv	r3, r2, r3
200096de:	61fb      	str	r3, [r7, #28]
      break;
200096e0:	e109      	b.n	200098f6 <HAL_RCCEx_GetPeriphCLKFreq+0xa56>
      else if((HAL_IS_BIT_SET(RCC->CRRCR, RCC_CRRCR_HSI48RDY)) && (srcclk == RCC_USBCLKSOURCE_HSI48)) /* HSI48 ? */
200096e2:	4b1e      	ldr	r3, [pc, #120]	; (2000975c <HAL_RCCEx_GetPeriphCLKFreq+0x8bc>)
200096e4:	f8d3 3098 	ldr.w	r3, [r3, #152]	; 0x98
200096e8:	f003 0302 	and.w	r3, r3, #2
200096ec:	2b02      	cmp	r3, #2
200096ee:	f040 8102 	bne.w	200098f6 <HAL_RCCEx_GetPeriphCLKFreq+0xa56>
200096f2:	693b      	ldr	r3, [r7, #16]
200096f4:	2b00      	cmp	r3, #0
200096f6:	f040 80fe 	bne.w	200098f6 <HAL_RCCEx_GetPeriphCLKFreq+0xa56>
        frequency = HSI48_VALUE;
200096fa:	4b1c      	ldr	r3, [pc, #112]	; (2000976c <HAL_RCCEx_GetPeriphCLKFreq+0x8cc>)
200096fc:	61fb      	str	r3, [r7, #28]
      break;
200096fe:	e0fa      	b.n	200098f6 <HAL_RCCEx_GetPeriphCLKFreq+0xa56>
      srcclk = __HAL_RCC_GET_RNG_SOURCE();
20009700:	4b16      	ldr	r3, [pc, #88]	; (2000975c <HAL_RCCEx_GetPeriphCLKFreq+0x8bc>)
20009702:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
20009706:	f003 6340 	and.w	r3, r3, #201326592	; 0xc000000
2000970a:	613b      	str	r3, [r7, #16]
      if(srcclk == RCC_RNGCLKSOURCE_PLL)  /* PLL ? */
2000970c:	693b      	ldr	r3, [r7, #16]
2000970e:	f1b3 6f00 	cmp.w	r3, #134217728	; 0x8000000
20009712:	d114      	bne.n	2000973e <HAL_RCCEx_GetPeriphCLKFreq+0x89e>
        plln = READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos;
20009714:	4b11      	ldr	r3, [pc, #68]	; (2000975c <HAL_RCCEx_GetPeriphCLKFreq+0x8bc>)
20009716:	68db      	ldr	r3, [r3, #12]
20009718:	0a1b      	lsrs	r3, r3, #8
2000971a:	f003 037f 	and.w	r3, r3, #127	; 0x7f
2000971e:	60fb      	str	r3, [r7, #12]
        frequency = (pllvco * plln) / (((READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLQ) >> RCC_PLLCFGR_PLLQ_Pos) + 1U) << 1U);
20009720:	69bb      	ldr	r3, [r7, #24]
20009722:	68fa      	ldr	r2, [r7, #12]
20009724:	fb02 f203 	mul.w	r2, r2, r3
20009728:	4b0c      	ldr	r3, [pc, #48]	; (2000975c <HAL_RCCEx_GetPeriphCLKFreq+0x8bc>)
2000972a:	68db      	ldr	r3, [r3, #12]
2000972c:	0d5b      	lsrs	r3, r3, #21
2000972e:	f003 0303 	and.w	r3, r3, #3
20009732:	3301      	adds	r3, #1
20009734:	005b      	lsls	r3, r3, #1
20009736:	fbb2 f3f3 	udiv	r3, r2, r3
2000973a:	61fb      	str	r3, [r7, #28]
      break;
2000973c:	e0dd      	b.n	200098fa <HAL_RCCEx_GetPeriphCLKFreq+0xa5a>
      else if( (HAL_IS_BIT_SET(RCC->CRRCR, RCC_CRRCR_HSI48RDY)) && (srcclk == RCC_RNGCLKSOURCE_HSI48)) /* HSI48 ? */
2000973e:	4b07      	ldr	r3, [pc, #28]	; (2000975c <HAL_RCCEx_GetPeriphCLKFreq+0x8bc>)
20009740:	f8d3 3098 	ldr.w	r3, [r3, #152]	; 0x98
20009744:	f003 0302 	and.w	r3, r3, #2
20009748:	2b02      	cmp	r3, #2
2000974a:	f040 80d6 	bne.w	200098fa <HAL_RCCEx_GetPeriphCLKFreq+0xa5a>
2000974e:	693b      	ldr	r3, [r7, #16]
20009750:	2b00      	cmp	r3, #0
20009752:	f040 80d2 	bne.w	200098fa <HAL_RCCEx_GetPeriphCLKFreq+0xa5a>
        frequency = HSI48_VALUE;
20009756:	4b05      	ldr	r3, [pc, #20]	; (2000976c <HAL_RCCEx_GetPeriphCLKFreq+0x8cc>)
20009758:	61fb      	str	r3, [r7, #28]
      break;
2000975a:	e0ce      	b.n	200098fa <HAL_RCCEx_GetPeriphCLKFreq+0xa5a>
2000975c:	40021000 	.word	0x40021000
20009760:	00f42400 	.word	0x00f42400
20009764:	00bb8000 	.word	0x00bb8000
20009768:	007a1200 	.word	0x007a1200
2000976c:	02dc6c00 	.word	0x02dc6c00
      srcclk = __HAL_RCC_GET_ADC12_SOURCE();
20009770:	4b68      	ldr	r3, [pc, #416]	; (20009914 <HAL_RCCEx_GetPeriphCLKFreq+0xa74>)
20009772:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
20009776:	f003 5340 	and.w	r3, r3, #805306368	; 0x30000000
2000977a:	613b      	str	r3, [r7, #16]
      if(srcclk == RCC_ADC12CLKSOURCE_PLL)
2000977c:	693b      	ldr	r3, [r7, #16]
2000977e:	f1b3 5f80 	cmp.w	r3, #268435456	; 0x10000000
20009782:	d129      	bne.n	200097d8 <HAL_RCCEx_GetPeriphCLKFreq+0x938>
        if(__HAL_RCC_GET_PLLCLKOUT_CONFIG(RCC_PLL_ADCCLK) != 0U)
20009784:	4b63      	ldr	r3, [pc, #396]	; (20009914 <HAL_RCCEx_GetPeriphCLKFreq+0xa74>)
20009786:	68db      	ldr	r3, [r3, #12]
20009788:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
2000978c:	2b00      	cmp	r3, #0
2000978e:	f000 80b6 	beq.w	200098fe <HAL_RCCEx_GetPeriphCLKFreq+0xa5e>
          plln = READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos;
20009792:	4b60      	ldr	r3, [pc, #384]	; (20009914 <HAL_RCCEx_GetPeriphCLKFreq+0xa74>)
20009794:	68db      	ldr	r3, [r3, #12]
20009796:	0a1b      	lsrs	r3, r3, #8
20009798:	f003 037f 	and.w	r3, r3, #127	; 0x7f
2000979c:	60fb      	str	r3, [r7, #12]
          pllp = READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLPDIV) >> RCC_PLLCFGR_PLLPDIV_Pos;
2000979e:	4b5d      	ldr	r3, [pc, #372]	; (20009914 <HAL_RCCEx_GetPeriphCLKFreq+0xa74>)
200097a0:	68db      	ldr	r3, [r3, #12]
200097a2:	0edb      	lsrs	r3, r3, #27
200097a4:	f003 031f 	and.w	r3, r3, #31
200097a8:	617b      	str	r3, [r7, #20]
          if(pllp == 0U)
200097aa:	697b      	ldr	r3, [r7, #20]
200097ac:	2b00      	cmp	r3, #0
200097ae:	d10a      	bne.n	200097c6 <HAL_RCCEx_GetPeriphCLKFreq+0x926>
            if(READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLP) != 0U)
200097b0:	4b58      	ldr	r3, [pc, #352]	; (20009914 <HAL_RCCEx_GetPeriphCLKFreq+0xa74>)
200097b2:	68db      	ldr	r3, [r3, #12]
200097b4:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
200097b8:	2b00      	cmp	r3, #0
200097ba:	d002      	beq.n	200097c2 <HAL_RCCEx_GetPeriphCLKFreq+0x922>
              pllp = 17U;
200097bc:	2311      	movs	r3, #17
200097be:	617b      	str	r3, [r7, #20]
200097c0:	e001      	b.n	200097c6 <HAL_RCCEx_GetPeriphCLKFreq+0x926>
              pllp = 7U;
200097c2:	2307      	movs	r3, #7
200097c4:	617b      	str	r3, [r7, #20]
          frequency = (pllvco * plln) / pllp;
200097c6:	69bb      	ldr	r3, [r7, #24]
200097c8:	68fa      	ldr	r2, [r7, #12]
200097ca:	fb02 f203 	mul.w	r2, r2, r3
200097ce:	697b      	ldr	r3, [r7, #20]
200097d0:	fbb2 f3f3 	udiv	r3, r2, r3
200097d4:	61fb      	str	r3, [r7, #28]
      break;
200097d6:	e092      	b.n	200098fe <HAL_RCCEx_GetPeriphCLKFreq+0xa5e>
      else if(srcclk == RCC_ADC12CLKSOURCE_SYSCLK)
200097d8:	693b      	ldr	r3, [r7, #16]
200097da:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
200097de:	f040 808e 	bne.w	200098fe <HAL_RCCEx_GetPeriphCLKFreq+0xa5e>
        frequency = HAL_RCC_GetSysClockFreq();
200097e2:	f7fe fe5f 	bl	200084a4 <HAL_RCC_GetSysClockFreq>
200097e6:	61f8      	str	r0, [r7, #28]
      break;
200097e8:	e089      	b.n	200098fe <HAL_RCCEx_GetPeriphCLKFreq+0xa5e>
      srcclk = __HAL_RCC_GET_ADC345_SOURCE();
200097ea:	4b4a      	ldr	r3, [pc, #296]	; (20009914 <HAL_RCCEx_GetPeriphCLKFreq+0xa74>)
200097ec:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
200097f0:	f003 4340 	and.w	r3, r3, #3221225472	; 0xc0000000
200097f4:	613b      	str	r3, [r7, #16]
      if(srcclk == RCC_ADC345CLKSOURCE_PLL)
200097f6:	693b      	ldr	r3, [r7, #16]
200097f8:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
200097fc:	d128      	bne.n	20009850 <HAL_RCCEx_GetPeriphCLKFreq+0x9b0>
        if(__HAL_RCC_GET_PLLCLKOUT_CONFIG(RCC_PLL_ADCCLK) != 0U)
200097fe:	4b45      	ldr	r3, [pc, #276]	; (20009914 <HAL_RCCEx_GetPeriphCLKFreq+0xa74>)
20009800:	68db      	ldr	r3, [r3, #12]
20009802:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
20009806:	2b00      	cmp	r3, #0
20009808:	d07b      	beq.n	20009902 <HAL_RCCEx_GetPeriphCLKFreq+0xa62>
          plln = READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos;
2000980a:	4b42      	ldr	r3, [pc, #264]	; (20009914 <HAL_RCCEx_GetPeriphCLKFreq+0xa74>)
2000980c:	68db      	ldr	r3, [r3, #12]
2000980e:	0a1b      	lsrs	r3, r3, #8
20009810:	f003 037f 	and.w	r3, r3, #127	; 0x7f
20009814:	60fb      	str	r3, [r7, #12]
          pllp = READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLPDIV) >> RCC_PLLCFGR_PLLPDIV_Pos;
20009816:	4b3f      	ldr	r3, [pc, #252]	; (20009914 <HAL_RCCEx_GetPeriphCLKFreq+0xa74>)
20009818:	68db      	ldr	r3, [r3, #12]
2000981a:	0edb      	lsrs	r3, r3, #27
2000981c:	f003 031f 	and.w	r3, r3, #31
20009820:	617b      	str	r3, [r7, #20]
          if(pllp == 0U)
20009822:	697b      	ldr	r3, [r7, #20]
20009824:	2b00      	cmp	r3, #0
20009826:	d10a      	bne.n	2000983e <HAL_RCCEx_GetPeriphCLKFreq+0x99e>
            if(READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLP) != 0U)
20009828:	4b3a      	ldr	r3, [pc, #232]	; (20009914 <HAL_RCCEx_GetPeriphCLKFreq+0xa74>)
2000982a:	68db      	ldr	r3, [r3, #12]
2000982c:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
20009830:	2b00      	cmp	r3, #0
20009832:	d002      	beq.n	2000983a <HAL_RCCEx_GetPeriphCLKFreq+0x99a>
              pllp = 17U;
20009834:	2311      	movs	r3, #17
20009836:	617b      	str	r3, [r7, #20]
20009838:	e001      	b.n	2000983e <HAL_RCCEx_GetPeriphCLKFreq+0x99e>
              pllp = 7U;
2000983a:	2307      	movs	r3, #7
2000983c:	617b      	str	r3, [r7, #20]
          frequency = (pllvco * plln) / pllp;
2000983e:	69bb      	ldr	r3, [r7, #24]
20009840:	68fa      	ldr	r2, [r7, #12]
20009842:	fb02 f203 	mul.w	r2, r2, r3
20009846:	697b      	ldr	r3, [r7, #20]
20009848:	fbb2 f3f3 	udiv	r3, r2, r3
2000984c:	61fb      	str	r3, [r7, #28]
      break;
2000984e:	e058      	b.n	20009902 <HAL_RCCEx_GetPeriphCLKFreq+0xa62>
      else if(srcclk == RCC_ADC345CLKSOURCE_SYSCLK)
20009850:	693b      	ldr	r3, [r7, #16]
20009852:	f1b3 4f00 	cmp.w	r3, #2147483648	; 0x80000000
20009856:	d154      	bne.n	20009902 <HAL_RCCEx_GetPeriphCLKFreq+0xa62>
        frequency = HAL_RCC_GetSysClockFreq();
20009858:	f7fe fe24 	bl	200084a4 <HAL_RCC_GetSysClockFreq>
2000985c:	61f8      	str	r0, [r7, #28]
      break;
2000985e:	e050      	b.n	20009902 <HAL_RCCEx_GetPeriphCLKFreq+0xa62>
      srcclk = __HAL_RCC_GET_QSPI_SOURCE();
20009860:	4b2c      	ldr	r3, [pc, #176]	; (20009914 <HAL_RCCEx_GetPeriphCLKFreq+0xa74>)
20009862:	f8d3 309c 	ldr.w	r3, [r3, #156]	; 0x9c
20009866:	f403 1340 	and.w	r3, r3, #3145728	; 0x300000
2000986a:	613b      	str	r3, [r7, #16]
      if(srcclk == RCC_QSPICLKSOURCE_PLL)  /* PLL ? */
2000986c:	693b      	ldr	r3, [r7, #16]
2000986e:	f5b3 1f00 	cmp.w	r3, #2097152	; 0x200000
20009872:	d114      	bne.n	2000989e <HAL_RCCEx_GetPeriphCLKFreq+0x9fe>
        plln = READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos;
20009874:	4b27      	ldr	r3, [pc, #156]	; (20009914 <HAL_RCCEx_GetPeriphCLKFreq+0xa74>)
20009876:	68db      	ldr	r3, [r3, #12]
20009878:	0a1b      	lsrs	r3, r3, #8
2000987a:	f003 037f 	and.w	r3, r3, #127	; 0x7f
2000987e:	60fb      	str	r3, [r7, #12]
        frequency = (pllvco * plln) / (((READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLQ) >> RCC_PLLCFGR_PLLQ_Pos) + 1U) << 1U);
20009880:	69bb      	ldr	r3, [r7, #24]
20009882:	68fa      	ldr	r2, [r7, #12]
20009884:	fb02 f203 	mul.w	r2, r2, r3
20009888:	4b22      	ldr	r3, [pc, #136]	; (20009914 <HAL_RCCEx_GetPeriphCLKFreq+0xa74>)
2000988a:	68db      	ldr	r3, [r3, #12]
2000988c:	0d5b      	lsrs	r3, r3, #21
2000988e:	f003 0303 	and.w	r3, r3, #3
20009892:	3301      	adds	r3, #1
20009894:	005b      	lsls	r3, r3, #1
20009896:	fbb2 f3f3 	udiv	r3, r2, r3
2000989a:	61fb      	str	r3, [r7, #28]
      break;
2000989c:	e033      	b.n	20009906 <HAL_RCCEx_GetPeriphCLKFreq+0xa66>
      else if(srcclk == RCC_QSPICLKSOURCE_HSI)
2000989e:	693b      	ldr	r3, [r7, #16]
200098a0:	f5b3 1f80 	cmp.w	r3, #1048576	; 0x100000
200098a4:	d102      	bne.n	200098ac <HAL_RCCEx_GetPeriphCLKFreq+0xa0c>
        frequency = HSI_VALUE;
200098a6:	4b1c      	ldr	r3, [pc, #112]	; (20009918 <HAL_RCCEx_GetPeriphCLKFreq+0xa78>)
200098a8:	61fb      	str	r3, [r7, #28]
      break;
200098aa:	e02c      	b.n	20009906 <HAL_RCCEx_GetPeriphCLKFreq+0xa66>
      else if(srcclk == RCC_QSPICLKSOURCE_SYSCLK)
200098ac:	693b      	ldr	r3, [r7, #16]
200098ae:	2b00      	cmp	r3, #0
200098b0:	d129      	bne.n	20009906 <HAL_RCCEx_GetPeriphCLKFreq+0xa66>
        frequency = HAL_RCC_GetSysClockFreq();
200098b2:	f7fe fdf7 	bl	200084a4 <HAL_RCC_GetSysClockFreq>
200098b6:	61f8      	str	r0, [r7, #28]
      break;
200098b8:	e025      	b.n	20009906 <HAL_RCCEx_GetPeriphCLKFreq+0xa66>
      break;
200098ba:	bf00      	nop
200098bc:	e024      	b.n	20009908 <HAL_RCCEx_GetPeriphCLKFreq+0xa68>
      break;
200098be:	bf00      	nop
200098c0:	e022      	b.n	20009908 <HAL_RCCEx_GetPeriphCLKFreq+0xa68>
      break;
200098c2:	bf00      	nop
200098c4:	e020      	b.n	20009908 <HAL_RCCEx_GetPeriphCLKFreq+0xa68>
      break;
200098c6:	bf00      	nop
200098c8:	e01e      	b.n	20009908 <HAL_RCCEx_GetPeriphCLKFreq+0xa68>
      break;
200098ca:	bf00      	nop
200098cc:	e01c      	b.n	20009908 <HAL_RCCEx_GetPeriphCLKFreq+0xa68>
      break;
200098ce:	bf00      	nop
200098d0:	e01a      	b.n	20009908 <HAL_RCCEx_GetPeriphCLKFreq+0xa68>
      break;
200098d2:	bf00      	nop
200098d4:	e018      	b.n	20009908 <HAL_RCCEx_GetPeriphCLKFreq+0xa68>
      break;
200098d6:	bf00      	nop
200098d8:	e016      	b.n	20009908 <HAL_RCCEx_GetPeriphCLKFreq+0xa68>
      break;
200098da:	bf00      	nop
200098dc:	e014      	b.n	20009908 <HAL_RCCEx_GetPeriphCLKFreq+0xa68>
      break;
200098de:	bf00      	nop
200098e0:	e012      	b.n	20009908 <HAL_RCCEx_GetPeriphCLKFreq+0xa68>
      break;
200098e2:	bf00      	nop
200098e4:	e010      	b.n	20009908 <HAL_RCCEx_GetPeriphCLKFreq+0xa68>
      break;
200098e6:	bf00      	nop
200098e8:	e00e      	b.n	20009908 <HAL_RCCEx_GetPeriphCLKFreq+0xa68>
      break;
200098ea:	bf00      	nop
200098ec:	e00c      	b.n	20009908 <HAL_RCCEx_GetPeriphCLKFreq+0xa68>
      break;
200098ee:	bf00      	nop
200098f0:	e00a      	b.n	20009908 <HAL_RCCEx_GetPeriphCLKFreq+0xa68>
      break;
200098f2:	bf00      	nop
200098f4:	e008      	b.n	20009908 <HAL_RCCEx_GetPeriphCLKFreq+0xa68>
      break;
200098f6:	bf00      	nop
200098f8:	e006      	b.n	20009908 <HAL_RCCEx_GetPeriphCLKFreq+0xa68>
      break;
200098fa:	bf00      	nop
200098fc:	e004      	b.n	20009908 <HAL_RCCEx_GetPeriphCLKFreq+0xa68>
      break;
200098fe:	bf00      	nop
20009900:	e002      	b.n	20009908 <HAL_RCCEx_GetPeriphCLKFreq+0xa68>
      break;
20009902:	bf00      	nop
20009904:	e000      	b.n	20009908 <HAL_RCCEx_GetPeriphCLKFreq+0xa68>
      break;
20009906:	bf00      	nop
    }
  }

  return(frequency);
20009908:	69fb      	ldr	r3, [r7, #28]
}
2000990a:	4618      	mov	r0, r3
2000990c:	3720      	adds	r7, #32
2000990e:	46bd      	mov	sp, r7
20009910:	bd80      	pop	{r7, pc}
20009912:	bf00      	nop
20009914:	40021000 	.word	0x40021000
20009918:	00f42400 	.word	0x00f42400

2000991c <HAL_RCCEx_EnableLSECSS>:
  *         with HAL_RCC_OscConfig() and the LSE oscillator clock is to be selected as RTC
  *         clock with HAL_RCCEx_PeriphCLKConfig().
  * @retval None
  */
void HAL_RCCEx_EnableLSECSS(void)
{
2000991c:	b480      	push	{r7}
2000991e:	af00      	add	r7, sp, #0
  SET_BIT(RCC->BDCR, RCC_BDCR_LSECSSON) ;
20009920:	4b06      	ldr	r3, [pc, #24]	; (2000993c <HAL_RCCEx_EnableLSECSS+0x20>)
20009922:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
20009926:	4a05      	ldr	r2, [pc, #20]	; (2000993c <HAL_RCCEx_EnableLSECSS+0x20>)
20009928:	f043 0320 	orr.w	r3, r3, #32
2000992c:	f8c2 3090 	str.w	r3, [r2, #144]	; 0x90
}
20009930:	bf00      	nop
20009932:	46bd      	mov	sp, r7
20009934:	f85d 7b04 	ldr.w	r7, [sp], #4
20009938:	4770      	bx	lr
2000993a:	bf00      	nop
2000993c:	40021000 	.word	0x40021000

20009940 <HAL_RCCEx_DisableLSECSS>:
  * @brief  Disable the LSE Clock Security System.
  * @note   LSE Clock Security System can only be disabled after a LSE failure detection.
  * @retval None
  */
void HAL_RCCEx_DisableLSECSS(void)
{
20009940:	b480      	push	{r7}
20009942:	af00      	add	r7, sp, #0
  CLEAR_BIT(RCC->BDCR, RCC_BDCR_LSECSSON) ;
20009944:	4b09      	ldr	r3, [pc, #36]	; (2000996c <HAL_RCCEx_DisableLSECSS+0x2c>)
20009946:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
2000994a:	4a08      	ldr	r2, [pc, #32]	; (2000996c <HAL_RCCEx_DisableLSECSS+0x2c>)
2000994c:	f023 0320 	bic.w	r3, r3, #32
20009950:	f8c2 3090 	str.w	r3, [r2, #144]	; 0x90

  /* Disable LSE CSS IT if any */
  __HAL_RCC_DISABLE_IT(RCC_IT_LSECSS);
20009954:	4b05      	ldr	r3, [pc, #20]	; (2000996c <HAL_RCCEx_DisableLSECSS+0x2c>)
20009956:	699b      	ldr	r3, [r3, #24]
20009958:	4a04      	ldr	r2, [pc, #16]	; (2000996c <HAL_RCCEx_DisableLSECSS+0x2c>)
2000995a:	f423 7300 	bic.w	r3, r3, #512	; 0x200
2000995e:	6193      	str	r3, [r2, #24]
}
20009960:	bf00      	nop
20009962:	46bd      	mov	sp, r7
20009964:	f85d 7b04 	ldr.w	r7, [sp], #4
20009968:	4770      	bx	lr
2000996a:	bf00      	nop
2000996c:	40021000 	.word	0x40021000

20009970 <HAL_RCCEx_EnableLSECSS_IT>:
  * @brief  Enable the LSE Clock Security System Interrupt & corresponding EXTI line.
  * @note   LSE Clock Security System Interrupt is mapped on RTC EXTI line 19
  * @retval None
  */
void HAL_RCCEx_EnableLSECSS_IT(void)
{
20009970:	b480      	push	{r7}
20009972:	af00      	add	r7, sp, #0
  /* Enable LSE CSS */
  SET_BIT(RCC->BDCR, RCC_BDCR_LSECSSON) ;
20009974:	4b0f      	ldr	r3, [pc, #60]	; (200099b4 <HAL_RCCEx_EnableLSECSS_IT+0x44>)
20009976:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
2000997a:	4a0e      	ldr	r2, [pc, #56]	; (200099b4 <HAL_RCCEx_EnableLSECSS_IT+0x44>)
2000997c:	f043 0320 	orr.w	r3, r3, #32
20009980:	f8c2 3090 	str.w	r3, [r2, #144]	; 0x90

  /* Enable LSE CSS IT */
  __HAL_RCC_ENABLE_IT(RCC_IT_LSECSS);
20009984:	4b0b      	ldr	r3, [pc, #44]	; (200099b4 <HAL_RCCEx_EnableLSECSS_IT+0x44>)
20009986:	699b      	ldr	r3, [r3, #24]
20009988:	4a0a      	ldr	r2, [pc, #40]	; (200099b4 <HAL_RCCEx_EnableLSECSS_IT+0x44>)
2000998a:	f443 7300 	orr.w	r3, r3, #512	; 0x200
2000998e:	6193      	str	r3, [r2, #24]

  /* Enable IT on EXTI Line 19 */
  __HAL_RCC_LSECSS_EXTI_ENABLE_IT();
20009990:	4b09      	ldr	r3, [pc, #36]	; (200099b8 <HAL_RCCEx_EnableLSECSS_IT+0x48>)
20009992:	681b      	ldr	r3, [r3, #0]
20009994:	4a08      	ldr	r2, [pc, #32]	; (200099b8 <HAL_RCCEx_EnableLSECSS_IT+0x48>)
20009996:	f443 2300 	orr.w	r3, r3, #524288	; 0x80000
2000999a:	6013      	str	r3, [r2, #0]
  __HAL_RCC_LSECSS_EXTI_ENABLE_RISING_EDGE();
2000999c:	4b06      	ldr	r3, [pc, #24]	; (200099b8 <HAL_RCCEx_EnableLSECSS_IT+0x48>)
2000999e:	689b      	ldr	r3, [r3, #8]
200099a0:	4a05      	ldr	r2, [pc, #20]	; (200099b8 <HAL_RCCEx_EnableLSECSS_IT+0x48>)
200099a2:	f443 2300 	orr.w	r3, r3, #524288	; 0x80000
200099a6:	6093      	str	r3, [r2, #8]
}
200099a8:	bf00      	nop
200099aa:	46bd      	mov	sp, r7
200099ac:	f85d 7b04 	ldr.w	r7, [sp], #4
200099b0:	4770      	bx	lr
200099b2:	bf00      	nop
200099b4:	40021000 	.word	0x40021000
200099b8:	40010400 	.word	0x40010400

200099bc <HAL_RCCEx_LSECSS_IRQHandler>:
/**
  * @brief Handle the RCC LSE Clock Security System interrupt request.
  * @retval None
  */
void HAL_RCCEx_LSECSS_IRQHandler(void)
{
200099bc:	b580      	push	{r7, lr}
200099be:	af00      	add	r7, sp, #0
  /* Check RCC LSE CSSF flag  */
  if(__HAL_RCC_GET_IT(RCC_IT_LSECSS))
200099c0:	4b07      	ldr	r3, [pc, #28]	; (200099e0 <HAL_RCCEx_LSECSS_IRQHandler+0x24>)
200099c2:	69db      	ldr	r3, [r3, #28]
200099c4:	f403 7300 	and.w	r3, r3, #512	; 0x200
200099c8:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
200099cc:	d105      	bne.n	200099da <HAL_RCCEx_LSECSS_IRQHandler+0x1e>
  {
    /* RCC LSE Clock Security System interrupt user callback */
    HAL_RCCEx_LSECSS_Callback();
200099ce:	f000 f809 	bl	200099e4 <HAL_RCCEx_LSECSS_Callback>

    /* Clear RCC LSE CSS pending bit */
    __HAL_RCC_CLEAR_IT(RCC_IT_LSECSS);
200099d2:	4b03      	ldr	r3, [pc, #12]	; (200099e0 <HAL_RCCEx_LSECSS_IRQHandler+0x24>)
200099d4:	f44f 7200 	mov.w	r2, #512	; 0x200
200099d8:	621a      	str	r2, [r3, #32]
  }
}
200099da:	bf00      	nop
200099dc:	bd80      	pop	{r7, pc}
200099de:	bf00      	nop
200099e0:	40021000 	.word	0x40021000

200099e4 <HAL_RCCEx_LSECSS_Callback>:
/**
  * @brief  RCCEx LSE Clock Security System interrupt callback.
  * @retval none
  */
__weak void HAL_RCCEx_LSECSS_Callback(void)
{
200099e4:	b480      	push	{r7}
200099e6:	af00      	add	r7, sp, #0
  /* NOTE : This function should not be modified, when the callback is needed,
            the @ref HAL_RCCEx_LSECSS_Callback should be implemented in the user file
   */
}
200099e8:	bf00      	nop
200099ea:	46bd      	mov	sp, r7
200099ec:	f85d 7b04 	ldr.w	r7, [sp], #4
200099f0:	4770      	bx	lr
	...

200099f4 <HAL_RCCEx_EnableLSCO>:
  *            @arg @ref RCC_LSCOSOURCE_LSI  LSI clock selected as LSCO source
  *            @arg @ref RCC_LSCOSOURCE_LSE  LSE clock selected as LSCO source
  * @retval None
  */
void HAL_RCCEx_EnableLSCO(uint32_t LSCOSource)
{
200099f4:	b580      	push	{r7, lr}
200099f6:	b08a      	sub	sp, #40	; 0x28
200099f8:	af00      	add	r7, sp, #0
200099fa:	6078      	str	r0, [r7, #4]
  GPIO_InitTypeDef GPIO_InitStruct;
  FlagStatus       pwrclkchanged = RESET;
200099fc:	2300      	movs	r3, #0
200099fe:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
  FlagStatus       backupchanged = RESET;
20009a02:	2300      	movs	r3, #0
20009a04:	f887 3026 	strb.w	r3, [r7, #38]	; 0x26

  /* Check the parameters */
  assert_param(IS_RCC_LSCOSOURCE(LSCOSource));

  /* LSCO Pin Clock Enable */
  __LSCO_CLK_ENABLE();
20009a08:	4b2d      	ldr	r3, [pc, #180]	; (20009ac0 <HAL_RCCEx_EnableLSCO+0xcc>)
20009a0a:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
20009a0c:	4a2c      	ldr	r2, [pc, #176]	; (20009ac0 <HAL_RCCEx_EnableLSCO+0xcc>)
20009a0e:	f043 0301 	orr.w	r3, r3, #1
20009a12:	64d3      	str	r3, [r2, #76]	; 0x4c
20009a14:	4b2a      	ldr	r3, [pc, #168]	; (20009ac0 <HAL_RCCEx_EnableLSCO+0xcc>)
20009a16:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
20009a18:	f003 0301 	and.w	r3, r3, #1
20009a1c:	60fb      	str	r3, [r7, #12]
20009a1e:	68fb      	ldr	r3, [r7, #12]

  /* Configure the LSCO pin in analog mode */
  GPIO_InitStruct.Pin = LSCO_PIN;
20009a20:	2304      	movs	r3, #4
20009a22:	613b      	str	r3, [r7, #16]
  GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
20009a24:	2303      	movs	r3, #3
20009a26:	617b      	str	r3, [r7, #20]
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
20009a28:	2302      	movs	r3, #2
20009a2a:	61fb      	str	r3, [r7, #28]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
20009a2c:	2300      	movs	r3, #0
20009a2e:	61bb      	str	r3, [r7, #24]
  HAL_GPIO_Init(LSCO_GPIO_PORT, &GPIO_InitStruct);
20009a30:	f107 0310 	add.w	r3, r7, #16
20009a34:	4619      	mov	r1, r3
20009a36:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
20009a3a:	f7fb f84d 	bl	20004ad8 <HAL_GPIO_Init>

  /* Update LSCOSEL clock source in Backup Domain control register */
  if(__HAL_RCC_PWR_IS_CLK_DISABLED())
20009a3e:	4b20      	ldr	r3, [pc, #128]	; (20009ac0 <HAL_RCCEx_EnableLSCO+0xcc>)
20009a40:	6d9b      	ldr	r3, [r3, #88]	; 0x58
20009a42:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
20009a46:	2b00      	cmp	r3, #0
20009a48:	d10e      	bne.n	20009a68 <HAL_RCCEx_EnableLSCO+0x74>
  {
    __HAL_RCC_PWR_CLK_ENABLE();
20009a4a:	4b1d      	ldr	r3, [pc, #116]	; (20009ac0 <HAL_RCCEx_EnableLSCO+0xcc>)
20009a4c:	6d9b      	ldr	r3, [r3, #88]	; 0x58
20009a4e:	4a1c      	ldr	r2, [pc, #112]	; (20009ac0 <HAL_RCCEx_EnableLSCO+0xcc>)
20009a50:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
20009a54:	6593      	str	r3, [r2, #88]	; 0x58
20009a56:	4b1a      	ldr	r3, [pc, #104]	; (20009ac0 <HAL_RCCEx_EnableLSCO+0xcc>)
20009a58:	6d9b      	ldr	r3, [r3, #88]	; 0x58
20009a5a:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
20009a5e:	60bb      	str	r3, [r7, #8]
20009a60:	68bb      	ldr	r3, [r7, #8]
    pwrclkchanged = SET;
20009a62:	2301      	movs	r3, #1
20009a64:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
  }
  if(HAL_IS_BIT_CLR(PWR->CR1, PWR_CR1_DBP))
20009a68:	4b16      	ldr	r3, [pc, #88]	; (20009ac4 <HAL_RCCEx_EnableLSCO+0xd0>)
20009a6a:	681b      	ldr	r3, [r3, #0]
20009a6c:	f403 7380 	and.w	r3, r3, #256	; 0x100
20009a70:	2b00      	cmp	r3, #0
20009a72:	d104      	bne.n	20009a7e <HAL_RCCEx_EnableLSCO+0x8a>
  {
    HAL_PWR_EnableBkUpAccess();
20009a74:	f7fb fb40 	bl	200050f8 <HAL_PWR_EnableBkUpAccess>
    backupchanged = SET;
20009a78:	2301      	movs	r3, #1
20009a7a:	f887 3026 	strb.w	r3, [r7, #38]	; 0x26
  }

  MODIFY_REG(RCC->BDCR, RCC_BDCR_LSCOSEL | RCC_BDCR_LSCOEN, LSCOSource | RCC_BDCR_LSCOEN);
20009a7e:	4b10      	ldr	r3, [pc, #64]	; (20009ac0 <HAL_RCCEx_EnableLSCO+0xcc>)
20009a80:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
20009a84:	f023 7240 	bic.w	r2, r3, #50331648	; 0x3000000
20009a88:	687b      	ldr	r3, [r7, #4]
20009a8a:	4313      	orrs	r3, r2
20009a8c:	4a0c      	ldr	r2, [pc, #48]	; (20009ac0 <HAL_RCCEx_EnableLSCO+0xcc>)
20009a8e:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
20009a92:	f8c2 3090 	str.w	r3, [r2, #144]	; 0x90

  if(backupchanged == SET)
20009a96:	f897 3026 	ldrb.w	r3, [r7, #38]	; 0x26
20009a9a:	2b01      	cmp	r3, #1
20009a9c:	d101      	bne.n	20009aa2 <HAL_RCCEx_EnableLSCO+0xae>
  {
    HAL_PWR_DisableBkUpAccess();
20009a9e:	f7fb fb3b 	bl	20005118 <HAL_PWR_DisableBkUpAccess>
  }
  if(pwrclkchanged == SET)
20009aa2:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
20009aa6:	2b01      	cmp	r3, #1
20009aa8:	d105      	bne.n	20009ab6 <HAL_RCCEx_EnableLSCO+0xc2>
  {
    __HAL_RCC_PWR_CLK_DISABLE();
20009aaa:	4b05      	ldr	r3, [pc, #20]	; (20009ac0 <HAL_RCCEx_EnableLSCO+0xcc>)
20009aac:	6d9b      	ldr	r3, [r3, #88]	; 0x58
20009aae:	4a04      	ldr	r2, [pc, #16]	; (20009ac0 <HAL_RCCEx_EnableLSCO+0xcc>)
20009ab0:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
20009ab4:	6593      	str	r3, [r2, #88]	; 0x58
  }
}
20009ab6:	bf00      	nop
20009ab8:	3728      	adds	r7, #40	; 0x28
20009aba:	46bd      	mov	sp, r7
20009abc:	bd80      	pop	{r7, pc}
20009abe:	bf00      	nop
20009ac0:	40021000 	.word	0x40021000
20009ac4:	40007000 	.word	0x40007000

20009ac8 <HAL_RCCEx_DisableLSCO>:
/**
  * @brief  Disable the Low Speed clock output.
  * @retval None
  */
void HAL_RCCEx_DisableLSCO(void)
{
20009ac8:	b580      	push	{r7, lr}
20009aca:	b082      	sub	sp, #8
20009acc:	af00      	add	r7, sp, #0
  FlagStatus       pwrclkchanged = RESET;
20009ace:	2300      	movs	r3, #0
20009ad0:	71fb      	strb	r3, [r7, #7]
  FlagStatus       backupchanged = RESET;
20009ad2:	2300      	movs	r3, #0
20009ad4:	71bb      	strb	r3, [r7, #6]

  /* Update LSCOEN bit in Backup Domain control register */
  if(__HAL_RCC_PWR_IS_CLK_DISABLED())
20009ad6:	4b1c      	ldr	r3, [pc, #112]	; (20009b48 <HAL_RCCEx_DisableLSCO+0x80>)
20009ad8:	6d9b      	ldr	r3, [r3, #88]	; 0x58
20009ada:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
20009ade:	2b00      	cmp	r3, #0
20009ae0:	d10d      	bne.n	20009afe <HAL_RCCEx_DisableLSCO+0x36>
  {
    __HAL_RCC_PWR_CLK_ENABLE();
20009ae2:	4b19      	ldr	r3, [pc, #100]	; (20009b48 <HAL_RCCEx_DisableLSCO+0x80>)
20009ae4:	6d9b      	ldr	r3, [r3, #88]	; 0x58
20009ae6:	4a18      	ldr	r2, [pc, #96]	; (20009b48 <HAL_RCCEx_DisableLSCO+0x80>)
20009ae8:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
20009aec:	6593      	str	r3, [r2, #88]	; 0x58
20009aee:	4b16      	ldr	r3, [pc, #88]	; (20009b48 <HAL_RCCEx_DisableLSCO+0x80>)
20009af0:	6d9b      	ldr	r3, [r3, #88]	; 0x58
20009af2:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
20009af6:	603b      	str	r3, [r7, #0]
20009af8:	683b      	ldr	r3, [r7, #0]
    pwrclkchanged = SET;
20009afa:	2301      	movs	r3, #1
20009afc:	71fb      	strb	r3, [r7, #7]
  }
  if(HAL_IS_BIT_CLR(PWR->CR1, PWR_CR1_DBP))
20009afe:	4b13      	ldr	r3, [pc, #76]	; (20009b4c <HAL_RCCEx_DisableLSCO+0x84>)
20009b00:	681b      	ldr	r3, [r3, #0]
20009b02:	f403 7380 	and.w	r3, r3, #256	; 0x100
20009b06:	2b00      	cmp	r3, #0
20009b08:	d103      	bne.n	20009b12 <HAL_RCCEx_DisableLSCO+0x4a>
  {
    /* Enable access to the backup domain */
    HAL_PWR_EnableBkUpAccess();
20009b0a:	f7fb faf5 	bl	200050f8 <HAL_PWR_EnableBkUpAccess>
    backupchanged = SET;
20009b0e:	2301      	movs	r3, #1
20009b10:	71bb      	strb	r3, [r7, #6]
  }

  CLEAR_BIT(RCC->BDCR, RCC_BDCR_LSCOEN);
20009b12:	4b0d      	ldr	r3, [pc, #52]	; (20009b48 <HAL_RCCEx_DisableLSCO+0x80>)
20009b14:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
20009b18:	4a0b      	ldr	r2, [pc, #44]	; (20009b48 <HAL_RCCEx_DisableLSCO+0x80>)
20009b1a:	f023 7380 	bic.w	r3, r3, #16777216	; 0x1000000
20009b1e:	f8c2 3090 	str.w	r3, [r2, #144]	; 0x90

  /* Restore previous configuration */
  if(backupchanged == SET)
20009b22:	79bb      	ldrb	r3, [r7, #6]
20009b24:	2b01      	cmp	r3, #1
20009b26:	d101      	bne.n	20009b2c <HAL_RCCEx_DisableLSCO+0x64>
  {
    /* Disable access to the backup domain */
    HAL_PWR_DisableBkUpAccess();
20009b28:	f7fb faf6 	bl	20005118 <HAL_PWR_DisableBkUpAccess>
  }
  if(pwrclkchanged == SET)
20009b2c:	79fb      	ldrb	r3, [r7, #7]
20009b2e:	2b01      	cmp	r3, #1
20009b30:	d105      	bne.n	20009b3e <HAL_RCCEx_DisableLSCO+0x76>
  {
    __HAL_RCC_PWR_CLK_DISABLE();
20009b32:	4b05      	ldr	r3, [pc, #20]	; (20009b48 <HAL_RCCEx_DisableLSCO+0x80>)
20009b34:	6d9b      	ldr	r3, [r3, #88]	; 0x58
20009b36:	4a04      	ldr	r2, [pc, #16]	; (20009b48 <HAL_RCCEx_DisableLSCO+0x80>)
20009b38:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
20009b3c:	6593      	str	r3, [r2, #88]	; 0x58
  }
}
20009b3e:	bf00      	nop
20009b40:	3708      	adds	r7, #8
20009b42:	46bd      	mov	sp, r7
20009b44:	bd80      	pop	{r7, pc}
20009b46:	bf00      	nop
20009b48:	40021000 	.word	0x40021000
20009b4c:	40007000 	.word	0x40007000

20009b50 <HAL_RCCEx_CRSConfig>:
  * @brief  Start automatic synchronization for polling mode
  * @param  pInit Pointer on RCC_CRSInitTypeDef structure
  * @retval None
  */
void HAL_RCCEx_CRSConfig(RCC_CRSInitTypeDef *pInit)
{
20009b50:	b480      	push	{r7}
20009b52:	b085      	sub	sp, #20
20009b54:	af00      	add	r7, sp, #0
20009b56:	6078      	str	r0, [r7, #4]
  assert_param(IS_RCC_CRS_HSI48CALIBRATION(pInit->HSI48CalibrationValue));

  /* CONFIGURATION */

  /* Before configuration, reset CRS registers to their default values*/
  __HAL_RCC_CRS_FORCE_RESET();
20009b58:	4b1c      	ldr	r3, [pc, #112]	; (20009bcc <HAL_RCCEx_CRSConfig+0x7c>)
20009b5a:	6b9b      	ldr	r3, [r3, #56]	; 0x38
20009b5c:	4a1b      	ldr	r2, [pc, #108]	; (20009bcc <HAL_RCCEx_CRSConfig+0x7c>)
20009b5e:	f443 7380 	orr.w	r3, r3, #256	; 0x100
20009b62:	6393      	str	r3, [r2, #56]	; 0x38
  __HAL_RCC_CRS_RELEASE_RESET();
20009b64:	4b19      	ldr	r3, [pc, #100]	; (20009bcc <HAL_RCCEx_CRSConfig+0x7c>)
20009b66:	6b9b      	ldr	r3, [r3, #56]	; 0x38
20009b68:	4a18      	ldr	r2, [pc, #96]	; (20009bcc <HAL_RCCEx_CRSConfig+0x7c>)
20009b6a:	f423 7380 	bic.w	r3, r3, #256	; 0x100
20009b6e:	6393      	str	r3, [r2, #56]	; 0x38

  /* Set the SYNCDIV[2:0] bits according to Prescaler value */
  /* Set the SYNCSRC[1:0] bits according to Source value */
  /* Set the SYNCSPOL bit according to Polarity value */
  value = (pInit->Prescaler | pInit->Source | pInit->Polarity);
20009b70:	687b      	ldr	r3, [r7, #4]
20009b72:	681a      	ldr	r2, [r3, #0]
20009b74:	687b      	ldr	r3, [r7, #4]
20009b76:	685b      	ldr	r3, [r3, #4]
20009b78:	431a      	orrs	r2, r3
20009b7a:	687b      	ldr	r3, [r7, #4]
20009b7c:	689b      	ldr	r3, [r3, #8]
20009b7e:	4313      	orrs	r3, r2
20009b80:	60fb      	str	r3, [r7, #12]
  /* Set the RELOAD[15:0] bits according to ReloadValue value */
  value |= pInit->ReloadValue;
20009b82:	687b      	ldr	r3, [r7, #4]
20009b84:	68db      	ldr	r3, [r3, #12]
20009b86:	68fa      	ldr	r2, [r7, #12]
20009b88:	4313      	orrs	r3, r2
20009b8a:	60fb      	str	r3, [r7, #12]
  /* Set the FELIM[7:0] bits according to ErrorLimitValue value */
  value |= (pInit->ErrorLimitValue << CRS_CFGR_FELIM_Pos);
20009b8c:	687b      	ldr	r3, [r7, #4]
20009b8e:	691b      	ldr	r3, [r3, #16]
20009b90:	041b      	lsls	r3, r3, #16
20009b92:	68fa      	ldr	r2, [r7, #12]
20009b94:	4313      	orrs	r3, r2
20009b96:	60fb      	str	r3, [r7, #12]
  WRITE_REG(CRS->CFGR, value);
20009b98:	4a0d      	ldr	r2, [pc, #52]	; (20009bd0 <HAL_RCCEx_CRSConfig+0x80>)
20009b9a:	68fb      	ldr	r3, [r7, #12]
20009b9c:	6053      	str	r3, [r2, #4]

  /* Adjust HSI48 oscillator smooth trimming */
  /* Set the TRIM[6:0] bits according to RCC_CRS_HSI48CalibrationValue value */
  MODIFY_REG(CRS->CR, CRS_CR_TRIM, (pInit->HSI48CalibrationValue << CRS_CR_TRIM_Pos));
20009b9e:	4b0c      	ldr	r3, [pc, #48]	; (20009bd0 <HAL_RCCEx_CRSConfig+0x80>)
20009ba0:	681b      	ldr	r3, [r3, #0]
20009ba2:	f423 42fe 	bic.w	r2, r3, #32512	; 0x7f00
20009ba6:	687b      	ldr	r3, [r7, #4]
20009ba8:	695b      	ldr	r3, [r3, #20]
20009baa:	021b      	lsls	r3, r3, #8
20009bac:	4908      	ldr	r1, [pc, #32]	; (20009bd0 <HAL_RCCEx_CRSConfig+0x80>)
20009bae:	4313      	orrs	r3, r2
20009bb0:	600b      	str	r3, [r1, #0]

  /* START AUTOMATIC SYNCHRONIZATION*/

  /* Enable Automatic trimming & Frequency error counter */
  SET_BIT(CRS->CR, CRS_CR_AUTOTRIMEN | CRS_CR_CEN);
20009bb2:	4b07      	ldr	r3, [pc, #28]	; (20009bd0 <HAL_RCCEx_CRSConfig+0x80>)
20009bb4:	681b      	ldr	r3, [r3, #0]
20009bb6:	4a06      	ldr	r2, [pc, #24]	; (20009bd0 <HAL_RCCEx_CRSConfig+0x80>)
20009bb8:	f043 0360 	orr.w	r3, r3, #96	; 0x60
20009bbc:	6013      	str	r3, [r2, #0]
}
20009bbe:	bf00      	nop
20009bc0:	3714      	adds	r7, #20
20009bc2:	46bd      	mov	sp, r7
20009bc4:	f85d 7b04 	ldr.w	r7, [sp], #4
20009bc8:	4770      	bx	lr
20009bca:	bf00      	nop
20009bcc:	40021000 	.word	0x40021000
20009bd0:	40002000 	.word	0x40002000

20009bd4 <HAL_RCCEx_CRSSoftwareSynchronizationGenerate>:
/**
  * @brief  Generate the software synchronization event
  * @retval None
  */
void HAL_RCCEx_CRSSoftwareSynchronizationGenerate(void)
{
20009bd4:	b480      	push	{r7}
20009bd6:	af00      	add	r7, sp, #0
  SET_BIT(CRS->CR, CRS_CR_SWSYNC);
20009bd8:	4b05      	ldr	r3, [pc, #20]	; (20009bf0 <HAL_RCCEx_CRSSoftwareSynchronizationGenerate+0x1c>)
20009bda:	681b      	ldr	r3, [r3, #0]
20009bdc:	4a04      	ldr	r2, [pc, #16]	; (20009bf0 <HAL_RCCEx_CRSSoftwareSynchronizationGenerate+0x1c>)
20009bde:	f043 0380 	orr.w	r3, r3, #128	; 0x80
20009be2:	6013      	str	r3, [r2, #0]
}
20009be4:	bf00      	nop
20009be6:	46bd      	mov	sp, r7
20009be8:	f85d 7b04 	ldr.w	r7, [sp], #4
20009bec:	4770      	bx	lr
20009bee:	bf00      	nop
20009bf0:	40002000 	.word	0x40002000

20009bf4 <HAL_RCCEx_CRSGetSynchronizationInfo>:
  * @brief  Return synchronization info
  * @param  pSynchroInfo Pointer on RCC_CRSSynchroInfoTypeDef structure
  * @retval None
  */
void HAL_RCCEx_CRSGetSynchronizationInfo(RCC_CRSSynchroInfoTypeDef *pSynchroInfo)
{
20009bf4:	b480      	push	{r7}
20009bf6:	b083      	sub	sp, #12
20009bf8:	af00      	add	r7, sp, #0
20009bfa:	6078      	str	r0, [r7, #4]
  /* Check the parameter */
  assert_param(pSynchroInfo != (void *)NULL);

  /* Get the reload value */
  pSynchroInfo->ReloadValue = (READ_BIT(CRS->CFGR, CRS_CFGR_RELOAD));
20009bfc:	4b0e      	ldr	r3, [pc, #56]	; (20009c38 <HAL_RCCEx_CRSGetSynchronizationInfo+0x44>)
20009bfe:	685b      	ldr	r3, [r3, #4]
20009c00:	b29a      	uxth	r2, r3
20009c02:	687b      	ldr	r3, [r7, #4]
20009c04:	601a      	str	r2, [r3, #0]

  /* Get HSI48 oscillator smooth trimming */
  pSynchroInfo->HSI48CalibrationValue = (READ_BIT(CRS->CR, CRS_CR_TRIM) >> CRS_CR_TRIM_Pos);
20009c06:	4b0c      	ldr	r3, [pc, #48]	; (20009c38 <HAL_RCCEx_CRSGetSynchronizationInfo+0x44>)
20009c08:	681b      	ldr	r3, [r3, #0]
20009c0a:	0a1b      	lsrs	r3, r3, #8
20009c0c:	f003 027f 	and.w	r2, r3, #127	; 0x7f
20009c10:	687b      	ldr	r3, [r7, #4]
20009c12:	605a      	str	r2, [r3, #4]

  /* Get Frequency error capture */
  pSynchroInfo->FreqErrorCapture = (READ_BIT(CRS->ISR, CRS_ISR_FECAP) >> CRS_ISR_FECAP_Pos);
20009c14:	4b08      	ldr	r3, [pc, #32]	; (20009c38 <HAL_RCCEx_CRSGetSynchronizationInfo+0x44>)
20009c16:	689b      	ldr	r3, [r3, #8]
20009c18:	0c1b      	lsrs	r3, r3, #16
20009c1a:	b29a      	uxth	r2, r3
20009c1c:	687b      	ldr	r3, [r7, #4]
20009c1e:	609a      	str	r2, [r3, #8]

  /* Get Frequency error direction */
  pSynchroInfo->FreqErrorDirection = (READ_BIT(CRS->ISR, CRS_ISR_FEDIR));
20009c20:	4b05      	ldr	r3, [pc, #20]	; (20009c38 <HAL_RCCEx_CRSGetSynchronizationInfo+0x44>)
20009c22:	689b      	ldr	r3, [r3, #8]
20009c24:	f403 4200 	and.w	r2, r3, #32768	; 0x8000
20009c28:	687b      	ldr	r3, [r7, #4]
20009c2a:	60da      	str	r2, [r3, #12]
}
20009c2c:	bf00      	nop
20009c2e:	370c      	adds	r7, #12
20009c30:	46bd      	mov	sp, r7
20009c32:	f85d 7b04 	ldr.w	r7, [sp], #4
20009c36:	4770      	bx	lr
20009c38:	40002000 	.word	0x40002000

20009c3c <HAL_RCCEx_CRSWaitSynchronization>:
*            @arg @ref RCC_CRS_SYNCERR
*            @arg @ref RCC_CRS_SYNCMISS
*            @arg @ref RCC_CRS_TRIMOVF
*/
uint32_t HAL_RCCEx_CRSWaitSynchronization(uint32_t Timeout)
{
20009c3c:	b580      	push	{r7, lr}
20009c3e:	b084      	sub	sp, #16
20009c40:	af00      	add	r7, sp, #0
20009c42:	6078      	str	r0, [r7, #4]
  uint32_t crsstatus = RCC_CRS_NONE;
20009c44:	2300      	movs	r3, #0
20009c46:	60fb      	str	r3, [r7, #12]
  uint32_t tickstart;

  /* Get timeout */
  tickstart = HAL_GetTick();
20009c48:	f7f7 fe28 	bl	2000189c <HAL_GetTick>
20009c4c:	60b8      	str	r0, [r7, #8]

  /* Wait for CRS flag or timeout detection */
  do
  {
    if(Timeout != HAL_MAX_DELAY)
20009c4e:	687b      	ldr	r3, [r7, #4]
20009c50:	f1b3 3fff 	cmp.w	r3, #4294967295
20009c54:	d00c      	beq.n	20009c70 <HAL_RCCEx_CRSWaitSynchronization+0x34>
    {
      if(((HAL_GetTick() - tickstart) > Timeout) || (Timeout == 0U))
20009c56:	f7f7 fe21 	bl	2000189c <HAL_GetTick>
20009c5a:	4602      	mov	r2, r0
20009c5c:	68bb      	ldr	r3, [r7, #8]
20009c5e:	1ad3      	subs	r3, r2, r3
20009c60:	687a      	ldr	r2, [r7, #4]
20009c62:	429a      	cmp	r2, r3
20009c64:	d302      	bcc.n	20009c6c <HAL_RCCEx_CRSWaitSynchronization+0x30>
20009c66:	687b      	ldr	r3, [r7, #4]
20009c68:	2b00      	cmp	r3, #0
20009c6a:	d101      	bne.n	20009c70 <HAL_RCCEx_CRSWaitSynchronization+0x34>
      {
        crsstatus = RCC_CRS_TIMEOUT;
20009c6c:	2301      	movs	r3, #1
20009c6e:	60fb      	str	r3, [r7, #12]
      }
    }
    /* Check CRS SYNCOK flag  */
    if(__HAL_RCC_CRS_GET_FLAG(RCC_CRS_FLAG_SYNCOK))
20009c70:	4b2a      	ldr	r3, [pc, #168]	; (20009d1c <HAL_RCCEx_CRSWaitSynchronization+0xe0>)
20009c72:	689b      	ldr	r3, [r3, #8]
20009c74:	f003 0301 	and.w	r3, r3, #1
20009c78:	2b01      	cmp	r3, #1
20009c7a:	d106      	bne.n	20009c8a <HAL_RCCEx_CRSWaitSynchronization+0x4e>
    {
      /* CRS SYNC event OK */
      crsstatus |= RCC_CRS_SYNCOK;
20009c7c:	68fb      	ldr	r3, [r7, #12]
20009c7e:	f043 0302 	orr.w	r3, r3, #2
20009c82:	60fb      	str	r3, [r7, #12]

      /* Clear CRS SYNC event OK bit */
      __HAL_RCC_CRS_CLEAR_FLAG(RCC_CRS_FLAG_SYNCOK);
20009c84:	4b25      	ldr	r3, [pc, #148]	; (20009d1c <HAL_RCCEx_CRSWaitSynchronization+0xe0>)
20009c86:	2201      	movs	r2, #1
20009c88:	60da      	str	r2, [r3, #12]
    }

    /* Check CRS SYNCWARN flag  */
    if(__HAL_RCC_CRS_GET_FLAG(RCC_CRS_FLAG_SYNCWARN))
20009c8a:	4b24      	ldr	r3, [pc, #144]	; (20009d1c <HAL_RCCEx_CRSWaitSynchronization+0xe0>)
20009c8c:	689b      	ldr	r3, [r3, #8]
20009c8e:	f003 0302 	and.w	r3, r3, #2
20009c92:	2b02      	cmp	r3, #2
20009c94:	d106      	bne.n	20009ca4 <HAL_RCCEx_CRSWaitSynchronization+0x68>
    {
      /* CRS SYNC warning */
      crsstatus |= RCC_CRS_SYNCWARN;
20009c96:	68fb      	ldr	r3, [r7, #12]
20009c98:	f043 0304 	orr.w	r3, r3, #4
20009c9c:	60fb      	str	r3, [r7, #12]

      /* Clear CRS SYNCWARN bit */
      __HAL_RCC_CRS_CLEAR_FLAG(RCC_CRS_FLAG_SYNCWARN);
20009c9e:	4b1f      	ldr	r3, [pc, #124]	; (20009d1c <HAL_RCCEx_CRSWaitSynchronization+0xe0>)
20009ca0:	2202      	movs	r2, #2
20009ca2:	60da      	str	r2, [r3, #12]
    }

    /* Check CRS TRIM overflow flag  */
    if(__HAL_RCC_CRS_GET_FLAG(RCC_CRS_FLAG_TRIMOVF))
20009ca4:	4b1d      	ldr	r3, [pc, #116]	; (20009d1c <HAL_RCCEx_CRSWaitSynchronization+0xe0>)
20009ca6:	689b      	ldr	r3, [r3, #8]
20009ca8:	f403 6380 	and.w	r3, r3, #1024	; 0x400
20009cac:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
20009cb0:	d106      	bne.n	20009cc0 <HAL_RCCEx_CRSWaitSynchronization+0x84>
    {
      /* CRS SYNC Error */
      crsstatus |= RCC_CRS_TRIMOVF;
20009cb2:	68fb      	ldr	r3, [r7, #12]
20009cb4:	f043 0320 	orr.w	r3, r3, #32
20009cb8:	60fb      	str	r3, [r7, #12]

      /* Clear CRS Error bit */
      __HAL_RCC_CRS_CLEAR_FLAG(RCC_CRS_FLAG_TRIMOVF);
20009cba:	4b18      	ldr	r3, [pc, #96]	; (20009d1c <HAL_RCCEx_CRSWaitSynchronization+0xe0>)
20009cbc:	2204      	movs	r2, #4
20009cbe:	60da      	str	r2, [r3, #12]
    }

    /* Check CRS Error flag  */
    if(__HAL_RCC_CRS_GET_FLAG(RCC_CRS_FLAG_SYNCERR))
20009cc0:	4b16      	ldr	r3, [pc, #88]	; (20009d1c <HAL_RCCEx_CRSWaitSynchronization+0xe0>)
20009cc2:	689b      	ldr	r3, [r3, #8]
20009cc4:	f403 7380 	and.w	r3, r3, #256	; 0x100
20009cc8:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
20009ccc:	d106      	bne.n	20009cdc <HAL_RCCEx_CRSWaitSynchronization+0xa0>
    {
      /* CRS SYNC Error */
      crsstatus |= RCC_CRS_SYNCERR;
20009cce:	68fb      	ldr	r3, [r7, #12]
20009cd0:	f043 0308 	orr.w	r3, r3, #8
20009cd4:	60fb      	str	r3, [r7, #12]

      /* Clear CRS Error bit */
      __HAL_RCC_CRS_CLEAR_FLAG(RCC_CRS_FLAG_SYNCERR);
20009cd6:	4b11      	ldr	r3, [pc, #68]	; (20009d1c <HAL_RCCEx_CRSWaitSynchronization+0xe0>)
20009cd8:	2204      	movs	r2, #4
20009cda:	60da      	str	r2, [r3, #12]
    }

    /* Check CRS SYNC Missed flag  */
    if(__HAL_RCC_CRS_GET_FLAG(RCC_CRS_FLAG_SYNCMISS))
20009cdc:	4b0f      	ldr	r3, [pc, #60]	; (20009d1c <HAL_RCCEx_CRSWaitSynchronization+0xe0>)
20009cde:	689b      	ldr	r3, [r3, #8]
20009ce0:	f403 7300 	and.w	r3, r3, #512	; 0x200
20009ce4:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
20009ce8:	d106      	bne.n	20009cf8 <HAL_RCCEx_CRSWaitSynchronization+0xbc>
    {
      /* CRS SYNC Missed */
      crsstatus |= RCC_CRS_SYNCMISS;
20009cea:	68fb      	ldr	r3, [r7, #12]
20009cec:	f043 0310 	orr.w	r3, r3, #16
20009cf0:	60fb      	str	r3, [r7, #12]

      /* Clear CRS SYNC Missed bit */
      __HAL_RCC_CRS_CLEAR_FLAG(RCC_CRS_FLAG_SYNCMISS);
20009cf2:	4b0a      	ldr	r3, [pc, #40]	; (20009d1c <HAL_RCCEx_CRSWaitSynchronization+0xe0>)
20009cf4:	2204      	movs	r2, #4
20009cf6:	60da      	str	r2, [r3, #12]
    }

    /* Check CRS Expected SYNC flag  */
    if(__HAL_RCC_CRS_GET_FLAG(RCC_CRS_FLAG_ESYNC))
20009cf8:	4b08      	ldr	r3, [pc, #32]	; (20009d1c <HAL_RCCEx_CRSWaitSynchronization+0xe0>)
20009cfa:	689b      	ldr	r3, [r3, #8]
20009cfc:	f003 0308 	and.w	r3, r3, #8
20009d00:	2b08      	cmp	r3, #8
20009d02:	d102      	bne.n	20009d0a <HAL_RCCEx_CRSWaitSynchronization+0xce>
    {
      /* frequency error counter reached a zero value */
      __HAL_RCC_CRS_CLEAR_FLAG(RCC_CRS_FLAG_ESYNC);
20009d04:	4b05      	ldr	r3, [pc, #20]	; (20009d1c <HAL_RCCEx_CRSWaitSynchronization+0xe0>)
20009d06:	2208      	movs	r2, #8
20009d08:	60da      	str	r2, [r3, #12]
    }
  } while(RCC_CRS_NONE == crsstatus);
20009d0a:	68fb      	ldr	r3, [r7, #12]
20009d0c:	2b00      	cmp	r3, #0
20009d0e:	d09e      	beq.n	20009c4e <HAL_RCCEx_CRSWaitSynchronization+0x12>

  return crsstatus;
20009d10:	68fb      	ldr	r3, [r7, #12]
}
20009d12:	4618      	mov	r0, r3
20009d14:	3710      	adds	r7, #16
20009d16:	46bd      	mov	sp, r7
20009d18:	bd80      	pop	{r7, pc}
20009d1a:	bf00      	nop
20009d1c:	40002000 	.word	0x40002000

20009d20 <HAL_RCCEx_CRS_IRQHandler>:
/**
  * @brief Handle the Clock Recovery System interrupt request.
  * @retval None
  */
void HAL_RCCEx_CRS_IRQHandler(void)
{
20009d20:	b580      	push	{r7, lr}
20009d22:	b084      	sub	sp, #16
20009d24:	af00      	add	r7, sp, #0
  uint32_t crserror = RCC_CRS_NONE;
20009d26:	2300      	movs	r3, #0
20009d28:	60fb      	str	r3, [r7, #12]
  /* Get current IT flags and IT sources values */
  uint32_t itflags = READ_REG(CRS->ISR);
20009d2a:	4b33      	ldr	r3, [pc, #204]	; (20009df8 <HAL_RCCEx_CRS_IRQHandler+0xd8>)
20009d2c:	689b      	ldr	r3, [r3, #8]
20009d2e:	60bb      	str	r3, [r7, #8]
  uint32_t itsources = READ_REG(CRS->CR);
20009d30:	4b31      	ldr	r3, [pc, #196]	; (20009df8 <HAL_RCCEx_CRS_IRQHandler+0xd8>)
20009d32:	681b      	ldr	r3, [r3, #0]
20009d34:	607b      	str	r3, [r7, #4]

  /* Check CRS SYNCOK flag  */
  if(((itflags & RCC_CRS_FLAG_SYNCOK) != 0U) && ((itsources & RCC_CRS_IT_SYNCOK) != 0U))
20009d36:	68bb      	ldr	r3, [r7, #8]
20009d38:	f003 0301 	and.w	r3, r3, #1
20009d3c:	2b00      	cmp	r3, #0
20009d3e:	d00a      	beq.n	20009d56 <HAL_RCCEx_CRS_IRQHandler+0x36>
20009d40:	687b      	ldr	r3, [r7, #4]
20009d42:	f003 0301 	and.w	r3, r3, #1
20009d46:	2b00      	cmp	r3, #0
20009d48:	d005      	beq.n	20009d56 <HAL_RCCEx_CRS_IRQHandler+0x36>
  {
    /* Clear CRS SYNC event OK flag */
    WRITE_REG(CRS->ICR, CRS_ICR_SYNCOKC);
20009d4a:	4b2b      	ldr	r3, [pc, #172]	; (20009df8 <HAL_RCCEx_CRS_IRQHandler+0xd8>)
20009d4c:	2201      	movs	r2, #1
20009d4e:	60da      	str	r2, [r3, #12]

    /* user callback */
    HAL_RCCEx_CRS_SyncOkCallback();
20009d50:	f000 f854 	bl	20009dfc <HAL_RCCEx_CRS_SyncOkCallback>
20009d54:	e04b      	b.n	20009dee <HAL_RCCEx_CRS_IRQHandler+0xce>
  }
  /* Check CRS SYNCWARN flag  */
  else if(((itflags & RCC_CRS_FLAG_SYNCWARN) != 0U) && ((itsources & RCC_CRS_IT_SYNCWARN) != 0U))
20009d56:	68bb      	ldr	r3, [r7, #8]
20009d58:	f003 0302 	and.w	r3, r3, #2
20009d5c:	2b00      	cmp	r3, #0
20009d5e:	d00a      	beq.n	20009d76 <HAL_RCCEx_CRS_IRQHandler+0x56>
20009d60:	687b      	ldr	r3, [r7, #4]
20009d62:	f003 0302 	and.w	r3, r3, #2
20009d66:	2b00      	cmp	r3, #0
20009d68:	d005      	beq.n	20009d76 <HAL_RCCEx_CRS_IRQHandler+0x56>
  {
    /* Clear CRS SYNCWARN flag */
    WRITE_REG(CRS->ICR, CRS_ICR_SYNCWARNC);
20009d6a:	4b23      	ldr	r3, [pc, #140]	; (20009df8 <HAL_RCCEx_CRS_IRQHandler+0xd8>)
20009d6c:	2202      	movs	r2, #2
20009d6e:	60da      	str	r2, [r3, #12]

    /* user callback */
    HAL_RCCEx_CRS_SyncWarnCallback();
20009d70:	f000 f84b 	bl	20009e0a <HAL_RCCEx_CRS_SyncWarnCallback>
20009d74:	e03b      	b.n	20009dee <HAL_RCCEx_CRS_IRQHandler+0xce>
  }
  /* Check CRS Expected SYNC flag  */
  else if(((itflags & RCC_CRS_FLAG_ESYNC) != 0U) && ((itsources & RCC_CRS_IT_ESYNC) != 0U))
20009d76:	68bb      	ldr	r3, [r7, #8]
20009d78:	f003 0308 	and.w	r3, r3, #8
20009d7c:	2b00      	cmp	r3, #0
20009d7e:	d00a      	beq.n	20009d96 <HAL_RCCEx_CRS_IRQHandler+0x76>
20009d80:	687b      	ldr	r3, [r7, #4]
20009d82:	f003 0308 	and.w	r3, r3, #8
20009d86:	2b00      	cmp	r3, #0
20009d88:	d005      	beq.n	20009d96 <HAL_RCCEx_CRS_IRQHandler+0x76>
  {
    /* frequency error counter reached a zero value */
    WRITE_REG(CRS->ICR, CRS_ICR_ESYNCC);
20009d8a:	4b1b      	ldr	r3, [pc, #108]	; (20009df8 <HAL_RCCEx_CRS_IRQHandler+0xd8>)
20009d8c:	2208      	movs	r2, #8
20009d8e:	60da      	str	r2, [r3, #12]

    /* user callback */
    HAL_RCCEx_CRS_ExpectedSyncCallback();
20009d90:	f000 f842 	bl	20009e18 <HAL_RCCEx_CRS_ExpectedSyncCallback>
20009d94:	e02b      	b.n	20009dee <HAL_RCCEx_CRS_IRQHandler+0xce>
  }
  /* Check CRS Error flags  */
  else
  {
    if(((itflags & RCC_CRS_FLAG_ERR) != 0U) && ((itsources & RCC_CRS_IT_ERR) != 0U))
20009d96:	68bb      	ldr	r3, [r7, #8]
20009d98:	f003 0304 	and.w	r3, r3, #4
20009d9c:	2b00      	cmp	r3, #0
20009d9e:	d026      	beq.n	20009dee <HAL_RCCEx_CRS_IRQHandler+0xce>
20009da0:	687b      	ldr	r3, [r7, #4]
20009da2:	f003 0304 	and.w	r3, r3, #4
20009da6:	2b00      	cmp	r3, #0
20009da8:	d021      	beq.n	20009dee <HAL_RCCEx_CRS_IRQHandler+0xce>
    {
      if((itflags & RCC_CRS_FLAG_SYNCERR) != 0U)
20009daa:	68bb      	ldr	r3, [r7, #8]
20009dac:	f403 7380 	and.w	r3, r3, #256	; 0x100
20009db0:	2b00      	cmp	r3, #0
20009db2:	d003      	beq.n	20009dbc <HAL_RCCEx_CRS_IRQHandler+0x9c>
      {
        crserror |= RCC_CRS_SYNCERR;
20009db4:	68fb      	ldr	r3, [r7, #12]
20009db6:	f043 0308 	orr.w	r3, r3, #8
20009dba:	60fb      	str	r3, [r7, #12]
      }
      if((itflags & RCC_CRS_FLAG_SYNCMISS) != 0U)
20009dbc:	68bb      	ldr	r3, [r7, #8]
20009dbe:	f403 7300 	and.w	r3, r3, #512	; 0x200
20009dc2:	2b00      	cmp	r3, #0
20009dc4:	d003      	beq.n	20009dce <HAL_RCCEx_CRS_IRQHandler+0xae>
      {
        crserror |= RCC_CRS_SYNCMISS;
20009dc6:	68fb      	ldr	r3, [r7, #12]
20009dc8:	f043 0310 	orr.w	r3, r3, #16
20009dcc:	60fb      	str	r3, [r7, #12]
      }
      if((itflags & RCC_CRS_FLAG_TRIMOVF) != 0U)
20009dce:	68bb      	ldr	r3, [r7, #8]
20009dd0:	f403 6380 	and.w	r3, r3, #1024	; 0x400
20009dd4:	2b00      	cmp	r3, #0
20009dd6:	d003      	beq.n	20009de0 <HAL_RCCEx_CRS_IRQHandler+0xc0>
      {
        crserror |= RCC_CRS_TRIMOVF;
20009dd8:	68fb      	ldr	r3, [r7, #12]
20009dda:	f043 0320 	orr.w	r3, r3, #32
20009dde:	60fb      	str	r3, [r7, #12]
      }

      /* Clear CRS Error flags */
      WRITE_REG(CRS->ICR, CRS_ICR_ERRC);
20009de0:	4b05      	ldr	r3, [pc, #20]	; (20009df8 <HAL_RCCEx_CRS_IRQHandler+0xd8>)
20009de2:	2204      	movs	r2, #4
20009de4:	60da      	str	r2, [r3, #12]

      /* user error callback */
      HAL_RCCEx_CRS_ErrorCallback(crserror);
20009de6:	68f8      	ldr	r0, [r7, #12]
20009de8:	f000 f81d 	bl	20009e26 <HAL_RCCEx_CRS_ErrorCallback>
    }
  }
}
20009dec:	e7ff      	b.n	20009dee <HAL_RCCEx_CRS_IRQHandler+0xce>
20009dee:	bf00      	nop
20009df0:	3710      	adds	r7, #16
20009df2:	46bd      	mov	sp, r7
20009df4:	bd80      	pop	{r7, pc}
20009df6:	bf00      	nop
20009df8:	40002000 	.word	0x40002000

20009dfc <HAL_RCCEx_CRS_SyncOkCallback>:
/**
  * @brief  RCCEx Clock Recovery System SYNCOK interrupt callback.
  * @retval none
  */
__weak void HAL_RCCEx_CRS_SyncOkCallback(void)
{
20009dfc:	b480      	push	{r7}
20009dfe:	af00      	add	r7, sp, #0
  /* NOTE : This function should not be modified, when the callback is needed,
            the @ref HAL_RCCEx_CRS_SyncOkCallback should be implemented in the user file
   */
}
20009e00:	bf00      	nop
20009e02:	46bd      	mov	sp, r7
20009e04:	f85d 7b04 	ldr.w	r7, [sp], #4
20009e08:	4770      	bx	lr

20009e0a <HAL_RCCEx_CRS_SyncWarnCallback>:
/**
  * @brief  RCCEx Clock Recovery System SYNCWARN interrupt callback.
  * @retval none
  */
__weak void HAL_RCCEx_CRS_SyncWarnCallback(void)
{
20009e0a:	b480      	push	{r7}
20009e0c:	af00      	add	r7, sp, #0
  /* NOTE : This function should not be modified, when the callback is needed,
            the @ref HAL_RCCEx_CRS_SyncWarnCallback should be implemented in the user file
   */
}
20009e0e:	bf00      	nop
20009e10:	46bd      	mov	sp, r7
20009e12:	f85d 7b04 	ldr.w	r7, [sp], #4
20009e16:	4770      	bx	lr

20009e18 <HAL_RCCEx_CRS_ExpectedSyncCallback>:
/**
  * @brief  RCCEx Clock Recovery System Expected SYNC interrupt callback.
  * @retval none
  */
__weak void HAL_RCCEx_CRS_ExpectedSyncCallback(void)
{
20009e18:	b480      	push	{r7}
20009e1a:	af00      	add	r7, sp, #0
  /* NOTE : This function should not be modified, when the callback is needed,
            the @ref HAL_RCCEx_CRS_ExpectedSyncCallback should be implemented in the user file
   */
}
20009e1c:	bf00      	nop
20009e1e:	46bd      	mov	sp, r7
20009e20:	f85d 7b04 	ldr.w	r7, [sp], #4
20009e24:	4770      	bx	lr

20009e26 <HAL_RCCEx_CRS_ErrorCallback>:
  *           @arg @ref RCC_CRS_SYNCMISS
  *           @arg @ref RCC_CRS_TRIMOVF
  * @retval none
  */
__weak void HAL_RCCEx_CRS_ErrorCallback(uint32_t Error)
{
20009e26:	b480      	push	{r7}
20009e28:	b083      	sub	sp, #12
20009e2a:	af00      	add	r7, sp, #0
20009e2c:	6078      	str	r0, [r7, #4]
  UNUSED(Error);

  /* NOTE : This function should not be modified, when the callback is needed,
            the @ref HAL_RCCEx_CRS_ErrorCallback should be implemented in the user file
   */
}
20009e2e:	bf00      	nop
20009e30:	370c      	adds	r7, #12
20009e32:	46bd      	mov	sp, r7
20009e34:	f85d 7b04 	ldr.w	r7, [sp], #4
20009e38:	4770      	bx	lr
	...

20009e3c <__errno>:
20009e3c:	4b01      	ldr	r3, [pc, #4]	; (20009e44 <__errno+0x8>)
20009e3e:	6818      	ldr	r0, [r3, #0]
20009e40:	4770      	bx	lr
20009e42:	bf00      	nop
20009e44:	2000041c 	.word	0x2000041c

20009e48 <exit>:
20009e48:	b508      	push	{r3, lr}
20009e4a:	4b07      	ldr	r3, [pc, #28]	; (20009e68 <exit+0x20>)
20009e4c:	4604      	mov	r4, r0
20009e4e:	b113      	cbz	r3, 20009e56 <exit+0xe>
20009e50:	2100      	movs	r1, #0
20009e52:	f3af 8000 	nop.w
20009e56:	4b05      	ldr	r3, [pc, #20]	; (20009e6c <exit+0x24>)
20009e58:	6818      	ldr	r0, [r3, #0]
20009e5a:	6a83      	ldr	r3, [r0, #40]	; 0x28
20009e5c:	b103      	cbz	r3, 20009e60 <exit+0x18>
20009e5e:	4798      	blx	r3
20009e60:	4620      	mov	r0, r4
20009e62:	f7f7 fab6 	bl	200013d2 <_exit>
20009e66:	bf00      	nop
20009e68:	00000000 	.word	0x00000000
20009e6c:	2000a208 	.word	0x2000a208

20009e70 <__libc_init_array>:
20009e70:	b570      	push	{r4, r5, r6, lr}
20009e72:	4d0d      	ldr	r5, [pc, #52]	; (20009ea8 <__libc_init_array+0x38>)
20009e74:	4c0d      	ldr	r4, [pc, #52]	; (20009eac <__libc_init_array+0x3c>)
20009e76:	1b64      	subs	r4, r4, r5
20009e78:	10a4      	asrs	r4, r4, #2
20009e7a:	2600      	movs	r6, #0
20009e7c:	42a6      	cmp	r6, r4
20009e7e:	d109      	bne.n	20009e94 <__libc_init_array+0x24>
20009e80:	4d0b      	ldr	r5, [pc, #44]	; (20009eb0 <__libc_init_array+0x40>)
20009e82:	4c0c      	ldr	r4, [pc, #48]	; (20009eb4 <__libc_init_array+0x44>)
20009e84:	f000 f822 	bl	20009ecc <_init>
20009e88:	1b64      	subs	r4, r4, r5
20009e8a:	10a4      	asrs	r4, r4, #2
20009e8c:	2600      	movs	r6, #0
20009e8e:	42a6      	cmp	r6, r4
20009e90:	d105      	bne.n	20009e9e <__libc_init_array+0x2e>
20009e92:	bd70      	pop	{r4, r5, r6, pc}
20009e94:	f855 3b04 	ldr.w	r3, [r5], #4
20009e98:	4798      	blx	r3
20009e9a:	3601      	adds	r6, #1
20009e9c:	e7ee      	b.n	20009e7c <__libc_init_array+0xc>
20009e9e:	f855 3b04 	ldr.w	r3, [r5], #4
20009ea2:	4798      	blx	r3
20009ea4:	3601      	adds	r6, #1
20009ea6:	e7f2      	b.n	20009e8e <__libc_init_array+0x1e>
20009ea8:	200003e0 	.word	0x200003e0
20009eac:	200003e0 	.word	0x200003e0
20009eb0:	200003e0 	.word	0x200003e0
20009eb4:	200003e4 	.word	0x200003e4

20009eb8 <memset>:
20009eb8:	4402      	add	r2, r0
20009eba:	4603      	mov	r3, r0
20009ebc:	4293      	cmp	r3, r2
20009ebe:	d100      	bne.n	20009ec2 <memset+0xa>
20009ec0:	4770      	bx	lr
20009ec2:	f803 1b01 	strb.w	r1, [r3], #1
20009ec6:	e7f9      	b.n	20009ebc <memset+0x4>

20009ec8 <__EH_FRAME_BEGIN__>:
20009ec8:	0000 0000                                   ....

20009ecc <_init>:
20009ecc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
20009ece:	bf00      	nop
20009ed0:	bcf8      	pop	{r3, r4, r5, r6, r7}
20009ed2:	bc08      	pop	{r3}
20009ed4:	469e      	mov	lr, r3
20009ed6:	4770      	bx	lr

20009ed8 <_fini>:
20009ed8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
20009eda:	bf00      	nop
20009edc:	bcf8      	pop	{r3, r4, r5, r6, r7}
20009ede:	bc08      	pop	{r3}
20009ee0:	469e      	mov	lr, r3
20009ee2:	4770      	bx	lr

Disassembly of section .RamFunc:

20009ee4 <HAL_FLASHEx_EnableRunPowerDown>:
  * @brief  Enable the Power down in Run Mode
  * @note   This function should be called and executed from SRAM memory.
  * @retval None
  */
__RAM_FUNC HAL_StatusTypeDef HAL_FLASHEx_EnableRunPowerDown(void)
{
20009ee4:	b480      	push	{r7}
20009ee6:	af00      	add	r7, sp, #0
  /* Enable the Power Down in Run mode*/
  __HAL_FLASH_POWER_DOWN_ENABLE();
20009ee8:	4b08      	ldr	r3, [pc, #32]	; (20009f0c <HAL_FLASHEx_EnableRunPowerDown+0x28>)
20009eea:	4a09      	ldr	r2, [pc, #36]	; (20009f10 <HAL_FLASHEx_EnableRunPowerDown+0x2c>)
20009eec:	605a      	str	r2, [r3, #4]
20009eee:	4b07      	ldr	r3, [pc, #28]	; (20009f0c <HAL_FLASHEx_EnableRunPowerDown+0x28>)
20009ef0:	4a08      	ldr	r2, [pc, #32]	; (20009f14 <HAL_FLASHEx_EnableRunPowerDown+0x30>)
20009ef2:	605a      	str	r2, [r3, #4]
20009ef4:	4b05      	ldr	r3, [pc, #20]	; (20009f0c <HAL_FLASHEx_EnableRunPowerDown+0x28>)
20009ef6:	681b      	ldr	r3, [r3, #0]
20009ef8:	4a04      	ldr	r2, [pc, #16]	; (20009f0c <HAL_FLASHEx_EnableRunPowerDown+0x28>)
20009efa:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
20009efe:	6013      	str	r3, [r2, #0]

  return HAL_OK;
20009f00:	2300      	movs	r3, #0

}
20009f02:	4618      	mov	r0, r3
20009f04:	46bd      	mov	sp, r7
20009f06:	f85d 7b04 	ldr.w	r7, [sp], #4
20009f0a:	4770      	bx	lr
20009f0c:	40022000 	.word	0x40022000
20009f10:	04152637 	.word	0x04152637
20009f14:	fafbfcfd 	.word	0xfafbfcfd

20009f18 <HAL_FLASHEx_DisableRunPowerDown>:
  * @brief  Disable the Power down in Run Mode
  * @note   This function should be called and executed from SRAM memory.
  * @retval None
  */
__RAM_FUNC HAL_StatusTypeDef HAL_FLASHEx_DisableRunPowerDown(void)
{
20009f18:	b480      	push	{r7}
20009f1a:	af00      	add	r7, sp, #0
  /* Disable the Power Down in Run mode*/
  __HAL_FLASH_POWER_DOWN_DISABLE();
20009f1c:	4b08      	ldr	r3, [pc, #32]	; (20009f40 <HAL_FLASHEx_DisableRunPowerDown+0x28>)
20009f1e:	4a09      	ldr	r2, [pc, #36]	; (20009f44 <HAL_FLASHEx_DisableRunPowerDown+0x2c>)
20009f20:	605a      	str	r2, [r3, #4]
20009f22:	4b07      	ldr	r3, [pc, #28]	; (20009f40 <HAL_FLASHEx_DisableRunPowerDown+0x28>)
20009f24:	4a08      	ldr	r2, [pc, #32]	; (20009f48 <HAL_FLASHEx_DisableRunPowerDown+0x30>)
20009f26:	605a      	str	r2, [r3, #4]
20009f28:	4b05      	ldr	r3, [pc, #20]	; (20009f40 <HAL_FLASHEx_DisableRunPowerDown+0x28>)
20009f2a:	681b      	ldr	r3, [r3, #0]
20009f2c:	4a04      	ldr	r2, [pc, #16]	; (20009f40 <HAL_FLASHEx_DisableRunPowerDown+0x28>)
20009f2e:	f423 5300 	bic.w	r3, r3, #8192	; 0x2000
20009f32:	6013      	str	r3, [r2, #0]

  return HAL_OK;
20009f34:	2300      	movs	r3, #0
}
20009f36:	4618      	mov	r0, r3
20009f38:	46bd      	mov	sp, r7
20009f3a:	f85d 7b04 	ldr.w	r7, [sp], #4
20009f3e:	4770      	bx	lr
20009f40:	40022000 	.word	0x40022000
20009f44:	04152637 	.word	0x04152637
20009f48:	fafbfcfd 	.word	0xfafbfcfd

20009f4c <HAL_FLASHEx_OB_DBankConfig>:
  *            @arg OB_DBANK_64_BITS: Dual-bank with 64-bits data
  *
  * @retval HAL_Status
  */
__RAM_FUNC HAL_StatusTypeDef HAL_FLASHEx_OB_DBankConfig(uint32_t DBankConfig)
{
20009f4c:	b480      	push	{r7}
20009f4e:	b087      	sub	sp, #28
20009f50:	af00      	add	r7, sp, #0
20009f52:	6078      	str	r0, [r7, #4]
  uint32_t count, reg;
  HAL_StatusTypeDef status = HAL_ERROR;
20009f54:	2301      	movs	r3, #1
20009f56:	74fb      	strb	r3, [r7, #19]

  /* Process Locked */
  __HAL_LOCK(&pFlash);
20009f58:	4b6f      	ldr	r3, [pc, #444]	; (2000a118 <HAL_FLASHEx_OB_DBankConfig+0x1cc>)
20009f5a:	781b      	ldrb	r3, [r3, #0]
20009f5c:	2b01      	cmp	r3, #1
20009f5e:	d101      	bne.n	20009f64 <HAL_FLASHEx_OB_DBankConfig+0x18>
20009f60:	2302      	movs	r3, #2
20009f62:	e0d2      	b.n	2000a10a <HAL_FLASHEx_OB_DBankConfig+0x1be>
20009f64:	4b6c      	ldr	r3, [pc, #432]	; (2000a118 <HAL_FLASHEx_OB_DBankConfig+0x1cc>)
20009f66:	2201      	movs	r2, #1
20009f68:	701a      	strb	r2, [r3, #0]

  /* Check if the PCROP is disabled */
  reg = FLASH->PCROP1SR;
20009f6a:	4b6c      	ldr	r3, [pc, #432]	; (2000a11c <HAL_FLASHEx_OB_DBankConfig+0x1d0>)
20009f6c:	6a5b      	ldr	r3, [r3, #36]	; 0x24
20009f6e:	60fb      	str	r3, [r7, #12]
  if (reg > FLASH->PCROP1ER)
20009f70:	4b6a      	ldr	r3, [pc, #424]	; (2000a11c <HAL_FLASHEx_OB_DBankConfig+0x1d0>)
20009f72:	6a9b      	ldr	r3, [r3, #40]	; 0x28
20009f74:	68fa      	ldr	r2, [r7, #12]
20009f76:	429a      	cmp	r2, r3
20009f78:	f240 80c3 	bls.w	2000a102 <HAL_FLASHEx_OB_DBankConfig+0x1b6>
  {
    reg = FLASH->PCROP2SR;
20009f7c:	4b67      	ldr	r3, [pc, #412]	; (2000a11c <HAL_FLASHEx_OB_DBankConfig+0x1d0>)
20009f7e:	6c5b      	ldr	r3, [r3, #68]	; 0x44
20009f80:	60fb      	str	r3, [r7, #12]
    if (reg > FLASH->PCROP2ER)
20009f82:	4b66      	ldr	r3, [pc, #408]	; (2000a11c <HAL_FLASHEx_OB_DBankConfig+0x1d0>)
20009f84:	6c9b      	ldr	r3, [r3, #72]	; 0x48
20009f86:	68fa      	ldr	r2, [r7, #12]
20009f88:	429a      	cmp	r2, r3
20009f8a:	f240 80ba 	bls.w	2000a102 <HAL_FLASHEx_OB_DBankConfig+0x1b6>
    {
      /* Disable Flash prefetch */
      __HAL_FLASH_PREFETCH_BUFFER_DISABLE();
20009f8e:	4b63      	ldr	r3, [pc, #396]	; (2000a11c <HAL_FLASHEx_OB_DBankConfig+0x1d0>)
20009f90:	681b      	ldr	r3, [r3, #0]
20009f92:	4a62      	ldr	r2, [pc, #392]	; (2000a11c <HAL_FLASHEx_OB_DBankConfig+0x1d0>)
20009f94:	f423 7380 	bic.w	r3, r3, #256	; 0x100
20009f98:	6013      	str	r3, [r2, #0]

      if (READ_BIT(FLASH->ACR, FLASH_ACR_ICEN) != 0U)
20009f9a:	4b60      	ldr	r3, [pc, #384]	; (2000a11c <HAL_FLASHEx_OB_DBankConfig+0x1d0>)
20009f9c:	681b      	ldr	r3, [r3, #0]
20009f9e:	f403 7300 	and.w	r3, r3, #512	; 0x200
20009fa2:	2b00      	cmp	r3, #0
20009fa4:	d011      	beq.n	20009fca <HAL_FLASHEx_OB_DBankConfig+0x7e>
      {
        /* Disable Flash instruction cache */
        __HAL_FLASH_INSTRUCTION_CACHE_DISABLE();
20009fa6:	4b5d      	ldr	r3, [pc, #372]	; (2000a11c <HAL_FLASHEx_OB_DBankConfig+0x1d0>)
20009fa8:	681b      	ldr	r3, [r3, #0]
20009faa:	4a5c      	ldr	r2, [pc, #368]	; (2000a11c <HAL_FLASHEx_OB_DBankConfig+0x1d0>)
20009fac:	f423 7300 	bic.w	r3, r3, #512	; 0x200
20009fb0:	6013      	str	r3, [r2, #0]

        /* Flush Flash instruction cache */
        __HAL_FLASH_INSTRUCTION_CACHE_RESET();
20009fb2:	4b5a      	ldr	r3, [pc, #360]	; (2000a11c <HAL_FLASHEx_OB_DBankConfig+0x1d0>)
20009fb4:	681b      	ldr	r3, [r3, #0]
20009fb6:	4a59      	ldr	r2, [pc, #356]	; (2000a11c <HAL_FLASHEx_OB_DBankConfig+0x1d0>)
20009fb8:	f443 6300 	orr.w	r3, r3, #2048	; 0x800
20009fbc:	6013      	str	r3, [r2, #0]
20009fbe:	4b57      	ldr	r3, [pc, #348]	; (2000a11c <HAL_FLASHEx_OB_DBankConfig+0x1d0>)
20009fc0:	681b      	ldr	r3, [r3, #0]
20009fc2:	4a56      	ldr	r2, [pc, #344]	; (2000a11c <HAL_FLASHEx_OB_DBankConfig+0x1d0>)
20009fc4:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
20009fc8:	6013      	str	r3, [r2, #0]
      }

      if (READ_BIT(FLASH->ACR, FLASH_ACR_DCEN) != 0U)
20009fca:	4b54      	ldr	r3, [pc, #336]	; (2000a11c <HAL_FLASHEx_OB_DBankConfig+0x1d0>)
20009fcc:	681b      	ldr	r3, [r3, #0]
20009fce:	f403 6380 	and.w	r3, r3, #1024	; 0x400
20009fd2:	2b00      	cmp	r3, #0
20009fd4:	d011      	beq.n	20009ffa <HAL_FLASHEx_OB_DBankConfig+0xae>
      {
        /* Disable Flash data cache */
        __HAL_FLASH_DATA_CACHE_DISABLE();
20009fd6:	4b51      	ldr	r3, [pc, #324]	; (2000a11c <HAL_FLASHEx_OB_DBankConfig+0x1d0>)
20009fd8:	681b      	ldr	r3, [r3, #0]
20009fda:	4a50      	ldr	r2, [pc, #320]	; (2000a11c <HAL_FLASHEx_OB_DBankConfig+0x1d0>)
20009fdc:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
20009fe0:	6013      	str	r3, [r2, #0]

        /* Flush Flash data cache */
        __HAL_FLASH_DATA_CACHE_RESET();
20009fe2:	4b4e      	ldr	r3, [pc, #312]	; (2000a11c <HAL_FLASHEx_OB_DBankConfig+0x1d0>)
20009fe4:	681b      	ldr	r3, [r3, #0]
20009fe6:	4a4d      	ldr	r2, [pc, #308]	; (2000a11c <HAL_FLASHEx_OB_DBankConfig+0x1d0>)
20009fe8:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
20009fec:	6013      	str	r3, [r2, #0]
20009fee:	4b4b      	ldr	r3, [pc, #300]	; (2000a11c <HAL_FLASHEx_OB_DBankConfig+0x1d0>)
20009ff0:	681b      	ldr	r3, [r3, #0]
20009ff2:	4a4a      	ldr	r2, [pc, #296]	; (2000a11c <HAL_FLASHEx_OB_DBankConfig+0x1d0>)
20009ff4:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
20009ff8:	6013      	str	r3, [r2, #0]
      }

      /* Disable WRP zone A of 1st bank if needed */
      reg = FLASH->WRP1AR;
20009ffa:	4b48      	ldr	r3, [pc, #288]	; (2000a11c <HAL_FLASHEx_OB_DBankConfig+0x1d0>)
20009ffc:	6adb      	ldr	r3, [r3, #44]	; 0x2c
20009ffe:	60fb      	str	r3, [r7, #12]
      if (((reg & FLASH_WRP1AR_WRP1A_STRT) >> FLASH_WRP1AR_WRP1A_STRT_Pos) <=
2000a000:	68fb      	ldr	r3, [r7, #12]
2000a002:	f003 027f 	and.w	r2, r3, #127	; 0x7f
          ((reg & FLASH_WRP1AR_WRP1A_END) >> FLASH_WRP1AR_WRP1A_END_Pos))
2000a006:	68fb      	ldr	r3, [r7, #12]
2000a008:	0c1b      	lsrs	r3, r3, #16
2000a00a:	f003 037f 	and.w	r3, r3, #127	; 0x7f
      if (((reg & FLASH_WRP1AR_WRP1A_STRT) >> FLASH_WRP1AR_WRP1A_STRT_Pos) <=
2000a00e:	429a      	cmp	r2, r3
2000a010:	d807      	bhi.n	2000a022 <HAL_FLASHEx_OB_DBankConfig+0xd6>
      {
        MODIFY_REG(FLASH->WRP1AR, (FLASH_WRP1AR_WRP1A_STRT | FLASH_WRP1AR_WRP1A_END), FLASH_WRP1AR_WRP1A_STRT);
2000a012:	4b42      	ldr	r3, [pc, #264]	; (2000a11c <HAL_FLASHEx_OB_DBankConfig+0x1d0>)
2000a014:	6adb      	ldr	r3, [r3, #44]	; 0x2c
2000a016:	f023 137f 	bic.w	r3, r3, #8323199	; 0x7f007f
2000a01a:	4a40      	ldr	r2, [pc, #256]	; (2000a11c <HAL_FLASHEx_OB_DBankConfig+0x1d0>)
2000a01c:	f043 037f 	orr.w	r3, r3, #127	; 0x7f
2000a020:	62d3      	str	r3, [r2, #44]	; 0x2c
      }

      /* Disable WRP zone B of 1st bank if needed */
      reg = FLASH->WRP1BR;
2000a022:	4b3e      	ldr	r3, [pc, #248]	; (2000a11c <HAL_FLASHEx_OB_DBankConfig+0x1d0>)
2000a024:	6b1b      	ldr	r3, [r3, #48]	; 0x30
2000a026:	60fb      	str	r3, [r7, #12]
      if (((reg & FLASH_WRP1BR_WRP1B_STRT) >> FLASH_WRP1BR_WRP1B_STRT_Pos) <=
2000a028:	68fb      	ldr	r3, [r7, #12]
2000a02a:	f003 027f 	and.w	r2, r3, #127	; 0x7f
          ((reg & FLASH_WRP1BR_WRP1B_END) >> FLASH_WRP1BR_WRP1B_END_Pos))
2000a02e:	68fb      	ldr	r3, [r7, #12]
2000a030:	0c1b      	lsrs	r3, r3, #16
2000a032:	f003 037f 	and.w	r3, r3, #127	; 0x7f
      if (((reg & FLASH_WRP1BR_WRP1B_STRT) >> FLASH_WRP1BR_WRP1B_STRT_Pos) <=
2000a036:	429a      	cmp	r2, r3
2000a038:	d807      	bhi.n	2000a04a <HAL_FLASHEx_OB_DBankConfig+0xfe>
      {
        MODIFY_REG(FLASH->WRP1BR, (FLASH_WRP1BR_WRP1B_STRT | FLASH_WRP1BR_WRP1B_END), FLASH_WRP1BR_WRP1B_STRT);
2000a03a:	4b38      	ldr	r3, [pc, #224]	; (2000a11c <HAL_FLASHEx_OB_DBankConfig+0x1d0>)
2000a03c:	6b1b      	ldr	r3, [r3, #48]	; 0x30
2000a03e:	f023 137f 	bic.w	r3, r3, #8323199	; 0x7f007f
2000a042:	4a36      	ldr	r2, [pc, #216]	; (2000a11c <HAL_FLASHEx_OB_DBankConfig+0x1d0>)
2000a044:	f043 037f 	orr.w	r3, r3, #127	; 0x7f
2000a048:	6313      	str	r3, [r2, #48]	; 0x30
      }

      /* Disable WRP zone A of 2nd bank if needed */
      reg = FLASH->WRP2AR;
2000a04a:	4b34      	ldr	r3, [pc, #208]	; (2000a11c <HAL_FLASHEx_OB_DBankConfig+0x1d0>)
2000a04c:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
2000a04e:	60fb      	str	r3, [r7, #12]
      if (((reg & FLASH_WRP2AR_WRP2A_STRT) >> FLASH_WRP2AR_WRP2A_STRT_Pos) <=
2000a050:	68fb      	ldr	r3, [r7, #12]
2000a052:	f003 027f 	and.w	r2, r3, #127	; 0x7f
          ((reg & FLASH_WRP2AR_WRP2A_END) >> FLASH_WRP2AR_WRP2A_END_Pos))
2000a056:	68fb      	ldr	r3, [r7, #12]
2000a058:	0c1b      	lsrs	r3, r3, #16
2000a05a:	f003 037f 	and.w	r3, r3, #127	; 0x7f
      if (((reg & FLASH_WRP2AR_WRP2A_STRT) >> FLASH_WRP2AR_WRP2A_STRT_Pos) <=
2000a05e:	429a      	cmp	r2, r3
2000a060:	d807      	bhi.n	2000a072 <HAL_FLASHEx_OB_DBankConfig+0x126>
      {
        MODIFY_REG(FLASH->WRP2AR, (FLASH_WRP2AR_WRP2A_STRT | FLASH_WRP2AR_WRP2A_END), FLASH_WRP2AR_WRP2A_STRT);
2000a062:	4b2e      	ldr	r3, [pc, #184]	; (2000a11c <HAL_FLASHEx_OB_DBankConfig+0x1d0>)
2000a064:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
2000a066:	f023 137f 	bic.w	r3, r3, #8323199	; 0x7f007f
2000a06a:	4a2c      	ldr	r2, [pc, #176]	; (2000a11c <HAL_FLASHEx_OB_DBankConfig+0x1d0>)
2000a06c:	f043 037f 	orr.w	r3, r3, #127	; 0x7f
2000a070:	64d3      	str	r3, [r2, #76]	; 0x4c
      }

      /* Disable WRP zone B of 2nd bank if needed */
      reg = FLASH->WRP2BR;
2000a072:	4b2a      	ldr	r3, [pc, #168]	; (2000a11c <HAL_FLASHEx_OB_DBankConfig+0x1d0>)
2000a074:	6d1b      	ldr	r3, [r3, #80]	; 0x50
2000a076:	60fb      	str	r3, [r7, #12]
      if (((reg & FLASH_WRP2BR_WRP2B_STRT) >> FLASH_WRP2BR_WRP2B_STRT_Pos) <=
2000a078:	68fb      	ldr	r3, [r7, #12]
2000a07a:	f003 027f 	and.w	r2, r3, #127	; 0x7f
          ((reg & FLASH_WRP2BR_WRP2B_END) >> FLASH_WRP2BR_WRP2B_END_Pos))
2000a07e:	68fb      	ldr	r3, [r7, #12]
2000a080:	0c1b      	lsrs	r3, r3, #16
2000a082:	f003 037f 	and.w	r3, r3, #127	; 0x7f
      if (((reg & FLASH_WRP2BR_WRP2B_STRT) >> FLASH_WRP2BR_WRP2B_STRT_Pos) <=
2000a086:	429a      	cmp	r2, r3
2000a088:	d807      	bhi.n	2000a09a <HAL_FLASHEx_OB_DBankConfig+0x14e>
      {
        MODIFY_REG(FLASH->WRP2BR, (FLASH_WRP2BR_WRP2B_STRT | FLASH_WRP2BR_WRP2B_END), FLASH_WRP2BR_WRP2B_STRT);
2000a08a:	4b24      	ldr	r3, [pc, #144]	; (2000a11c <HAL_FLASHEx_OB_DBankConfig+0x1d0>)
2000a08c:	6d1b      	ldr	r3, [r3, #80]	; 0x50
2000a08e:	f023 137f 	bic.w	r3, r3, #8323199	; 0x7f007f
2000a092:	4a22      	ldr	r2, [pc, #136]	; (2000a11c <HAL_FLASHEx_OB_DBankConfig+0x1d0>)
2000a094:	f043 037f 	orr.w	r3, r3, #127	; 0x7f
2000a098:	6513      	str	r3, [r2, #80]	; 0x50
      }

      /* Modify the DBANK user option byte */
      MODIFY_REG(FLASH->OPTR, FLASH_OPTR_DBANK, DBankConfig);
2000a09a:	4b20      	ldr	r3, [pc, #128]	; (2000a11c <HAL_FLASHEx_OB_DBankConfig+0x1d0>)
2000a09c:	6a1b      	ldr	r3, [r3, #32]
2000a09e:	f423 0280 	bic.w	r2, r3, #4194304	; 0x400000
2000a0a2:	491e      	ldr	r1, [pc, #120]	; (2000a11c <HAL_FLASHEx_OB_DBankConfig+0x1d0>)
2000a0a4:	687b      	ldr	r3, [r7, #4]
2000a0a6:	4313      	orrs	r3, r2
2000a0a8:	620b      	str	r3, [r1, #32]

      /* Set OPTSTRT Bit */
      SET_BIT(FLASH->CR, FLASH_CR_OPTSTRT);
2000a0aa:	4b1c      	ldr	r3, [pc, #112]	; (2000a11c <HAL_FLASHEx_OB_DBankConfig+0x1d0>)
2000a0ac:	695b      	ldr	r3, [r3, #20]
2000a0ae:	4a1b      	ldr	r2, [pc, #108]	; (2000a11c <HAL_FLASHEx_OB_DBankConfig+0x1d0>)
2000a0b0:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
2000a0b4:	6153      	str	r3, [r2, #20]

      /* Wait for last operation to be completed */
      /* 8 is the number of required instruction cycles for the below loop statement (timeout expressed in ms) */
      count = FLASH_TIMEOUT_VALUE * (SystemCoreClock / 8U / 1000U);
2000a0b6:	4b1a      	ldr	r3, [pc, #104]	; (2000a120 <HAL_FLASHEx_OB_DBankConfig+0x1d4>)
2000a0b8:	681b      	ldr	r3, [r3, #0]
2000a0ba:	4a1a      	ldr	r2, [pc, #104]	; (2000a124 <HAL_FLASHEx_OB_DBankConfig+0x1d8>)
2000a0bc:	fba2 2303 	umull	r2, r3, r2, r3
2000a0c0:	0a5b      	lsrs	r3, r3, #9
2000a0c2:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
2000a0c6:	fb02 f303 	mul.w	r3, r2, r3
2000a0ca:	617b      	str	r3, [r7, #20]
      do
      {
        if (count == 0U)
2000a0cc:	697b      	ldr	r3, [r7, #20]
2000a0ce:	2b00      	cmp	r3, #0
2000a0d0:	d00a      	beq.n	2000a0e8 <HAL_FLASHEx_OB_DBankConfig+0x19c>
        {
          break;
        }
        count--;
2000a0d2:	697b      	ldr	r3, [r7, #20]
2000a0d4:	3b01      	subs	r3, #1
2000a0d6:	617b      	str	r3, [r7, #20]
      }
      while (__HAL_FLASH_GET_FLAG(FLASH_FLAG_BSY) != RESET);
2000a0d8:	4b10      	ldr	r3, [pc, #64]	; (2000a11c <HAL_FLASHEx_OB_DBankConfig+0x1d0>)
2000a0da:	691b      	ldr	r3, [r3, #16]
2000a0dc:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
2000a0e0:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
2000a0e4:	d0f2      	beq.n	2000a0cc <HAL_FLASHEx_OB_DBankConfig+0x180>
2000a0e6:	e000      	b.n	2000a0ea <HAL_FLASHEx_OB_DBankConfig+0x19e>
          break;
2000a0e8:	bf00      	nop

      /* If the option byte program operation is completed, disable the OPTSTRT Bit */
      CLEAR_BIT(FLASH->CR, FLASH_CR_OPTSTRT);
2000a0ea:	4b0c      	ldr	r3, [pc, #48]	; (2000a11c <HAL_FLASHEx_OB_DBankConfig+0x1d0>)
2000a0ec:	695b      	ldr	r3, [r3, #20]
2000a0ee:	4a0b      	ldr	r2, [pc, #44]	; (2000a11c <HAL_FLASHEx_OB_DBankConfig+0x1d0>)
2000a0f0:	f423 3300 	bic.w	r3, r3, #131072	; 0x20000
2000a0f4:	6153      	str	r3, [r2, #20]

      /* Set the bit to force the option byte reloading */
      SET_BIT(FLASH->CR, FLASH_CR_OBL_LAUNCH);
2000a0f6:	4b09      	ldr	r3, [pc, #36]	; (2000a11c <HAL_FLASHEx_OB_DBankConfig+0x1d0>)
2000a0f8:	695b      	ldr	r3, [r3, #20]
2000a0fa:	4a08      	ldr	r2, [pc, #32]	; (2000a11c <HAL_FLASHEx_OB_DBankConfig+0x1d0>)
2000a0fc:	f043 6300 	orr.w	r3, r3, #134217728	; 0x8000000
2000a100:	6153      	str	r3, [r2, #20]
    }
  }

  /* Process Unlocked */
  __HAL_UNLOCK(&pFlash);
2000a102:	4b05      	ldr	r3, [pc, #20]	; (2000a118 <HAL_FLASHEx_OB_DBankConfig+0x1cc>)
2000a104:	2200      	movs	r2, #0
2000a106:	701a      	strb	r2, [r3, #0]

  return status;
2000a108:	7cfb      	ldrb	r3, [r7, #19]
}
2000a10a:	4618      	mov	r0, r3
2000a10c:	371c      	adds	r7, #28
2000a10e:	46bd      	mov	sp, r7
2000a110:	f85d 7b04 	ldr.w	r7, [sp], #4
2000a114:	4770      	bx	lr
2000a116:	bf00      	nop
2000a118:	200003fc 	.word	0x200003fc
2000a11c:	40022000 	.word	0x40022000
2000a120:	200003f0 	.word	0x200003f0
2000a124:	10624dd3 	.word	0x10624dd3
